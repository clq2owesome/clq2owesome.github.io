<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LeoChan&#39;s 个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="描述啊">
<meta property="og:type" content="website">
<meta property="og:title" content="LeoChan&#39;s 个人博客">
<meta property="og:url" content="https://clq2owesome.github.io/index.html">
<meta property="og:site_name" content="LeoChan&#39;s 个人博客">
<meta property="og:description" content="描述啊">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeoChan&#39;s 个人博客">
<meta name="twitter:description" content="描述啊">
  
    <link rel="alternate" href="/atom.xml" title="LeoChan&#39;s 个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LeoChan&#39;s 个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术都是通用的，重要的是是否具有自主解决问题的能力！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://clq2owesome.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-正则表达式/正则表达式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/08/正则表达式/正则表达式/" class="article-date">
  <time datetime="2018-03-08T02:09:45.000Z" itemprop="datePublished">2018-03-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/正则表达式/">正则表达式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/08/正则表达式/正则表达式/">正则表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>常用：</p>
<ul>
<li><code>\d</code>：代表任意一个数字，0~9的任意一个</li>
<li><code>\w</code>：任意一个字母或数字或下划线，也就是 A~Z,a~z,0~9,_ 中任意一个</li>
<li><code>\s</code>：包括空格、制表符、换页符等空白字符的其中任意一个</li>
<li><code>.</code>：小数点可以匹配除了换行符（\n）以外的任意一个字符（包括数字）</li>
<li><code>\b</code>:匹配这样的位置(字符和边界符之间的位置)：它的前一个字符和后一个字符不全\w,单词边界符可以是中文符号、英文符号、空格、制表符、回车符号，以及各种边界，比如单词在开头，单词在结尾。 比如：”end\b”可以匹配”weekend”，”weekend “, “weekend,”等</li>
</ul>
<p>以上写法，当其为大写时刚好相反</p>
<ul>
<li><code>\S</code>：匹配所有非空白字符（”\s” 可匹配各个空白字符）</li>
<li><code>\D</code>：匹配所有的非数字字符</li>
<li><code>\W</code>：匹配所有的字母、数字、下划线以外的字符</li>
<li><code>\B</code>：<code>\b</code>相反，匹配字符和非边界符之间的位置,比如：”\Bee\B”可以匹配”weekend”</li>
</ul>
<p>特殊符号的含义：</p>
<ul>
<li><code>?</code>：匹配表达式0次或者1次，相当于 {0,1}，比如：”a[cd]?”可以匹配 “a”,”ac”,”ad”</li>
<li><code>+</code>：表达式至少出现1次，相当于 {1,}，比如：”a+b”可以匹配 “ab”,”aab”,”aaab”</li>
<li><code>*</code>：表达式不出现或出现任意次，相当于 {0,}，比如：”a*b”可以匹配 “b”,”aaaab”.</li>
<li><code>^</code>：与字符串开始的地方匹配，不匹配任何字符，比如：”^aaa”可以匹配”aaasdsd”，”\^a”可以匹配”^av”</li>
<li>$：与字符串结束的地方匹配，不匹配任何字符，比如：”aaa$”可以匹配”sdsdaaa”</li>
<li><code>|</code>：左右两边表达式之间 “或” 关系，匹配左边或者右边，比如“Tom|Jack‘可以匹配到”hi,Tom, i am Jack”</li>
</ul>
<h3 id="的用法"><a href="#的用法" class="headerlink" title="{}的用法"></a>{}的用法</h3><p>一般放在被修饰的表达式的后面</p>
<ul>
<li><code>{n}</code>：表达式重复n次，比如：”a{5}” 相当于 “aaaaa”</li>
<li><code>{m,n}</code>：表达式至少重复m次，最多重复n次，比如：”ba{1,3}”可以匹配 “ba”或”baa”或”baaa”</li>
<li><code>{m,}</code>：表达式至少重复m次，比如：”\w\d{2,}”可以匹配 “a12”,”_456”,”M12344”</li>
</ul>
<h3 id="的用法-1"><a href="#的用法-1" class="headerlink" title="[]的用法"></a>[]的用法</h3><p>使用方括号 [ ] 包含一系列字符，能够匹配其中任意一个字符。用 [^ ] 包含一系列字符，则能够匹配其中字符之外的任意一个字符。同样的道理，虽然可以匹配其中任意一个，但是只能是一个，不是多个。<br>例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[ab5@] ：匹配 <span class="string">"a"</span> 或 <span class="string">"b"</span> 或 <span class="string">"5"</span> 或 <span class="string">"@"</span></div><div class="line">[^abc]：匹配 <span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span> 之外的任意一个字符</div><div class="line">[f-k]：匹配 <span class="string">"f"</span>~<span class="string">"k"</span> 之间的任意一个字母</div><div class="line">[^A-F0<span class="number">-3</span>]：匹配 <span class="string">"A"</span>~<span class="string">"F"</span>,<span class="string">"0"</span>~<span class="string">"3"</span> 之外的任意一个字符</div></pre></td></tr></table></figure></p>
<h3 id="的用法-2"><a href="#的用法-2" class="headerlink" title="()的用法"></a>()的用法</h3><p>括号的作用，其实三言两语就能说明白，括号提供了分组，便于我们引用它。</p>
<h4 id="1-分组和分支结构"><a href="#1-分组和分支结构" class="headerlink" title="1. 分组和分支结构"></a>1. 分组和分支结构</h4><p>这二者是括号最直接的作用，也是最原始的功能。</p>
<h5 id="1-1-分组"><a href="#1-1-分组" class="headerlink" title="1.1 分组"></a>1.1 分组</h5><p>我们知道/a+/匹配连续出现的“a”，而要匹配连续出现的“ab”时，需要使用/(ab)+/。</p>
<p>其中括号是提供分组功能，使量词“+”作用于“ab”这个整体，测试如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(ab)+/g</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"ababa abbb ababab"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) ); <span class="comment">// ["abab", "ab", "ababab"]</span></div></pre></td></tr></table></figure></p>
<h5 id="1-2-分支结构"><a href="#1-2-分支结构" class="headerlink" title="1.2 分支结构"></a>1.2 分支结构</h5><p>而在多选分支结构(p1|p2)中，此处括号的作用也是不言而喻的，提供了子表达式的所有可能  </p>
<p>比如，要匹配如下的字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">I love JavaScript</div><div class="line">I love Regular Expression</div></pre></td></tr></table></figure></p>
<p>可以使用正则：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/^I love (JavaScript|Regular Expression)$/</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"I love JavaScript"</span>) ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"I love Regular Expression"</span>) ); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>如果去掉正则中的括号，即<code>/^I love JavaScript|Regular Expression$/</code>，匹配字符串是”I love JavaScript”和”Regular Expression”，当然这不是我们想要的。</p>
<h4 id="2-引用分组"><a href="#2-引用分组" class="headerlink" title="2. 引用分组"></a>2. 引用分组</h4><p>是括号一个重要的作用，有了它，我们就可以进行数据提取，以及更强大的替换操作。</p>
<p>而要使用它带来的好处，必须配合使用实际环境的API。</p>
<p>以日期为例。假设格式是yyyy-mm-dd的，我们可以先写一个简单的正则：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;/</span>;</div></pre></td></tr></table></figure></p>
<p>然后再修改成括号版的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</div></pre></td></tr></table></figure></p>
<h5 id="2-1-提取数据"><a href="#2-1-提取数据" class="headerlink" title="2.1 提取数据"></a>2.1 提取数据</h5><p>比如提取出年、月、日，可以这么做：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-12"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) ); </div><div class="line"><span class="comment">// =&gt; ["2017-06-12", "2017", "06", "12", index: 0, input: "2017-06-12"]</span></div></pre></td></tr></table></figure></p>
<p>match返回的一个数组，第一个元素是整体匹配结果，然后是各个分组（括号里）匹配的内容，然后是匹配下标，最后是输入的文本。（注意：如果正则是否有修饰符g，match返回的数组格式是不一样的）。</p>
<p>另外也可以使用正则对象的exec方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-12"</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.exec(string) ); </div><div class="line"><span class="comment">// =&gt; ["2017-06-12", "2017", "06", "12", index: 0, input: "2017-06-12"]</span></div></pre></td></tr></table></figure></p>
<p>同时，也可以使用构造函数的全局属性$1至$9来获取：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-12"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>); <span class="comment">// "2017"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">2</span>); <span class="comment">// "06"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">3</span>); <span class="comment">// "12"</span></div></pre></td></tr></table></figure></p>
<h5 id="2-2-替换"><a href="#2-2-替换" class="headerlink" title="2.2 替换"></a>2.2 替换</h5><p>比如，想把yyyy-mm-dd格式，替换成mm/dd/yyyy怎么做？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-12"</span>;</div><div class="line"><span class="keyword">var</span> result = string.replace(regex, <span class="string">"$2/$3/$1"</span>);</div><div class="line"><span class="built_in">console</span>.log(result); <span class="comment">// "06/12/2017"</span></div></pre></td></tr></table></figure></p>
<p>其中replace中的，第二个参数里用$1、$2、$3指代相应的分组。等价于如下的形式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-12"</span>;</div><div class="line"><span class="keyword">var</span> result = string.replace(regex, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">RegExp</span>.$<span class="number">2</span> + <span class="string">"/"</span> + <span class="built_in">RegExp</span>.$<span class="number">3</span> + <span class="string">"/"</span> + <span class="built_in">RegExp</span>.$<span class="number">1</span>;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(result); <span class="comment">// "06/12/2017"</span></div></pre></td></tr></table></figure></p>
<p>也等价于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</div><div class="line">var string = &quot;2017-06-12&quot;;</div><div class="line">var result = string.replace(regex, function(match, year, month, day) &#123;</div><div class="line">	return month + &quot;/&quot; + day + &quot;/&quot; + year;</div><div class="line">&#125;);</div><div class="line">console.log(result); // &quot;06/12/2017&quot;</div></pre></td></tr></table></figure></p>
<h4 id="3-反向引用"><a href="#3-反向引用" class="headerlink" title="3. 反向引用"></a>3. 反向引用</h4><p>除了使用相应API来引用分组，也可以在正则本身里引用分组。但只能引用之前出现的分组，即反向引用。</p>
<p>还是以日期为例。</p>
<p>比如要写一个正则支持匹配如下三种格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2016-06-12</div><div class="line">2016/06/12</div><div class="line">2016.06.12</div></pre></td></tr></table></figure></p>
<p>最先可能想到的正则是:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;(-|\/|\.)\d&#123;2&#125;/</span>;</div><div class="line"><span class="keyword">var</span> string1 = <span class="string">"2017-06-12"</span>;</div><div class="line"><span class="keyword">var</span> string2 = <span class="string">"2017/06/12"</span>;</div><div class="line"><span class="keyword">var</span> string3 = <span class="string">"2017.06.12"</span>;</div><div class="line"><span class="keyword">var</span> string4 = <span class="string">"2016-06/12"</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(string1) ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(string2) ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(string3) ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(string4) ); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>其中/和.需要转义。虽然匹配了要求的情况，但也匹配”2016-06/12”这样的数据。</p>
<p>假设我们想要求分割符前后一致怎么办？此时需要使用反向引用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;\1\d&#123;2&#125;/</span>;</div><div class="line"><span class="keyword">var</span> string1 = <span class="string">"2017-06-12"</span>;</div><div class="line"><span class="keyword">var</span> string2 = <span class="string">"2017/06/12"</span>;</div><div class="line"><span class="keyword">var</span> string3 = <span class="string">"2017.06.12"</span>;</div><div class="line"><span class="keyword">var</span> string4 = <span class="string">"2016-06/12"</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(string1) ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(string2) ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(string3) ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(string4) ); <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>注意里面的\1，表示的引用之前的那个分组(-|\/|.)。不管它匹配到什么（比如-），\1都匹配那个同样的具体某个字符。</p>
<p>我们知道了\1的含义后，那么\2和\3的概念也就理解了，即分别指代第二个和第三个分组。</p>
<p>看到这里，此时，恐怕你会有三个问题。</p>
<h5 id="括号嵌套怎么办？"><a href="#括号嵌套怎么办？" class="headerlink" title="括号嵌套怎么办？"></a>括号嵌套怎么办？</h5><p>以左括号（开括号）为准。比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/^((\d)(\d(\d)))\1\2\3\4$/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"1231231233"</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(string) ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.$<span class="number">1</span> ); <span class="comment">// 123</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.$<span class="number">2</span> ); <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.$<span class="number">3</span> ); <span class="comment">// 23</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.$<span class="number">4</span> ); <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<p>我们可以看看这个正则匹配模式：</p>
<p>第一个字符是数字，比如说1，</p>
<p>第二个字符是数字，比如说2，</p>
<p>第三个字符是数字，比如说3，</p>
<p>接下来的是\1，是第一个分组内容，那么看第一个开括号对应的分组是什么，是123，</p>
<p>接下来的是\2，找到第2个开括号，对应的分组，匹配的内容是1，</p>
<p>接下来的是\3，找到第3个开括号，对应的分组，匹配的内容是23，</p>
<p>最后的是\4，找到第3个开括号，对应的分组，匹配的内容是3。</p>
<p>这个问题，估计仔细看一下，就该明白了。</p>
<h5 id="3-2-10表示什么呢？"><a href="#3-2-10表示什么呢？" class="headerlink" title="3.2 \10表示什么呢？"></a>3.2 \10表示什么呢？</h5><p>另外一个疑问可能是，即\10是表示第10个分组，还是\1和0呢？答案是前者，虽然一个正则里出现\10比较罕见。测试如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(1)(2)(3)(4)(5)(6)(7)(8)(9)(#) \10+/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"123456789# ######"</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(string) );</div></pre></td></tr></table></figure></p>
<h5 id="3-3-引用不存在的分组会怎样？"><a href="#3-3-引用不存在的分组会怎样？" class="headerlink" title="3.3 引用不存在的分组会怎样？"></a>3.3 引用不存在的分组会怎样？</h5><p>因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错，只是匹配反向引用的字符本身。例如\2，就匹配”\2”。注意”\2”表示对2进行了转意。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/\1\2\3\4\5\6\7\8\9/</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"\1\2\3\4\5\6\7\8\9"</span>) ); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<h4 id="4-非捕获分组"><a href="#4-非捕获分组" class="headerlink" title="4. 非捕获分组"></a>4. 非捕获分组</h4><p>之前文中出现的分组，都会捕获它们匹配到的数据，以便后续引用，因此也称他们是捕获型分组。</p>
<p>如果只想要括号最原始的功能，但不会引用它，即，既不在API里引用，也不在正则里反向引用。此时可以使用非捕获分组(?:p)，例如本文第一个例子可以修改为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(?:ab)+/g</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"ababa abbb ababab"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) ); <span class="comment">// ["abab", "ab", "ababab"]</span></div></pre></td></tr></table></figure></p>
<h4 id="5-相关案例"><a href="#5-相关案例" class="headerlink" title="5. 相关案例"></a>5. 相关案例</h4><p>至此括号的作用已经讲完了，总结一句话，就是提供了可供我们使用的分组，如何用就看我们的了。</p>
<h5 id="5-1-字符串trim方法模拟"><a href="#5-1-字符串trim方法模拟" class="headerlink" title="5.1 字符串trim方法模拟"></a>5.1 字符串trim方法模拟</h5><p>trim方法是去掉字符串的开头和结尾的空白符。有两种思路去做。</p>
<p>第一种，匹配到开头和结尾的空白符，然后替换成空字符。如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> str.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">''</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( trim(<span class="string">"  foobar   "</span>) ); <span class="comment">// "foobar"</span></div></pre></td></tr></table></figure></p>
<p>第二种，匹配整个字符串，然后用引用来提取出相应的数据：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> str.replace(<span class="regexp">/^\s*(.*?)\s*$/g</span>, <span class="string">"$1"</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( trim(<span class="string">"  foobar   "</span>) ); <span class="comment">// "foobar"</span></div></pre></td></tr></table></figure></p>
<p>这里使用了惰性匹配*?，不然也会匹配最后一个空格之前的所有空格的。<br>当然，前者效率高。</p>
<h5 id="5-2-将每个单词的首字母转换为大写"><a href="#5-2-将每个单词的首字母转换为大写" class="headerlink" title="5.2 将每个单词的首字母转换为大写"></a>5.2 将每个单词的首字母转换为大写</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">titleize</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> str.toLowerCase().replace(<span class="regexp">/(?:^|\s)\w/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> c.toUpperCase();</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( titleize(<span class="string">'my name is epeli'</span>) ); <span class="comment">// "My Name Is Epeli"</span></div></pre></td></tr></table></figure>
<p>思路是找到每个单词的首字母，当然这里不使用非捕获匹配也是可以的。</p>
<h5 id="5-3-驼峰化"><a href="#5-3-驼峰化" class="headerlink" title="5.3 驼峰化"></a>5.3 驼峰化</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">camelize</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> str.replace(<span class="regexp">/[-_\s]+(.)?/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, c</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> c ? c.toUpperCase() : <span class="string">''</span>;</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( camelize(<span class="string">'-moz-transform'</span>) ); <span class="comment">// MozTransform</span></div></pre></td></tr></table></figure>
<p>首字母不会转化为大写的。其中分组(.)表示首字母，单词的界定，前面的字符可以是多个连字符、下划线以及空白符。正则后面的?的目的，是为了应对str尾部的字符可能不是单词字符，比如str是’-moz-transform ‘。</p>
<h5 id="5-4-中划线化"><a href="#5-4-中划线化" class="headerlink" title="5.4 中划线化"></a>5.4 中划线化</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">unction dasherize(str) &#123;</div><div class="line">	<span class="keyword">return</span> str.replace(<span class="regexp">/([A-Z])/g</span>, <span class="string">'-$1'</span>).replace(<span class="regexp">/[-_\s]+/g</span>, <span class="string">'-'</span>).toLowerCase();</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( dasherize(<span class="string">'MozTransform'</span>) ); <span class="comment">// -moz-transform</span></div></pre></td></tr></table></figure>
<p>驼峰化的逆过程。</p>
<h5 id="5-5-html转义和反转义"><a href="#5-5-html转义和反转义" class="headerlink" title="5.5 html转义和反转义"></a>5.5 html转义和反转义</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将HTML特殊字符转换成等值的实体</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">escapeHTML</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> escapeChars = &#123;</div><div class="line">	  <span class="string">'¢'</span> : <span class="string">'cent'</span>,</div><div class="line">	  <span class="string">'£'</span> : <span class="string">'pound'</span>,</div><div class="line">	  <span class="string">'¥'</span> : <span class="string">'yen'</span>,</div><div class="line">	  <span class="string">'€'</span>: <span class="string">'euro'</span>,</div><div class="line">	  <span class="string">'©'</span> :<span class="string">'copy'</span>,</div><div class="line">	  <span class="string">'®'</span> : <span class="string">'reg'</span>,</div><div class="line">	  <span class="string">'&lt;'</span> : <span class="string">'lt'</span>,</div><div class="line">	  <span class="string">'&gt;'</span> : <span class="string">'gt'</span>,</div><div class="line">	  <span class="string">'"'</span> : <span class="string">'quot'</span>,</div><div class="line">	  <span class="string">'&amp;'</span> : <span class="string">'amp'</span>,</div><div class="line">	  <span class="string">'\''</span> : <span class="string">'#39'</span></div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">return</span> str.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'['</span> + <span class="built_in">Object</span>.keys(escapeChars).join(<span class="string">''</span>) +<span class="string">']'</span>, <span class="string">'g'</span>), <span class="function"><span class="keyword">function</span>(<span class="params">match</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">'&amp;'</span> + escapeChars[match] + <span class="string">';'</span>;</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( escapeHTML(<span class="string">'&lt;div&gt;Blah blah blah&lt;/div&gt;'</span>) );</div><div class="line"><span class="comment">// =&gt; &amp;lt;div&amp;gt;Blah blah blah&amp;lt;/div&amp;gt;</span></div></pre></td></tr></table></figure>
<p>其中使用了用构造函数生成的正则，然后替换相应的格式就行了，这个跟本文没多大关系。</p>
<p>倒是它的逆过程，使用了括号，以便提供引用，也很简单，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// 实体字符转换为等值的HTML。</div><div class="line">function unescapeHTML(str) &#123;</div><div class="line">	var htmlEntities = &#123;</div><div class="line">	  nbsp: &apos; &apos;,</div><div class="line">	  cent: &apos;¢&apos;,</div><div class="line">	  pound: &apos;£&apos;,</div><div class="line">	  yen: &apos;¥&apos;,</div><div class="line">	  euro: &apos;€&apos;,</div><div class="line">	  copy: &apos;©&apos;,</div><div class="line">	  reg: &apos;®&apos;,</div><div class="line">	  lt: &apos;&lt;&apos;,</div><div class="line">	  gt: &apos;&gt;&apos;,</div><div class="line">	  quot: &apos;&quot;&apos;,</div><div class="line">	  amp: &apos;&amp;&apos;,</div><div class="line">	  apos: &apos;\&apos;&apos;</div><div class="line">	&#125;;</div><div class="line">	return str.replace(/\&amp;([^;]+);/g, function(match, key) &#123;</div><div class="line">		if (key in htmlEntities) &#123;</div><div class="line">			return htmlEntities[key];</div><div class="line">		&#125;</div><div class="line">		return match;</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">console.log( unescapeHTML(&apos;&amp;lt;div&amp;gt;Blah blah blah&amp;lt;/div&amp;gt;&apos;) );</div><div class="line">// =&gt; &lt;div&gt;Blah blah blah&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>通过key获取相应的分组引用，然后作为对象的键。</p>
<h5 id="5-6-匹配成对标签"><a href="#5-6-匹配成对标签" class="headerlink" title="5.6 匹配成对标签"></a>5.6 匹配成对标签</h5><p>要求匹配：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>regular expression<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>laoyao bye bye<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>不匹配：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>wrong!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>匹配一个开标签，可以使用正则&lt;[^&gt;]+&gt;，</p>
<p>匹配一个闭标签，可以使用&lt;\/[^&gt;]+&gt;，</p>
<p>但是要求匹配成对标签，那就需要使用反向引用，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var regex = /&lt;([^&gt;]+)&gt;[\d\D]*&lt;\/\1&gt;/;</div><div class="line">var string1 = &quot;&lt;title&gt;regular expression&lt;/title&gt;&quot;;</div><div class="line">var string2 = &quot;&lt;p&gt;laoyao bye bye&lt;/p&gt;&quot;;</div><div class="line">var string3 = &quot;&lt;title&gt;wrong!&lt;/p&gt;&quot;;</div><div class="line">console.log( regex.test(string1) ); // true</div><div class="line">console.log( regex.test(string2) ); // true</div><div class="line">console.log( regex.test(string3) ); // false</div></pre></td></tr></table></figure></p>
<p>其中开标签&lt;[^&gt;]+&gt;改成&lt;([^&gt;]+)&gt;，使用括号的目的是为了后面使用反向引用，而提供分组。闭标签使用了反向引用，&lt;\/\1&gt;。</p>
<p>另外[\d\D]的意思是，这个字符是数字或者不是数字，因此，也就是匹配任意字符的意思。</p>
<h2 id="正则表达式中-括号-方括号-大括号-的区别"><a href="#正则表达式中-括号-方括号-大括号-的区别" class="headerlink" title="正则表达式中(括号) [方括号] {大括号}的区别"></a>正则表达式中(括号) [方括号] {大括号}的区别</h2><ul>
<li><p><code>括号()</code> ： 括号是多个匹配，它把括号内的当做一组来处理，限制一些多选的范围，比如上面的需求只能是com cn net结尾的用括号就是最好的选择。<br>括号能提取字符串，如(com|cn|net)就可以限制，只能是com或cn或net。<br>括号将括号里面的内容作为一组，这就是与[]不同的地方。</p>
</li>
<li><p><code>方括号[]</code>： 方括号是单个匹配，如[abc]他限制的不是abc连续出现，而是只能是其中一个，这样写那么规则就是找到这个位置时只能是a或是b或是c；<br>方括号是正则表达式中最常用的，常用的用法有：[a-zA-Z0-9]匹配所有英文字母和数字，[^a-zA-Z0-9]匹配所有非英文字母和数字。</p>
</li>
<li><p><code>大括号{}</code>： 大括号的用法很简单，就是匹配次数，它需要和其他有意义的正则表达式一起使用。<br>比如[a-c]{2}意思就是匹配a-c之间的一个字母出现且只出现两次；<br>比如(com){1}意思就是com必须出现一次<br>比如\W{1,3}意思就是非字母数字最少出现一次最多出现3次。</p>
</li>
</ul>
<h2 id="贪婪与非贪婪模式"><a href="#贪婪与非贪婪模式" class="headerlink" title="贪婪与非贪婪模式"></a>贪婪与非贪婪模式</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>贪婪与非贪婪模式影响的是被量词修饰的子表达式的匹配行为，贪婪模式在整个表达式匹配成功的前提下，尽可能多的匹配，而非贪婪模式在整个表达式匹配成功的前提下，尽可能少的匹配。非贪婪模式只被部分NFA引擎所支持。 </p>
<p>属于贪婪模式的量词，也叫做匹配优先量词，包括：<br><code>{m,n}</code>、<code>{m,}</code>、<code>?</code>、<code>*</code>和<code>+</code>。    </p>
<p>在一些使用NFA引擎的语言中，在匹配优先量词后加上“?”，即变成属于非贪婪模式的量词，也叫做忽略优先量词，包括：<br><code>{m,n}?</code>、<code>{m,}?</code>、<code>??</code>、<code>*?</code>和<code>+?</code>。 </p>
<p>从正则语法的角度来讲，被匹配优先量词修饰的子表达式使用的就是贪婪模式，如“(Expression)+”；被忽略优先量词修饰的子表达式使用的就是非贪婪模式，如“(Expression)+?”。 </p>
<p>对于贪婪模式，各种文档的叫法基本一致，但是对于非贪婪模式，有的叫懒惰模式或惰性模式，有的叫勉强模式，其实叫什么无所谓，只要掌握原理和用法，能够运用自如也就是了。个人习惯使用贪婪与非贪婪的叫法</p>
<p>这两种模式如下图所示：<br>| 贪婪   | 非贪婪  | 意　　义（X为表达式）           |<br>| —— | ——- | ——————————- |<br>| X?     | X??     | 匹配 X 零次或一次               |<br>| X<em>     | X</em>?     | 匹配 X 零次或多次               |<br>| X+     | X+?     | 匹配 X 一次或多次               |<br>| X{n,}  | X{n,}?  | 匹配 X 至少 n 次                |<br>| X{n,m} | X{n,m}? | 匹配 X 至少 n 次，但不多于 m 次 |</p>
<p>看下一个例子，假定要分析的字符串是xfooxxxxxxfoo</p>
<ul>
<li><p><strong>贪婪模式</strong>:<br>  最大匹配方式。模式分为子模式p1(.*)和子模式p2(foo)两个部分. 其中p1中的量词匹配方式使用默认方式(贪婪型)。 匹配开始时,吃入所有字符xfooxxxxxx去匹配子模式p1。匹配成功,但这样以来就没有了字符串去匹配子模式p2。本轮匹配失败；第二轮：减少p1部分的匹配量，吐出最后一个字符, 把字符串分割成xfooxxxxxxfo和o两个子字符串s1和s2。 s1匹配p1, 但s2不匹配p2。本轮匹配失败；第三轮，再次减少p1部分匹配量，吐出两个字符, 字符串被分割成xfooxxxxxxfo和oo两部分。结果同上。第四轮，再次减少p1匹配量, 字符串分割成xfooxxxxxx和foo两个部分, 这次s1/s2分别和p1/p2匹配。停止尝试,返回匹配成功。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var regex = /.*foo/;</div><div class="line">var string = &quot;xfooxxxxxxfoo&quot;;</div><div class="line">console.log( string.match(regex) ); //xfooxxxxxxfoo</div></pre></td></tr></table></figure>
</li>
<li><p><strong>非贪婪模式</strong>:<br>  最小匹配方式。第一次尝试匹配, p1由于是0或任意次，因此被忽略，用字符串去匹配p2,失败；第二次，读入第一个字符x, 尝试和p1匹配, 匹配成功; 字符串剩余部分fooxxxxxxfoo中前三个字符和p2也是匹配的. 因此, 停止尝试, 返回匹配成功。在这种模式下，如果对剩余字符串继续去寻找和模式相匹配的子字符串，还会找到字符串末尾的另一个xfoo，而在贪婪模式下，由于第一次匹配成功的子串就已经是所有字符，因此不存在第二个匹配子串。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var regex = /.*?foo/;</div><div class="line">var string = &quot;xfooxxxxxxfoo&quot;;</div><div class="line">console.log( string.match(regex) ); //xfoo</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="JavaScript-RegExp-对象"><a href="#JavaScript-RegExp-对象" class="headerlink" title="JavaScript RegExp 对象"></a>JavaScript RegExp 对象</h2><p>正则表达式是描述字符模式的对象。</p>
<p>正则表达式用于对字符串模式匹配及检索替换，是对字符串执行模式匹配的强大工具。</p>
<h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> patt=<span class="keyword">new</span> <span class="built_in">RegExp</span>(pattern,modifiers);</div><div class="line"></div><div class="line">或者更简单的方式:</div><div class="line"></div><div class="line"><span class="keyword">var</span> patt=<span class="regexp">/pattern/m</span>odifiers;</div></pre></td></tr></table></figure>
<ul>
<li>pattern（模式） 描述了表达式的模式</li>
<li>modifiers(修饰符) 用于指定全局匹配、区分大小写的匹配和多行匹配</li>
</ul>
<p>注意：当使用构造函数创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 \）。比如，以下是等价的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\w+"</span>);</div><div class="line"><span class="keyword">var</span> re = <span class="regexp">/\w+/</span>;</div></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var re = new RegExp(&quot;\\w+&quot;);</div><div class="line">re.test(&quot;abc&quot;);//true</div><div class="line"></div><div class="line">/\w+\.test(&quot;abc&quot;);//true</div></pre></td></tr></table></figure></p>
<p><strong>修饰符</strong><br>修饰符用于执行区分大小写和全局匹配:</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>执行对大小写不敏感的匹配。</td>
</tr>
<tr>
<td>g</td>
<td>执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td>
</tr>
<tr>
<td>m</td>
<td>执行多行匹配。</td>
</tr>
</tbody>
</table>
<h6 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h6><p>exec() 方法用于检索字符串中的正则表达式的匹配。</p>
<p>如果字符串中有匹配的值返回该匹配值，否则返回 null。</p>
<p><strong>语法：</strong><br>RegExpObject.exec(string)</p>
<p><strong>例子:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str=<span class="string">"Hello world!"</span>;</div><div class="line"><span class="comment">//查找"Hello"</span></div><div class="line"><span class="keyword">var</span> patt=<span class="regexp">/Hello/g</span>;</div><div class="line"><span class="built_in">console</span>.log(patt.exec(str)); <span class="comment">//Hello</span></div></pre></td></tr></table></figure></p>
<h6 id="test"><a href="#test" class="headerlink" title="test()"></a>test()</h6><p>test() 方法用于检测一个字符串是否匹配某个模式.</p>
<p>如果字符串中有匹配的值返回 true ，否则返回 false。</p>
<p><strong>语法：</strong><br>RegExpObject.test(string)</p>
<p><strong>例子:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var str=&quot;Hello world!&quot;;</div><div class="line">//查找&quot;Hello&quot;</div><div class="line">var patt=/Hello/g;</div><div class="line">console.log(patt.test(str)); //true</div></pre></td></tr></table></figure></p>
<h6 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h6><p>找到一个或多个正则表达式的匹配。</p>
<p><strong>语法：</strong><br>string.match(regexp)</p>
<p><strong>例子:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">有修饰符g</div><div class="line"><span class="keyword">var</span> str=<span class="string">"The rain in SPAIN stays mainly in the plain"</span>; </div><div class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/ain/g</span>));<span class="comment">//"ain", "ain", "ain"</span></div><div class="line"></div><div class="line">没有修饰符g</div><div class="line"><span class="keyword">var</span> str=<span class="string">"The rain in SPAIN stays mainly in the plain"</span>; </div><div class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/ain/</span>));<span class="comment">//"ain"</span></div></pre></td></tr></table></figure></p>
<p>注意： match() 方法将检索字符串 String Object，以找到一个或多个与 regexp 匹配的文本。这个方法的行为在很大程度上有赖于 regexp 是否具有标志 g。如果 regexp 没有标志 g，那么 match() 方法就只能在 stringObject 中执行一次匹配。如果没有找到任何匹配的文本， match() 将返回 null。否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/03/08/正则表达式/正则表达式/" data-id="cjei8yddw001w7obl6lmks9x4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/集合/Hashtable与ConcurrentHashMap区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/集合/Hashtable与ConcurrentHashMap区别/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/集合/">集合</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/集合/Hashtable与ConcurrentHashMap区别/">Hashtable与ConcurrentHashMap区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://note.youdao.com/yws/public/resource/60a3d77c47e4530035e791fad744780f/7194365EC16245ED9B0AAAF1128B2232" alt="image"><br>如上图所示，HashTable每次都要锁住整个结构，而ConcurrentHashMap锁的方式是稍微细粒度的。ConcurrentHashMap将hash表分为16个桶（默认值），诸如get,put,remove等常用操作只锁当前需要用到的桶。 </p>
<p>试想，原来 只能一个线程进入，现在却能同时16个写线程进入（写线程才需要锁定，而读线程几乎不受限制，之后会提到），并发性的提升是显而易见的。  </p>
<p>更令人惊讶的是ConcurrentHashMap的读取并发，因为在读取的大多数时候都没有用到锁定，所以读取操作几乎是完全的并发操作，而写操作锁定的粒度又非常细，比起之前又更加快速（这一点在桶更多时表现得更明显些）。<strong>只有在求size等操作时才需要锁定整个表</strong>。    </p>
<p>在迭代时，ConcurrentHashMap使用了不同于传统集合的快速失败迭代器的另一种迭代方式，我们称为弱一致迭代器。在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出 ConcurrentModificationException，取而代之的是在改变时new新的数据从而不影响原有的数 据，iterator完成后再将头指针替换为新的数据，这样iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变，更重要的，这保证了多个线程并发执行的连续性和扩展性，是性能提升的关键。  </p>
<h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ol>
<li>Hashtable 和 ConcurrentHashMap都是线程安全的，可以在多线程环境中运行；<br>ConcurrentHashMap 是设计为非阻塞的。在更新时会局部锁住某部分数据，但不会把整个表都锁住。同步读取操作则是完全非阻塞的。好处是在保证合理的同步前提下，效率很高。坏处 是严格来说读取操作不能保证反映最近的更新。例如线程A调用putAll写入大量数据，期间线程B调用get，则只能get到目前为止已经顺利插入的部分 数据。此外，使用默认构造器创建的ConcurrentHashMap比较占内存，如果程序需要创建巨量ConcurrentHashMap，应该在构造 时指定concurrencyLevel </li>
<li>key跟value都不能是null</li>
</ol>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol>
<li><p>两者主要是性能上的差异，Hashtable的所有操作都会锁住整个对象，，是阻塞的,虽然能够保证线程安全，但是性能较差；好处是总能获取最实时的更新，比如说线程A调用putAll写入大量数据，期间线程B调用get，线程B就会被阻塞，直到线程A完成putAll，因此线程B肯定能获取到线程A写入的完整数据。坏处是所有调用都要排队，效率较低。</p>
</li>
<li><p>ConcurrentHashMap内部使用Segment数组，每个Segment类似于Hashtable，在“写”线程或者部分特殊的“读”线程中锁住的是某个Segment对象，其它的线程能够并发执行其它的Segment对象。 ConcurrentHashMap 是设计为非阻塞的。在更新时会局部锁住某部分数据，但不会把整个表都锁住。同步读取操作则是完全非阻塞的。好处是在保证合理的同步前提下，效率很高。坏处 是严格来说读取操作不能保证反映最近的更新。例如线程A调用putAll写入大量数据，期间线程B调用get，则只能get到目前为止已经顺利插入的部分 数据。此外，使用默认构造器创建的ConcurrentHashMap比较占内存，如果程序需要创建巨量ConcurrentHashMap，应该在构造 时指定concurrencyLevel  </p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/集合/Hashtable与ConcurrentHashMap区别/" data-id="cjei8ydhp007u7oblgm3q91hw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/分布式/分布式事务" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/分布式/分布式事务/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/分布式/">分布式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/分布式/分布式事务/">分布式事务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="分布式事务概述"><a href="#分布式事务概述" class="headerlink" title="分布式事务概述"></a>分布式事务概述</h3><p>分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。以上是百度百科的解释，简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。</p>
<h3 id="分布式事务的产生的原因"><a href="#分布式事务的产生的原因" class="headerlink" title="分布式事务的产生的原因"></a>分布式事务的产生的原因</h3><h5 id="1-数据库分库分表"><a href="#1-数据库分库分表" class="headerlink" title="1.数据库分库分表"></a>1.数据库分库分表</h5><p>当数据库单表一年产生的数据超过1000W，那么就要考虑分库分表，具体分库分表的原理在此不做解释，以后有空详细说，简单的说就是原来的一个数据库变成了多个数据库。这时候，如果一个操作既访问01库，又访问02库，而且要保证数据的一致性，那么就要用到分布式事务。<br><img src="http://img.blog.csdn.net/20170320083203650?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZV9zb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image">    </p>
<h5 id="2-应用SOA化"><a href="#2-应用SOA化" class="headerlink" title="2.应用SOA化"></a>2.应用SOA化</h5><p>所谓的SOA化，就是业务的服务化。比如原来单机支撑了整个电商网站，现在对整个网站进行拆解，分离出了订单中心、用户中心、库存中心。对于订单中心，有专门的数据库存储订单信息，用户中心也有专门的数据库存储用户信息，库存中心也会有专门的数据库存储库存信息。这时候如果要同时对订单和库存进行操作，那么就会涉及到订单数据库和库存数据库，为了保证数据一致性，就需要用到分布式事务。<br><img src="http://img.blog.csdn.net/20170320083209525?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZV9zb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"><br>以上两种情况表象不同，但是本质相同，都是因为要操作的数据库变多了！    </p>
<h3 id="分布式事务的应用场景"><a href="#分布式事务的应用场景" class="headerlink" title="分布式事务的应用场景"></a>分布式事务的应用场景</h3><h5 id="1-支付"><a href="#1-支付" class="headerlink" title="1.支付"></a>1.支付</h5><p>最经典的场景就是支付了，一笔支付，是对买家账户进行扣款，同时对卖家账户进行加钱，这些操作必须在一个事务里执行，要么全部成功，要么全部失败。而对于买家账户属于买家中心，对应的是买家数据库，而卖家账户属于卖家中心，对应的是卖家数据库，对不同数据库的操作必然需要引入分布式事务。</p>
<h5 id="2-在线下单"><a href="#2-在线下单" class="headerlink" title="2.在线下单"></a>2.在线下单</h5><p>买家在电商平台下单，往往会涉及到两个动作，一个是扣库存，第二个是更新订单状态，库存和订单一般属于不同的数据库，需要使用分布式事务保证数据一致性。</p>
<h3 id="常见的分布式事务解决方案"><a href="#常见的分布式事务解决方案" class="headerlink" title="常见的分布式事务解决方案"></a>常见的分布式事务解决方案</h3><h4 id="基于XA协议的两阶段提交"><a href="#基于XA协议的两阶段提交" class="headerlink" title="基于XA协议的两阶段提交"></a>基于XA协议的两阶段提交</h4><p>XA是一个分布式事务协议，由Tuxedo提出。XA中大致分为两部分：事务管理器和本地资源管理器。其中本地资源管理器往往由数据库实现，比如Oracle、DB2这些商业数据库都实现了XA接口，而事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。XA实现分布式事务的原理如下：<br><img src="http://img.blog.csdn.net/20170320083214850?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZV9zb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image">    </p>
<p>总的来说，XA协议比较简单，而且一旦商业数据库实现了XA协议，使用分布式事务的成本也比较低。但是，XA也有致命的缺点，那就是性能不理想，特别是在交易下单链路，往往并发量很高，XA无法满足高并发场景。XA目前在商业数据库支持的比较理想，在mysql数据库中支持的不太理想，mysql的XA实现，没有记录prepare阶段日志，主备切换回导致主库与备库数据不一致。许多nosql也没有支持XA，这让XA的应用场景变得非常狭隘。  </p>
<p>两阶段提交协议（Two-phase Commit，2PC）经常被用来实现分布式事务。一般分为协调器C和若干事务执行者Si两种角色，这里的事务执行者就是具体的数据库，协调器可以和事务执行器在一台机器上。<br><img src="http://ww2.sinaimg.cn/large/7cc829d3gw1eux5nfbny7j20l908xta6.jpg" alt="image">  </p>
<ol>
<li><p>我们的应用程序（client）发起一个开始请求到TC；</p>
</li>
<li><p>TC先将<prepare>消息写到本地日志，之后向所有的Si发起<prepare>消息。以支付宝转账到余额宝为例，TC给A的prepare消息是通知支付宝数据库相应账目扣款1万，TC给B的prepare消息是通知余额宝数据库相应账目增加1w。为什么在执行任务前需要先写本地日志，主要是为了故障后恢复用，本地日志起到现实生活中凭证 的效果，如果没有本地日志（凭证），出问题容易死无对证；</prepare></prepare></p>
</li>
<li><p>Si收到<prepare>消息后，执行具体本机事务，但不会进行commit，如果成功返回<yes>，不成功返回<no>。同理，返回前都应把要返回的消息写到日志里，当作凭证。</no></yes></prepare></p>
</li>
<li><p>TC收集所有执行器返回的消息，如果所有执行器都返回yes，那么给所有执行器发生送commit消息，执行器收到commit后执行本地事务的commit操作；如果有任一个执行器返回no，那么给所有执行器发送abort消息，执行器收到abort消息后执行事务abort操作。</p>
</li>
</ol>
<p>注：TC或Si把发送或接收到的消息先写到日志里，主要是为了故障后恢复用。如某一Si从故障中恢复后，先检查本机的日志，如果已收到<commit>，则提交，如果<abort>则回滚。如果是<yes>，则再向TC询问一下，确定下一步。如果什么都没有，则很可能在<prepare>阶段Si就崩溃了，因此需要回滚。</prepare></yes></abort></commit></p>
<p>现如今实现基于两阶段提交的分布式事务也没那么困难了，如果使用java，那么可以使用开源软件atomikos(<a href="http://www.atomikos.com/)来快速实现。" target="_blank" rel="external">http://www.atomikos.com/)来快速实现。</a><br>​<br>不过但凡使用过的上述两阶段提交的同学都可以发现性能实在是太差，根本不适合高并发的系统。为什么？</p>
<ol>
<li>两阶段提交涉及多次节点间的网络通信，通信时间太长！</li>
<li>事务时间相对于变长了，锁定的资源的时间也变长了，造成资源等待时间也增加好多！</li>
</ol>
<p>正是由于分布式事务存在很严重的性能问题，大部分高并发服务都在避免使用，往往通过其他途径来解决数据一致性问题。</p>
<h4 id="消息事务-最终一致性"><a href="#消息事务-最终一致性" class="headerlink" title="消息事务+最终一致性"></a>消息事务+最终一致性</h4><p>如果仔细观察生活的话，生活的很多场景已经给了我们提示。</p>
<p>比如在北京很有名的姚记炒肝点了炒肝并付了钱后，他们并不会直接把你点的炒肝给你，而是给你一张小票，然后让你拿着小票到出货区排队去取。为什么他们要将付钱和取货两个动作分开呢？原因很多，其中一个很重要的原因是为了使他们接待能力增强（并发量更高）。</p>
<p>所谓的消息事务就是基于消息中间件的两阶段提交，本质上是对消息中间件的一种特殊利用，它是将本地事务和发消息放在了一个分布式事务里，保证要么本地操作成功成功并且对外发消息成功，要么两者都失败，开源的RocketMQ就支持这一特性，具体原理如下： </p>
<p><img src="http://img.blog.csdn.net/20170320083222287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZV9zb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image">    </p>
<ol>
<li>A系统向消息中间件发送一条预备消息</li>
<li>消息中间件保存预备消息并返回成功</li>
<li>A执行本地事务</li>
<li>A发送提交消息给消息中间件</li>
</ol>
<p>通过以上4步完成了一个消息事务。对于以上的4个步骤，每个步骤都可能产生错误，下面一一分析：</p>
<ul>
<li>步骤一出错，则整个事务失败，不会执行A的本地操作</li>
<li>步骤二出错，则整个事务失败，不会执行A的本地操作</li>
<li>步骤三出错，这时候需要回滚预备消息，怎么回滚？答案是A系统实现一个消息中间件的回调接口，消息中间件会去不断执行回调接口，检查A事务执行是否执行成功，如果失败则回滚预备消息</li>
<li>步骤四出错，这时候A的本地事务是成功的，那么消息中间件要回滚A吗？答案是不需要，其实通过回调接口，消息中间件能够检查到A执行成功了，这时候其实不需要A发提交消息了，消息中间件可以自己对消息进行提交，从而完成整个消息事务</li>
</ul>
<p>基于消息中间件的两阶段提交往往用在高并发场景下，将一个分布式事务拆成一个消息事务（A系统的本地操作+发消息）+B系统的本地操作，其中B系统的操作由消息驱动，只要消息事务成功，那么A操作一定成功，消息也一定发出来了，这时候B会收到消息去执行本地操作，如果本地操作失败，消息会重投，直到B操作成功，这样就变相地实现了A与B的分布式事务。原理如下：<br><img src="http://img.blog.csdn.net/20170320083228100?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZV9zb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"><br>虽然上面的方案能够完成A和B的操作，但是A和B并不是严格一致的，而是最终一致的，我们在这里牺牲了一致性，换来了性能的大幅度提升。当然，这种玩法也是有风险的，如果B一直执行不成功，那么一致性会被破坏，具体要不要玩，还是得看业务能够承担多少风险。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/分布式/分布式事务/" data-id="cjei8ydfo00317oblqnwco8cq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/分布式/分布式锁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/分布式/分布式锁/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/分布式/">分布式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/分布式/分布式锁/">分布式锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。</p>
<p>分布式的<code>CAP理论</code>告诉我们“任何一个分布式系统都无法同时满足<code>一致性（Consistency）</code>、<code>可用性（Availability）</code>和<code>分区容错性（Partition tolerance）</code>，最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。</p>
<p>在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行。在单机环境中，Java中其实提供了很多并发处理相关的API，但是这些API在分布式场景中就无能为力了。也就是说单纯的Java Api并不能提供分布式锁的能力。所以针对分布式锁的实现目前有多种方案：</p>
<ul>
<li>基于数据库实现分布式锁</li>
<li>基于缓存（redis，memcached）实现分布式锁</li>
<li>基于Zookeeper实现分布式锁</li>
</ul>
<h3 id="分布式情况"><a href="#分布式情况" class="headerlink" title="分布式情况"></a>分布式情况</h3><ul>
<li>分布式与单机情况下最大的不同在于其不是多线程而是多进程。</li>
<li>多线程由于可以共享堆内存，因此可以简单的采取内存作为标记存储位置。而进程之间甚至可能都不在同一台物理机上，因此需要将标记存储在一个所有进程都能看到的地方。</li>
</ul>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><ul>
<li>当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。</li>
<li>与单机模式下的锁不仅需要保证进程可见，还需要考虑进程与锁之间的网络问题。（我觉得分布式情况下之所以问题变得复杂，主要就是需要考虑到网络的延时和不可靠）</li>
<li>分布式锁还是可以将标记存在内存，只是该内存不是某个进程分配的内存而是公共内存如Redis、Memcache。至于利用数据库、文件等做锁与单机的实现是一样的，只要保证标记能互斥就行。</li>
</ul>
<h3 id="单机Redis锁"><a href="#单机Redis锁" class="headerlink" title="单机Redis锁"></a>单机Redis锁</h3><h5 id="基本锁"><a href="#基本锁" class="headerlink" title="基本锁"></a>基本锁</h5><p><strong>原理</strong>：利用Redis的setnx如果不存在某个key则设置值，设置成功则表示取得锁成功。<br><strong>缺点</strong>：如果获取锁后的进程，在还没执行完的时候挂调了，则锁永远不会释放。</p>
<h5 id="改进型"><a href="#改进型" class="headerlink" title="改进型"></a>改进型</h5><p><strong>改进</strong>：在基本型是锁上的setnx后设置expire，保证即使获取锁的进程不主动释放锁，过一段时间后也能自动释放。<br><strong>缺点</strong>：setnx与expire不是一个原子操作，可能执行完setnx该进程就挂了。<br>当锁过期后，该进程还没执行完，可能造成同时多个进程取得锁。（貌似这个问题目前还没有很优雅的解决方案）</p>
<h5 id="再改进"><a href="#再改进" class="headerlink" title="再改进"></a>再改进</h5><p><strong>改进</strong>：利用Lua脚本，将setnx与expire变成一个原子操作，可解决一部分问题。<br><strong>缺点</strong>：还是锁过期的问题。</p>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ol>
<li>直接调用Lua脚本原子setnx同时expire，设置一个随机值。</li>
<li>获取到锁则执行同步代码块，没获取则根据业务场景可以选择自旋、休眠、或做一个等待队列等拥有锁进程来唤醒（类似Synchronize的同步队列）。</li>
<li>当同步代码块执行完成，先判断锁的key是否是自己设置的，如果是则删除key（可利用Lua做成原子操作），不是则表明自己的锁已经过期，不需要删除。（这时候就出现了多进程同时有锁的问题了）</li>
</ol>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>一般情况下直接用setnx加expire就够了，但从安全性的角度看还是存在一下几个问题：</p>
<ol>
<li>单点问题。单机Redis只在单机上，如果单机down了，那么所有需要用分布式锁的地方均获取不到锁，全部阻塞。需要做好降级的处理。</li>
<li>可能出现多进程同时拥有锁。</li>
</ol>
<h3 id="集群Rides锁"><a href="#集群Rides锁" class="headerlink" title="集群Rides锁"></a>集群Rides锁</h3><h4 id="Redlock"><a href="#Redlock" class="headerlink" title="Redlock"></a>Redlock</h4><p>Redlock是Redis的作者antirez给出的集群模式的Redis分布式锁，它基于N个完全独立的Redis节点（通常情况下N可以设置成5）。</p>
<h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h5><ol>
<li>获取当前时间（毫秒数）。</li>
<li>按顺序依次向N个Redis节点执行获取锁的操作。获取锁的操作与单机锁一样。</li>
<li>如果获取锁成功的节点数&gt;=N/2+1，则再计算获取锁的时间有没有超过锁过期时间（可考虑设置一个必须留多长的时间给代码块执行），如果超过了则认为取锁失败。</li>
<li>如果取锁失败则应该对所有节点进行释放锁的操作。<h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5></li>
</ol>
<p>当有5个节点，某次上锁对a,b,c三个节点上锁成功，而后c马上down了，此时还没通过AOF或RDB写入磁盘。而后c又马上恢复，此时c没有上锁数据，因此此时可能出现c,d,e三个节点被别的进程上锁。所以在节点恢复时应该延时起码一个锁的过期时间。</p>
<h3 id="Zookeeper锁"><a href="#Zookeeper锁" class="headerlink" title="Zookeeper锁"></a>Zookeeper锁</h3><h5 id="zookeeper锁相关基础知识"><a href="#zookeeper锁相关基础知识" class="headerlink" title="zookeeper锁相关基础知识"></a>zookeeper锁相关基础知识</h5><ul>
<li>zk一般由多个节点构成（单数），采用zab一致性协议。因此可以将zk看成一个单点结构，对其修改数据其内部自动将所有节点数据进行修改而后才提供查询服务。</li>
<li>zk的数据以目录树的形式，每个目录称为 znode， znode中可存储数据（一般不超过1M），还可以在其中增加子节点。</li>
<li>子节点有三种类型。序列化节点，每在该节点下增加一个节点自动给该节点的名称上自增。临时节点，一旦创建这个 znode 的客户端与服务器失去联系，这个 znode 也将自动删除。最后就是普通节点。</li>
<li>Watch机制，client可以监控每个节点的变化，当产生变化会给client产生一个事件。</li>
</ul>
<h5 id="zk基本锁"><a href="#zk基本锁" class="headerlink" title="zk基本锁"></a>zk基本锁</h5><p><strong>原理</strong>：利用临时节点与watch机制。每个锁占用一个普通节点/lock，当需要获取锁时在/lock下创建一个临时节点，创建成功则表示获取锁成功，失败则watch/lock节点，有删除操作后再去争锁。临时节点好处在于当进程挂掉后能自动上锁的节点自动删除即取消锁。</p>
<p><strong>缺点</strong>：所有取锁失败的进程都监听父节点，很容易发生羊群效应，即当释放锁后所有等待进程一起来创建节点，并发量很大。</p>
<h5 id="zk锁优化"><a href="#zk锁优化" class="headerlink" title="zk锁优化"></a>zk锁优化</h5><p><strong>原理</strong>：上锁改为创建临时有序节点，每个上锁的节点均能创建节点成功，知识其序号不同。只有序号最小的可以拥有锁，当需要不是最小的则watch序号排在前面的一个节点(公平锁)。</p>
<p><strong>步骤</strong>：</p>
<ol>
<li>在/lock节点下创建一个有序临时节点(EPHEMERAL_SEQUENTIAL)。</li>
<li>判断创建的节点序号是否最小，如果是最小则获取锁成功。不是则取锁失败，然后watch序号比本身小的前一个节点。</li>
<li>当取锁失败，设置watch后则等待watch事件到来后，再次判断是否序号最小。</li>
<li>取锁成功则执行代码，最后删除本身节点，释放了锁。</li>
</ol>
<h3 id="分布式锁总结"><a href="#分布式锁总结" class="headerlink" title="分布式锁总结"></a>分布式锁总结</h3><h5 id="分布式锁存在的问题"><a href="#分布式锁存在的问题" class="headerlink" title="分布式锁存在的问题"></a>分布式锁存在的问题</h5><ol>
<li>均可能存在多进程拥有锁的情况。redis锁主要是expire时间与代码执行时间的问题，zk锁的问题在于zk是通过心跳监控进程存活状态，如果进程进行GC pause或者因为网络原因导致很长时间没与zk联系，则将导致zk认为进程已挂，而后锁自动释放，而此时进程并未挂任然在执行。</li>
<li>Redlock锁的时间问题。由于redis的expire的实现是通过pexpireat，如果某个节点发生时钟跳跃，则该节点可能过早释放锁导致一系列问题。</li>
</ol>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><ol>
<li>获取锁时提供一个fencing token(两种说法，一种说需要有序，一种说随机值就可以，我觉得随机值就可以)，在进程获取锁后对数据进行操作时，数据所在的资源服务器需要去锁中查看当前token，如果token对的才执行，不对则放弃执行。</li>
<li>我觉得对于放弃执行的应该在我们的代码块中增加类似事物的rollback的操作。因此如果资源服务器拒绝了我们的操作则表明此时起码已经存在了另外一个进程拥有锁了，为了保证数据安全性不能继续执行，因此需要回滚到执行代码块之前而继续去竞争锁。</li>
<li>至于Redis锁的时间问题，Antirez说在运维层面是可以控制时钟跳跃的区间的，只要能控制跳跃区间与expire的比例就没问题，详细可看《基于Redis的分布式锁真的安全吗？》</li>
</ol>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><ol>
<li>大多数时候采用zk锁就好了，没必要再考虑安全性的问题。其实也可以通过zk锁+幂等校验来达到双层保障。</li>
<li>fencing 机制需要对数据服务进行修改适配，个人觉得没这个必要吧。。。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/分布式/分布式锁/" data-id="cjei8ydfr00347obl85r62c8q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/集合/在List循环中删除元素" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/集合/在List循环中删除元素/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/集合/">集合</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/集合/在List循环中删除元素/">在List循环中删除元素</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="测试list"><a href="#测试list" class="headerlink" title="测试list"></a>测试list</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line">list.add(&quot;a&quot;);</div><div class="line">list.add(&quot;b&quot;);</div><div class="line">list.add(&quot;c&quot;);</div></pre></td></tr></table></figure>
<h3 id="普通下标方式一"><a href="#普通下标方式一" class="headerlink" title="普通下标方式一"></a>普通下标方式一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">for(int i=0; i&lt;3;i++) &#123;</div><div class="line">	for(int j=0;j&lt;list.size(); j++) &#123;</div><div class="line">        if (list.get(j).equals(&quot;b&quot;)) &#123;</div><div class="line">        		list.remove(j);</div><div class="line">            System.out.println(&quot;delete&quot;);</div><div class="line">            j--;//关键</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        System.out.println(list.get(j));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="迭代方式"><a href="#迭代方式" class="headerlink" title="迭代方式"></a>迭代方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">for(int i=0; i&lt;3;i++) &#123;</div><div class="line">	Iterator&lt;String&gt; iter = list.iterator();</div><div class="line">    while (iter.hasNext()) &#123;</div><div class="line">        String item = iter.next();</div><div class="line">        if (item.equals(&quot;b&quot;)) &#123;</div><div class="line">            iter.remove();</div><div class="line">            System.out.println(&quot;delete&quot;);</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        System.out.println(item);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CopyOnWriteArrayList方式"><a href="#CopyOnWriteArrayList方式" class="headerlink" title="CopyOnWriteArrayList方式"></a>CopyOnWriteArrayList方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">final CopyOnWriteArrayList&lt;String&gt; cowList = new CopyOnWriteArrayList&lt;String&gt;(list);</div><div class="line">for(int i=0; i&lt;3;i++) &#123;</div><div class="line">	for (String item : cowList) &#123;</div><div class="line">        if (item.equals(&quot;b&quot;)) &#123;</div><div class="line">            cowList.remove(item);</div><div class="line">            System.out.println(&quot;delete&quot;);</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        System.out.println(item);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="统一输出"><a href="#统一输出" class="headerlink" title="统一输出"></a>统一输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">a</div><div class="line">delete</div><div class="line">c</div><div class="line">a</div><div class="line">c</div><div class="line">a</div><div class="line">c</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/集合/在List循环中删除元素/" data-id="cjei8ydhr007z7obl2904nrkr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/集合/几种常见的map" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/集合/几种常见的map/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/集合/">集合</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/集合/几种常见的map/">几种常见的map</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>java为数据结构中的映射定义了一个接口java.util.Map;它有四个实现类,分别是HashMap Hashtable LinkedHashMap 和TreeMap.<br>Map主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重复。</p>
<h3 id="Hashmap"><a href="#Hashmap" class="headerlink" title="Hashmap"></a>Hashmap</h3><p><img src="http://img.blog.csdn.net/20150725203054803" alt="image"><br>Hashmap 是一个最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。</p>
<p>一般情况下，我们用的最多的是HashMap,在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。如果需要输出的顺序和输入的相同,那么用LinkedHashMap 可以实现,它还可以按读取顺序来排列.</p>
<p>HashMap是一个最常用的Map，它根据键的hashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为NULL，允许多条记录的值为NULL。</p>
<p>HashMap不支持线程同步，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致性。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。</p>
<p>在散列表中有一下名词需要了解: </p>
<ul>
<li><code>Capacity</code>：容量, hash表里bucket(桶)的数量, 也就是散列数组大小.默认为16，如果HashMap要存x=100个元素，那么HashMap的容量应该设置为2\^n次方，由于100/0.75 = 133.33。为了防止rehash，向上取整，为134。最接近134的数为2\^n=128,由于128比134小，所以要取n的下一个数，即2\^n=256,所以HashMap的初始容量应该为256</li>
<li><code>Initial capacity</code>：初始容量, 创建hash表的时 初始bucket的数量, 默认构建容量是16. 也可以使用特定容量. </li>
<li><code>Size</code> ： 大小, 当前散列表中存储数据的数量. </li>
<li><code>Load factor</code>：加载因子, 默认值0.75(就是75%), 向散列表增加数据时如果 size/capacity 的值大于Load factor则发生扩容并且重新散列(rehash).<br>那么当加载因子较小时候散列查找性能会提高, 同时也浪费了散列桶空间容量. 0.75是性能和空间相对平衡结果. 在创建散列表时候指定合理容量, 从而可以减少rehash提高性能。 </li>
</ul>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(10000);</div></pre></td></tr></table></figure></p>
<p>存入大量数据时可以使用该方法，减少扩容次数，提高性能 </p>
<p>如果数据量很小，不推荐使用此方法，会造成空间浪费，用默认无参的即可</p>
<h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>Hashtable与 HashMap类似,它继承自Dictionary类，不同的是:它不允许记录的键或者值为空;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了 Hashtable在写入时会比较慢。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashMap 是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。</p>
<p>HashMap和LinkedHashMap区别在于HashMap是无序的，LinkedHashMap是有序的。在使用HashMap时，要根据实际情况选择最优的解决方案，降低性能和空间上的浪费。</p>
<p>LinkedHashMap维护着一个双向循环链表。此链表定义了迭代顺序，该迭代顺序通常就是将存放元素的顺序。</p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/集合/几种常见的map/" data-id="cjei8ydhq007x7oblj57m6oq8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/集合/HashSet原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/集合/HashSet原理/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/集合/">集合</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/集合/HashSet原理/">HashSet原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="HashSet的实现原理"><a href="#HashSet的实现原理" class="headerlink" title="HashSet的实现原理"></a>HashSet的实现原理</h2><ol>
<li>HashSet是基于HashMap实现的，默认构造函数是构建一个初始容量为16，负载因子为0.75 的HashMap。封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的 Object 对象。</li>
<li>当我们试图把某个类的对象当成 HashMap的 key，或试图将这个类的对象放入 HashSet中保存时，重写该类的equals(Object obj)方法和 hashCode() 方法很重要，而且这两个方法的返回值必须保持一致：当该类的两个的 hashCode() 返回值相同时，它们通过 equals() 方法比较也应该返回 true。通常来说，所有参与计算 hashCode()返回值的关键属性，都应该用于作为 equals() 比较的标准。</li>
<li>HashSet的其他操作都是基于HashMap的。</li>
</ol>
<p>HashSet实现Set接口，由哈希表（实际上是一个HashMap实例）支持。它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素，但是HashSet中不允许有重复元素</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>对于HashSet而言，它是基于HashMap实现的，HashSet底层使用HashMap来保存所有元素，因此HashSet 的实现比较简单，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成， HashSet的源代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div></pre></td><td class="code"><pre><div class="line">public class HashSet&lt;E&gt;  </div><div class="line">    extends AbstractSet&lt;E&gt;  </div><div class="line">    implements Set&lt;E&gt;, Cloneable, java.io.Serializable  </div><div class="line">&#123;  </div><div class="line">    static final long serialVersionUID = -5024744406713321676L;  </div><div class="line">  </div><div class="line">    // 底层使用HashMap来保存HashSet中所有元素。  </div><div class="line">    private transient HashMap&lt;E,Object&gt; map;  </div><div class="line">      </div><div class="line">    // 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。  </div><div class="line">    private static final Object PRESENT = new Object();  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 默认的无参构造器，构造一个空的HashSet。 </div><div class="line">     *  </div><div class="line">     * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 </div><div class="line">     */  </div><div class="line">    public HashSet() &#123;  </div><div class="line">        map = new HashMap&lt;E,Object&gt;();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 构造一个包含指定collection中的元素的新set。 </div><div class="line">     * </div><div class="line">     * 实际底层使用默认的加载因子0.75和足以包含指定 </div><div class="line">     * collection中所有元素的初始容量来创建一个HashMap。 </div><div class="line">     * @param c 其中的元素将存放在此set中的collection。 </div><div class="line">     */  </div><div class="line">    public HashSet(Collection&lt;? extends E&gt; c) &#123;  </div><div class="line">        map = new HashMap&lt;E,Object&gt;(Math.max((int) (c.size()/.75f) + 1, 16));  </div><div class="line">        addAll(c);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 以指定的initialCapacity和loadFactor构造一个空的HashSet。 </div><div class="line">     * </div><div class="line">     * 实际底层以相应的参数构造一个空的HashMap。 </div><div class="line">     * @param initialCapacity 初始容量。 </div><div class="line">     * @param loadFactor 加载因子。 </div><div class="line">     */  </div><div class="line">    public HashSet(int initialCapacity, float loadFactor) &#123;  </div><div class="line">        map = new HashMap&lt;E,Object&gt;(initialCapacity, loadFactor);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 以指定的initialCapacity构造一个空的HashSet。 </div><div class="line">     * </div><div class="line">     * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。 </div><div class="line">     * @param initialCapacity 初始容量。 </div><div class="line">     */  </div><div class="line">    public HashSet(int initialCapacity) &#123;  </div><div class="line">        map = new HashMap&lt;E,Object&gt;(initialCapacity);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 </div><div class="line">     * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。 </div><div class="line">     * </div><div class="line">     * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。 </div><div class="line">     * @param initialCapacity 初始容量。 </div><div class="line">     * @param loadFactor 加载因子。 </div><div class="line">     * @param dummy 标记。 </div><div class="line">     */  </div><div class="line">    HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;  </div><div class="line">        map = new LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 返回对此set中元素进行迭代的迭代器。返回元素的顺序并不是特定的。 </div><div class="line">     *  </div><div class="line">     * 底层实际调用底层HashMap的keySet来返回所有的key。 </div><div class="line">     * 可见HashSet中的元素，只是存放在了底层HashMap的key上， </div><div class="line">     * value使用一个static final的Object对象标识。 </div><div class="line">     * @return 对此set中元素进行迭代的Iterator。 </div><div class="line">     */  </div><div class="line">    public Iterator&lt;E&gt; iterator() &#123;  </div><div class="line">        return map.keySet().iterator();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 返回此set中的元素的数量（set的容量）。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。 </div><div class="line">     * @return 此set中的元素的数量（set的容量）。 </div><div class="line">     */  </div><div class="line">    public int size() &#123;  </div><div class="line">        return map.size();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 如果此set不包含任何元素，则返回true。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。 </div><div class="line">     * @return 如果此set不包含任何元素，则返回true。 </div><div class="line">     */  </div><div class="line">    public boolean isEmpty() &#123;  </div><div class="line">        return map.isEmpty();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 如果此set包含指定元素，则返回true。 </div><div class="line">     * 更确切地讲，当且仅当此set包含一个满足(o==null ? e==null : o.equals(e)) </div><div class="line">     * 的e元素时，返回true。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的containsKey判断是否包含指定key。 </div><div class="line">     * @param o 在此set中的存在已得到测试的元素。 </div><div class="line">     * @return 如果此set包含指定元素，则返回true。 </div><div class="line">     */  </div><div class="line">    public boolean contains(Object o) &#123;  </div><div class="line">        return map.containsKey(o);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 如果此set中尚未包含指定元素，则添加指定元素。 </div><div class="line">     * 更确切地讲，如果此 set 没有包含满足(e==null ? e2==null : e.equals(e2)) </div><div class="line">     * 的元素e2，则向此set 添加指定的元素e。 </div><div class="line">     * 如果此set已包含该元素，则该调用不更改set并返回false。 </div><div class="line">     * </div><div class="line">     * 底层实际将将该元素作为key放入HashMap。 </div><div class="line">     * 由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key </div><div class="line">     * 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true）， </div><div class="line">     * 新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变， </div><div class="line">     * 因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中， </div><div class="line">     * 原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。 </div><div class="line">     * @param e 将添加到此set中的元素。 </div><div class="line">     * @return 如果此set尚未包含指定元素，则返回true。 </div><div class="line">     */  </div><div class="line">    public boolean add(E e) &#123;  </div><div class="line">        return map.put(e, PRESENT)==null;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 如果指定元素存在于此set中，则将其移除。 </div><div class="line">     * 更确切地讲，如果此set包含一个满足(o==null ? e==null : o.equals(e))的元素e， </div><div class="line">     * 则将其移除。如果此set已包含该元素，则返回true </div><div class="line">     * （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的remove方法删除指定Entry。 </div><div class="line">     * @param o 如果存在于此set中则需要将其移除的对象。 </div><div class="line">     * @return 如果set包含指定元素，则返回true。 </div><div class="line">     */  </div><div class="line">    public boolean remove(Object o) &#123;  </div><div class="line">        return map.remove(o)==PRESENT;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 从此set中移除所有元素。此调用返回后，该set将为空。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的clear方法清空Entry中所有元素。 </div><div class="line">     */  </div><div class="line">    public void clear() &#123;  </div><div class="line">        map.clear();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到HashSet中。 </div><div class="line">     */  </div><div class="line">    public Object clone() &#123;  </div><div class="line">        try &#123;  </div><div class="line">            HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone();  </div><div class="line">            newSet.map = (HashMap&lt;E, Object&gt;) map.clone();  </div><div class="line">            return newSet;  </div><div class="line">        &#125; catch (CloneNotSupportedException e) &#123;  </div><div class="line">            throw new InternalError();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/集合/HashSet原理/" data-id="cjei8ydhp007s7oblefgb6mnw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/集合/CopyOnWrite容器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/集合/CopyOnWrite容器/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/集合/">集合</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/集合/CopyOnWrite容器/">CopyOnWrite容器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p>
<h3 id="什么是CopyOnWrite容器"><a href="#什么是CopyOnWrite容器" class="headerlink" title="什么是CopyOnWrite容器"></a>什么是CopyOnWrite容器</h3><p><strong>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器</strong>。</p>
<h3 id="CopyOnWriteArrayList的实现原理"><a href="#CopyOnWriteArrayList的实现原理" class="headerlink" title="CopyOnWriteArrayList的实现原理"></a>CopyOnWriteArrayList的实现原理</h3><p>在使用CopyOnWriteArrayList之前，我们先阅读其源码了解下它是如何实现的。以下代码是向ArrayList里添加元素，可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public boolean add(T e) &#123;</div><div class="line">	</div><div class="line">	final ReentrantLock lock = this.lock;</div><div class="line">	lock.lock();</div><div class="line">	try &#123;</div><div class="line"></div><div class="line">		Object[] elements = getArray();</div><div class="line"></div><div class="line">		int len = elements.length;</div><div class="line">		// 复制出新数组</div><div class="line">		Object[] newElements = Arrays.copyOf(elements, len + 1);</div><div class="line"></div><div class="line">		// 把新元素添加到新数组里</div><div class="line">		newElements[len] = e;</div><div class="line">		</div><div class="line">		// 把原数组引用指向新数组</div><div class="line">		setArray(newElements);</div><div class="line"></div><div class="line">		return true;</div><div class="line"></div><div class="line">	&#125; finally &#123;</div><div class="line"></div><div class="line">		lock.unlock();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">final void setArray(Object[] a) &#123;</div><div class="line">	array = a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public E get(int index) &#123;</div><div class="line">    return get(getArray(), index);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>JDK中并没有提供CopyOnWriteMap，我们可以参考CopyOnWriteArrayList来实现一个，基本代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">import java.util.Collection;</div><div class="line">import java.util.Map;</div><div class="line">import java.util.Set;</div><div class="line"></div><div class="line">public class CopyOnWriteMap&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable &#123;</div><div class="line">    private volatile Map&lt;K, V&gt; internalMap;</div><div class="line"></div><div class="line">    public CopyOnWriteMap() &#123;</div><div class="line">        internalMap = new HashMap&lt;K, V&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public V put(K key, V value) &#123;</div><div class="line"></div><div class="line">        synchronized (this) &#123;</div><div class="line">            Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap);</div><div class="line">            V val = newMap.put(key, value);</div><div class="line">            internalMap = newMap;</div><div class="line">            return val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public V get(Object key) &#123;</div><div class="line">        return internalMap.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void putAll(Map&lt;? extends K, ? extends V&gt; newData) &#123;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap);</div><div class="line">            newMap.putAll(newData);</div><div class="line">            internalMap = newMap;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现很简单，只要了解了CopyOnWrite机制，我们可以实现各种CopyOnWrite容器，并且在不同的应用场景中使用。</p>
<h3 id="CopyOnWrite的应用场景"><a href="#CopyOnWrite的应用场景" class="headerlink" title="CopyOnWrite的应用场景"></a>CopyOnWrite的应用场景</h3><p>CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">package com.ifeve.book;</div><div class="line"></div><div class="line">import java.util.Map;</div><div class="line"></div><div class="line">import com.ifeve.book.forkjoin.CopyOnWriteMap;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 黑名单服务</div><div class="line"> *</div><div class="line"> * @author fangtengfei</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class BlackListServiceImpl &#123;</div><div class="line"></div><div class="line">    private static CopyOnWriteMap&lt;String, Boolean&gt; blackListMap = new CopyOnWriteMap&lt;String, Boolean&gt;(</div><div class="line">            1000);</div><div class="line"></div><div class="line">    public static boolean isBlackList(String id) &#123;</div><div class="line">        return blackListMap.get(id) == null ? false : true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void addBlackList(String id) &#123;</div><div class="line">        blackListMap.put(id, Boolean.TRUE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 批量添加黑名单</div><div class="line">     *</div><div class="line">     * @param ids</div><div class="line">     */</div><div class="line">    public static void addBlackList(Map&lt;String,Boolean&gt; ids) &#123;</div><div class="line">        blackListMap.putAll(ids);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码很简单，但是使用CopyOnWriteMap需要注意两件事情：</p>
<ol>
<li><p>减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。</p>
</li>
<li><p>使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。如使用上面代码里的addBlackList方法。</p>
</li>
</ol>
<h3 id="CopyOnWrite的缺点"><a href="#CopyOnWrite的缺点" class="headerlink" title="CopyOnWrite的缺点"></a>CopyOnWrite的缺点</h3><p>CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p>
<p><strong>内存占用问题</strong>。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</p>
<p>针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。</p>
<p><strong>数据一致性问题</strong>。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/集合/CopyOnWrite容器/" data-id="cjei8ydho007p7obldorl7p9a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/基础/对象存活" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/基础/对象存活/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/基础/对象存活/">对象存活</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用的</p>
<p>目前主流的java虚拟机里面没有选用引用计数器算法来管理内存，其中主要的原因是它很难解决对象之间相互循环引用的问题</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p><strong>这个算法的基本思路就是通过一系列的称为“GC Roots”的对象为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的</strong>。<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/obj.png" alt="image"><br>如图，object5，object6，object7就是不可用的，可以清除的</p>
<p>在java语言中，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关</p>
<p>在JDK1.2之后，java对引用的概念进行了扩充，将引用分为<code>强引用（Strong Reference）</code>，<code>软引用（Soft Reference）</code>，<code>弱引用（Weak Reference）</code>，<code>虚引用（Phantom Reference）</code>4种，这4种引用强度依次逐渐减弱</p>
<ul>
<li>强引用就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收被引用的对象</li>
<li><strong>软引用是用来描述一些还有用但并非必需的对象</strong>。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出的异常。在JDK1.2之后，提供了SoftReference类来实现软引用</li>
<li><strong>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前</strong>。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用</li>
<li>虚引用也称为幽灵引用或者幻影引用，他是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。<strong>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</strong>。在JDK1.2之后，提供了OhantomReference类实现虚引用</li>
</ul>
<h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>即使在可达性分析算法中被可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，<strong>要真正宣告一个对象死亡，至少要经历两次标识过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”</strong>。</p>
<p>如果这个对象被判定为有必要执行finalize()方法，那么合格对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个虚拟机自动建立的，低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统奔溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()方法中成功拯救自己-只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/基础/对象存活/" data-id="cjei8ydg500477obl1ootflc0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/基础/java运行期优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/基础/java运行期优化/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/基础/java运行期优化/">java运行期优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在部分的商用虚拟机（Sun HotSpot， IMB J9）中，Java程序最初是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码定位“<strong>热点代码</strong>”（Hot Spot Code）。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为<strong>即时编译器</strong>（Just In TimenCompiler，简称JIT编译器）。</p>
<p>即时编辑器并不是虚拟机必须的部分，Java虚拟机规范并没有规定Java虚拟机内必须要有即时编译器的存在，更没有限定或指导即时编译器应该如何实现。但是，即时编译器编译性能的好坏，代码优化程度的高低却是衡量一款商用虚拟机优秀与否的最关键的技术指标之一。</p>
<h3 id="HotSpot虚拟机内的即时编译器"><a href="#HotSpot虚拟机内的即时编译器" class="headerlink" title="HotSpot虚拟机内的即时编译器"></a>HotSpot虚拟机内的即时编译器</h3><h4 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h4><p>解释器与编译器两者各有优势：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。</p>
<p>当程序运行环境中内存资源限制较大（如部分嵌入式系统中），可以使用解释执行节约内存，反之可以使用编译执行来提升效率。同时，解释器还可以作为编译器激进优化时的一个“逃生门”，让编译器根据概率选择一些大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，如加载了新类后类型继承结构出现变化，出现“罕见陷阱”时可以通过逆优化退回到解释状态继续执行。如下图所示：<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/jieshi.png" alt="image"></p>
<p>HotSpot虚拟机中内置了两个即时编译器，分别称为<strong>Client Compiler</strong>（C1 编译器） 和 <strong>Server Compiler</strong>（C2 编译器），默认采用解释器与其中一个编译器直接配合的方式工作，程序使用哪个编译器，取决于虚拟机运行的模式，HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用“<strong>-client</strong>”或“<strong>-server</strong>”参数去强制指定虚拟机运行在Client模式或Server模式。</p>
<p>虚拟机中的三种模式：</p>
<ul>
<li>混合模式（Mixed Mode）：解释器与编译器搭配使用的方式</li>
<li>解释模式（Interpreted Mode）：使用参数“-Xint”强制虚拟机运行于解释模式，这时编译器完全不介入工作，全部代码都使用解释方式执行</li>
<li>编译模式（Compiled Mode）：使用参数“—Xcomp”强制让虚拟机运行于编译模式，这时将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程</li>
</ul>
<p>由于即使编译器编译本地代码需要占用程序运行时间，要编译出优化程度更高的代码，所花费的时间可能更长；而且想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，这对解释执行的速度也有影响。  </p>
<p>为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot虚拟机还会逐渐启用<strong>分层编译</strong>（Tiered Compilation）的策略。这个策略最终在JDK1.7的Server模式虚拟机中作为默认编译策略被开启。</p>
<p>分层编译根据编译器编译，优化的规模与耗时，划分出不同的编译层次，其中包括：</p>
<ol>
<li>第0层，程序解释执行，解释器不开启性能监控功能（Profiling）。可触发第1层编译。</li>
<li>第1层，也称为C1编译，将字节码编译为本地代码，进行简单，可靠的优化，如有必要将加入性能监控的逻辑。</li>
<li>第2层（或2层以上），也称为C2编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化</li>
</ol>
<p>实施分层编译后，Client Compiler 和 Server Compiler将会同时工作，许多代码都可能会被多次编译，用Client Compiler获取更高的编译速度，用Server Compiler来获取更好的编译质量，在解释执行的时候也无须再承担收集性能监控信息的任务。</p>
<h4 id="编译对象和触发条件"><a href="#编译对象和触发条件" class="headerlink" title="编译对象和触发条件"></a>编译对象和触发条件</h4><p>在运行过程中会被即时编译器编译的“热点代码”有两类，即：</p>
<ul>
<li>被多次调用的方法</li>
<li>被多次执行的循环体</li>
</ul>
<p>方法和循环体都是以整个方法作为<strong>编译对象</strong>的。这种编译方式因为编译发生在方法执行过程之中，因此形象地称之为<strong>栈上替换</strong>（On Stack Replacement，简称<strong>OSR编译</strong>）。</p>
<p>判断一段代码是不是热点代码，是不是需要触发即时编译，这样的行为称为<strong>热点探测</strong>（Hot Spot Detection）。目前有两种方式：</p>
<ul>
<li><strong>基于采样的热点探测</strong>（Sample Based Hot Spot Detection）：采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”。<ul>
<li>好处：实现简单，高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可）</li>
<li>缺点：很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测</li>
</ul>
</li>
<li><strong>基于计数器的热点探测</strong>（Counter Based Hot Spot Detection）：采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值就认为它是“热点方法”。<ul>
<li>好处：统计结果相对来说更加精确和严谨</li>
<li>缺点：实现起来麻烦一些，需要为每个方法建立并维护计数器，而不能直接获取到方法的调用关系</li>
</ul>
</li>
</ul>
<p>在HotSpot虚拟机中使用的是第二种方式，因此它为每个方法准备了两类计数器：<strong>方法调用计数器</strong>（Invocation Counter）和<strong>回边计数器</strong>（Back Edge Counter）。</p>
<h6 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h6><p>默认阀值在Client模式下是1500次，在Server模式下是10000次，可以通过参数<code>-XX:CompileThreshold</code>来设定。</p>
<p><strong>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。如果已超过阀值，那么将会向即时编译器提交一个该方法的代码编译请求</strong>。</p>
<p>如果不做任何设置，执行引擎并不会同步等待编译请求完成，而是继续进行解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成。当编译工作完成之后，这个方法的调用入口地址就会被系统自动改写成新的，下一次调用该方法时 就会使用已编译的版本，如下图所示：<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/jit.png" alt="image">   </p>
<p><strong>方法调用计数器热度的衰减</strong>（Counter Decay）：如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行效率，即一段时间之内方法被调用的次数。超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程就称为方法调用计数器热度的衰减。而这段时间就称为<strong>此方法统计的半衰周期</strong>（Counter Half Life Time）。</p>
<p><code>-XX:-UseCounterDeacy</code>：关闭热度衰减<br><code>-XX:CounterHalfLifeTime</code>：设置半衰周期的时间，单位是秒</p>
<h6 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h6><p>通过参数：<code>-XX:OnStackReplacPercentage</code>来间接调整回边计数器的阀值</p>
<ul>
<li><p>Client模式下：<br>  回边计数器的阀值计算公式为：<strong>方法调用计数器阀值 x OSR比率（OnStackReplacePercentage） / 100</strong>   </p>
<p>  其中，OnStackReplacePercentage默认值为933，如果都取默认值，那Client模式虚拟机的回边计数器的阀值为13995</p>
</li>
<li><p>Server模式下：<br>  回边计数器的阀值计算公式为：<strong>方法调用计数器阀值 x ( OSR比率（OnStackReplacePercentage） - 解释器监控比率（InterpreterProfilePercentage） ) / 100</strong>  </p>
<p>  其中，OnStackReplacePercentage默认值为140，InterpreterProfilePercentage默认值为33，如果都取默认值，那Server模式虚拟机的回边计数器的阀值为10700</p>
</li>
</ul>
<p><strong>当解释器遇到一条回边指令时，会先查找讲要执行的代码片段是否有已经编译好的版本，如果有，它将会优先执行已编译的代码，否则就把回边计数器的值加1，然后判断方法调用计数器与回边计数之和是否超过回边计数器的阀值。当超过阀值的时候，将会提交一个OSR编译请求，并且把回边计数器的值降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果</strong>，如下图所示：<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/osr.png" alt="image">   </p>
<p>与方法计数不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出状态，这样下次再进入该方法的时候就会执行标准编译过程。</p>
<p>注意：上面的描述都是仅仅描述了Client VM的即时编译方式，对于Server VM来说，执行情况会比上面的描述更复杂一些。</p>
<h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><p>在默认设置下，无论是方法调用产生的即时编译请求，还是OSR编译请求，虚拟机在代码编译器还未完成之前，都仍然将按照解释方式继续执行，而编译动作则在后台的编译线程中进行。用户可以通过参数<code>-XX:-BackgroundCompilation</code>来禁止后台编译，在禁止后台编译后，一旦达到JIT的编译条件，执行线程向虚拟机提交编译请求后将会一直等待，直到编译过程完成后再开始执行编译器输出的本地代码。</p>
<p>Client Compiler编译的三个过程：</p>
<ol>
<li>在第一个阶段，一个平台独立的前端字节码构造成一种高级中间代码表示（High-Level Intermediate Repressentation，HIR）。HIR使用静态单分配（Static Single Assignment，SSA）的形式来代表代码值，这可以使得一些在HIR的构造过程之中和之后进行的优化动作更容易实现。在此之前编译器会在字节码上完成一部分基础优化，如方法内联，常量传播等优化将会在字节码被构造成HIR之前完成</li>
<li>在第二阶段，一个平台相关的后端从HIR中产生低级中间代码表示（Low-Level Intermediate Representation，LIR），而在此之前会在HIR上完成另外一些优化，如空值检查消除，范围检查消除等，以便让HIR达到更高效的代码表示形式</li>
<li>最后阶段是在平台相关的后端使用线性扫描算法（Linear Scan Register Allocation）在LIR上分配寄存器，并在LIR上做窥孔（Peephole）优化，然后产生机器代码。</li>
</ol>
<p>各阶段的流程如下图所示：<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/com1.png" alt="image"></p>
<h4 id="最具代表性的优化技术"><a href="#最具代表性的优化技术" class="headerlink" title="最具代表性的优化技术"></a>最具代表性的优化技术</h4><ul>
<li>语言无关的经典优化技术之一：公共子表达式消除</li>
<li>语言无关的经典优化技术之一：数组范围检查消除</li>
<li>最重要的优化技术之一：方法内联</li>
<li>最前沿的优化技术之一：逃逸分析</li>
</ul>
<h6 id="公共子表达式消除"><a href="#公共子表达式消除" class="headerlink" title="公共子表达式消除"></a>公共子表达式消除</h6><p>含义：如果一个表达式E已经计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成为了<strong>公共子表达式</strong>。对于这种表达式，没有必要花时间再对它进行计算，只需要直接用前面计算过的表达式结果代替E就可以了。如果这种优化仅限于程序的基本块内，便称为<strong>局部公共子表达式消除</strong>。如果这种优化的范围涵盖了多个基本块，那就称为<strong>全局公共子表达式消除</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">假设有如下代码：</div><div class="line">int d = (c * b) * 12 + a + (a + b * c);</div><div class="line">当这段代码进入到虚拟机即时编译器后，它将进行如下优化：</div><div class="line">编译器检测到“c*b”与“b*c”是一样的表达式，而且在计算期间b与c的值是不变的，</div><div class="line">因此，这条表达式就可能被视为：</div><div class="line">int d = E * 12 + a + (a + E);</div><div class="line">这时，编译器还可能进行另外一种优化：代数化简</div><div class="line">int d = E * 13 + a * 2;</div></pre></td></tr></table></figure></p>
<h6 id="数组边界检查消除"><a href="#数组边界检查消除" class="headerlink" title="数组边界检查消除"></a>数组边界检查消除</h6><p>Java语言是一门动态安全的语言，对数组的读写访问也不像C，C++那样在本质上是裸指针操作。</p>
<p>如果有一个数组foo[]，在java语言中访问数组元素foo[i]的时候系统将会自动进行上下界的范围检查，即检查i必须满足i&gt;=0&amp;&amp;i&lt;foo.length这个条件，否则将抛出一个运行时异常：java.lang.ArrayIndexOutOfBoundsException。这对软件开发者来说是一件很好的事情，即使程序员没有专门编写防御代码，也可以避免大部分的溢出攻击。但是对于虚拟机的执行子系统来说，每次数组元素的读写都带有一次隐含的条件判定操作，对于拥有大量数组访问的程序代码，这无疑是一种性能负担。</p>
<p>无论如何，为了安全，数组边界检查肯定是必须做的，但数组边界检查是不是必须在运行期间一次不漏地检查则是可以“商量”的。例如下面这个简单的情况：数组下标是一个常量，如foo[3]，只要在编译期根据数据流分析来确定foo.length的值，并判断下标“3”没有越界，执行的时候就无须判断了。更加常见的情况是数组访问发生在循环之中，并且使用循环变量来进行数组访问，如果编译器只要通过数据流分析就可以判定循环变量的取值范围永远在区间[0, foo.length)之内，那在整个循环中就可以把数组的上下界检查消除，这可以节省很多次的条件判断操作。</p>
<p>要消除这些隐式开销，除了如数组边界检查优化这种尽可能把运行期检查提到编译器完成的思路之外，另外还有一种避免思路-<strong>隐式异常处理</strong>。Java中空指针检查和算术运算中除数为0的检查都采用了这种思路。举个例子，例如程序访问一个对象（假设对象叫foo）的某个属性（假设属性叫value），那以java伪代码来表示虚拟机访问foo.value过程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (foo != null) &#123;</div><div class="line">    return foo.value;</div><div class="line">&#125; else &#123;</div><div class="line">    throw new NullPointException();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在用隐式异常优化后，虚拟机会把上面的伪代码所表示的访问过程变为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">    return foo.value;</div><div class="line">&#125; catch(segment_fault) &#123;</div><div class="line">    uncommon_trap();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虚拟机会注册一个Segment Fault信号的异常处理器，这样当foo不为空的时候，对value的访问是不会额外消耗一次对foo判空的开销的。代价就是当foo真的为空时，必须转入到异常处理器中恢复并抛出NullpointException异常，这个过程必须从用户态转到内核态中处理，结束后再回到用户态，速度远比一次判空检查慢。当foo极少为空的时候，隐式异常优化是值得的，但假如foo经常为空的话，这样的优化反而会让程序更慢，还好HotSpot虚拟机足够“聪明”，它会根据运行期收集到的Profile信息自动选择最优方案。</p>
<p>与语言相关的其他消除操作还有：<strong>自动装箱消除</strong>（Autobox Elimination），<strong>安全点消除</strong>（Safepoint Elimination），<strong>消除反射</strong>（Dereflection）等</p>
<h6 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h6><p>编译器最重要的优化手段之一，除了消除方法调用的成本外，它更重要的意义是为其他优化手段建立良好的基础。<br>例如：内联对其他优化手段的意义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static void foo(Object obj) &#123;</div><div class="line">    if(obj != null) &#123;</div><div class="line">        System.out.println(&quot;do something&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void testInline(String[] args) &#123;</div><div class="line">    Object obj = null;</div><div class="line">    foo(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>事实上，testInline()方法内部全部都是无用的代码，如果不做内联，后续即使进行了无用代码消除的优化，也无法发现任何“Dead Code”，因为如果分开来看，foo()和testInline()两个方法里面的操作都可能是有意义的。</p>
<p>含义：<strong>方法内联的优化行为看起来很简单，不过是把目标方法的代码“复制”到发起调用的方法之中，避免发生真实的方法调用而已</strong>。但实际上Java虚拟机中的内联过程远远没有那么简单，因为如果不是即时编译器做了一些特别的努力，按照经典编译原理的优化理论，大多数的java方法都无法进行内联。</p>
<p>只有使用invokespecial指令调用的私有方法，实例构造器，父类方法以及使用invokestatic指令进行调用的静态方法才是在编译器进行解析的，除了上述4种方法外，其他的java方法调用都需要在运行时进行方法接收者的多态选择，并且都有可能存在多于一个版本的方法接收者（最多再除去被final修饰的方法这种特殊情况，尽管它使用invokevirtual指令调用，但也是非虚方法，Java语言规范中明确说明了这点）。简而言之，<strong>Java语言中默认的实例方法是虚方法</strong>。</p>
<p>为了解决虚方法的内联问题，Java虚拟机团队想了很多办法，首先是引入了一种名为“<strong>类型继承关系分析</strong>”（Class Hierarchy Analysis， <strong>CHA</strong>）的技术。<strong>这是一种基于整个应用程序的类型分析技术，它用于确定在目前已加载的类中，某个接口是否有多于一种的实现，某个类是否存在子类，子类是否为抽象类等信息</strong>。</p>
<p>编译器在进行内联时，如果是非虚方法，那么直接进行内联就可以了，这时候的内联是有稳定前提保障的。如果遇到虚方法，则会向CHA查询此方法在当前程序下是否有多个目标版本可供选择，如果查询结果只有一个版本，那也可以进行内联，不过这种内联就属于激进优化，需要预留一个“逃生门”（Guard条件不成立时的Slow Path），称为<strong>守护内联</strong>（Guarded Inlining）。如果程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的接收者的继承关系发生变化的类，那这个内联优化的代码就可以一直使用下去。但如果加载了导致继承关系发生变化的新类，那就需要抛弃已经编译的代码，退回到解释状态执行，或者重新编译。</p>
<p>如果向CHA查询出来的结果是有多个版本的目标方法可供选择，则编译器还将会进行最后一次努力，使用内联缓存（Inline Cache）来完成方法内联，这是一个建立在目标方法正常入口之前的缓存，它的工作原理大致是：<strong>在未发生方法调用之前，内联缓存状态为空，当第一次调用发生后，缓存记录下方法接收者的版本信息，并且每次进行方法调用时都比较接收者版本，如果以后进来的每次调用的方法接收者版本都是一样的，那这个内联还可以一直用下去。如果发生了方法接收者不一致的情况，就说明程序真正使用了虚方法的多态特性，这时才会取消内联，查找虚方法表进行方法分派</strong>。</p>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>逃逸分析（Escape Analysis）是目前java虚拟机中比较前沿的优化技术，它与类型继承关系分析一样，并不是直接优化代码的手段，而是为其他优化手段提供依据的分析技术。</p>
<p>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为<strong>方法逃逸</strong>。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为<strong>线程逃逸</strong>。</p>
<p>如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可能会为这个变量进行一些高效的优化：</p>
<ul>
<li>栈上分配（Stack Allocation）：Java虚拟机中，在Java堆上分配创建对象的内存空间几乎是Java程序员都清楚的常识了，Java堆中的对象对于各个线程都是共享可见的，只要持有这个对象的引用，就可以访问堆中存储的对象数据。虚拟机的垃圾收集系统可以回收堆中不再使用的对象，但回收动作无论是筛选可回收对象，还是回收和整理内存都需要耗费时间。<strong>如果确定一个对象不会逃逸除方法之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中，不会逃逸的局部对象所占的比例很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾收集系统的压力将会小很多</strong>。</li>
<li>同步消除（Synchronization Elimination）；线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那这个变量的读写肯定不会有竞争，对这个变量实施的同步措施也就可以消除掉。</li>
<li>标量替换（Scalar Replacement）：标量（Scalar）是指一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型（int，long等数值类型以及reference类型等）都不能再进一步分解，它们就可以称为<strong>标量</strong>。相对的，如果一个数据可以继续分解，那它就称作<strong>聚合量</strong>（Aggregate），Java中的对象就是最典型的聚合量。如果把一个Java对象拆散，根据程序访问的情况，将其使用到的成员变量恢复原始类型来访问就叫做<strong>标量替换</strong>。如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话，那程序真正执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。将对象拆分后，除了可以让对象的成员变量在栈上（栈上存储的数据，有很大的概率会被虚拟机分配至物理机器的高速寄存器中存储）分配和读写之外，还可以为后续进一步的优化手段创建条件。</li>
</ul>
<p>逃逸分析不成熟的原因主要是不能保证逃逸分析的性能收益必定高于它的消耗。</p>
<p><code>-XX:+DoEscapeAnalysis</code>:手动开启逃逸分析<br><code>-XX:+PrintEscapeAnalysis</code>:查看分析结果<br><code>-XX:+EliminateAllocations</code>:开启标量替换<br><code>-XX:+EliminateLocks</code>:开启同步消除<br><code>-XX:+PrintEliminateAllocations</code>:查看标量的替换情况   </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/基础/java运行期优化/" data-id="cjei8ydg6004c7oblud4egmwb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Eclipse/">Eclipse</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Github/">Github</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Cookie/">Cookie</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JAXB/">JAXB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JavaMail/">JavaMail</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/基础/">基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/数据类型/">数据类型</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/日记/">日记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/时间日期/">时间日期</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/线程/">线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/网络NIO/">网络NIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/队列/">队列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/集合/">集合</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Application-Event/">Application Event</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/JPA/">JPA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Security/">Security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Spring-Boot/">Spring Boot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Spring-Session/">Spring Session</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Task/">Task</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-MVC/">spring MVC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-data-redis/">spring data redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/基础/">基础</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/">前端技术相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/forever/">forever</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/javascript/">javascript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库相关/">数据库相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据库相关/mysql/">mysql</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/">服务器相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hessian/">Hessian</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hudson-Jenkins/">Hudson & Jenkins</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Memcached/">Memcached</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Nginx/">Nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Tomcat/">Tomcat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/red5/">red5</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/resin/">resin</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/正则表达式/">正则表达式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/08/正则表达式/正则表达式/">正则表达式</a>
          </li>
        
          <li>
            <a href="/2018/02/25/Java/集合/Hashtable与ConcurrentHashMap区别/">Hashtable与ConcurrentHashMap区别</a>
          </li>
        
          <li>
            <a href="/2018/02/25/Java/分布式/分布式事务/">分布式事务</a>
          </li>
        
          <li>
            <a href="/2018/02/25/Java/分布式/分布式锁/">分布式锁</a>
          </li>
        
          <li>
            <a href="/2018/02/25/Java/集合/在List循环中删除元素/">在List循环中删除元素</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 LeoChan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>