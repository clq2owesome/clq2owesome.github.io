<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LeoChan&#39;s 个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="描述啊">
<meta property="og:type" content="website">
<meta property="og:title" content="LeoChan&#39;s 个人博客">
<meta property="og:url" content="https://clq2owesome.github.io/index.html">
<meta property="og:site_name" content="LeoChan&#39;s 个人博客">
<meta property="og:description" content="描述啊">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeoChan&#39;s 个人博客">
<meta name="twitter:description" content="描述啊">
  
    <link rel="alternate" href="/atom.xml" title="LeoChan&#39;s 个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LeoChan&#39;s 个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术都是通用的，重要的是是否具有自主解决问题的能力！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://clq2owesome.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-服务器相关/Tomcat/TOMCAT原理详解及请求过程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/12/服务器相关/Tomcat/TOMCAT原理详解及请求过程/" class="article-date">
  <time datetime="2018-04-12T02:09:45.000Z" itemprop="datePublished">2018-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/Tomcat/">Tomcat</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/12/服务器相关/Tomcat/TOMCAT原理详解及请求过程/">TOMCAT原理详解及请求过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat:"></a>Tomcat:</h3><p>Tomcat是一个JSP/Servlet容器。其作为Servlet容器，有三种工作模式：独立的Servlet容器、进程内的Servlet容器和进程外的Servlet容器。</p>
<h3 id="Tomcat目录："><a href="#Tomcat目录：" class="headerlink" title="Tomcat目录："></a>Tomcat目录：</h3><ul>
<li><strong>bin</strong>：存放启动和关闭tomcat脚本</li>
<li><strong>conf</strong>：存放不同的配置文件（server.xml和web.xml）；</li>
<li><strong>doc</strong>：存放Tomcat文档；</li>
<li><strong>lib/japser/common</strong>：存放Tomcat运行需要的库文件（JARS）；</li>
<li><strong>logs</strong>：存放Tomcat执行时的LOG文件；</li>
<li><strong>src</strong>：存放Tomcat的源代码；</li>
<li><strong>webapps</strong>：Tomcat的主要Web发布目录（包括应用程序示例）；</li>
<li><strong>work</strong>：存放jsp编译后产生的class文件；</li>
</ul>
<h3 id="Tomcat配置文件："><a href="#Tomcat配置文件：" class="headerlink" title="Tomcat配置文件："></a>Tomcat配置文件：</h3><p>我们打开con文件夹可以看到Tomcat的配置文件：</p>
<ul>
<li><p><strong>server.xml</strong>: Tomcat的主配置文件，包含Service, Connector, Engine, Realm, Valve, Hosts主组件的相关配置信息；</p>
</li>
<li><p><strong>web.xml</strong>：遵循Servlet规范标准的配置文件，用于配置servlet，并为所有的Web应用程序提供包括MIME映射等默认配置信息；</p>
</li>
<li><p><strong>tomcat-user.xml</strong>：Realm认证时用到的相关角色、用户和密码等信息；Tomcat自带的manager默认情况下会用到此文件；在Tomcat中添加/删除用户，为用户　　指定角色等将通过编辑此文件实现；</p>
</li>
<li><p><strong>catalina.policy</strong>：Java相关的安全策略配置文件，在系统资源级别上提供访问控制的能力；</p>
</li>
<li><p><strong>catalina.properties</strong>：Tomcat内部package的定义及访问相关控制，也包括对通过类装载器装载的内容的控制；Tomcat在启动时会事先读取此文件的相关设置；</p>
</li>
<li><p><strong>logging.properties</strong>:Tomcat6通过自己内部实现的JAVA日志记录器来记录操作相关的日志，此文件即为日志记录器相关的配置信息，可以用来定义日志记录的组　　件级别以及日志文件的存在位置等；</p>
</li>
<li><p><strong>context.xml</strong>：所有host的默认配置信息；</p>
</li>
</ul>
<h3 id="Tomcat架构及常用的组件："><a href="#Tomcat架构及常用的组件：" class="headerlink" title="Tomcat架构及常用的组件："></a>Tomcat架构及常用的组件：</h3><p><img src="https://raw.githubusercontent.com/clq2owesome/image/master/1078737-20170109110435088-1621430699.png" alt="image"></p>
<ol>
<li><p>Server组件<br> 如上面示例文件中定义的：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</div></pre></td></tr></table></figure>
<p> 这会让Tomcat启动一个server实例（即一个JVM），它监听在8005端口以接收shutdown命令，使用 telnet 连接8005 端口可以直接执行 SHUTDOWN 命令来关闭 Tomcat。各Server的定义不能使用同一个端口，这意味着如果在同一个物理机上启动了多个Server实例，必须配置它们使用不同的端口。这个端口的定义用于为管理员提供一个关闭此实例的便捷途径，因此，管理员可以直接telnet至此端口使用SHUTDOWN命令关闭此实例。不过，基于安全角度的考虑，这通常不允许远程进行。</p>
<h6 id="Server的相关属性："><a href="#Server的相关属性：" class="headerlink" title="Server的相关属性："></a>Server的相关属性：</h6><ul>
<li><p><strong>className</strong>: 用于实现此Server容器的完全限定类的名称，默认为org.apache.catalina.core.StandardServer；</p>
</li>
<li><p><strong>port</strong>: 接收shutdown指令的端口，默认仅允许通过本机访问，默认为8005；</p>
</li>
<li><p><strong>shutdown</strong>：发往此Server用于实现关闭tomcat实例的命令字符串，默认为SHUTDOWN；</p>
</li>
</ul>
</li>
<li><p>Service组件  </p>
<p> Service主要用于关联一个引擎和与此引擎相关的连接器，每个连接器通过一个特定的端口和协议接收入站请求交将其转发至关联的引擎进行处理。困此，Service要包含一个引擎、一个或多个连接器。</p>
<p> 如上面示例中的定义：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Service name=&quot;Catalina&quot;&gt;</div></pre></td></tr></table></figure>
<p> 这定义了一个名为Catalina的Service，此名字也会在产生相关的日志信息时记录在日志文件当中。</p>
<h6 id="Service相关的属性："><a href="#Service相关的属性：" class="headerlink" title="Service相关的属性："></a>Service相关的属性：</h6><ul>
<li><p><strong>className</strong>：用于实现service的类名，一般都是org.apache.catalina.core.StandardService。</p>
</li>
<li><p><strong>name</strong>：此服务的名称，默认为Catalina；</p>
</li>
</ul>
</li>
<li><p>Connector组件：</p>
<p> 进入Tomcat的请求可以根据Tomcat的工作模式分为如下两类：</p>
<ul>
<li><p>Tomcat作为应用程序服务器：请求来自于前端的web服务器，这可能是Apache, IIS, Nginx等；</p>
</li>
<li><p>Tomcat作为独立服务器：请求来自于web浏览器；</p>
<p>Tomcat应该考虑工作情形并为相应情形下的请求分别定义好需要的连接器才能正确接收来自于客户端的请求。一个引擎可以有一个或多个连接器，以适应多种请求方式。</p>
<p>定义连接器可以使用多种属性，有些属性也只适用于某特定的连接器类型。一般说来，常见于server.xml中的连接器类型通常有4种：</p>
</li>
</ul>
<ol>
<li>HTTP连接器 </li>
<li>SSL连接器 </li>
<li>AJP 1.3连接器 </li>
<li><p>proxy连接器</p>
<p>如上面示例server.xml中定义的HTTP连接器：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">”8080″</span> <span class="attr">protocol</span>=<span class="string">”HTTP/1.1″</span></span></div><div class="line">    <span class="attr">maxThreads</span>=<span class="string">”150″</span> <span class="attr">connectionTimeout</span>=<span class="string">”20000″</span></div><div class="line">    <span class="attr">redirectPort</span>=<span class="string">”8443″/</span>&gt;</div></pre></td></tr></table></figure>
<p>定义连接器时可以配置的属性非常多，但通常定义HTTP连接器时必须定义的属性只有“port“，定义AJP连接器时必须定义的属性只有”protocol”，因为默认的协议为HTTP。以下为常用属性的说明：</p>
</li>
</ol>
<ul>
<li><p><strong>address</strong>：指定连接器监听的地址，默认为所有地址，即0.0.0.0； 可以自己指定地，如</p>
</li>
<li><p><strong>maxThreads</strong>：支持的最大并发连接数，默认为200；</p>
</li>
<li><p><strong>port</strong>：监听的端口，默认为0；</p>
</li>
<li><p><strong>protocol</strong>：连接器使用的协议，默认为HTTP/1.1，定义AJP协议时通常为AJP/1.3；</p>
</li>
<li><p><strong>redirectPort</strong>：如果某连接器支持的协议是HTTP，当接收客户端发来的HTTPS请求时，则转发至此属性定义的端口；</p>
</li>
<li><p><strong>connectionTimeout</strong>：等待客户端发送请求的超时时间，单位为毫秒，默认为60000，即1分钟；</p>
</li>
<li><p><strong>enableLookups</strong>：是否通过request.getRemoteHost()进行DNS查询以获取客户端的主机名；默认为true； 进行反解的，可以设置为false</p>
</li>
<li><p><strong>acceptCount</strong>：设置等待队列的最大长度；通常在tomcat所有处理线程均处于繁忙状态时，新发来的请求将被放置于等待队列中；</p>
<p>下面是一个定义了多个属性的SSL连接器：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">”8443″</span></span></div><div class="line">    <span class="attr">maxThreads</span>=<span class="string">”150″</span> <span class="attr">minSpareThreads</span>=<span class="string">”25″</span> <span class="attr">maxSpareThreads</span>=<span class="string">”75″</span></div><div class="line">    <span class="attr">enableLookups</span>=<span class="string">”false”</span> <span class="attr">acceptCount</span>=<span class="string">”100″</span> <span class="attr">debug</span>=<span class="string">”0″</span></div><div class="line">    <span class="attr">scheme</span>=<span class="string">”https”</span> <span class="attr">secure</span>=<span class="string">”true”</span></div><div class="line">    <span class="attr">clientAuth</span>=<span class="string">”false”</span> <span class="attr">sslProtocol</span>=<span class="string">”TLS”</span> /&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Engine组件：     </p>
<p> Engine是Servlet处理器的一个实例，即servlet引擎，默认为定义在server.xml中的Catalina。Engine需要defaultHost属性来为其定义一个接收所有发往非明确定义虚拟主机的请求的host组件。如前面示例中定义的：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;</div></pre></td></tr></table></figure>
<h6 id="常用的属性定义："><a href="#常用的属性定义：" class="headerlink" title="常用的属性定义："></a>常用的属性定义：</h6><ul>
<li><p><strong>defaultHost</strong>：Tomcat支持基于FQDN的虚拟主机，这些虚拟主机可以通过在Engine容器中定义多个不同的Host组件来实现；但如果此引擎的连接器收到一个发往非非明确定义虚拟主机的请求时则需要将此请求发往一个默认的虚拟主机进行处理，因此，在Engine中定义的多个虚拟主机的主机名称中至少要有一个跟defaultHost定义的主机名称同名；</p>
</li>
<li><p><strong>name</strong>：Engine组件的名称，用于日志和错误信息记录时区别不同的引擎；</p>
<p>Engine容器中可以包含Realm、Host、Listener和Valve子容器。</p>
</li>
</ul>
</li>
<li><p>Host组件：</p>
<p> 位于Engine容器中用于接收请求并进行相应处理的主机或虚拟主机，如前面示例中的定义：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span></span></div><div class="line">        <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</div><div class="line">    </div><div class="line"><span class="tag">&lt;/<span class="name">Host</span>&gt;</span></div></pre></td></tr></table></figure>
<h6 id="常用属性说明："><a href="#常用属性说明：" class="headerlink" title="常用属性说明："></a>常用属性说明：</h6><ul>
<li><p><strong>appBase</strong>：此Host的webapps目录，即存放非归档的web应用程序的目录或归档后的WAR文件的目录路径；可以使用基于$CATALINA_HOME的相对路径；</p>
</li>
<li><p><strong>autoDeploy</strong>：在Tomcat处于运行状态时放置于appBase目录中的应用程序文件是否自动进行deploy；默认为true；</p>
</li>
<li><p><strong>unpackWars</strong>：在启用此webapps时是否对WAR格式的归档文件先进行展开；默认为true；</p>
<p>虚拟主机定义示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">”localhost”</span> <span class="attr">appBase</span>=<span class="string">"webapps"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">""</span> <span class="attr">docBase</span>=<span class="string">"ROOT"</span>/&gt;</span></div><div class="line">        #path路径是定义在defaultHost背后的</div><div class="line">        <span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"/bbs"</span> <span class="attr">docBase</span>=<span class="string">"/web/bss"</span> 　</span></div><div class="line">        <span class="attr">reloadable</span>=<span class="string">"true"</span> <span class="attr">crossContext</span>=<span class="string">"true"</span> /&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></div><div class="line">    </div><div class="line">    <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"mail.magedu.com"</span> <span class="attr">appBase</span>=<span class="string">"/web/mail"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">""</span> <span class="attr">docBase</span>=<span class="string">"ROOT"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></div></pre></td></tr></table></figure>
<p>主机别名定义：</p>
<p>如果一个主机有两个或两个以上的主机名，额外的名称均可以以别名的形式进行定义，如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">”www.ttlsa.com”</span> <span class="attr">appBase</span>=<span class="string">”webapps”</span> <span class="attr">unpackWARs</span>=<span class="string">”true”</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">Alias</span>&gt;</span>feiyu.com<span class="tag">&lt;/<span class="name">Alias</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">Host</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Context组件：</p>
<p> Context在某些意义上类似于apache中的路径别名，一个Context定义用于标识tomcat实例中的一个Web应用程序；如下面的定义：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">!–</span> <span class="attr">Tomcat</span> <span class="attr">Root</span> <span class="attr">Context</span> –&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">""</span> <span class="attr">docBase</span>=<span class="string">"/web/webapps"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">!–</span> <span class="attr">buzzin</span> <span class="attr">webapp</span> –&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"/bbs"</span></span></div><div class="line"><span class="attr">docBase</span>=<span class="string">"/web/threads/bbs"</span></div><div class="line"><span class="attr">reloadable</span>=<span class="string">"true"</span>&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">!–</span> <span class="attr">chat</span> <span class="attr">server</span> –&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"/chat"</span> <span class="attr">docBase</span>=<span class="string">"/web/chat"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">!–</span> <span class="attr">darian</span> <span class="attr">web</span> –&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"/darian"</span> <span class="attr">docBase</span>=<span class="string">"darian"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p> 在Tomcat中，每一个context定义也可以使用一个单独的XML文件进行，其文件的目录为<code>$CATALINA_HOME/conf/</code>。可以用于Context中的XML元素有Loader，Manager，Realm，Resources和WatchedResource。</p>
<h6 id="常用的属性定义有："><a href="#常用的属性定义有：" class="headerlink" title="常用的属性定义有："></a>常用的属性定义有：</h6><ul>
<li><p><strong>docBase</strong>：相应的Web应用程序的存放位置；也可以使用相对路径，起始路径为此Context所属Host中appBase定义的路径；切记，docBase的路径名不能与相应的Host中appBase中定义的路径名有包含关系，比如，如果appBase为deploy，而docBase绝不能为deploy-bbs类的名字；</p>
</li>
<li><p><strong>path</strong>：相对于Web服务器根路径而言的URI；如果为空“”，则表示为此webapp的根路径；如果context定义在一个单独的xml文件中，此属性不需要定义，有可能是别名；</p>
</li>
<li><p><strong>reloadable</strong>：是否允许重新加载此context相关的Web应用程序的类；默认为false；</p>
</li>
</ul>
</li>
<li><p>Realm组件：</p>
<p> 一个Realm表示一个安全上下文，它是一个授权访问某个给定Context的用户列表和某用户所允许切换的角色相关定义的列表。因此，Realm就像是一个用户和组相关的数据库。定义Realm时惟一必须要提供的属性是classname，它是Realm的多个不同实现，用于表示此Realm认证的用户及角色等认证信息的存放位置。</p>
<ul>
<li><p><strong>JAASRealm</strong>：基于Java Authintication and Authorization Service实现用户认证；</p>
</li>
<li><p><strong>JDBCRealm</strong>：通过JDBC访问某关系型数据库表实现用户认证；</p>
</li>
<li><p><strong>JNDIRealm</strong>：基于JNDI使用目录服务实现认证信息的获取；</p>
</li>
<li><p><strong>MemoryRealm</strong>：查找tomcat-user.xml文件实现用户信息的获取；</p>
</li>
<li><p><strong>UserDatabaseRealm</strong>：基于UserDatabase文件(通常是tomcat-user.xml)实现用户认证，它实现是一个完全可更新和持久有效的MemoryRealm，因此能够跟标准的MemoryRealm兼容；它通过JNDI实现；</p>
<p>下面是一个常见的使用UserDatabase的配置:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span></span></div><div class="line">    <span class="attr">resourceName</span>=<span class="string">"UserDatabase"</span>/&gt;</div></pre></td></tr></table></figure>
<p>下面是一个使用JDBC方式获取用户认证信息的配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.JDBCRealm"</span></span></div><div class="line">    <span class="attr">debug</span>=<span class="string">"99"</span></div><div class="line">    <span class="attr">driverName</span>=<span class="string">"org.gjt.mm.mysql.Driver"</span></div><div class="line">    <span class="attr">connectionURL</span>=<span class="string">"jdbc:mysql://localhost/authority"</span></div><div class="line">    <span class="attr">connectionName</span>=<span class="string">"test"</span> <span class="attr">connectionPassword</span>=<span class="string">"test"</span></div><div class="line">    <span class="attr">userTable</span>=<span class="string">"users"</span> <span class="attr">userNameCol</span>=<span class="string">"user_name"</span></div><div class="line">    <span class="attr">userCredCol</span>=<span class="string">"user_pass"</span></div><div class="line">    <span class="attr">userRoleTable</span>=<span class="string">"user_roles"</span> <span class="attr">roleNameCol</span>=<span class="string">"role_name"</span> /&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Valve组件：</p>
<p> Valve类似于过滤器，它可以工作于Engine和Host/Context之间、Host和Context之间以及Context和Web应用程序的某资源之间。一个容器内可以建立多个Valve，而且Valve定义的次序也决定了它们生效的次序。Tomcat6中实现了多种不同的Valve：</p>
<ul>
<li><p><strong>AccessLogValve</strong>：访问日志Valve</p>
</li>
<li><p><strong>ExtendedAccessValve</strong>：扩展功能的访问日志Valve</p>
</li>
<li><p><strong>JDBCAccessLogValve</strong>：通过JDBC将访问日志信息发送到数据库中；</p>
</li>
<li><p><strong>RequestDumperValve</strong>：请求转储Valve；</p>
</li>
<li><p><strong>RemoteAddrValve</strong>：基于远程地址的访问控制；</p>
</li>
<li><p><strong>RemoteHostValve</strong>：基于远程主机名称的访问控制；</p>
</li>
<li><p><strong>SemaphoreValve</strong>：用于控制Tomcat主机上任何容器上的并发访问数量；</p>
</li>
<li><p><strong>JvmRouteBinderValve</strong>：在配置多个Tomcat为以Apache通过mod_proxy或mod_jk作为前端的集群架构中，当期望停止某节点时，可以通过此Valve将用记请求定向至备用节点；使用此Valve，必须使JvmRouteSessionIDBinderListener；</p>
</li>
<li><p><strong>ReplicationValve</strong>：专用于Tomcat集群架构中，可以在某个请求的session信息发生更改时触发session数据在各节点间进行复制；</p>
</li>
<li><p><strong>SingleSignOn</strong>：将两个或多个需要对用户进行认证webapp在认证用户时连接在一起，即一次认证即可访问所有连接在一起的webapp；</p>
</li>
<li><p><strong>ClusterSingleSingOn</strong>：对SingleSignOn的扩展，专用于Tomcat集群当中，需要结合ClusterSingleSignOnListener进行工作；</p>
<p>RemoteHostValve和RemoteAddrValve可以分别用来实现基于主机名称和基于IP地址的访问控制，控制本身可以通过allow或deny来进行定义，这有点类似于Apache的访问控制功能；如下面的Valve则实现了仅允许本机访问/probe：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Context path=”/probe” docBase=”probe”&gt;</div><div class="line">    &lt;Valve className=”org.apache.catalina.valves.RemoteAddrValve”</div><div class="line">    allow=”127\.0\.0\.1″/&gt;</div><div class="line">&lt;/Context&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="Tomcat请求过程："><a href="#Tomcat请求过程：" class="headerlink" title="Tomcat请求过程："></a>Tomcat请求过程：</h3><p>Tomcat Server处理一个HTTP请求的过程：<br><img src="http://img0.tuicool.com/Mnqe22j.png%21web" alt="image"> </p>
<ol>
<li>用户点击网页内容，请求被发送到本机端口8080，被在那里监听的Coyote HTTP/1.1 Connector获得。 </li>
<li>Connector把该请求交给它所在的Service的Engine来处理，并等待Engine的回应。 </li>
<li>Engine获得请求localhost/test/index.jsp，匹配所有的虚拟主机Host。 </li>
<li>Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机），名为localhost的Host获得请求/test/index.jsp，匹配它所拥有的所有的Context。Host匹配到路径为/test的Context（如果匹配不到就把该请求交给路径名为“ ”的Context去处理）。</li>
<li>path=“/test”的Context获得请求/index.jsp，在它的mapping table中寻找出对应的Servlet。Context匹配到URL PATTERN为*.jsp的Servlet,对应于JspServlet类。</li>
<li>构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet（）或doPost（）.执行业务逻辑、数据存储等程序。</li>
<li>Context把执行完之后的HttpServletResponse对象返回给Host。</li>
<li>Host把HttpServletResponse对象返回给Engine。</li>
<li>Engine把HttpServletResponse对象返回Connector。</li>
<li>Connector把HttpServletResponse对象返回给客户Browser。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/04/12/服务器相关/Tomcat/TOMCAT原理详解及请求过程/" data-id="cjfvvpho000d0m9fyc17s2ojl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网络/HTTPS工作原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/12/网络/HTTPS工作原理/" class="article-date">
  <time datetime="2018-04-12T02:09:45.000Z" itemprop="datePublished">2018-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络/">网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/12/网络/HTTPS工作原理/">HTTPS工作原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL协议不仅仅是一套加密传输的协议，更是一件经过艺术家精心设计的艺术品，TLS/SSL中使用了非对称加密，对称加密以及HASH算法。握手过程的简单描述如下：</p>
<ol>
<li>浏览器将自己支持的一套加密规则发送给网站。</li>
<li>网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。</li>
<li><p>获得网站证书之后浏览器要做以下工作：<br> a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。</p>
<p> b) 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码（对称算法的私匙），并用证书中提供的公钥加密。</p>
<p> c) 使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。</p>
</li>
<li><p>网站接收浏览器发来的数据之后要做以下的操作：<br> a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。</p>
<p> b) 使用密码加密一段握手消息，发送给浏览器。</p>
</li>
<li>浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。</li>
</ol>
<p>这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。另外，HTTPS一般使用的加密与HASH算法如下：   </p>
<ul>
<li>非对称加密算法：RSA，DSA/DSS</li>
<li>对称加密算法：AES，RC4，3DES</li>
<li>HASH算法：MD5，SHA1，SHA256</li>
</ul>
<p>其中<strong>非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据进行加密，而HASH算法用于验证数据的完整性</strong>。由于浏览器生成的密码是整个数据加密的关键，因此在传输的时候使用了非对称加密算法对其加密。非对称加密算法会生成公钥和私钥，公钥只能用于加密数据，因此可以随意传输，而网站的私钥用于对数据进行解密，所以网站都会非常小心的保管自己的私钥，防止泄漏。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/04/12/网络/HTTPS工作原理/" data-id="cjfvvphhr001ym9fykck7bv7z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网络/三次握手和四次挥手" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/12/网络/三次握手和四次挥手/" class="article-date">
  <time datetime="2018-04-12T02:09:45.000Z" itemprop="datePublished">2018-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络/">网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/12/网络/三次握手和四次挥手/">三次握手和四次挥手</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>建立TCP需要三次握手才能建立，而断开连接则需要四次握手。整个过程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/clq2owesome/image/master/tcp.jpg" alt="image">   </p>
<p>Client端所经历的状态：</p>
<p><img src="https://raw.githubusercontent.com/clq2owesome/image/master/client4.jpg" alt="image"></p>
<p>Server端所经历的状态：</p>
<p><img src="https://raw.githubusercontent.com/clq2owesome/image/master/server4.jpg" alt="image"></p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="http://s3.51cto.com/wyfs02/M01/11/7C/wKioL1LSW6rjI1nhAAE63Uv8ZRY731.jpg?_=5959335" alt="image">    </p>
<ul>
<li><strong>seq（Sequence Number）</strong>：发送序列号 ，占4个字节，范围[0,4284967296],由于TCP是面向字节流的，在一个1个TCP连接中传送字节流中国的每一个字节都按照顺序编号，此外序号是循环使用的 </li>
<li><strong>ACK（Acknowledgment Number）</strong>：确认序列号， 仅当ACK=1时确认字段才有效，当ACK=0时确认字段无效，<strong>并且TCP规定，在连接建立后所有的传送报文段都必须要把ACK置为1</strong></li>
<li><strong>SYN</strong>：同步序列号，用来发起一个连接。<strong>当SYN=1而ACK=0时表明这是一个请求报文段；若对方同意连接，则响应报文中SYN=1，ACK=1</strong></li>
<li><strong>FIN</strong> ：用来释放一个连接，<strong>当FIN=1表示此报文段的发送方已经发送完毕。并要求释放链接</strong></li>
</ul>
<ol>
<li><p>客户端的TCP进程也首先创建传输控制模块TCB，然后向服务端发出连接请求报文段，<strong>该报文段首部中的SYN=1，ACK=0</strong>，同时选择一个初始序号 seq=x。<strong>TCP规定，SYN=1的报文段不能携带数据，但要消耗掉一个序号</strong>。这时，<strong>TCP客户进程进入SYN—SENT（同步已发送）状态，这是 TCP连接的第一次握手</strong>。</p>
</li>
<li><p>Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN=1，ACK=1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server 自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。同样该报文段也是SYN=1的报文段，不能携带数据，但同样要消耗掉一个序号。这时<strong>服务器进入SYN—RCVD（同 步收到），表示服务器已经收到Client的连接请求，等待client的确认，这是TCP连接的第二次握手</strong>。</p>
</li>
<li><p>TCP客户端进程收到服务端进程的确认后，还要向服务端给出确认。确认报文段的ACK=1，确认号ack=y+1，而自己的序号为seq=x+1。 <strong>TCP的标准规定，ACK报文段可以携带数据，但如果不携带数据则不消耗序号，因此，如果不携带数据，则下一个报文段的序号仍为seq=x+1</strong>。这 时，<strong>TCP连接已经建立，客户端进入ESTABLISHED（已建立连接）状态。这是TCP连接的第三次握手，可以看出第三次握手客户端已经可以发送携带 数据的报文段了</strong></p>
<p> 当服务端收到确认后，也进入ESTABLISHED（已建立连接）状态。</p>
</li>
</ol>
<h4 id="三次握手的一些问题"><a href="#三次握手的一些问题" class="headerlink" title="三次握手的一些问题"></a>三次握手的一些问题</h4><h6 id="为什么要进行第三次握手"><a href="#为什么要进行第三次握手" class="headerlink" title="为什么要进行第三次握手"></a>为什么要进行第三次握手</h6><p>前俩比较容易理解，第三次握手看似多余其实不然，这<strong>主要是为了防止已失效的请求报文段突然又传送到了服务端而产生连接的误判</strong> </p>
<p>比如：客户端发送了一个连接请求报文段A到服务端，但是在某些网络节点上长时间滞留了，而后客户端又超时重发了一个连接请求报文段B该服务端，而后 正常建立连接，数据传输完毕，并释放了连接。但是请求报文段A延迟了一段时间后，又到了服务端，这本是一个早已失效的报文段，但是服务端收到后会误以为客户端又发出了一次连接请求，于是向客户端发出确认报文段，并同意建立连接。那么问题来了，假如这里没有三次握手，这时服务端只要发送了确认，新的连接就建立了，但由于客户端没有发出建立连接的请求，因此不会理会服务端的确认，也不会向服务端发送数据，而服务端却认为新的连接已经建立了，并在 一直等待客户端发送数据，这样服务端就会一直等待下去，直到超出保活计数器的设定值，而将客户端判定为出了问题，才会关闭这个连接。这样就浪费了很多服务 器的资源。而如果采用三次握手，客户端就不会向服务端发出确认，服务端由于收不到确认，就知道客户端没有要求建立连接，从而不建立该连接。</p>
<h6 id="SYN-Flood-攻击"><a href="#SYN-Flood-攻击" class="headerlink" title="SYN Flood 攻击"></a>SYN Flood 攻击</h6><p>SYN- Flood攻击是当前网络上最为常见的DDoS攻击，也是最为经典的拒绝服务攻击，它就是利用了TCP协议实现上的一个缺陷，通过向网络服务所在端口发送大量 的伪造源地址的攻击报文，就可能造成目标服务器中的半开连接队列被占满，从而阻止其他合法用户进行访问。这种攻击早在1996年就被发现，但至今仍然显示 出强大的生命力。很多操作系统，甚至防火墙、路由器都无法有效地防御这种攻击，而且由于它可以方便地伪造源地址，追查起来非常困难。它的数据包特征通常 是，源发送了大量的SYN包，并且缺少三次握手的最后一步握手ACK回复。 </p>
<p><strong>原理</strong>：攻击者首先伪造地址对 服务器发起SYN请求，服务器回应(SYN+ACK)包，而真实的IP会认为，我没有发送请求，不作回应。服务 器没有收到回应，这样的话，服务器不知 道(SYN+ACK)是否发送成功，默认情况下会重试5次（tcp_syn_retries）。这样的话，对于服务器的内存，带宽都有很大的消耗。攻击者 如果处于公网，可以伪造IP的话，对于服务器就很难根据IP来判断攻击者，给防护带来很大的困难。</p>
<p><strong>SYN Flood 防护措施</strong>：</p>
<ul>
<li><p>无效连接监视释放 </p>
<p>  这种方法不停的监视系统中半开连接和不活动连接，当达到一定阈值时拆除这些连接，释放系统资源。这种绝对公平的方法往往也会将正常的连接的请求也会被释放掉，”伤敌一千，自损八百”</p>
</li>
<li><p>延缓TCB分配方法 </p>
<p>  SYN Flood关键是利用了，SYN数据报文一到，系统立即分配TCB资源，从而占用了系统资源，因此有俩种技术来解决这一问题 </p>
<ul>
<li><p>Syn Cache技术 </p>
<p>  这种技术在收到SYN时不急着去分配TCB，而是先回应一个ACK报文，并在一个专用的HASH表中（Cache）中保存这种半开连接，直到收到正确的ACK报文再去分配TCB </p>
</li>
<li><p>Syn Cookie技术 </p>
<p>  Syn Cookie技术则完全不使用任何存储资源，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS、时间等，在收到对方 的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源 </p>
</li>
</ul>
</li>
<li><p>使用SYN Proxy防火墙</p>
<p>  对试图穿越的SYN请求进行验证之后才放行</p>
</li>
</ul>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://raw.githubusercontent.com/clq2owesome/image/master/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg" alt="image"></p>
<p><strong>第一次挥手</strong>：主机1向主机2，发送FIN报文段，表示关闭数据传送，并主机1进入FIN_WAIT_1状态，表示没有数据要传输了 </p>
<p><strong>第二次挥手</strong>：主机2收到FIN报文段后进入CLOSE_WAIT状态（被动关闭），然后发送ACK确认，表示同意你关闭请求了，主机到主机的数据链路关闭，主机进入FIN_WAIT_2状态 </p>
<p><strong>第三次挥手</strong>：主机2等待主机1发送完数据，发送FIN到主机1请求关闭，主机2进入LAST_ACK状态 </p>
<p><strong>第四次挥手</strong>：主机1收到主机2发送的FIN后，回复ACK确认到主机2，主机1进入TIME_WAIT状态。主机2收到主机1的ACK后就关闭连接了，状态为CLOSED。主机1等待2MSL，仍然没有收到主机2的回复，说明主机2已经正常关闭了，主机1关闭连接。</p>
<h4 id="状态解析"><a href="#状态解析" class="headerlink" title="状态解析"></a>状态解析</h4><ul>
<li><p><strong>FIN_WAIT_1</strong>:<br>FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是： FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。（主动方）</p>
</li>
<li><p><strong>FIN_WAIT_2</strong>：<br>上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外一方告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方）</p>
</li>
<li><p><strong>TIME_WAIT</strong>:<br>表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方）</p>
</li>
<li><p><strong>CLOSING（比较少见）</strong>:<br>这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。</p>
</li>
<li><p><strong>CLOSE_WAIT</strong>:<br>这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是查看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。（被动方）</p>
</li>
<li><p><strong>LAST_ACK</strong>:<br>这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）</p>
</li>
<li><p><strong>CLOSED</strong>:<br>表示连接中断。</p>
</li>
</ul>
<h4 id="四次挥手的问题"><a href="#四次挥手的问题" class="headerlink" title="四次挥手的问题"></a>四次挥手的问题</h4><h6 id="什么是孤儿连接"><a href="#什么是孤儿连接" class="headerlink" title="什么是孤儿连接"></a>什么是孤儿连接</h6><p>连续停留在FIN_WAIT2状态可能发生，客户端执行半关闭状态后，未等服务器关闭连接就直接退出了，此时客户端连接由内核接管。Linux为防止孤儿连接长时间存在内核中，定义了两个变量指定孤儿连接数目和生存时间。</p>
<h6 id="为什么要四次挥手而不是三次呢？"><a href="#为什么要四次挥手而不是三次呢？" class="headerlink" title="为什么要四次挥手而不是三次呢？"></a>为什么要四次挥手而不是三次呢？</h6><p>当主机2发送ACK确认主机1的FIN时，并不代表主机2的数据发送完毕，主机1发送完FIN处于半关闭状态（不能发送数据，但可以接收数据），所以要等待主机2的数据发送完毕后，发出FIN关闭连接请求时，主机2才进入CLOSED状态，主机1再ACK确认关闭进入CLOSE状态。</p>
<h6 id="为什么TIME-WAIT-状态要等2MSL才进入CLOSED状态？"><a href="#为什么TIME-WAIT-状态要等2MSL才进入CLOSED状态？" class="headerlink" title="为什么TIME_WAIT 状态要等2MSL才进入CLOSED状态？"></a>为什么TIME_WAIT 状态要等2MSL才进入CLOSED状态？</h6><p>MSL（Maximum Segment Lifetime）：报文最大生存时间，是任何报文段被丢弃前在网络内的最长时间。当主机1回复主机2的FIN后，等待(2-4分钟)，即使两端的应用程序结束。</p>
<p>如果主机1直接进入CLOSED状态，由于IP协议不可靠性或网络问题，导致主机1最后发出的ACK报文未被主机2接收到，那么主机2在超时后继续向主机1重新发送FIN，而主机1已经关闭，那么找不到向主机1发送FIN的连接，主机2这时收到RST并把错误报告给高层，不符合TCP协议的可靠性特点。<br>如果主机1直接进入CLOSED状态，而主机2还有数据滞留在网络中，当有一个新连接的端口和原来主机2的相同，那么当原来滞留的数据到达后，主机1认为这些数据是新连接的。等待2MSL确保本次连接所有数据消失。</p>
<h6 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h6><p>从以上TCP连接关闭的状态转换图可以看出，主动关闭的一方在发送完对对方FIN报文的确认(ACK)报文后，会进入TIME_WAIT状态。TIME_WAIT状态也称为2MSL状态。</p>
<p>什么是2MSL？MSL即Maximum Segment Lifetime，也就是报文最大生存时间，引用《TCP/IP详解》中的话：“它(MSL)是任何报文段被丢弃前在网络内的最长时间。”那么，2MSL也就是这个时间的2倍。其实我觉得没必要把这个MSL的确切含义搞明白，你所需要明白的是，当TCP连接完成四个报文段的交换时，主动关闭的一方将继续等待一定时间(2-4分钟)，即使两端的应用程序结束。</p>
<p>为什么需要2MSL？根据《TCP/IP详解》和《The TCP/IP Guide》中的说法，有两个原因：<br>其一，保证发送的ACK会成功发送到对方，如何保证？我觉得可能是通过超时计时器发送。这个就很难用代码演示了。</p>
<p>其二，报文可能会被混淆，意思是说，其他时候的连接可能会被当作本次的连接。直接引用《The TCP/IP Guide》的说法：The second is to provide a“buffering period” between the end of this connection and any subsequent ones. If not for this period, it is possible that packets from different connections could be mixed, creating confusion.</p>
<p>TIME_WAIT状态所带来的影响：<br>当某个连接的一端处于TIME_WAIT状态时，该连接将不能再被使用。事实上，对于我们比较有现实意义的是，这个端口将不能再被使用。某个端口处于TIME_WAIT状态(其实应该是这个连接)时，这意味着这个TCP连接并没有断开(完全断开)，那么，如果你bind这个端口，就会失败。对于服务器而言，如果服务器突然crash掉了，那么它将无法再2MSL内重新启动，因为bind会失败。解决这个问题的一个方法就是设置socket的SO_REUSEADDR选项。这个选项意味着你可以重用一个地址。</p>
<p>特别注意：<br>当建立一个TCP连接时，服务器端会继续用原有端口监听，同时用这个端口与客户端通信。而客户端默认情况下会使用一个随机端口与服务器端的监听端口通信。有时候，为了服务器端的安全性，我们需要对客户端进行验证，即限定某个IP某个特定端口的客户端。客户端可以使用bind来使用特定的端口。对于服务器端，当设置了SO_REUSEADDR选项时，它可以在2MSL内启动并listen成功。<br>但是对于客户端，当使用bind并设置SO_REUSEADDR时，如果在2MSL内启动，虽然bind会成功，但是在windows平台上connect会失败。而在linux上则不存在这个问题。(我的实验平台：winxp, ubuntu7.10)</p>
<p>要解决windows平台的这个问题，可以设置SO_LINGER选项。SO_LINGER选项决定调用close时TCP的行为。SO_LINGER涉及到linger结构体，如果设置结构体中l_onoff为非0，l_linger为0，那么调用close时TCP连接会立刻断开，TCP不会将发送缓冲中未发送的数据发送，而是立即发送一个RST报文给对方，这个时候TCP连接就不会进入TIME_WAIT状态。如你所见，这样做虽然解决了问题，但是并不安全。通过以上方式设置SO_LINGER状态，等同于设置SO_DONTLINGER状态。</p>
<p>断开连接时的意外：<br>这个算不上断开连接时的意外，当TCP连接发生一些物理上的意外情况时，例如网线断开，linux上的TCP实现会依然认为该连接有效，而windows则会在一定时间后返回错误信息。这似乎可以通过设置SO_KEEPALIVE选项来解决，不过不知道这个选项是否对于所有平台都有效。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/04/12/网络/三次握手和四次挥手/" data-id="cjfvvphhw002em9fyqzlddt4m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器相关/Tomcat/内存分配" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/12/服务器相关/Tomcat/内存分配/" class="article-date">
  <time datetime="2018-04-12T02:09:45.000Z" itemprop="datePublished">2018-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/Tomcat/">Tomcat</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/12/服务器相关/Tomcat/内存分配/">内存分配</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="堆内存分配"><a href="#堆内存分配" class="headerlink" title="堆内存分配"></a>堆内存分配</h3><p>JVM初始分配的堆内存由<code>-Xms</code>指定，<strong>默认是物理内存的1/64</strong>；JVM最大分配的堆内存由<code>-Xmx</code>指定，<strong>默认是物理内存的1/4</strong>。</p>
<p><strong>默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；<br>空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。因此服务器一般设置-Xms、-Xmx 相等以避免在每次GC 后调整堆的大小。</strong></p>
<p>说明：如果-Xmx 不指定或者指定偏小，应用可能会导致java.lang.OutOfMemory错误，此错误来自JVM，不是Throwable的，无法用try…catch捕捉。 </p>
<h3 id="非堆内存分配"><a href="#非堆内存分配" class="headerlink" title="非堆内存分配"></a>非堆内存分配</h3><p>JVM使用<code>-XX:PermSize</code>设置非堆内存初始值，<strong>默认是物理内存的1/64</strong>；由<code>XX:MaxPermSize</code>设置最大非堆内存的大小，<strong>默认是物理内存的1/4</strong>。</p>
<p>XX:MaxPermSize设置过小会导致java.lang.OutOfMemoryError: PermGen space 就是内存益出。 </p>
<p>jdk8改变了内存模型，将类定义存放到了元数据（MetaspaceSize）空间，而元数据空间是与堆空间共享同一块内存区域的，所以在JDK8以后版本不会存在PermGen space异常了，故不用设置此参数。</p>
<h3 id="JVM内存限制-最大值"><a href="#JVM内存限制-最大值" class="headerlink" title="JVM内存限制(最大值)"></a>JVM内存限制(最大值)</h3><p>首先JVM内存限制于实际的最大物理内存，假设物理内存无限大的话，JVM内存的最大值跟操作系统有很大的关系。简单的说就32位处理器虽然可控内存空间有4GB,但是具体的操作系统会给一个限制，这个限制一般是2GB-3GB（一般来说Windows系统下为1.5G-2G，Linux系统下为2G-3G），而64bit以上的处理器就不会有限制了</p>
<h3 id="tomcat配置"><a href="#tomcat配置" class="headerlink" title="tomcat配置"></a>tomcat配置</h3><h4 id="修改启动时内存参数、并指定JVM时区-（在Windows-Server-2008-下时间少了8个小时）："><a href="#修改启动时内存参数、并指定JVM时区-（在Windows-Server-2008-下时间少了8个小时）：" class="headerlink" title="修改启动时内存参数、并指定JVM时区 （在Windows Server 2008 下时间少了8个小时）："></a>修改启动时内存参数、并指定JVM时区 （在Windows Server 2008 下时间少了8个小时）：</h4><p>在Tomcat上运行j2ee项目代码时，经常会出现内存溢出的情况，解决办法是在系统参数中增加系统参数： </p>
<p>修改Tomcat的内存配置，打开$TOMCAT_HOME/bin/catalina.sh文件（Windows系统是catalina.bat文件），大楖在250行左右，在JAVA_OPTS参数上添加内存参数设置即可。完整的JVM参数设置如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">JAVA_OPTS=&quot;$JAVA_OPTS -server -Xms2048m -Xmx2048m -XX:PermSize=128m -XX:MaxPermSize=256 -Djava.awt.headless=true&quot;</div></pre></td></tr></table></figure></p>
<p><strong>-server参数</strong>：表示以服务模式启动，启动速度会稍微慢一点，但性能会高很多。不加这个参数，默认是以客户端模式启动。 </p>
<p>注意：前后二者区别，有无set，有无双引号。</p>
<h4 id="线程池配置（Tomcat6下）"><a href="#线程池配置（Tomcat6下）" class="headerlink" title="线程池配置（Tomcat6下）"></a>线程池配置（Tomcat6下）</h4><p>使用线程池，用较少的线程处理较多的访问，可以提高tomcat处理请求的能力。</p>
<p>使用方式：  </p>
<ol>
<li>打开<code>/conf/server.xml</code>，增加:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Executor name=&quot;tomcatThreadPool&quot; namePrefix=&quot;catalina-exec-&quot; </div><div class="line">    maxThreads=&quot;500&quot; minSpareThreads=&quot;20&quot; maxIdleTime=&quot;60000&quot; /&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>最大线程500（一般服务器足以），最小空闲线程数20，线程最大空闲时间60秒。</p>
<ol>
<li>修改<connector ...="">节点，增加executor属性，如:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;Connector executor=&quot;tomcatThreadPool&quot;</div><div class="line">    port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; </div><div class="line">    maxThreads=&quot;600&quot;</div><div class="line">    acceptCount=&quot;100&quot;</div><div class="line">    minSpareThreads=&quot;100&quot;</div><div class="line">    maxSpareThreads=&quot;300&quot;</div><div class="line">    connectionTimeout=&quot;60000&quot;</div><div class="line">    keepAliveTimeout=&quot;15000&quot;</div><div class="line">    maxKeepAliveRequests=&quot;1&quot;</div><div class="line">    redirectPort=&quot;443&quot;</div><div class="line">    maxHttpHeaderSize=&quot;8192&quot; </div><div class="line">    URIEncoding=&quot;UTF-8&quot; </div><div class="line">    enableLookups=&quot;false&quot;  </div><div class="line">    disableUploadTimeout=&quot;true&quot;/&gt;</div></pre></td></tr></table></figure>
</connector></li>
</ol>
<p>参数说明：</p>
<ul>
<li><strong>connectionTimeout</strong> - 网络连接超时，单位：毫秒。设置为0表示永不超时，这样设置有隐患的。通常可设置为30000毫秒。</li>
<li><strong>keepAliveTimeout</strong> - 长连接最大保持时间（毫秒）。此处为15秒。</li>
<li><strong>maxKeepAliveRequests</strong> - 最大长连接个数（1表示禁用，-1表示不限制个数，默认100个。一般设置在100~200之间） the maximum number of HTTP requests that can be held in the pipeline until the connection is closed by the server. Setting this attribute to 1 disables HTTP/1.0 keep-alive, as well as HTTP/1.1 keep-alive and pipelining. Setting this to -1 allows an unlimited number of pipelined or keep-alive HTTP requests. If not specified, this attribute is set to 100.</li>
<li><strong>maxHttpHeaderSize</strong> - http请求头信息的最大程度，超过此长度的部分不予处理。一般8K。</li>
<li><strong>URIEncoding</strong> - 指定Tomcat容器的URL编码格式。</li>
<li><strong>acceptCount</strong> - 指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理，默认为10个。defines the maximum queue length for incoming connection requests when all possible request processing threads are in use. Any requests received when the queue is full are refused. The default value is 10.</li>
<li><strong>disableUploadTimeout</strong> - 上传时是否使用超时机制</li>
<li><strong>enableLookups</strong> - 是否反查域名，取值为：true或false。为了提高处理能力，应设置为false</li>
<li><strong>bufferSize</strong> - defines the size (in bytes) of the buffer to be provided for input streams created by this connector. By default, buffers of 2048 bytes are provided.</li>
<li><strong>maxSpareThreads</strong> - 最多空闲连接数，一旦创建的线程超过这个值，Tomcat就会关闭不再需要的socket线程，默认为50 the maximum number of unused request processing threads that are allowed to exist until the thread pool starts stopping the unnecessary threads. The default value is 50.</li>
<li><strong>maxThreads</strong> - 最多同时处理的连接数，Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数，默认为200。 the maximum number of request processing threads to be created by this Connector, which therefore determines the maximum number of simultaneous requests that can be handled. If not specified, this attribute is set to 200.</li>
<li><strong>minSpareThreads</strong> - 最小空闲线程数，Tomcat初始化时创建的线程数,默认为4 the number of request processing threads that are created when this Connector is first started. The connector will also make sure it has the specified number of idle processing threads available. This attribute should be set to a value smaller than that set for maxThreads. The default value is 4.</li>
<li><strong>minProcessors</strong> - 最小空闲连接线程数，用于提高系统处理性能，默认值为10。（用于Tomcat4中）</li>
<li><strong>maxProcessors</strong> - 最大连接线程数，即：并发处理的最大请求数，默认值为75。（用于Tomcat4中）</li>
</ul>
<p>注意：可以多个connector公用1个线程池。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/04/12/服务器相关/Tomcat/内存分配/" data-id="cjfvvpho800dmm9fy7srp4eks" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器相关/Tomcat/Tomcat整体架构浅析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/12/服务器相关/Tomcat/Tomcat整体架构浅析/" class="article-date">
  <time datetime="2018-04-12T02:09:45.000Z" itemprop="datePublished">2018-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/Tomcat/">Tomcat</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/12/服务器相关/Tomcat/Tomcat整体架构浅析/">Tomcat整体架构浅析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p><img src="http://img.my.csdn.net/uploads/201206/05/1338887929_7279.JPG" alt="image">     </p>
<p>从上图中可以看出 Tomcat 的心脏是两个组件：<strong>Connector</strong> 和 <strong>Container</strong>，关于这两个组件将在后面详细介绍。Connector 组件是可以被替换，这样可以提供给服务器设计者更多的选择，因为这个组件是如此重要，不仅跟服务器的设计的本身，而且和不同的应用场景也十分相关，所以一个 Container 可以选择对应多个 Connector。多个 Connector 和一个 Container 就形成了一个 Service，Service 的概念大家都很熟悉了，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非 Server 莫属了。所以<strong>整个 Tomcat 的生命周期由 Server 控制</strong>。</p>
<p>组件包含关系图：<br><img src="http://dl.iteye.com/upload/picture/pic/124649/3f5d0ac0-1c40-3c78-9bed-e990f41e3b84.jpg" alt="image"><br>Standard<em>XXXX</em>是组件接口的默认实现类。</p>
<p>另外一种结构图：<br><img src="http://img.blog.csdn.net/20180109095231653?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzgyNDU1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p>
<p>Server标签设置的端口号为8005，shutdown=”SHUTDOWN” ，表示在8005端口监听“SHUTDOWN”命令，如果接收到了就会关闭Tomcat。一个Server有一个Service，当然还可以进行配置，一个Service有多个，Service左边的内容都属于Container的，Service下边是Connector。</p>
<h4 id="以-Service-作为“婚姻”"><a href="#以-Service-作为“婚姻”" class="headerlink" title="以 Service 作为“婚姻”"></a>以 Service 作为“婚姻”</h4><p>我们将 Tomcat 中 Connector、Container 作为一个整体比作一对情侣的话，Connector 主要负责对外交流，可以比作为 Boy，Container 主要处理 Connector 接受的请求，主要是处理内部事务，可以比作为 Girl。那么这个 Service 就是连接这对男女的结婚证了。是 Service 将它们连接在一起，共同组成一个家庭。当然要组成一个家庭还要很多其它的元素。</p>
<p>说白了，Service 只是在 Connector 和 Container 外面多包一层，把它们组装在一起，向外面提供服务，一个 Service 可以设置多个 Connector，但是只能有一个 Container 容器。这个 Service 接口的方法列表如下：</p>
<p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/image002.png" alt="image"> </p>
<p>从 Service 接口中定义的方法中可以看出，它主要是为了关联 Connector 和 Container，同时会初始化它下面的其它组件，注意接口中它并没有规定一定要控制它下面的组件的生命周期。所有组件的生命周期在一个 Lifecycle 的接口中控制，这里用到了一个重要的设计模式，关于这个接口将在后面介绍。</p>
<p>Tomcat 中 Service 接口的标准实现类是 StandardService 它不仅实现了 Service 借口同时还实现了 Lifecycle 接口，这样它就可以控制它下面的组件的生命周期了。<strong>StandardService</strong> 类结构图如下：</p>
<p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/image003.png" alt="image"> </p>
<p>从上图中可以看出除了 Service 接口的方法的实现以及控制组件生命周期的 Lifecycle 接口的实现，还有几个方法是用于在事件监听的方法的实现，不仅是这个 Service 组件，Tomcat 中其它组件也同样有这几个方法，这也是一个典型的设计模式，将在后面介绍。</p>
<p>下面看一下 StandardService 中主要的几个方法实现的代码，下面是 setContainer 和 addConnector 方法的源码：   </p>
<p>清单 1.StandardService. SetContainer<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContainer</span><span class="params">(Container container)</span> </span>&#123;</div><div class="line">    Container oldContainer = <span class="keyword">this</span>.container;</div><div class="line">    <span class="keyword">if</span> ((oldContainer != <span class="keyword">null</span>) &amp;&amp; (oldContainer <span class="keyword">instanceof</span> Engine))</div><div class="line">        ((Engine) oldContainer).setService(<span class="keyword">null</span>);</div><div class="line">    <span class="keyword">this</span>.container = container;</div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">this</span>.container != <span class="keyword">null</span>) &amp;&amp; (<span class="keyword">this</span>.container <span class="keyword">instanceof</span> Engine))</div><div class="line">        ((Engine) <span class="keyword">this</span>.container).setService(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">if</span> (started &amp;&amp; (<span class="keyword">this</span>.container != <span class="keyword">null</span>) &amp;&amp; (<span class="keyword">this</span>.container <span class="keyword">instanceof</span> Lifecycle)) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ((Lifecycle) <span class="keyword">this</span>.container).start();</div><div class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</div><div class="line">            ;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">synchronized</span> (connectors) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; connectors.length; i++)</div><div class="line">            connectors[i].setContainer(<span class="keyword">this</span>.container);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (started &amp;&amp; (oldContainer != <span class="keyword">null</span>) &amp;&amp; (oldContainer <span class="keyword">instanceof</span> Lifecycle)) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ((Lifecycle) oldContainer).stop();</div><div class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</div><div class="line">            ;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    support.firePropertyChange(<span class="string">"container"</span>, oldContainer, <span class="keyword">this</span>.container);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码很简单，其实就是先判断当前的这个 Service 有没有已经关联了 Container，如果已经关联了，那么去掉这个关联关系—— oldContainer.setService(null)。如果这个 oldContainer 已经被启动了，结束它的生命周期。然后再替换新的关联、再初始化并开始这个新的 Container 的生命周期。最后将这个过程通知感兴趣的事件监听程序。这里值得注意的地方就是，修改 Container 时要将新的 Container 关联到每个 Connector，还好 Container 和 Connector 没有双向关联，不然这个关联关系将会很难维护。</p>
<p>清单 2. StandardService. addConnector<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public void addConnector(Connector connector) &#123;</div><div class="line">    synchronized (connectors) &#123;</div><div class="line">        connector.setContainer(this.container);</div><div class="line">        connector.setService(this);</div><div class="line">        Connector results[] = new Connector[connectors.length + 1];</div><div class="line">        System.arraycopy(connectors, 0, results, 0, connectors.length);</div><div class="line">        results[connectors.length] = connector;</div><div class="line">        connectors = results;</div><div class="line">        if (initialized) &#123;</div><div class="line">            try &#123;</div><div class="line">                connector.initialize();</div><div class="line">            &#125; catch (LifecycleException e) &#123;</div><div class="line">                e.printStackTrace(System.err);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (started &amp;&amp; (connector instanceof Lifecycle)) &#123;</div><div class="line">            try &#123;</div><div class="line">                ((Lifecycle) connector).start();</div><div class="line">            &#125; catch (LifecycleException e) &#123;</div><div class="line">                ;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        support.firePropertyChange(&quot;connector&quot;, null, connector);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面是 addConnector 方法，这个方法也很简单，首先是设置关联关系，然后是初始化工作，开始新的生命周期。这里值得一提的是，注意 Connector 用的是数组而不是 List 集合，这个从性能角度考虑可以理解，有趣的是这里用了数组但是并没有向我们平常那样，一开始就分配一个固定大小的数组，它这里的实现机制是：重新创建一个当前大小的数组对象，然后将原来的数组对象 copy 到新的数组中，这种方式实现了类似的动态数组的功能，这种实现方式，值得我们以后拿来借鉴。</p>
<p>最新的 Tomcat6 中 StandardService 也基本没有变化，但是从 Tomcat5 开始 Service、Server 和容器类都继承了 MBeanRegistration 接口，Mbeans 的管理更加合理。</p>
<h4 id="以-Server-为“居”"><a href="#以-Server-为“居”" class="headerlink" title="以 Server 为“居”"></a>以 Server 为“居”</h4><p>前面说一对情侣因为 Service 而成为一对夫妻，有了能够组成一个家庭的基本条件，但是它们还要有个实体的家，这是它们在社会上生存之本，有了家它们就可以安心的为人民服务了，一起为社会创造财富。</p>
<p>Server 要完成的任务很简单，就是要能够提供一个接口让其它程序能够访问到这个 Service 集合、同时要维护它所包含的所有 Service 的生命周期，包括如何初始化、如何结束服务、如何找到别人要访问的 Service。还有其它的一些次要的任务，如您住在这个地方要向当地政府去登记啊、可能还有要配合当地公安机关日常的安全检查什么的。</p>
<p>Server 的类结构图如下：</p>
<p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/image004.png" alt="image"></p>
<p>它的标准实现类 StandardServer 实现了上面这些方法，同时也实现了 Lifecycle、MbeanRegistration 两个接口的所有方法，下面主要看一下 <strong>StandardServer</strong> 重要的一个方法 addService 的实现：</p>
<p>清单 3. StandardServer.addService<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public void addService(Service service) &#123;</div><div class="line">    service.setServer(this);</div><div class="line">    synchronized (services) &#123;</div><div class="line">        Service results[] = new Service[services.length + 1];</div><div class="line">        System.arraycopy(services, 0, results, 0, services.length);</div><div class="line">        results[services.length] = service;</div><div class="line">        services = results;</div><div class="line">        if (initialized) &#123;</div><div class="line">            try &#123;</div><div class="line">                service.initialize();</div><div class="line">            &#125; catch (LifecycleException e) &#123;</div><div class="line">                e.printStackTrace(System.err);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (started &amp;&amp; (service instanceof Lifecycle)) &#123;</div><div class="line">            try &#123;</div><div class="line">                ((Lifecycle) service).start();</div><div class="line">            &#125; catch (LifecycleException e) &#123;</div><div class="line">                ;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        support.firePropertyChange(&quot;service&quot;, null, service);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面第一句就知道了 Service 和 Server 是相互关联的，Server 也是和 Service 管理 Connector 一样管理它，也是将 Service 放在一个数组中，后面部分的代码也是管理这个新加进来的 Service 的生命周期。Tomcat6 中也是没有什么变化的。</p>
<h4 id="组件的生命线“Lifecycle”"><a href="#组件的生命线“Lifecycle”" class="headerlink" title="组件的生命线“Lifecycle”"></a>组件的生命线“Lifecycle”</h4><p>前面一直在说 Service 和 Server 管理它下面组件的生命周期，那它们是如何管理的呢？</p>
<p>Tomcat 中组件的生命周期是通过 Lifecycle 接口来控制的，组件只要继承这个接口并实现其中的方法就可以统一被拥有它的组件控制了，这样一层一层的直到一个最高级的组件就可以控制 Tomcat 中所有组件的生命周期，这个最高的组件就是 Server，而控制 Server 的是 Startup，也就是您启动和关闭 Tomcat。</p>
<p>下面是 Lifecycle 接口的类结构图：   </p>
<p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/image005.png" alt="image">    </p>
<p>除了控制生命周期的 Start 和 Stop 方法外还有一个监听机制，在生命周期开始和结束的时候做一些额外的操作。这个机制在其它的框架中也被使用，如在 Spring 中。关于这个设计模式会在后面介绍。</p>
<p>Lifecycle 接口的方法的实现都在其它组件中，就像前面中说的，组件的生命周期由包含它的父组件控制，所以它的 Start 方法自然就是调用它下面的组件的 Start 方法，Stop 方法也是一样。如在 Server 中 Start 方法就会调用 Service 组件的 Start 方法，Server 的 Start 方法代码如下：</p>
<p>清单 4. StandardServer.Start<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void start() throws LifecycleException &#123;</div><div class="line">    if (started) &#123;</div><div class="line">        log.debug(sm.getString(&quot;standardServer.start.started&quot;));</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, null);</div><div class="line">    lifecycle.fireLifecycleEvent(START_EVENT, null);</div><div class="line">    started = true;</div><div class="line">    synchronized (services) &#123;</div><div class="line">        for (int i = 0; i &lt; services.length; i++) &#123;</div><div class="line">            if (services[i] instanceof Lifecycle)</div><div class="line">                ((Lifecycle) services[i]).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    lifecycle.fireLifecycleEvent(AFTER_START_EVENT, null);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>监听的代码会包围 Service 组件的启动过程，就是简单的循环启动所有 Service 组件的 Start 方法，但是所有 Service 必须要实现 Lifecycle 接口，这样做会更加灵活。</p>
<p>Server 的 Stop 方法代码如下：</p>
<p>清单 5. StandardServer.Stop<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void stop() throws LifecycleException &#123;</div><div class="line">    if (!started)</div><div class="line">        return;</div><div class="line">    lifecycle.fireLifecycleEvent(BEFORE_STOP_EVENT, null);</div><div class="line">    lifecycle.fireLifecycleEvent(STOP_EVENT, null);</div><div class="line">    started = false;</div><div class="line">    for (int i = 0; i &lt; services.length; i++) &#123;</div><div class="line">        if (services[i] instanceof Lifecycle)</div><div class="line">            ((Lifecycle) services[i]).stop();</div><div class="line">    &#125;</div><div class="line">    lifecycle.fireLifecycleEvent(AFTER_STOP_EVENT, null);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它所要做的事情也和 Start 方法差不多。</p>
<h3 id="Connector-组件"><a href="#Connector-组件" class="headerlink" title="Connector 组件"></a>Connector 组件</h3><p>Connector 组件是 Tomcat 中两个核心组件之一，它的主要任务是负责接收浏览器的发过来的 tcp 连接请求，创建一个 Request 和 Response 对象分别用于和请求端交换数据，然后会产生一个线程来处理这个请求并把产生的 Request 和 Response 对象传给处理这个请求的线程，处理这个请求的线程就是 Container 组件要做的事了。</p>
<p>Connector最底层使用的是Socket来进行连接的，Request和Response是按照HTTP协议来封装的，所以Connector同时需要实现TCP/IP协议和HTTP协议！</p>
<p>一个Tomcat中只有一个Server，一个Server可以包含多个Service，一个Service只有一个Container，但是可以有多个Connectors，这是因为一个服务可以有多个连接，如同时提供Http和Https链接，也可以提供向相同协议不同端口的连接,示意图如下：<br><img src="http://img.blog.csdn.net/20180109095032618?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzgyNDU1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p>
<p>Connector的结构图：<br><img src="http://img.blog.csdn.net/20180109095336437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzgyNDU1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image">  </p>
<p>Connector就是使用ProtocolHandler来处理请求的，不同的ProtocolHandler代表不同的连接类型，比如：Http11Protocol使用的是普通Socket来连接的，Http11NioProtocol使用的是NioSocket来连接的。</p>
<p>其中ProtocolHandler由包含了三个部件：<strong>Endpoint</strong>、<strong>Processor</strong>、<strong>Adapter</strong>。</p>
<ol>
<li><p>Endpoint用来处理底层Socket的网络连接，Processor用于将Endpoint接收到的Socket封装成Request，Adapter用于将Request交给Container进行具体的处理。</p>
</li>
<li><p>Endpoint由于是处理底层的Socket网络连接，因此Endpoint是用来实现TCP/IP协议的，而Processor用来实现HTTP协议的，Adapter将请求适配到Servlet容器进行具体的处理。</p>
</li>
<li><p>Endpoint的抽象实现AbstractEndpoint里面定义的Acceptor和AsyncTimeout两个内部类和一个Handler接口。Acceptor用于监听请求，AsyncTimeout用于检查异步Request的超时，Handler用于处理接收到的Socket，在内部调用Processor进行处理。</p>
</li>
</ol>
<p>由于这个过程比较复杂，大体的流程可以用下面的顺序图来解释：</p>
<p>Connector 处理一次请求顺序图:<br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/origin_image006.png" alt="image"><br>​<br>Tomcat5 中默认的 Connector 是 Coyote，这个 Connector 是可以选择替换的。Connector 最重要的功能就是接收连接请求然后分配线程让 Container 来处理这个请求，所以这必然是多线程的，多线程的处理是 Connector 设计的核心。Tomcat5 将这个过程更加细化，它将 Connector 划分成 Connector、Processor、Protocol, 另外 Coyote 也定义自己的 Request 和 Response 对象。</p>
<p>下面主要看一下 Tomcat 中如何处理多线程的连接请求，先看一下 Connector 的主要类图：</p>
<p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/origin_image007.png" alt="image"></p>
<p>看一下 HttpConnector 的 Start 方法：</p>
<p>清单 6. HttpConnector.Start<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public void start() throws LifecycleException &#123;</div><div class="line">    if (started)</div><div class="line">        throw new LifecycleException</div><div class="line">            (sm.getString(&quot;httpConnector.alreadyStarted&quot;));</div><div class="line">    threadName = &quot;HttpConnector[&quot; + port + &quot;]&quot;;</div><div class="line">    lifecycle.fireLifecycleEvent(START_EVENT, null);</div><div class="line">    started = true;</div><div class="line">    threadStart();</div><div class="line">    while (curProcessors &lt; minProcessors) &#123;</div><div class="line">        if ((maxProcessors &gt; 0) &amp;&amp; (curProcessors &gt;= maxProcessors))</div><div class="line">            break;</div><div class="line">        HttpProcessor processor = newProcessor();</div><div class="line">        recycle(processor);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>threadStart() 执行就会进入等待请求的状态，直到一个新的请求到来才会激活它继续执行，这个激活是在 HttpProcessor 的 assign 方法中，这个方法是代码如下 ：</p>
<p>清单 7. HttpProcessor.assign<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">synchronized void assign(Socket socket) &#123;</div><div class="line">    while (available) &#123;</div><div class="line">        try &#123;</div><div class="line">            wait();</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    this.socket = socket;</div><div class="line">    available = true;</div><div class="line">    notifyAll();</div><div class="line">    if ((debug &gt;= 1) &amp;&amp; (socket != null))</div><div class="line">        log(&quot; An incoming request is being assigned&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建 HttpProcessor 对象是会把 available 设为 false，所以当请求到来时不会进入 while 循环，将请求的 socket 赋给当期处理的 socket，并将 available 设为 true，当 available 设为 true 是 HttpProcessor 的 run 方法将被激活，接下去将会处理这次请求。</p>
<p>Run 方法代码如下：</p>
<p>清单 8. HttpProcessor.Run<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void run() &#123; </div><div class="line">    while (!stopped) &#123; </div><div class="line">        Socket socket = await(); </div><div class="line">        if (socket == null) </div><div class="line">            continue; </div><div class="line">        try &#123; </div><div class="line">            process(socket); </div><div class="line">        &#125; catch (Throwable t) &#123; </div><div class="line">            log(&quot;process.invoke&quot;, t); </div><div class="line">        &#125; </div><div class="line">        connector.recycle(this); </div><div class="line">    &#125; </div><div class="line">    synchronized (threadSync) &#123; </div><div class="line">        threadSync.notifyAll(); </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>解析 socket 的过程在 process 方法中，process 方法的代码片段如下：</p>
<p>清单 9. HttpProcessor.process<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">private void process(Socket socket) &#123;</div><div class="line">    boolean ok = true;</div><div class="line">    boolean finishResponse = true;</div><div class="line">    SocketInputStream input = null;</div><div class="line">    OutputStream output = null;</div><div class="line">    try &#123;</div><div class="line">        input = new SocketInputStream(socket.getInputStream(),connector.getBufferSize());</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        log(&quot;process.create&quot;, e);</div><div class="line">        ok = false;</div><div class="line">    &#125;</div><div class="line">    keepAlive = true;</div><div class="line">    while (!stopped &amp;&amp; ok &amp;&amp; keepAlive) &#123;</div><div class="line">        finishResponse = true;</div><div class="line">        try &#123;</div><div class="line">            request.setStream(input);</div><div class="line">            request.setResponse(response);</div><div class="line">            output = socket.getOutputStream();</div><div class="line">            response.setStream(output);</div><div class="line">            response.setRequest(request);</div><div class="line">            ((HttpServletResponse) response.getResponse())</div><div class="line">                .setHeader(&quot;Server&quot;, SERVER_INFO);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            log(&quot;process.create&quot;, e);</div><div class="line">            ok = false;</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">            if (ok) &#123;</div><div class="line">                parseConnection(socket);</div><div class="line">                parseRequest(input, output);</div><div class="line">                if (!request.getRequest().getProtocol().startsWith(&quot;HTTP/0&quot;))</div><div class="line">                    parseHeaders(input);</div><div class="line">                if (http11) &#123;</div><div class="line">                    ackRequest(output);</div><div class="line">                    if (connector.isChunkingAllowed())</div><div class="line">                        response.setAllowChunking(true);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        。。。。。。</div><div class="line">        try &#123;</div><div class="line">            ((HttpServletResponse) response).setHeader</div><div class="line">                (&quot;Date&quot;, FastHttpDateFormat.getCurrentDate());</div><div class="line">            if (ok) &#123;</div><div class="line">                connector.getContainer().invoke(request, response);</div><div class="line">            &#125;</div><div class="line">            。。。。。。</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">            shutdownInput(input);</div><div class="line">            socket.close();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            ;</div><div class="line">        &#125; catch (Throwable e) &#123;</div><div class="line">            log(&quot;process.invoke&quot;, e);</div><div class="line">        &#125;</div><div class="line">    socket = null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当 Connector 将 socket 连接封装成 request 和 response 对象后接下来的事情就交给 Container 来处理了。</p>
<h3 id="Servlet-容器“Container”"><a href="#Servlet-容器“Container”" class="headerlink" title="Servlet 容器“Container”"></a>Servlet 容器“Container”</h3><p>Container 是容器的父接口，所有子容器都必须实现这个接口，Container 容器的设计用的是典型的责任链的设计模式，它有四个子容器组件构成，分别是：<strong>Engine</strong>、<strong>Host</strong>、<strong>Context</strong>、<strong>Wrapper</strong>，这四个组件不是平行的，而是父子关系，Engine 包含 Host,Host 包含 Context，Context 包含 Wrapper。通常一个 Servlet class 对应一个 Wrapper，如果有多个 Servlet 就可以定义多个 Wrapper，如果有多个 Wrapper 就要定义一个更高的 Container 了.</p>
<ul>
<li><strong>Engine</strong>：没有父容器，一个 Engine代表一个完整的 Servlet 引擎，它接收来自Connector的请求，并决定传给哪个Host来处理，Host处理完请求后，将结果返回给Engine，Engine再将结果返回给Connector。</li>
<li><strong>Host</strong>：Engine可以包含多个Host，每个Host代表一个虚拟主机，这个虚拟主机的作用就是运行多个应用，它负责安装和展开这些应用，并且标识这个应用以便能够区分它们，每个虚拟主机对应的一个域名，不同Host容器接受处理对应不同域名的请求。</li>
<li><strong>Context</strong>：Host可以包含多个Context，Context是Servlet规范的实现，它提供了Servlet的基本环境，一个Context代表一个运行在Host上的Web应用</li>
<li><strong>Wrapper</strong>: Context可以包含多个Wrapper, Wrapper 代表一个 Servlet，它负责管理一个 Servlet，包括的 Servlet 的装载、初始化、执行以及资源回收。Wrapper 是最底层的容器，它没有子容器了，所以调用它的 addChild 将会报错。</li>
</ul>
<p>结构图：<br><img src="http://img.blog.csdn.net/20180109110049444?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzgyNDU1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image">   </p>
<p>下面找一个Tomcat的文件目录对照一下，如下图所示：<br><img src="http://img.blog.csdn.net/20180109095725295?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzgyNDU1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p>
<p>Context和Host的区别是Context表示一个应用，我们的Tomcat中默认的配置下webapps下的每一个文件夹目录都是一个Context，其中ROOT目录中存放着主应用，其他目录存放着子应用，而整个webapps就是一个Host站点。</p>
<p>我们访问应用Context的时候，如果是ROOT下的则直接使用域名就可以访问，例如：<code>www.ledouit.com</code>,如果是Host（webapps）下的其他应用，则可以使用<code>www.ledouit.com/docs</code>进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主营用是ROOT目录下的。</p>
<p>如 Context，Context 通常就是对应下面这个配置：</p>
<p>清单 10. Server.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Context</span></span></div><div class="line">    <span class="attr">path</span>=<span class="string">"/library"</span></div><div class="line">    <span class="attr">docBase</span>=<span class="string">"D:\projects\library\deploy\target\library.war"</span></div><div class="line">    <span class="attr">reloadable</span>=<span class="string">"true"</span></div><div class="line">/&gt;</div></pre></td></tr></table></figure></p>
<h4 id="Container如何处理请求的"><a href="#Container如何处理请求的" class="headerlink" title="Container如何处理请求的"></a>Container如何处理请求的</h4><p>Container处理请求是使用Pipeline-Value管道来处理的！</p>
<p>Pipeline-Value是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将处理后的请求返回，再让下一个处理着继续处理。</p>
<p>但是！Pipeline-Value使用的责任链模式和普通的责任链模式有些不同！区别主要有以下两点：</p>
<ol>
<li>每个Pipeline都有特定的Value，而且是在管道的最后一个执行，这个Value叫做BaseValue，BaseValue是不可删除的；</li>
<li>在上层容器的管道的BaseValue中会调用下层容器的管道。</li>
</ol>
<p>我们知道Container包含四个子容器，而这四个子容器对应的BaseValue分别在：StandardEngineValue、StandardHostValue、StandardContextValue、StandardWrapperValue。</p>
<p>Pipeline的处理流程图如下：<br><img src="http://img.blog.csdn.net/20180109095850800?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzgyNDU1Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image">  </p>
<ol>
<li><p>Connector在接收到请求后会首先调用最顶层容器的Pipeline来处理，这里的最顶层容器的Pipeline就是EnginePipeline（Engine的管道）；</p>
</li>
<li><p>在Engine的管道中依次会执行EngineValue1、EngineValue2等等，最后会执行StandardEngineValue，在StandardEngineValue中会调用Host管道，然后再依次执行Host的HostValue1、HostValue2等，最后在执行StandardHostValue，然后再依次调用Context的管道和Wrapper的管道，最后执行到StandardWrapperValue。</p>
</li>
<li><p>当执行到StandardWrapperValue的时候，会在StandardWrapperValue中创建FilterChain，并调用其doFilter方法来处理请求，这个FilterChain包含着我们配置的与请求相匹配的Filter和Servlet，其doFilter方法会依次调用所有的Filter的doFilter方法和Servlet的service方法，这样请求就得到了处理！</p>
</li>
<li><p>当所有的Pipeline-Value都执行完之后，并且处理完了具体的请求，这个时候就可以将返回的结果交给Connector了，Connector在通过Socket的方式将结果返回给客户端。</p>
</li>
</ol>
<h4 id="容器的总体设计"><a href="#容器的总体设计" class="headerlink" title="容器的总体设计"></a>容器的总体设计</h4><p>Context 还可以定义在父容器 Host 中，Host 不是必须的，但是要运行 war 程序，就必须要 Host，因为 war 中必有 web.xml 文件，这个文件的解析就需要 Host 了，如果要有多个 Host 就要定义一个 top 容器 Engine 了。而 Engine 没有父容器了，一个 Engine 代表一个完整的 Servlet 引擎。</p>
<p>那么这些容器是如何协同工作的呢？先看一下它们之间的关系图：</p>
<p>四个容器的关系图:<br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/origin_image008.png" alt="image"></p>
<p>当 Connector 接受到一个连接请求时，将请求交给 Container，Container 是如何处理这个请求的？这四个组件是怎么分工的，怎么把请求传给特定的子容器的呢？又是如何将最终的请求交给 Servlet 处理。下面是这个过程的时序图：</p>
<p>Engine 和 Host 处理请求的时序图:<br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/origin_image009.png" alt="image"></p>
<p>这里看到了 Valve 是不是很熟悉，没错 Valve 的设计在其他框架中也有用的，同样 Pipeline 的原理也基本是相似的，它是一个管道，Engine 和 Host 都会执行这个 Pipeline，您可以在这个管道上增加任意的 Valve，Tomcat 会挨个执行这些 Valve，而且四个组件都会有自己的一套 Valve 集合。您怎么才能定义自己的 Valve 呢？在 server.xml 文件中可以添加，如给 Engine 和 Host 增加一个 Valve 如下：</p>
<p>清单 11. Server.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Engine</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span> <span class="attr">name</span>=<span class="string">"Catalina"</span>&gt;</span></div><div class="line"> </div><div class="line">    <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.RequestDumperValve"</span>/&gt;</span></div><div class="line">    ………</div><div class="line">    <span class="tag">&lt;<span class="name">Host</span> <span class="attr">appBase</span>=<span class="string">"webapps"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span> <span class="attr">name</span>=<span class="string">"localhost"</span> <span class="attr">unpackWARs</span>=<span class="string">"true"</span></span></div><div class="line">        <span class="attr">xmlNamespaceAware</span>=<span class="string">"false"</span> <span class="attr">xmlValidation</span>=<span class="string">"false"</span>&gt;</div><div class="line"> </div><div class="line">        <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.FastCommonAccessLogValve"</span></span></div><div class="line">            <span class="attr">directory</span>=<span class="string">"logs"</span>  <span class="attr">prefix</span>=<span class="string">"localhost_access_log."</span> <span class="attr">suffix</span>=<span class="string">".txt"</span></div><div class="line">            <span class="attr">pattern</span>=<span class="string">"common"</span> <span class="attr">resolveHosts</span>=<span class="string">"false"</span>/&gt;     </div><div class="line">    …………</div><div class="line">    <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>StandardEngineValve 和 StandardHostValve 是 Engine 和 Host 的默认的 Valve，它们是最后一个 Valve 负责将请求传给它们的子容器，以继续往下执行。</p>
<p>前面是 Engine 和 Host 容器的请求过程，下面看 Context 和 Wrapper 容器时如何处理请求的。下面是处理请求的时序图：</p>
<p>Context 和 wrapper 的处理请求时序图:<br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/origin_image010.png" alt="image">     </p>
<p>从 Tomcat5 开始，子容器的路由放在了 request 中，request 中保存了当前请求正在处理的 Host、Context 和 wrapper。</p>
<h4 id="Engine-容器"><a href="#Engine-容器" class="headerlink" title="Engine 容器"></a>Engine 容器</h4><p>Engine 容器比较简单，它只定义了一些基本的关联关系，接口类图如下：</p>
<p>Engine 接口的类结构:<br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/image011.png" alt="image"></p>
<p>它的标准实现类是 StandardEngine，这个类注意一点就是 Engine 没有父容器了，如果调用 setParent 方法时将会报错。添加子容器也只能是 Host 类型的，代码如下：</p>
<p>清单 12. StandardEngine. addChild<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void addChild(Container child) &#123;</div><div class="line">    if (!(child instanceof Host))</div><div class="line">        throw new IllegalArgumentException</div><div class="line">            (sm.getString(&quot;standardEngine.notHost&quot;));</div><div class="line">    super.addChild(child);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public void setParent(Container container) &#123;</div><div class="line">    throw new IllegalArgumentException</div><div class="line">        (sm.getString(&quot;standardEngine.notParent&quot;));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它的初始化方法也就是初始化和它相关联的组件，以及一些事件的监听。</p>
<h4 id="Host-容器"><a href="#Host-容器" class="headerlink" title="Host 容器"></a>Host 容器</h4><p>Host 是 Engine 的字容器，一个 Host 在 Engine 中代表一个虚拟主机，这个虚拟主机的作用就是运行多个应用，它负责安装和展开这些应用，并且标识这个应用以便能够区分它们。它的子容器通常是 Context，它除了关联子容器外，还有就是保存一个主机应该有的信息。</p>
<p>图 12. Host 相关的类图:<br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/origin_image012.png" alt="image"></p>
<p>从上图中可以看出除了所有容器都继承的 ContainerBase 外，StandardHost 还实现了 Deployer 接口，上图清楚的列出了这个接口的主要方法，这些方法都是安装、展开、启动和结束每个 web application。</p>
<p>Deployer 接口的实现是 StandardHostDeployer，这个类实现了的最要的几个方法，Host 可以调用这些方法完成应用的部署等。</p>
<h4 id="Context-容器"><a href="#Context-容器" class="headerlink" title="Context 容器"></a>Context 容器</h4><p>Context 代表 Servlet 的 Context，它具备了 Servlet 运行的基本环境，理论上只要有 Context 就能运行 Servlet 了。简单的 Tomcat 可以没有 Engine 和 Host。</p>
<p>Context 最重要的功能就是管理它里面的 Servlet 实例，Servlet 实例在 Context 中是以 Wrapper 出现的，还有一点就是 Context 如何才能找到正确的 Servlet 来执行它呢？ Tomcat5 以前是通过一个 Mapper 类来管理的，Tomcat5 以后这个功能被移到了 request 中，在前面的时序图中就可以发现获取子容器都是通过 request 来分配的。</p>
<p>Context 准备 Servlet 的运行环境是在 Start 方法开始的，这个方法的代码片段如下：</p>
<p>清单 13. StandardContext.start<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">public synchronized void start() throws LifecycleException &#123;</div><div class="line">    ………</div><div class="line">    if( !initialized ) &#123; </div><div class="line">        try &#123;</div><div class="line">            init();</div><div class="line">        &#125; catch( Exception ex ) &#123;</div><div class="line">            throw new LifecycleException(&quot;Error initializaing &quot;, ex);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    ………</div><div class="line">    lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, null);</div><div class="line">    setAvailable(false);</div><div class="line">    setConfigured(false);</div><div class="line">    boolean ok = true;</div><div class="line">    File configBase = getConfigBase();</div><div class="line">    if (configBase != null) &#123;</div><div class="line">        if (getConfigFile() == null) &#123;</div><div class="line">            File file = new File(configBase, getDefaultConfigFile());</div><div class="line">            setConfigFile(file.getPath());</div><div class="line">            try &#123;</div><div class="line">                File appBaseFile = new File(getAppBase());</div><div class="line">                if (!appBaseFile.isAbsolute()) &#123;</div><div class="line">                    appBaseFile = new File(engineBase(), getAppBase());</div><div class="line">                &#125;</div><div class="line">                String appBase = appBaseFile.getCanonicalPath();</div><div class="line">                String basePath = </div><div class="line">                    (new File(getBasePath())).getCanonicalPath();</div><div class="line">                if (!basePath.startsWith(appBase)) &#123;</div><div class="line">                    Server server = ServerFactory.getServer();</div><div class="line">                    ((StandardServer) server).storeContext(this);</div><div class="line">                &#125;</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                log.warn(&quot;Error storing config file&quot;, e);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            try &#123;</div><div class="line">                String canConfigFile =  (new File(getConfigFile())).getCanonicalPath();</div><div class="line">                if (!canConfigFile.startsWith (configBase.getCanonicalPath())) &#123;</div><div class="line">                    File file = new File(configBase, getDefaultConfigFile());</div><div class="line">                    if (copy(new File(canConfigFile), file)) &#123;</div><div class="line">                        setConfigFile(file.getPath());</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                log.warn(&quot;Error setting config file&quot;, e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    ………</div><div class="line">    Container children[] = findChildren();</div><div class="line">    for (int i = 0; i &lt; children.length; i++) &#123;</div><div class="line">        if (children[i] instanceof Lifecycle)</div><div class="line">            ((Lifecycle) children[i]).start();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    if (pipeline instanceof Lifecycle)</div><div class="line">        ((Lifecycle) pipeline).start();</div><div class="line">    ………</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它主要是设置各种资源属性和管理组件，还有非常重要的就是启动子容器和 Pipeline。</p>
<p>我们知道 Context 的配置文件中有个 reloadable 属性，如下面配置：</p>
<p>清单 14. Server.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Context</span></span></div><div class="line">    <span class="attr">path</span>=<span class="string">"/library"</span></div><div class="line">    <span class="attr">docBase</span>=<span class="string">"D:\projects\library\deploy\target\library.war"</span></div><div class="line">    <span class="attr">reloadable</span>=<span class="string">"true"</span></div><div class="line">/&gt;</div></pre></td></tr></table></figure></p>
<p>当这个 reloadable 设为 true 时，war 被修改后 Tomcat 会自动的重新加载这个应用。如何做到这点的呢 ? 这个功能是在 StandardContext 的 backgroundProcess 方法中实现的，这个方法的代码如下：</p>
<p>清单 15. StandardContext. backgroundProcess<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public void backgroundProcess() &#123;</div><div class="line">    if (!started) return;</div><div class="line">    count = (count + 1) % managerChecksFrequency;</div><div class="line">    if ((getManager() != null) &amp;&amp; (count == 0)) &#123;</div><div class="line">        try &#123;</div><div class="line">            getManager().backgroundProcess();</div><div class="line">        &#125; catch ( Exception x ) &#123;</div><div class="line">            log.warn(&quot;Unable to perform background process on manager&quot;,x);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (getLoader() != null) &#123;</div><div class="line">        if (reloadable &amp;&amp; (getLoader().modified())) &#123;</div><div class="line">            try &#123;</div><div class="line">                Thread.currentThread().setContextClassLoader</div><div class="line">                    (StandardContext.class.getClassLoader());</div><div class="line">                reload();</div><div class="line">            &#125; finally &#123;</div><div class="line">                if (getLoader() != null) &#123;</div><div class="line">                    Thread.currentThread().setContextClassLoader</div><div class="line">                        (getLoader().getClassLoader());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (getLoader() instanceof WebappLoader) &#123;</div><div class="line">            ((WebappLoader) getLoader()).closeJARs(false);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它会调用 reload 方法，而 reload 方法会先调用 stop 方法然后再调用 Start 方法，完成 Context 的一次重新加载。可以看出执行 reload 方法的条件是 reloadable 为 true 和应用被修改，那么这个 backgroundProcess 方法是怎么被调用的呢？</p>
<p>这个方法是在 ContainerBase 类中定义的内部类 ContainerBackgroundProcessor 被周期调用的，这个类是运行在一个后台线程中，它会周期的执行 run 方法，它的 run 方法会周期调用所有容器的 backgroundProcess 方法，因为所有容器都会继承 ContainerBase 类，所以所有容器都能够在 backgroundProcess 方法中定义周期执行的事件。</p>
<h4 id="Wrapper-容器"><a href="#Wrapper-容器" class="headerlink" title="Wrapper 容器"></a>Wrapper 容器</h4><p>Wrapper 代表一个 Servlet，它负责管理一个 Servlet，包括的 Servlet 的装载、初始化、执行以及资源回收。Wrapper 是最底层的容器，它没有子容器了，所以调用它的 addChild 将会报错。</p>
<p>Wrapper 的实现类是 StandardWrapper，StandardWrapper 还实现了拥有一个 Servlet 初始化信息的 ServletConfig，由此看出 StandardWrapper 将直接和 Servlet 的各种信息打交道。</p>
<p>下面看一下非常重要的一个方法 loadServlet，代码片段如下：</p>
<p>清单 16. StandardWrapper.loadServlet<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public synchronized Servlet loadServlet() throws ServletException &#123;</div><div class="line">    ………</div><div class="line">    Servlet servlet;</div><div class="line">    try &#123;</div><div class="line">        ………</div><div class="line">        ClassLoader classLoader = loader.getClassLoader();</div><div class="line">        ………</div><div class="line">        Class classClass = null;</div><div class="line">        ………</div><div class="line">        servlet = (Servlet) classClass.newInstance();</div><div class="line">        if ((servlet instanceof ContainerServlet) &amp;&amp;</div><div class="line">            (isContainerProvidedServlet(actualClass) ||</div><div class="line">            ((Context)getParent()).getPrivileged() )) &#123;</div><div class="line">                ((ContainerServlet) servlet).setWrapper(this);</div><div class="line">        &#125;</div><div class="line">        classLoadTime=(int) (System.currentTimeMillis() -t1);</div><div class="line">        try &#123;</div><div class="line">            instanceSupport.fireInstanceEvent(InstanceEvent.BEFORE_INIT_EVENT,servlet);</div><div class="line">            if( System.getSecurityManager() != null) &#123;</div><div class="line">                Class[] classType = new Class[]&#123;ServletConfig.class&#125;;</div><div class="line">                Object[] args = new Object[]&#123;((ServletConfig)facade)&#125;;</div><div class="line">                SecurityUtil.doAsPrivilege(&quot;init&quot;,servlet,classType,args);</div><div class="line">            &#125; else &#123;</div><div class="line">                servlet.init(facade);</div><div class="line">            &#125;</div><div class="line">            if ((loadOnStartup &gt;= 0) &amp;&amp; (jspFile != null)) &#123;</div><div class="line">                ………</div><div class="line">                if( System.getSecurityManager() != null) &#123;</div><div class="line">                    Class[] classType = new Class[]&#123;ServletRequest.class,</div><div class="line">                        ServletResponse.class&#125;;</div><div class="line">                    Object[] args = new Object[]&#123;req, res&#125;;</div><div class="line">                    SecurityUtil.doAsPrivilege(&quot;service&quot;,servlet,classType,args);</div><div class="line">                &#125; else &#123;</div><div class="line">                    servlet.service(req, res);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            instanceSupport.fireInstanceEvent(InstanceEvent.AFTER_INIT_EVENT,servlet);</div><div class="line">            ………</div><div class="line">         </div><div class="line">    return servlet;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它基本上描述了对 Servlet 的操作，当装载了 Servlet 后就会调用 Servlet 的 init 方法，同时会传一个 StandardWrapperFacade 对象给 Servlet，这个对象包装了 StandardWrapper，ServletConfig 与它们的关系图如下：</p>
<p>ServletConfig 与 StandardWrapperFacade、StandardWrapper 的关系:<br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/image013.png" alt="image"></p>
<p>Servlet 可以获得的信息都在 StandardWrapperFacade 封装，这些信息又是在 StandardWrapper 对象中拿到的。所以 Servlet 可以通过 ServletConfig 拿到有限的容器的信息。</p>
<p>当 Servlet 被初始化完成后，就等着 StandardWrapperValve 去调用它的 service 方法了，调用 service 方法之前要调用 Servlet 所有的 filter。</p>
<h3 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h3><p>接口中定义的方法:<br><img src="http://img.blog.csdn.net/20161007001421097" alt="image"></p>
<p>一个pipeline包含多个Valve，这些阀共分为两类，一类叫基础阀（通过getBasic、setBasic方法调用），一类是普通阀（通过addValve、removeValve调用）。管道都是包含在容器中，所以有getContainer和setContainer方法。一个管道一般有一个基础阀（通过setBasic添加），可以有0到多个普通阀（通过addValve添加）。 </p>
<p>isAsyncSupported：当管道中的所有阀门都支持异步时返回ture，否则返回false </p>
<p>该接口的标准实现是：org.apache.catalina.core.StandardPipeline<br>Engine、Host、Context及Wrapper的pipeline属性都继承自父类ContainerBase。</p>
<h3 id="Valve"><a href="#Valve" class="headerlink" title="Valve"></a>Valve</h3><p>接口方法:<br><img src="http://img.blog.csdn.net/20161007002724932" alt="image">    </p>
<p>重点关注setNext、getNext、invoke这三个方法，通过setNext设置该阀的下一阀，通过getNext返回该阀的下一个阀的引用，invoke方法则执行该阀内部自定义的请求处理代码。 </p>
<p><strong>ValveBase</strong>：是Valve接口的基本实现<br>四大容器类都有各自缺省的标准valve实现。它们分别是</p>
<ul>
<li><strong>StandardEngineValve</strong>：StandardEngine中的唯一阀门，主要用于从request中选择其host映射的Host容器StandardHost。</li>
<li><strong>StandardHostValve</strong>：StandardHost中最后的阀门，主要用于从request中选择其context映射的Context容器StandardContext以及访问request中的Session以更新会话的最后访问时间。</li>
<li><strong>StandardContextValve</strong>：StandardContext中的唯一阀门，主要作用是禁止任何对WEB-INF或META-INF目录下资源的重定向访问，对应用程序热部署功能的实现，从request中获得StandardWrapper。</li>
<li><strong>StandardWrapperValve</strong>：StandardWrapper中的唯一阀门，主要作用包括调用StandardWrapper的loadServlet方法生成Servlet实例和调用ApplicationFilterFactory生成Filter链。</li>
</ul>
<p>标准valve的调用逻辑图：<br><img src="http://img.blog.csdn.net/20161007004829253" alt="image">    </p>
<p>从StandardEngineValve开始， 所有的基础阀的实现最后都会调用其下一级容器，所有的普通阀都会执行getNext().invoke(request, response);，一直到StandardWrapperValve，完成请求处理过程。因为Wrapper是对一个Servlet的包装，所以它的基础阀内部调用的过滤器链的doFilter方法和Servlet的service方法。<br>上述机制保证了请求传递到servlet去处理。</p>
<p>当采用tomcat默认初始配置时，Valve链如下：<br><img src="http://img.blog.csdn.net/20161007005430411" alt="image"></p>
<h3 id="Tomcat-中其它组件"><a href="#Tomcat-中其它组件" class="headerlink" title="Tomcat 中其它组件"></a>Tomcat 中其它组件</h3><p>Tomcat 还有其它重要的组件，如安全组件 security、logger 日志组件、session、mbeans、naming 等其它组件。这些组件共同为 Connector 和 Container 提供必要的服务。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/04/12/服务器相关/Tomcat/Tomcat整体架构浅析/" data-id="cjfvvpho200d5m9fyhqjhdcns" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器相关/Tomcat/Tomcat类加载机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/12/服务器相关/Tomcat/Tomcat类加载机制/" class="article-date">
  <time datetime="2018-04-12T02:09:45.000Z" itemprop="datePublished">2018-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/Tomcat/">Tomcat</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/12/服务器相关/Tomcat/Tomcat类加载机制/">Tomcat类加载机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>tomcat的类加载概览图：  </p>
<p><img src="https://raw.githubusercontent.com/clq2owesome/image/master/141327112691951.jpg" alt="image"></p>
<h3 id="JVM类加载"><a href="#JVM类加载" class="headerlink" title="JVM类加载"></a>JVM类加载</h3><p>JVM类加载采用 父类委托机制，如下图所示：<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/jvm.jpg" alt="image"> </p>
<p>JVM中包括集中类加载器：</p>
<ol>
<li>BootStrapClassLoader 引导类加载器</li>
<li>ExtClassLoader 扩展类加载器</li>
<li>AppClassLoader 应用类加载器</li>
<li>CustomClassLoader 用户自定义类加载器</li>
</ol>
<p>他们的区别上面也都有说明。需要注意的是，不同的类加载器加载的类是不同的，因此如果用户加载器1加载的某个类，其他用户并不能够使用。</p>
<p>当JVM运行过程中，用户需要加载某些类时，会按照下面的步骤（父类委托机制）：</p>
<ol>
<li>用户自己的类加载器，把加载请求传给父加载器，父加载器再传给其父加载器，一直到加载器树的顶层。</li>
<li>最顶层的类加载器首先针对其特定的位置加载，如果加载不到就转交给子类。</li>
<li>如果一直到底层的类加载都没有加载到，那么就会抛出异常ClassNotFoundException。</li>
</ol>
<p>因此，按照这个过程可以想到，如果同样在CLASSPATH指定的目录中和自己工作目录中存放相同的class，会优先加载CLASSPATH目录中的文件。</p>
<h3 id="Tomcat类加载"><a href="#Tomcat类加载" class="headerlink" title="Tomcat类加载"></a>Tomcat类加载</h3><p>在tomcat中类的加载稍有不同，如下图：    </p>
<p><img src="https://raw.githubusercontent.com/clq2owesome/image/master/tomcat.jpg" alt="image"></p>
<p>当tomcat启动时，会创建几种类加载器：</p>
<ol>
<li><p>Bootstrap 引导类加载器 </p>
<p> 加载JVM启动所需的类，以及标准扩展类（位于jre/lib/ext下）</p>
</li>
<li><p>System 系统类加载器  </p>
<p> 加载tomcat启动的类，比如bootstrap.jar，通常在catalina.bat或者catalina.sh中指定。位于CATALINA_HOME/bin下</p>
</li>
<li><p>Common 通用类加载器 </p>
<p> 加载tomcat使用以及应用通用的一些类，位于CATALINA_HOME/lib下，比如servlet-api.jar</p>
</li>
<li><p>webapp 应用类加载器</p>
<p> 每个应用在部署后，都会创建一个唯一的类加载器。该类加载器会加载位于 WEB-INF/lib下的jar文件中的class 和 WEB-INF/classes下的class文件。</p>
</li>
</ol>
<p>当应用需要到某个类时，则会按照下面的顺序进行类加载：</p>
<ol>
<li>使用bootstrap引导类加载器加载</li>
<li>使用system系统类加载器加载</li>
<li>使用应用类加载器在WEB-INF/classes中加载</li>
<li>使用应用类加载器在WEB-INF/lib中加载</li>
<li>使用common类加载器在CATALINA_HOME/lib中加载</li>
</ol>
<h3 id="问题扩展"><a href="#问题扩展" class="headerlink" title="问题扩展"></a>问题扩展</h3><p>为什么java文件放在Eclipse中的src文件夹下会优先jar包中的class?</p>
<p>这是因为Eclipse中的src文件夹中的文件java以及webContent中的JSP都会在tomcat启动时，被编译成class文件放在 WEB-INF/class 中。</p>
<p>而Eclipse外部引用的jar包，则相当于放在 WEB-INF/lib 中。</p>
<p>因此肯定是 java文件或者JSP文件编译出的class优先加载。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/04/12/服务器相关/Tomcat/Tomcat类加载机制/" data-id="cjfvvpho100d3m9fyybcuowb0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-正则表达式/正则表达式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/08/正则表达式/正则表达式/" class="article-date">
  <time datetime="2018-03-08T02:09:45.000Z" itemprop="datePublished">2018-03-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/正则表达式/">正则表达式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/08/正则表达式/正则表达式/">正则表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>常用：</p>
<ul>
<li><code>\d</code>：代表任意一个数字，0~9的任意一个</li>
<li><code>\w</code>：任意一个字母或数字或下划线，也就是 A~Z,a~z,0~9,_ 中任意一个</li>
<li><code>\s</code>：包括空格、制表符、换页符等空白字符的其中任意一个</li>
<li><code>.</code>：小数点可以匹配除了换行符（\n）以外的任意一个字符（包括数字）</li>
<li><code>\b</code>:匹配这样的位置(字符和边界符之间的位置)：它的前一个字符和后一个字符不全\w,单词边界符可以是中文符号、英文符号、空格、制表符、回车符号，以及各种边界，比如单词在开头，单词在结尾。 比如：”end\b”可以匹配”weekend”，”weekend “, “weekend,”等</li>
</ul>
<p>以上写法，当其为大写时刚好相反</p>
<ul>
<li><code>\S</code>：匹配所有非空白字符（”\s” 可匹配各个空白字符）</li>
<li><code>\D</code>：匹配所有的非数字字符</li>
<li><code>\W</code>：匹配所有的字母、数字、下划线以外的字符</li>
<li><code>\B</code>：<code>\b</code>相反，匹配字符和非边界符之间的位置,比如：”\Bee\B”可以匹配”weekend”</li>
</ul>
<p>特殊符号的含义：</p>
<ul>
<li><code>?</code>：匹配表达式0次或者1次，相当于 {0,1}，比如：”a[cd]?”可以匹配 “a”,”ac”,”ad”</li>
<li><code>+</code>：表达式至少出现1次，相当于 {1,}，比如：”a+b”可以匹配 “ab”,”aab”,”aaab”</li>
<li><code>*</code>：表达式不出现或出现任意次，相当于 {0,}，比如：”a*b”可以匹配 “b”,”aaaab”.</li>
<li><code>^</code>：与字符串开始的地方匹配，不匹配任何字符，比如：”^aaa”可以匹配”aaasdsd”，”\^a”可以匹配”^av”</li>
<li>$：与字符串结束的地方匹配，不匹配任何字符，比如：”aaa$”可以匹配”sdsdaaa”</li>
<li><code>|</code>：左右两边表达式之间 “或” 关系，匹配左边或者右边，比如“Tom|Jack‘可以匹配到”hi,Tom, i am Jack”</li>
</ul>
<h3 id="的用法"><a href="#的用法" class="headerlink" title="{}的用法"></a>{}的用法</h3><p>一般放在被修饰的表达式的后面</p>
<ul>
<li><code>{n}</code>：表达式重复n次，比如：”a{5}” 相当于 “aaaaa”</li>
<li><code>{m,n}</code>：表达式至少重复m次，最多重复n次，比如：”ba{1,3}”可以匹配 “ba”或”baa”或”baaa”</li>
<li><code>{m,}</code>：表达式至少重复m次，比如：”\w\d{2,}”可以匹配 “a12”,”_456”,”M12344”</li>
</ul>
<h3 id="的用法-1"><a href="#的用法-1" class="headerlink" title="[]的用法"></a>[]的用法</h3><p>使用方括号 [ ] 包含一系列字符，能够匹配其中任意一个字符。用 [^ ] 包含一系列字符，则能够匹配其中字符之外的任意一个字符。同样的道理，虽然可以匹配其中任意一个，但是只能是一个，不是多个。<br>例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[ab5@] ：匹配 <span class="string">"a"</span> 或 <span class="string">"b"</span> 或 <span class="string">"5"</span> 或 <span class="string">"@"</span></div><div class="line">[^abc]：匹配 <span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span> 之外的任意一个字符</div><div class="line">[f-k]：匹配 <span class="string">"f"</span>~<span class="string">"k"</span> 之间的任意一个字母</div><div class="line">[^A-F0<span class="number">-3</span>]：匹配 <span class="string">"A"</span>~<span class="string">"F"</span>,<span class="string">"0"</span>~<span class="string">"3"</span> 之外的任意一个字符</div></pre></td></tr></table></figure></p>
<h3 id="的用法-2"><a href="#的用法-2" class="headerlink" title="()的用法"></a>()的用法</h3><p>括号的作用，其实三言两语就能说明白，括号提供了分组，便于我们引用它。</p>
<h4 id="1-分组和分支结构"><a href="#1-分组和分支结构" class="headerlink" title="1. 分组和分支结构"></a>1. 分组和分支结构</h4><p>这二者是括号最直接的作用，也是最原始的功能。</p>
<h5 id="1-1-分组"><a href="#1-1-分组" class="headerlink" title="1.1 分组"></a>1.1 分组</h5><p>我们知道/a+/匹配连续出现的“a”，而要匹配连续出现的“ab”时，需要使用/(ab)+/。</p>
<p>其中括号是提供分组功能，使量词“+”作用于“ab”这个整体，测试如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(ab)+/g</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"ababa abbb ababab"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) ); <span class="comment">// ["abab", "ab", "ababab"]</span></div></pre></td></tr></table></figure></p>
<h5 id="1-2-分支结构"><a href="#1-2-分支结构" class="headerlink" title="1.2 分支结构"></a>1.2 分支结构</h5><p>而在多选分支结构(p1|p2)中，此处括号的作用也是不言而喻的，提供了子表达式的所有可能  </p>
<p>比如，要匹配如下的字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">I love JavaScript</div><div class="line">I love Regular Expression</div></pre></td></tr></table></figure></p>
<p>可以使用正则：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/^I love (JavaScript|Regular Expression)$/</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"I love JavaScript"</span>) ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"I love Regular Expression"</span>) ); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>如果去掉正则中的括号，即<code>/^I love JavaScript|Regular Expression$/</code>，匹配字符串是”I love JavaScript”和”Regular Expression”，当然这不是我们想要的。</p>
<h4 id="2-引用分组"><a href="#2-引用分组" class="headerlink" title="2. 引用分组"></a>2. 引用分组</h4><p>是括号一个重要的作用，有了它，我们就可以进行数据提取，以及更强大的替换操作。</p>
<p>而要使用它带来的好处，必须配合使用实际环境的API。</p>
<p>以日期为例。假设格式是yyyy-mm-dd的，我们可以先写一个简单的正则：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;/</span>;</div></pre></td></tr></table></figure></p>
<p>然后再修改成括号版的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</div></pre></td></tr></table></figure></p>
<h5 id="2-1-提取数据"><a href="#2-1-提取数据" class="headerlink" title="2.1 提取数据"></a>2.1 提取数据</h5><p>比如提取出年、月、日，可以这么做：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-12"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) ); </div><div class="line"><span class="comment">// =&gt; ["2017-06-12", "2017", "06", "12", index: 0, input: "2017-06-12"]</span></div></pre></td></tr></table></figure></p>
<p>match返回的一个数组，第一个元素是整体匹配结果，然后是各个分组（括号里）匹配的内容，然后是匹配下标，最后是输入的文本。（注意：如果正则是否有修饰符g，match返回的数组格式是不一样的）。</p>
<p>另外也可以使用正则对象的exec方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-12"</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.exec(string) ); </div><div class="line"><span class="comment">// =&gt; ["2017-06-12", "2017", "06", "12", index: 0, input: "2017-06-12"]</span></div></pre></td></tr></table></figure></p>
<p>同时，也可以使用构造函数的全局属性$1至$9来获取：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-12"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>); <span class="comment">// "2017"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">2</span>); <span class="comment">// "06"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">3</span>); <span class="comment">// "12"</span></div></pre></td></tr></table></figure></p>
<h5 id="2-2-替换"><a href="#2-2-替换" class="headerlink" title="2.2 替换"></a>2.2 替换</h5><p>比如，想把yyyy-mm-dd格式，替换成mm/dd/yyyy怎么做？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-12"</span>;</div><div class="line"><span class="keyword">var</span> result = string.replace(regex, <span class="string">"$2/$3/$1"</span>);</div><div class="line"><span class="built_in">console</span>.log(result); <span class="comment">// "06/12/2017"</span></div></pre></td></tr></table></figure></p>
<p>其中replace中的，第二个参数里用$1、$2、$3指代相应的分组。等价于如下的形式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-12"</span>;</div><div class="line"><span class="keyword">var</span> result = string.replace(regex, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">RegExp</span>.$<span class="number">2</span> + <span class="string">"/"</span> + <span class="built_in">RegExp</span>.$<span class="number">3</span> + <span class="string">"/"</span> + <span class="built_in">RegExp</span>.$<span class="number">1</span>;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(result); <span class="comment">// "06/12/2017"</span></div></pre></td></tr></table></figure></p>
<p>也等价于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</div><div class="line">var string = &quot;2017-06-12&quot;;</div><div class="line">var result = string.replace(regex, function(match, year, month, day) &#123;</div><div class="line">	return month + &quot;/&quot; + day + &quot;/&quot; + year;</div><div class="line">&#125;);</div><div class="line">console.log(result); // &quot;06/12/2017&quot;</div></pre></td></tr></table></figure></p>
<h4 id="3-反向引用"><a href="#3-反向引用" class="headerlink" title="3. 反向引用"></a>3. 反向引用</h4><p>除了使用相应API来引用分组，也可以在正则本身里引用分组。但只能引用之前出现的分组，即反向引用。</p>
<p>还是以日期为例。</p>
<p>比如要写一个正则支持匹配如下三种格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2016-06-12</div><div class="line">2016/06/12</div><div class="line">2016.06.12</div></pre></td></tr></table></figure></p>
<p>最先可能想到的正则是:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;(-|\/|\.)\d&#123;2&#125;/</span>;</div><div class="line"><span class="keyword">var</span> string1 = <span class="string">"2017-06-12"</span>;</div><div class="line"><span class="keyword">var</span> string2 = <span class="string">"2017/06/12"</span>;</div><div class="line"><span class="keyword">var</span> string3 = <span class="string">"2017.06.12"</span>;</div><div class="line"><span class="keyword">var</span> string4 = <span class="string">"2016-06/12"</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(string1) ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(string2) ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(string3) ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(string4) ); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>其中/和.需要转义。虽然匹配了要求的情况，但也匹配”2016-06/12”这样的数据。</p>
<p>假设我们想要求分割符前后一致怎么办？此时需要使用反向引用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;\1\d&#123;2&#125;/</span>;</div><div class="line"><span class="keyword">var</span> string1 = <span class="string">"2017-06-12"</span>;</div><div class="line"><span class="keyword">var</span> string2 = <span class="string">"2017/06/12"</span>;</div><div class="line"><span class="keyword">var</span> string3 = <span class="string">"2017.06.12"</span>;</div><div class="line"><span class="keyword">var</span> string4 = <span class="string">"2016-06/12"</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(string1) ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(string2) ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(string3) ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(string4) ); <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>注意里面的\1，表示的引用之前的那个分组(-|\/|.)。不管它匹配到什么（比如-），\1都匹配那个同样的具体某个字符。</p>
<p>我们知道了\1的含义后，那么\2和\3的概念也就理解了，即分别指代第二个和第三个分组。</p>
<p>看到这里，此时，恐怕你会有三个问题。</p>
<h5 id="括号嵌套怎么办？"><a href="#括号嵌套怎么办？" class="headerlink" title="括号嵌套怎么办？"></a>括号嵌套怎么办？</h5><p>以左括号（开括号）为准。比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/^((\d)(\d(\d)))\1\2\3\4$/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"1231231233"</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(string) ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.$<span class="number">1</span> ); <span class="comment">// 123</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.$<span class="number">2</span> ); <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.$<span class="number">3</span> ); <span class="comment">// 23</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.$<span class="number">4</span> ); <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<p>我们可以看看这个正则匹配模式：</p>
<p>第一个字符是数字，比如说1，</p>
<p>第二个字符是数字，比如说2，</p>
<p>第三个字符是数字，比如说3，</p>
<p>接下来的是\1，是第一个分组内容，那么看第一个开括号对应的分组是什么，是123，</p>
<p>接下来的是\2，找到第2个开括号，对应的分组，匹配的内容是1，</p>
<p>接下来的是\3，找到第3个开括号，对应的分组，匹配的内容是23，</p>
<p>最后的是\4，找到第3个开括号，对应的分组，匹配的内容是3。</p>
<p>这个问题，估计仔细看一下，就该明白了。</p>
<h5 id="3-2-10表示什么呢？"><a href="#3-2-10表示什么呢？" class="headerlink" title="3.2 \10表示什么呢？"></a>3.2 \10表示什么呢？</h5><p>另外一个疑问可能是，即\10是表示第10个分组，还是\1和0呢？答案是前者，虽然一个正则里出现\10比较罕见。测试如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(1)(2)(3)(4)(5)(6)(7)(8)(9)(#) \10+/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"123456789# ######"</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(string) );</div></pre></td></tr></table></figure></p>
<h5 id="3-3-引用不存在的分组会怎样？"><a href="#3-3-引用不存在的分组会怎样？" class="headerlink" title="3.3 引用不存在的分组会怎样？"></a>3.3 引用不存在的分组会怎样？</h5><p>因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错，只是匹配反向引用的字符本身。例如\2，就匹配”\2”。注意”\2”表示对2进行了转意。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/\1\2\3\4\5\6\7\8\9/</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"\1\2\3\4\5\6\7\8\9"</span>) ); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<h4 id="4-非捕获分组"><a href="#4-非捕获分组" class="headerlink" title="4. 非捕获分组"></a>4. 非捕获分组</h4><p>之前文中出现的分组，都会捕获它们匹配到的数据，以便后续引用，因此也称他们是捕获型分组。</p>
<p>如果只想要括号最原始的功能，但不会引用它，即，既不在API里引用，也不在正则里反向引用。此时可以使用非捕获分组(?:p)，例如本文第一个例子可以修改为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(?:ab)+/g</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"ababa abbb ababab"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) ); <span class="comment">// ["abab", "ab", "ababab"]</span></div></pre></td></tr></table></figure></p>
<h4 id="5-相关案例"><a href="#5-相关案例" class="headerlink" title="5. 相关案例"></a>5. 相关案例</h4><p>至此括号的作用已经讲完了，总结一句话，就是提供了可供我们使用的分组，如何用就看我们的了。</p>
<h5 id="5-1-字符串trim方法模拟"><a href="#5-1-字符串trim方法模拟" class="headerlink" title="5.1 字符串trim方法模拟"></a>5.1 字符串trim方法模拟</h5><p>trim方法是去掉字符串的开头和结尾的空白符。有两种思路去做。</p>
<p>第一种，匹配到开头和结尾的空白符，然后替换成空字符。如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> str.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">''</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( trim(<span class="string">"  foobar   "</span>) ); <span class="comment">// "foobar"</span></div></pre></td></tr></table></figure></p>
<p>第二种，匹配整个字符串，然后用引用来提取出相应的数据：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> str.replace(<span class="regexp">/^\s*(.*?)\s*$/g</span>, <span class="string">"$1"</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( trim(<span class="string">"  foobar   "</span>) ); <span class="comment">// "foobar"</span></div></pre></td></tr></table></figure></p>
<p>这里使用了惰性匹配*?，不然也会匹配最后一个空格之前的所有空格的。<br>当然，前者效率高。</p>
<h5 id="5-2-将每个单词的首字母转换为大写"><a href="#5-2-将每个单词的首字母转换为大写" class="headerlink" title="5.2 将每个单词的首字母转换为大写"></a>5.2 将每个单词的首字母转换为大写</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">titleize</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> str.toLowerCase().replace(<span class="regexp">/(?:^|\s)\w/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> c.toUpperCase();</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( titleize(<span class="string">'my name is epeli'</span>) ); <span class="comment">// "My Name Is Epeli"</span></div></pre></td></tr></table></figure>
<p>思路是找到每个单词的首字母，当然这里不使用非捕获匹配也是可以的。</p>
<h5 id="5-3-驼峰化"><a href="#5-3-驼峰化" class="headerlink" title="5.3 驼峰化"></a>5.3 驼峰化</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">camelize</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> str.replace(<span class="regexp">/[-_\s]+(.)?/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, c</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> c ? c.toUpperCase() : <span class="string">''</span>;</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( camelize(<span class="string">'-moz-transform'</span>) ); <span class="comment">// MozTransform</span></div></pre></td></tr></table></figure>
<p>首字母不会转化为大写的。其中分组(.)表示首字母，单词的界定，前面的字符可以是多个连字符、下划线以及空白符。正则后面的?的目的，是为了应对str尾部的字符可能不是单词字符，比如str是’-moz-transform ‘。</p>
<h5 id="5-4-中划线化"><a href="#5-4-中划线化" class="headerlink" title="5.4 中划线化"></a>5.4 中划线化</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">unction dasherize(str) &#123;</div><div class="line">	<span class="keyword">return</span> str.replace(<span class="regexp">/([A-Z])/g</span>, <span class="string">'-$1'</span>).replace(<span class="regexp">/[-_\s]+/g</span>, <span class="string">'-'</span>).toLowerCase();</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( dasherize(<span class="string">'MozTransform'</span>) ); <span class="comment">// -moz-transform</span></div></pre></td></tr></table></figure>
<p>驼峰化的逆过程。</p>
<h5 id="5-5-html转义和反转义"><a href="#5-5-html转义和反转义" class="headerlink" title="5.5 html转义和反转义"></a>5.5 html转义和反转义</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将HTML特殊字符转换成等值的实体</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">escapeHTML</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> escapeChars = &#123;</div><div class="line">	  <span class="string">'¢'</span> : <span class="string">'cent'</span>,</div><div class="line">	  <span class="string">'£'</span> : <span class="string">'pound'</span>,</div><div class="line">	  <span class="string">'¥'</span> : <span class="string">'yen'</span>,</div><div class="line">	  <span class="string">'€'</span>: <span class="string">'euro'</span>,</div><div class="line">	  <span class="string">'©'</span> :<span class="string">'copy'</span>,</div><div class="line">	  <span class="string">'®'</span> : <span class="string">'reg'</span>,</div><div class="line">	  <span class="string">'&lt;'</span> : <span class="string">'lt'</span>,</div><div class="line">	  <span class="string">'&gt;'</span> : <span class="string">'gt'</span>,</div><div class="line">	  <span class="string">'"'</span> : <span class="string">'quot'</span>,</div><div class="line">	  <span class="string">'&amp;'</span> : <span class="string">'amp'</span>,</div><div class="line">	  <span class="string">'\''</span> : <span class="string">'#39'</span></div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">return</span> str.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'['</span> + <span class="built_in">Object</span>.keys(escapeChars).join(<span class="string">''</span>) +<span class="string">']'</span>, <span class="string">'g'</span>), <span class="function"><span class="keyword">function</span>(<span class="params">match</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">'&amp;'</span> + escapeChars[match] + <span class="string">';'</span>;</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( escapeHTML(<span class="string">'&lt;div&gt;Blah blah blah&lt;/div&gt;'</span>) );</div><div class="line"><span class="comment">// =&gt; &amp;lt;div&amp;gt;Blah blah blah&amp;lt;/div&amp;gt;</span></div></pre></td></tr></table></figure>
<p>其中使用了用构造函数生成的正则，然后替换相应的格式就行了，这个跟本文没多大关系。</p>
<p>倒是它的逆过程，使用了括号，以便提供引用，也很简单，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// 实体字符转换为等值的HTML。</div><div class="line">function unescapeHTML(str) &#123;</div><div class="line">	var htmlEntities = &#123;</div><div class="line">	  nbsp: &apos; &apos;,</div><div class="line">	  cent: &apos;¢&apos;,</div><div class="line">	  pound: &apos;£&apos;,</div><div class="line">	  yen: &apos;¥&apos;,</div><div class="line">	  euro: &apos;€&apos;,</div><div class="line">	  copy: &apos;©&apos;,</div><div class="line">	  reg: &apos;®&apos;,</div><div class="line">	  lt: &apos;&lt;&apos;,</div><div class="line">	  gt: &apos;&gt;&apos;,</div><div class="line">	  quot: &apos;&quot;&apos;,</div><div class="line">	  amp: &apos;&amp;&apos;,</div><div class="line">	  apos: &apos;\&apos;&apos;</div><div class="line">	&#125;;</div><div class="line">	return str.replace(/\&amp;([^;]+);/g, function(match, key) &#123;</div><div class="line">		if (key in htmlEntities) &#123;</div><div class="line">			return htmlEntities[key];</div><div class="line">		&#125;</div><div class="line">		return match;</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">console.log( unescapeHTML(&apos;&amp;lt;div&amp;gt;Blah blah blah&amp;lt;/div&amp;gt;&apos;) );</div><div class="line">// =&gt; &lt;div&gt;Blah blah blah&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>通过key获取相应的分组引用，然后作为对象的键。</p>
<h5 id="5-6-匹配成对标签"><a href="#5-6-匹配成对标签" class="headerlink" title="5.6 匹配成对标签"></a>5.6 匹配成对标签</h5><p>要求匹配：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>regular expression<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>laoyao bye bye<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>不匹配：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>wrong!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>匹配一个开标签，可以使用正则<code>&lt;[^&gt;]+&gt;</code>，</p>
<p>匹配一个闭标签，可以使用<code>&lt;\/[^&gt;]+&gt;</code>，</p>
<p>但是要求匹配成对标签，那就需要使用反向引用，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var regex = /&lt;([^&gt;]+)&gt;[\d\D]*&lt;\/\1&gt;/;</div><div class="line">var string1 = &quot;&lt;title&gt;regular expression&lt;/title&gt;&quot;;</div><div class="line">var string2 = &quot;&lt;p&gt;laoyao bye bye&lt;/p&gt;&quot;;</div><div class="line">var string3 = &quot;&lt;title&gt;wrong!&lt;/p&gt;&quot;;</div><div class="line">console.log( regex.test(string1) ); // true</div><div class="line">console.log( regex.test(string2) ); // true</div><div class="line">console.log( regex.test(string3) ); // false</div></pre></td></tr></table></figure></p>
<p>其中开标签<code>&lt;[^&gt;]+&gt;</code>改成<code>&lt;([^&gt;]+)&gt;</code>，使用括号的目的是为了后面使用反向引用，而提供分组。闭标签使用了反向引用，<code>&lt;\/\1&gt;</code>。</p>
<p>另外<code>[\d\D]</code>的意思是，这个字符是数字或者不是数字，因此，也就是匹配任意字符的意思。</p>
<h2 id="正则表达式中-括号-方括号-大括号-的区别"><a href="#正则表达式中-括号-方括号-大括号-的区别" class="headerlink" title="正则表达式中(括号) [方括号] {大括号}的区别"></a>正则表达式中(括号) [方括号] {大括号}的区别</h2><ul>
<li><p><code>括号()</code> ： 括号是多个匹配，它把括号内的当做一组来处理，限制一些多选的范围，比如上面的需求只能是com cn net结尾的用括号就是最好的选择。<br>括号能提取字符串，如(com|cn|net)就可以限制，只能是com或cn或net。<br>括号将括号里面的内容作为一组，这就是与[]不同的地方。</p>
</li>
<li><p><code>方括号[]</code>： 方括号是单个匹配，如[abc]他限制的不是abc连续出现，而是只能是其中一个，这样写那么规则就是找到这个位置时只能是a或是b或是c；<br>方括号是正则表达式中最常用的，常用的用法有：[a-zA-Z0-9]匹配所有英文字母和数字，[^a-zA-Z0-9]匹配所有非英文字母和数字。</p>
</li>
<li><p><code>大括号{}</code>： 大括号的用法很简单，就是匹配次数，它需要和其他有意义的正则表达式一起使用。<br>比如[a-c]{2}意思就是匹配a-c之间的一个字母出现且只出现两次；<br>比如(com){1}意思就是com必须出现一次<br>比如\W{1,3}意思就是非字母数字最少出现一次最多出现3次。</p>
</li>
</ul>
<h2 id="贪婪与非贪婪模式"><a href="#贪婪与非贪婪模式" class="headerlink" title="贪婪与非贪婪模式"></a>贪婪与非贪婪模式</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>贪婪与非贪婪模式影响的是被量词修饰的子表达式的匹配行为，贪婪模式在整个表达式匹配成功的前提下，尽可能多的匹配，而非贪婪模式在整个表达式匹配成功的前提下，尽可能少的匹配。非贪婪模式只被部分NFA引擎所支持。 </p>
<p>属于贪婪模式的量词，也叫做匹配优先量词，包括：<br><code>{m,n}</code>、<code>{m,}</code>、<code>?</code>、<code>*</code>和<code>+</code>。    </p>
<p>在一些使用NFA引擎的语言中，在匹配优先量词后加上“?”，即变成属于非贪婪模式的量词，也叫做忽略优先量词，包括：<br><code>{m,n}?</code>、<code>{m,}?</code>、<code>??</code>、<code>*?</code>和<code>+?</code>。 </p>
<p>从正则语法的角度来讲，被匹配优先量词修饰的子表达式使用的就是贪婪模式，如“(Expression)+”；被忽略优先量词修饰的子表达式使用的就是非贪婪模式，如“(Expression)+?”。 </p>
<p>对于贪婪模式，各种文档的叫法基本一致，但是对于非贪婪模式，有的叫懒惰模式或惰性模式，有的叫勉强模式，其实叫什么无所谓，只要掌握原理和用法，能够运用自如也就是了。个人习惯使用贪婪与非贪婪的叫法</p>
<p>这两种模式如下图所示：<br>| 贪婪   | 非贪婪  | 意　　义（X为表达式）           |<br>| —— | ——- | ——————————- |<br>| X?     | X??     | 匹配 X 零次或一次               |<br>| X<em>     | X</em>?     | 匹配 X 零次或多次               |<br>| X+     | X+?     | 匹配 X 一次或多次               |<br>| X{n,}  | X{n,}?  | 匹配 X 至少 n 次                |<br>| X{n,m} | X{n,m}? | 匹配 X 至少 n 次，但不多于 m 次 |</p>
<p>看下一个例子，假定要分析的字符串是xfooxxxxxxfoo</p>
<ul>
<li><p><strong>贪婪模式</strong>:<br>  最大匹配方式。模式分为子模式p1(.*)和子模式p2(foo)两个部分. 其中p1中的量词匹配方式使用默认方式(贪婪型)。 匹配开始时,吃入所有字符xfooxxxxxx去匹配子模式p1。匹配成功,但这样以来就没有了字符串去匹配子模式p2。本轮匹配失败；第二轮：减少p1部分的匹配量，吐出最后一个字符, 把字符串分割成xfooxxxxxxfo和o两个子字符串s1和s2。 s1匹配p1, 但s2不匹配p2。本轮匹配失败；第三轮，再次减少p1部分匹配量，吐出两个字符, 字符串被分割成xfooxxxxxxfo和oo两部分。结果同上。第四轮，再次减少p1匹配量, 字符串分割成xfooxxxxxx和foo两个部分, 这次s1/s2分别和p1/p2匹配。停止尝试,返回匹配成功。</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/.*foo/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"xfooxxxxxxfoo"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) ); <span class="comment">//xfooxxxxxxfoo</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>非贪婪模式</strong>:<br>  最小匹配方式。第一次尝试匹配, p1由于是0或任意次，因此被忽略，用字符串去匹配p2,失败；第二次，读入第一个字符x, 尝试和p1匹配, 匹配成功; 字符串剩余部分fooxxxxxxfoo中前三个字符和p2也是匹配的. 因此, 停止尝试, 返回匹配成功。在这种模式下，如果对剩余字符串继续去寻找和模式相匹配的子字符串，还会找到字符串末尾的另一个xfoo，而在贪婪模式下，由于第一次匹配成功的子串就已经是所有字符，因此不存在第二个匹配子串。</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/.*?foo/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"xfooxxxxxxfoo"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) ); <span class="comment">//xfoo</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="JavaScript-RegExp-对象"><a href="#JavaScript-RegExp-对象" class="headerlink" title="JavaScript RegExp 对象"></a>JavaScript RegExp 对象</h2><p>正则表达式是描述字符模式的对象。</p>
<p>正则表达式用于对字符串模式匹配及检索替换，是对字符串执行模式匹配的强大工具。</p>
<h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> patt=<span class="keyword">new</span> <span class="built_in">RegExp</span>(pattern,modifiers);</div><div class="line"></div><div class="line">或者更简单的方式:</div><div class="line"></div><div class="line"><span class="keyword">var</span> patt=<span class="regexp">/pattern/m</span>odifiers;</div></pre></td></tr></table></figure>
<ul>
<li>pattern（模式） 描述了表达式的模式</li>
<li>modifiers(修饰符) 用于指定全局匹配、区分大小写的匹配和多行匹配</li>
</ul>
<p>注意：当使用构造函数创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 \）。比如，以下是等价的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\w+"</span>);</div><div class="line"><span class="keyword">var</span> re = <span class="regexp">/\w+/</span>;</div></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\w+"</span>);</div><div class="line">re.test(<span class="string">"abc"</span>);<span class="comment">//true</span></div><div class="line"></div><div class="line">/\w+\.test(<span class="string">"abc"</span>);<span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p><strong>修饰符</strong><br>修饰符用于执行区分大小写和全局匹配:</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>执行对大小写不敏感的匹配。</td>
</tr>
<tr>
<td>g</td>
<td>执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td>
</tr>
<tr>
<td>m</td>
<td>执行多行匹配。</td>
</tr>
</tbody>
</table>
<h6 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h6><p>exec() 方法用于检索字符串中的正则表达式的匹配。</p>
<p>如果字符串中有匹配的值返回该匹配值，否则返回 null。</p>
<p><strong>语法：</strong><br>RegExpObject.exec(string)</p>
<p><strong>例子:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str=<span class="string">"Hello world!"</span>;</div><div class="line"><span class="comment">//查找"Hello"</span></div><div class="line"><span class="keyword">var</span> patt=<span class="regexp">/Hello/g</span>;</div><div class="line"><span class="built_in">console</span>.log(patt.exec(str)); <span class="comment">//Hello</span></div></pre></td></tr></table></figure></p>
<h6 id="test"><a href="#test" class="headerlink" title="test()"></a>test()</h6><p>test() 方法用于检测一个字符串是否匹配某个模式.</p>
<p>如果字符串中有匹配的值返回 true ，否则返回 false。</p>
<p><strong>语法：</strong><br>RegExpObject.test(string)</p>
<p><strong>例子:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str=<span class="string">"Hello world!"</span>;</div><div class="line"><span class="comment">//查找"Hello"</span></div><div class="line"><span class="keyword">var</span> patt=<span class="regexp">/Hello/g</span>;</div><div class="line"><span class="built_in">console</span>.log(patt.test(str)); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<h6 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h6><p>找到一个或多个正则表达式的匹配。</p>
<p><strong>语法：</strong><br>string.match(regexp)</p>
<p><strong>例子:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">有修饰符g</div><div class="line"><span class="keyword">var</span> str=<span class="string">"The rain in SPAIN stays mainly in the plain"</span>; </div><div class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/ain/g</span>));<span class="comment">//"ain", "ain", "ain"</span></div><div class="line"></div><div class="line">没有修饰符g</div><div class="line"><span class="keyword">var</span> str=<span class="string">"The rain in SPAIN stays mainly in the plain"</span>; </div><div class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/ain/</span>));<span class="comment">//"ain"</span></div></pre></td></tr></table></figure></p>
<p>注意： match() 方法将检索字符串 String Object，以找到一个或多个与 regexp 匹配的文本。这个方法的行为在很大程度上有赖于 regexp 是否具有标志 g。如果 regexp 没有标志 g，那么 match() 方法就只能在 stringObject 中执行一次匹配。如果没有找到任何匹配的文本， match() 将返回 null。否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/03/08/正则表达式/正则表达式/" data-id="cjfvvphho001rm9fyvt2beley" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/分布式/分布式事务" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/分布式/分布式事务/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/分布式/">分布式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/分布式/分布式事务/">分布式事务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="分布式事务概述"><a href="#分布式事务概述" class="headerlink" title="分布式事务概述"></a>分布式事务概述</h3><p>分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。以上是百度百科的解释，简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。</p>
<h3 id="分布式事务的产生的原因"><a href="#分布式事务的产生的原因" class="headerlink" title="分布式事务的产生的原因"></a>分布式事务的产生的原因</h3><h5 id="1-数据库分库分表"><a href="#1-数据库分库分表" class="headerlink" title="1.数据库分库分表"></a>1.数据库分库分表</h5><p>当数据库单表一年产生的数据超过1000W，那么就要考虑分库分表，具体分库分表的原理在此不做解释，以后有空详细说，简单的说就是原来的一个数据库变成了多个数据库。这时候，如果一个操作既访问01库，又访问02库，而且要保证数据的一致性，那么就要用到分布式事务。<br><img src="http://img.blog.csdn.net/20170320083203650?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZV9zb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image">    </p>
<h5 id="2-应用SOA化"><a href="#2-应用SOA化" class="headerlink" title="2.应用SOA化"></a>2.应用SOA化</h5><p>所谓的SOA化，就是业务的服务化。比如原来单机支撑了整个电商网站，现在对整个网站进行拆解，分离出了订单中心、用户中心、库存中心。对于订单中心，有专门的数据库存储订单信息，用户中心也有专门的数据库存储用户信息，库存中心也会有专门的数据库存储库存信息。这时候如果要同时对订单和库存进行操作，那么就会涉及到订单数据库和库存数据库，为了保证数据一致性，就需要用到分布式事务。<br><img src="http://img.blog.csdn.net/20170320083209525?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZV9zb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"><br>以上两种情况表象不同，但是本质相同，都是因为要操作的数据库变多了！    </p>
<h3 id="分布式事务的应用场景"><a href="#分布式事务的应用场景" class="headerlink" title="分布式事务的应用场景"></a>分布式事务的应用场景</h3><h5 id="1-支付"><a href="#1-支付" class="headerlink" title="1.支付"></a>1.支付</h5><p>最经典的场景就是支付了，一笔支付，是对买家账户进行扣款，同时对卖家账户进行加钱，这些操作必须在一个事务里执行，要么全部成功，要么全部失败。而对于买家账户属于买家中心，对应的是买家数据库，而卖家账户属于卖家中心，对应的是卖家数据库，对不同数据库的操作必然需要引入分布式事务。</p>
<h5 id="2-在线下单"><a href="#2-在线下单" class="headerlink" title="2.在线下单"></a>2.在线下单</h5><p>买家在电商平台下单，往往会涉及到两个动作，一个是扣库存，第二个是更新订单状态，库存和订单一般属于不同的数据库，需要使用分布式事务保证数据一致性。</p>
<h3 id="常见的分布式事务解决方案"><a href="#常见的分布式事务解决方案" class="headerlink" title="常见的分布式事务解决方案"></a>常见的分布式事务解决方案</h3><h4 id="基于XA协议的两阶段提交"><a href="#基于XA协议的两阶段提交" class="headerlink" title="基于XA协议的两阶段提交"></a>基于XA协议的两阶段提交</h4><p>XA是一个分布式事务协议，由Tuxedo提出。XA中大致分为两部分：事务管理器和本地资源管理器。其中本地资源管理器往往由数据库实现，比如Oracle、DB2这些商业数据库都实现了XA接口，而事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。XA实现分布式事务的原理如下：<br><img src="http://img.blog.csdn.net/20170320083214850?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZV9zb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image">    </p>
<p>总的来说，XA协议比较简单，而且一旦商业数据库实现了XA协议，使用分布式事务的成本也比较低。但是，XA也有致命的缺点，那就是性能不理想，特别是在交易下单链路，往往并发量很高，XA无法满足高并发场景。XA目前在商业数据库支持的比较理想，在mysql数据库中支持的不太理想，mysql的XA实现，没有记录prepare阶段日志，主备切换回导致主库与备库数据不一致。许多nosql也没有支持XA，这让XA的应用场景变得非常狭隘。  </p>
<p>两阶段提交协议（Two-phase Commit，2PC）经常被用来实现分布式事务。一般分为协调器C和若干事务执行者Si两种角色，这里的事务执行者就是具体的数据库，协调器可以和事务执行器在一台机器上。<br><img src="http://ww2.sinaimg.cn/large/7cc829d3gw1eux5nfbny7j20l908xta6.jpg" alt="image">  </p>
<ol>
<li><p>我们的应用程序（client）发起一个开始请求到TC；</p>
</li>
<li><p>TC先将<prepare>消息写到本地日志，之后向所有的Si发起<prepare>消息。以支付宝转账到余额宝为例，TC给A的prepare消息是通知支付宝数据库相应账目扣款1万，TC给B的prepare消息是通知余额宝数据库相应账目增加1w。为什么在执行任务前需要先写本地日志，主要是为了故障后恢复用，本地日志起到现实生活中凭证 的效果，如果没有本地日志（凭证），出问题容易死无对证；</prepare></prepare></p>
</li>
<li><p>Si收到<prepare>消息后，执行具体本机事务，但不会进行commit，如果成功返回<yes>，不成功返回<no>。同理，返回前都应把要返回的消息写到日志里，当作凭证。</no></yes></prepare></p>
</li>
<li><p>TC收集所有执行器返回的消息，如果所有执行器都返回yes，那么给所有执行器发生送commit消息，执行器收到commit后执行本地事务的commit操作；如果有任一个执行器返回no，那么给所有执行器发送abort消息，执行器收到abort消息后执行事务abort操作。</p>
</li>
</ol>
<p>注：TC或Si把发送或接收到的消息先写到日志里，主要是为了故障后恢复用。如某一Si从故障中恢复后，先检查本机的日志，如果已收到<commit>，则提交，如果<abort>则回滚。如果是<yes>，则再向TC询问一下，确定下一步。如果什么都没有，则很可能在<prepare>阶段Si就崩溃了，因此需要回滚。</prepare></yes></abort></commit></p>
<p>现如今实现基于两阶段提交的分布式事务也没那么困难了，如果使用java，那么可以使用开源软件atomikos(<a href="http://www.atomikos.com/)来快速实现。" target="_blank" rel="external">http://www.atomikos.com/)来快速实现。</a><br>​<br>不过但凡使用过的上述两阶段提交的同学都可以发现性能实在是太差，根本不适合高并发的系统。为什么？</p>
<ol>
<li>两阶段提交涉及多次节点间的网络通信，通信时间太长！</li>
<li>事务时间相对于变长了，锁定的资源的时间也变长了，造成资源等待时间也增加好多！</li>
</ol>
<p>正是由于分布式事务存在很严重的性能问题，大部分高并发服务都在避免使用，往往通过其他途径来解决数据一致性问题。</p>
<h4 id="消息事务-最终一致性"><a href="#消息事务-最终一致性" class="headerlink" title="消息事务+最终一致性"></a>消息事务+最终一致性</h4><p>如果仔细观察生活的话，生活的很多场景已经给了我们提示。</p>
<p>比如在北京很有名的姚记炒肝点了炒肝并付了钱后，他们并不会直接把你点的炒肝给你，而是给你一张小票，然后让你拿着小票到出货区排队去取。为什么他们要将付钱和取货两个动作分开呢？原因很多，其中一个很重要的原因是为了使他们接待能力增强（并发量更高）。</p>
<p>所谓的消息事务就是基于消息中间件的两阶段提交，本质上是对消息中间件的一种特殊利用，它是将本地事务和发消息放在了一个分布式事务里，保证要么本地操作成功成功并且对外发消息成功，要么两者都失败，开源的RocketMQ就支持这一特性，具体原理如下： </p>
<p><img src="http://img.blog.csdn.net/20170320083222287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZV9zb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image">    </p>
<ol>
<li>A系统向消息中间件发送一条预备消息</li>
<li>消息中间件保存预备消息并返回成功</li>
<li>A执行本地事务</li>
<li>A发送提交消息给消息中间件</li>
</ol>
<p>通过以上4步完成了一个消息事务。对于以上的4个步骤，每个步骤都可能产生错误，下面一一分析：</p>
<ul>
<li>步骤一出错，则整个事务失败，不会执行A的本地操作</li>
<li>步骤二出错，则整个事务失败，不会执行A的本地操作</li>
<li>步骤三出错，这时候需要回滚预备消息，怎么回滚？答案是A系统实现一个消息中间件的回调接口，消息中间件会去不断执行回调接口，检查A事务执行是否执行成功，如果失败则回滚预备消息</li>
<li>步骤四出错，这时候A的本地事务是成功的，那么消息中间件要回滚A吗？答案是不需要，其实通过回调接口，消息中间件能够检查到A执行成功了，这时候其实不需要A发提交消息了，消息中间件可以自己对消息进行提交，从而完成整个消息事务</li>
</ul>
<p>基于消息中间件的两阶段提交往往用在高并发场景下，将一个分布式事务拆成一个消息事务（A系统的本地操作+发消息）+B系统的本地操作，其中B系统的操作由消息驱动，只要消息事务成功，那么A操作一定成功，消息也一定发出来了，这时候B会收到消息去执行本地操作，如果本地操作失败，消息会重投，直到B操作成功，这样就变相地实现了A与B的分布式事务。原理如下：<br><img src="http://img.blog.csdn.net/20170320083228100?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZV9zb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"><br>虽然上面的方案能够完成A和B的操作，但是A和B并不是严格一致的，而是最终一致的，我们在这里牺牲了一致性，换来了性能的大幅度提升。当然，这种玩法也是有风险的，如果B一直执行不成功，那么一致性会被破坏，具体要不要玩，还是得看业务能够承担多少风险。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/分布式/分布式事务/" data-id="cjfvvphjw003sm9fymvit3xn4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/分布式/分布式锁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/分布式/分布式锁/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/分布式/">分布式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/分布式/分布式锁/">分布式锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。</p>
<p>分布式的<code>CAP理论</code>告诉我们“任何一个分布式系统都无法同时满足<code>一致性（Consistency）</code>、<code>可用性（Availability）</code>和<code>分区容错性（Partition tolerance）</code>，最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。</p>
<p>在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行。在单机环境中，Java中其实提供了很多并发处理相关的API，但是这些API在分布式场景中就无能为力了。也就是说单纯的Java Api并不能提供分布式锁的能力。所以针对分布式锁的实现目前有多种方案：</p>
<ul>
<li>基于数据库实现分布式锁</li>
<li>基于缓存（redis，memcached）实现分布式锁</li>
<li>基于Zookeeper实现分布式锁</li>
</ul>
<h3 id="分布式情况"><a href="#分布式情况" class="headerlink" title="分布式情况"></a>分布式情况</h3><ul>
<li>分布式与单机情况下最大的不同在于其不是多线程而是多进程。</li>
<li>多线程由于可以共享堆内存，因此可以简单的采取内存作为标记存储位置。而进程之间甚至可能都不在同一台物理机上，因此需要将标记存储在一个所有进程都能看到的地方。</li>
</ul>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><ul>
<li>当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。</li>
<li>与单机模式下的锁不仅需要保证进程可见，还需要考虑进程与锁之间的网络问题。（我觉得分布式情况下之所以问题变得复杂，主要就是需要考虑到网络的延时和不可靠）</li>
<li>分布式锁还是可以将标记存在内存，只是该内存不是某个进程分配的内存而是公共内存如Redis、Memcache。至于利用数据库、文件等做锁与单机的实现是一样的，只要保证标记能互斥就行。</li>
</ul>
<h3 id="单机Redis锁"><a href="#单机Redis锁" class="headerlink" title="单机Redis锁"></a>单机Redis锁</h3><h5 id="基本锁"><a href="#基本锁" class="headerlink" title="基本锁"></a>基本锁</h5><p><strong>原理</strong>：利用Redis的setnx如果不存在某个key则设置值，设置成功则表示取得锁成功。<br><strong>缺点</strong>：如果获取锁后的进程，在还没执行完的时候挂调了，则锁永远不会释放。</p>
<h5 id="改进型"><a href="#改进型" class="headerlink" title="改进型"></a>改进型</h5><p><strong>改进</strong>：在基本型是锁上的setnx后设置expire，保证即使获取锁的进程不主动释放锁，过一段时间后也能自动释放。<br><strong>缺点</strong>：setnx与expire不是一个原子操作，可能执行完setnx该进程就挂了。<br>当锁过期后，该进程还没执行完，可能造成同时多个进程取得锁。（貌似这个问题目前还没有很优雅的解决方案）</p>
<h5 id="再改进"><a href="#再改进" class="headerlink" title="再改进"></a>再改进</h5><p><strong>改进</strong>：利用Lua脚本，将setnx与expire变成一个原子操作，可解决一部分问题。<br><strong>缺点</strong>：还是锁过期的问题。</p>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ol>
<li>直接调用Lua脚本原子setnx同时expire，设置一个随机值。</li>
<li>获取到锁则执行同步代码块，没获取则根据业务场景可以选择自旋、休眠、或做一个等待队列等拥有锁进程来唤醒（类似Synchronize的同步队列）。</li>
<li>当同步代码块执行完成，先判断锁的key是否是自己设置的，如果是则删除key（可利用Lua做成原子操作），不是则表明自己的锁已经过期，不需要删除。（这时候就出现了多进程同时有锁的问题了）</li>
</ol>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>一般情况下直接用setnx加expire就够了，但从安全性的角度看还是存在一下几个问题：</p>
<ol>
<li>单点问题。单机Redis只在单机上，如果单机down了，那么所有需要用分布式锁的地方均获取不到锁，全部阻塞。需要做好降级的处理。</li>
<li>可能出现多进程同时拥有锁。</li>
</ol>
<h3 id="集群Rides锁"><a href="#集群Rides锁" class="headerlink" title="集群Rides锁"></a>集群Rides锁</h3><h4 id="Redlock"><a href="#Redlock" class="headerlink" title="Redlock"></a>Redlock</h4><p>Redlock是Redis的作者antirez给出的集群模式的Redis分布式锁，它基于N个完全独立的Redis节点（通常情况下N可以设置成5）。</p>
<h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h5><ol>
<li>获取当前时间（毫秒数）。</li>
<li>按顺序依次向N个Redis节点执行获取锁的操作。获取锁的操作与单机锁一样。</li>
<li>如果获取锁成功的节点数&gt;=N/2+1，则再计算获取锁的时间有没有超过锁过期时间（可考虑设置一个必须留多长的时间给代码块执行），如果超过了则认为取锁失败。</li>
<li>如果取锁失败则应该对所有节点进行释放锁的操作。<h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5></li>
</ol>
<p>当有5个节点，某次上锁对a,b,c三个节点上锁成功，而后c马上down了，此时还没通过AOF或RDB写入磁盘。而后c又马上恢复，此时c没有上锁数据，因此此时可能出现c,d,e三个节点被别的进程上锁。所以在节点恢复时应该延时起码一个锁的过期时间。</p>
<h3 id="Zookeeper锁"><a href="#Zookeeper锁" class="headerlink" title="Zookeeper锁"></a>Zookeeper锁</h3><h5 id="zookeeper锁相关基础知识"><a href="#zookeeper锁相关基础知识" class="headerlink" title="zookeeper锁相关基础知识"></a>zookeeper锁相关基础知识</h5><ul>
<li>zk一般由多个节点构成（单数），采用zab一致性协议。因此可以将zk看成一个单点结构，对其修改数据其内部自动将所有节点数据进行修改而后才提供查询服务。</li>
<li>zk的数据以目录树的形式，每个目录称为 znode， znode中可存储数据（一般不超过1M），还可以在其中增加子节点。</li>
<li>子节点有三种类型。序列化节点，每在该节点下增加一个节点自动给该节点的名称上自增。临时节点，一旦创建这个 znode 的客户端与服务器失去联系，这个 znode 也将自动删除。最后就是普通节点。</li>
<li>Watch机制，client可以监控每个节点的变化，当产生变化会给client产生一个事件。</li>
</ul>
<h5 id="zk基本锁"><a href="#zk基本锁" class="headerlink" title="zk基本锁"></a>zk基本锁</h5><p><strong>原理</strong>：利用临时节点与watch机制。每个锁占用一个普通节点/lock，当需要获取锁时在/lock下创建一个临时节点，创建成功则表示获取锁成功，失败则watch/lock节点，有删除操作后再去争锁。临时节点好处在于当进程挂掉后能自动上锁的节点自动删除即取消锁。</p>
<p><strong>缺点</strong>：所有取锁失败的进程都监听父节点，很容易发生羊群效应，即当释放锁后所有等待进程一起来创建节点，并发量很大。</p>
<h5 id="zk锁优化"><a href="#zk锁优化" class="headerlink" title="zk锁优化"></a>zk锁优化</h5><p><strong>原理</strong>：上锁改为创建临时有序节点，每个上锁的节点均能创建节点成功，知识其序号不同。只有序号最小的可以拥有锁，当需要不是最小的则watch序号排在前面的一个节点(公平锁)。</p>
<p><strong>步骤</strong>：</p>
<ol>
<li>在/lock节点下创建一个有序临时节点(EPHEMERAL_SEQUENTIAL)。</li>
<li>判断创建的节点序号是否最小，如果是最小则获取锁成功。不是则取锁失败，然后watch序号比本身小的前一个节点。</li>
<li>当取锁失败，设置watch后则等待watch事件到来后，再次判断是否序号最小。</li>
<li>取锁成功则执行代码，最后删除本身节点，释放了锁。</li>
</ol>
<h3 id="分布式锁总结"><a href="#分布式锁总结" class="headerlink" title="分布式锁总结"></a>分布式锁总结</h3><h5 id="分布式锁存在的问题"><a href="#分布式锁存在的问题" class="headerlink" title="分布式锁存在的问题"></a>分布式锁存在的问题</h5><ol>
<li>均可能存在多进程拥有锁的情况。redis锁主要是expire时间与代码执行时间的问题，zk锁的问题在于zk是通过心跳监控进程存活状态，如果进程进行GC pause或者因为网络原因导致很长时间没与zk联系，则将导致zk认为进程已挂，而后锁自动释放，而此时进程并未挂任然在执行。</li>
<li>Redlock锁的时间问题。由于redis的expire的实现是通过pexpireat，如果某个节点发生时钟跳跃，则该节点可能过早释放锁导致一系列问题。</li>
</ol>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><ol>
<li>获取锁时提供一个fencing token(两种说法，一种说需要有序，一种说随机值就可以，我觉得随机值就可以)，在进程获取锁后对数据进行操作时，数据所在的资源服务器需要去锁中查看当前token，如果token对的才执行，不对则放弃执行。</li>
<li>我觉得对于放弃执行的应该在我们的代码块中增加类似事物的rollback的操作。因此如果资源服务器拒绝了我们的操作则表明此时起码已经存在了另外一个进程拥有锁了，为了保证数据安全性不能继续执行，因此需要回滚到执行代码块之前而继续去竞争锁。</li>
<li>至于Redis锁的时间问题，Antirez说在运维层面是可以控制时钟跳跃的区间的，只要能控制跳跃区间与expire的比例就没问题，详细可看《基于Redis的分布式锁真的安全吗？》</li>
</ol>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><ol>
<li>大多数时候采用zk锁就好了，没必要再考虑安全性的问题。其实也可以通过zk锁+幂等校验来达到双层保障。</li>
<li>fencing 机制需要对数据服务进行修改适配，个人觉得没这个必要吧。。。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/分布式/分布式锁/" data-id="cjfvvphjx003vm9fyj2jm11pw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/基础/java8新特性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/基础/java8新特性/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/基础/java8新特性/">java8新特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="函数式接口（Functional-Interfaces）"><a href="#函数式接口（Functional-Interfaces）" class="headerlink" title="函数式接口（Functional Interfaces）"></a>函数式接口（Functional Interfaces）</h2><p>Java 8 引入的一个核心概念是函数式接口（<strong>Functional Interfaces</strong>）。通过在接口里面添加一个抽象方法，这些方法可以直接从接口中运行。如果一个接口定义个唯一一个抽象方法，那么这个接口就成为<strong>函数式接口</strong>。</p>
<p>同时，引入了一个新的注解：<code>@FunctionalInterface</code>。可以把他它放在一个接口前，表示这个接口是一个函数式接口。这个注解是非必须的，只要接口只包含一个方法的接口，虚拟机会自动判断，不过最好在接口上使用注解 @FunctionalInterface 进行声明。在接口中添加了 @FunctionalInterface 的接口，只允许有一个抽象方法，否则编译器也会报错。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">interface Converter&lt;F, T&gt; &#123;</div><div class="line">    T convert(F from);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</div><div class="line">Integer converted = converter.convert(&quot;123&quot;);</div><div class="line">System.out.println(converted);    // 123</div></pre></td></tr></table></figure></p>
<p>java.lang.Runnable 就是一个函数式接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface Runnable &#123;</div><div class="line">    public abstract void run();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们要记住默认的方法和静态方法不会违反函数接口的约定，例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface FunctionalDefaultMethods &#123;</div><div class="line">    void method();</div><div class="line"> </div><div class="line">    default void defaultMethod() &#123;</div><div class="line">        //相关代码</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    static void staticMethod() &#123;</div><div class="line">        //相关代码</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="方法和构造函数引用"><a href="#方法和构造函数引用" class="headerlink" title="方法和构造函数引用"></a>方法和构造函数引用</h2><p>上面的示例代码可以通过使用静态方法引用进一步简化:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</div><div class="line">Integer converted = converter.convert(&quot;123&quot;);</div><div class="line">System.out.println(converted);   // 123</div></pre></td></tr></table></figure></p>
<p>Java 8允许您通过<code>::</code>关键字来传递方法或构造函数的引用。上面的示例展示了如何引用静态方法。但是我们也可以引用对象方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Something &#123;</div><div class="line">    String startsWith(String s) &#123;</div><div class="line">        return String.valueOf(s.charAt(0));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Something something = new Something();</div><div class="line">Converter&lt;String, String&gt; converter = something::startsWith;</div><div class="line">String converted = converter.convert(&quot;Java&quot;);</div><div class="line">System.out.println(converted);    // &quot;J&quot;</div></pre></td></tr></table></figure></p>
<p>让我们看看<code>::</code>关键字如何对构造函数有效。首先，我们定义了一个不同构造函数的示例bean:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">    String firstName;</div><div class="line">    String lastName;</div><div class="line"></div><div class="line">    Person() &#123;&#125;</div><div class="line"></div><div class="line">    Person(String firstName, String lastName) &#123;</div><div class="line">        this.firstName = firstName;</div><div class="line">        this.lastName = lastName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来，我们指定一个人工厂接口用于创建新人员:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">interface PersonFactory&lt;P extends Person&gt; &#123;</div><div class="line">    P create(String firstName, String lastName);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们没有手工地实现工厂，而是通过构造函数引用将所有内容粘在一起:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PersonFactory&lt;Person&gt; personFactory = Person::new;</div><div class="line">Person person = personFactory.create(&quot;Peter&quot;, &quot;Parker&quot;);</div></pre></td></tr></table></figure></p>
<p>我们通过<code>Person::new</code>创建一个Person构造函数的引用。Java编译器会通过匹配PersonFactory.create的签名来自动选择正确的构造函数。</p>
<p>方法引用提供了一个很有用的语义来直接访问类或者实例的已经存在的方法或者构造方法。结合Lambda表达式，方法引用使语法结构紧凑简明。不需要复杂的引用。</p>
<p>下面我们用Car 这个类来做示例，Car这个类有不同的方法定义。让我们来看看java 8支持的4种方法引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public static class Car &#123;</div><div class="line">    public static Car create( final Supplier&lt; Car &gt; supplier ) &#123;</div><div class="line">        return supplier.get();</div><div class="line">    &#125;              </div><div class="line"> </div><div class="line">    public static void collide( final Car car ) &#123;</div><div class="line">        System.out.println( &quot;Collided &quot; + car.toString() );</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void follow( final Car another ) &#123;</div><div class="line">        System.out.println( &quot;Following the &quot; + another.toString() );</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void repair() &#123;</div><div class="line">        System.out.println( &quot;Repaired &quot; + this.toString() );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li><p>第一种方法引用是构造方法引用，语法是：<code>Class::new</code> ，对于泛型来说语法是：<code>Class&lt;T &gt;::new</code>，请注意构造方法没有参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">final Car car = Car.create( Car::new );</div><div class="line">final List&lt; Car &gt; cars = Arrays.asList( car );</div></pre></td></tr></table></figure>
</li>
<li><p>第二种方法引用是静态方法引用，语法是：<code>Class::static_method</code>请注意这个静态方法只支持一个类型为Car的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cars.forEach( Car::collide );</div></pre></td></tr></table></figure>
</li>
<li><p>第三种方法引用是类实例的方法引用，语法是：<code>Class::method</code>请注意方法没有参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cars.forEach( Car::repair );</div></pre></td></tr></table></figure>
</li>
<li><p>最后一种方法引用是引用特殊类的方法，语法是：<code>instance::method</code>，请注意只接受Car类型的一个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">final Car police = Car.create( Car::new );</div><div class="line">cars.forEach( police::follow );</div></pre></td></tr></table></figure>
</li>
</ol>
<p>运行这些例子我们将会在控制台得到如下信息（Car的实例可能会不一样）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Collided com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d</div><div class="line">Repaired com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d</div><div class="line">Following the com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d</div></pre></td></tr></table></figure></p>
<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>从lambda表达式访问外部范围变量非常类似于匿名对象。您可以从本地外部范围访问最终变量，以及实例字段和静态变量。</p>
<h3 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h3><p>我们可以从lambda表达式的外部范围读取最终的局部变量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">final int num = 1;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line"></div><div class="line">stringConverter.convert(2);     // 3</div></pre></td></tr></table></figure></p>
<p>但与匿名对象不同的是，变量num不必被声明为final。这段代码也是有效的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int num = 1;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line"></div><div class="line">stringConverter.convert(2);     // 3</div></pre></td></tr></table></figure></p>
<p>但是，对于要编译的代码，num必须是隐式的final。以下代码不编译:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int num = 1;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line">num = 3;</div></pre></td></tr></table></figure></p>
<p>也禁止在lambda表达式中写入num。</p>
<h3 id="访问字段和静态变量"><a href="#访问字段和静态变量" class="headerlink" title="访问字段和静态变量"></a>访问字段和静态变量</h3><p>在对局部变量的限制中，我们可以从lambda表达式中读取和写入对实例字段和静态变量的访问。这种行为在匿名对象中很常见。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Lambda4 &#123;</div><div class="line">    static int outerStaticNum;</div><div class="line">    int outerNum;</div><div class="line"></div><div class="line">    void testScopes() &#123;</div><div class="line">        Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;</div><div class="line">            outerNum = 23;</div><div class="line">            return String.valueOf(from);</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;</div><div class="line">            outerStaticNum = 72;</div><div class="line">            return String.valueOf(from);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="访问默认接口方法"><a href="#访问默认接口方法" class="headerlink" title="访问默认接口方法"></a>访问默认接口方法</h3><p>还记得第一部分的公式例子吗?接口公式定义了一个默认的方法sqrt，它可以从每个公式实例(包括匿名对象)访问。这不适用于lambda表达式。</p>
<p>无法从lambda表达式中访问默认方法。以下代码不编译:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Formula formula = (a) -&gt; sqrt( a * 100);</div></pre></td></tr></table></figure></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>函数式接口的重要属性是：我们能够使用 Lambda 实例化它们，Lambda 表达式让你能够将函数作为方法参数，或者将代码作为数据对待</strong>。Lambda 表达式的引入给开发者带来了不少优点：在 Java 8 之前，匿名内部类，监听器和事件处理器的使用都显得很冗长，代码可读性很差，Lambda 表达式的应用则使代码变得更加紧凑，可读性增强；Lambda 表达式使并行操作大集合变得很方便，可以充分发挥多核 CPU 的优势，更易于为多核处理器编写代码；</p>
<p>Lambda 表达式由三个部分组成：</p>
<ul>
<li>第一部分为一个括号内用逗号分隔的形式参数，参数是函数式接口里面方法的参数；</li>
<li>第二部分为一个箭头符号：-&gt;；</li>
<li>第三部分为方法体，可以是表达式和代码块。</li>
</ul>
<p>语法如下：</p>
<ol>
<li><p>方法体为表达式，该表达式的值作为返回值返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(parameters) -&gt; expression</div></pre></td></tr></table></figure>
</li>
<li><p>方法体为代码块，必须用 {} 来包裹起来，且需要一个 return 返回值，但若函数式接口里面方法返回值是 void，则无需返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(parameters) -&gt; &#123; statements; &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>例如，下面是使用匿名内部类和 Lambda 表达式的代码比较。<br>下面是用匿名内部类的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">button.addActionListener(new ActionListener() &#123;</div><div class="line">    @Override</div><div class="line">    public void actionPerformed(ActionEvent e) &#123;</div><div class="line">        System.out.print(&quot;Helllo Lambda in actionPerformed&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>下面是使用 Lambda 表达式后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">button.addActionListener(</div><div class="line">    //actionPerformed 有一个参数 e 传入，所以用 (ActionEvent e)</div><div class="line">    (ActionEvent e)-&gt; </div><div class="line">    System.out.print(&quot;Helllo Lambda in actionPerformed&quot;);</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>上面是方法体包含了参数传入 (ActionEvent e)，如果没有参数则只需 ( )，例如 Thread 中的 run 方法就没有参数传入，当它使用 Lambda 表达式后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Thread t = new Thread(</div><div class="line">    //run 没有参数传入，所以用 (), 后面用 &#123;&#125; 包起方法体</div><div class="line">    () -&gt; &#123;</div><div class="line">     System.out.println(&quot;Hello from a thread in run&quot;);</div><div class="line">    &#125;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>通过上面两个代码的比较可以发现使用 Lambda 表达式可以简化代码，并提高代码的可读性。<br>为了进一步简化 Lambda 表达式，可以使用方法引用。例如，下面三种分别是使用内部类，使用 Lambda 表示式和使用方法引用方式的比较：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//1. 使用内部类</div><div class="line">Function&lt;Integer, String&gt; f = new Function&lt;Integer,String&gt;()&#123;</div><div class="line">    @Override</div><div class="line">    public String apply(Integer t) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//2. 使用 Lambda 表达式</div><div class="line">Function&lt;Integer, String&gt; f2 = (t)-&gt;String.valueOf(t); </div><div class="line"></div><div class="line">//3. 使用方法引用的方式</div><div class="line">Function&lt;Integer, String&gt; f1 = String::valueOf;</div></pre></td></tr></table></figure></p>
<p>要使用 Lambda 表达式，需要定义一个函数式接口，这样往往会让程序充斥着过量的仅为 Lambda 表达式服务的函数式接口。为了减少这样过量的函数式接口，Java 8 在 java.util.function 中增加了不少新的函数式通用接口。例如：</p>
<ul>
<li><p><code>Function&lt;T, R&gt;</code>：将 T 作为输入，返回 R 作为输出，他还包含了和其他函数组合的默认方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</div><div class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</div><div class="line"></div><div class="line">backToString.apply(&quot;123&quot;);     // &quot;123&quot;</div></pre></td></tr></table></figure>
</li>
<li><p><code>Predicate&lt;T&gt;</code> ：将 T 作为输入，返回一个布尔值作为输出，该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（与、或、非）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">   Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;</div><div class="line">System.out.println(predicate.test(&quot;foo&quot;));// true   </div><div class="line">System.out.println(predicate.negate().test(&quot;foo&quot;));// false</div><div class="line"></div><div class="line">Predicate&lt;String&gt; nonNull = Objects::nonNull;</div><div class="line">Predicate&lt;String&gt; isNull = Objects::isNull;</div><div class="line">System.out.println(nonNull.test(&quot;aa&quot;));//true</div><div class="line">System.out.println(isNull.test(&quot;aa&quot;));//false</div><div class="line"></div><div class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</div><div class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</div></pre></td></tr></table></figure>
</li>
<li><p><code>Suppliers</code>：生成给定泛型类型的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Supplier&lt;Person&gt; personSupplier = Person::new;</div><div class="line">personSupplier.get();   // new Person</div></pre></td></tr></table></figure>
</li>
<li><p><code>Consumer&lt;T&gt;</code> ：将 T 作为输入，不返回任何内容，表示在单个参数上的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(&quot;Hello, &quot; + p.firstName);</div><div class="line">greeter.accept(new Person(&quot;Luke&quot;, &quot;Skywalker&quot;));</div></pre></td></tr></table></figure>
</li>
<li><p><code>Comparators</code>：比较器是较老版本的Java所熟悉的。Java 8向接口添加了各种默认方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</div><div class="line"></div><div class="line">Person p1 = new Person(&quot;John&quot;, &quot;Doe&quot;);</div><div class="line">Person p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;);</div><div class="line"></div><div class="line">comparator.compare(p1, p2);             // &gt; 0</div><div class="line">comparator.reversed().compare(p1, p2);  // &lt; 0</div></pre></td></tr></table></figure>
</li>
<li><p><code>Optionals</code>：Optionals不是功能性接口，相反，它是一个防止NullPointerException的漂亮工具</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Optional&lt;String&gt; optional = Optional.of(&quot;bam&quot;);</div><div class="line"></div><div class="line">optional.isPresent();           // true</div><div class="line">optional.get();                 // &quot;bam&quot;</div><div class="line">optional.orElse(&quot;fallback&quot;);    // &quot;bam&quot;</div><div class="line"></div><div class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(0)));     // &quot;b&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>著名的NullPointerException 是引起系统失败最常见的原因。很久以前Google Guava项目引入了Optional作为解决空指针异常的一种方式，不赞成代码被null检查的代码污染，期望程序员写整洁的代码。受Google Guava的鼓励，Optional 现在是Java 8库的一部分。</p>
<p>Optional 只是一个容器，它可以保存一些类型的值或者null。它提供很多有用的方法，所以没有理由不显式地检查null。请参照java 8的<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" target="_blank" rel="external">文档</a>查看详细信息。</p>
<p>让我们看看两个Optional 用法的小例子：一个是允许为空的值，另外一个是不允许为空的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Optional&lt; String &gt; fullName = Optional.ofNullable( null );</div><div class="line">System.out.println( &quot;Full Name is set? &quot; + fullName.isPresent() );        </div><div class="line">System.out.println( &quot;Full Name: &quot; + fullName.orElseGet( () -&gt; &quot;[none]&quot; ) ); </div><div class="line">System.out.println( fullName.map( s -&gt; &quot;Hey &quot; + s + &quot;!&quot; ).orElse( &quot;Hey Stranger!&quot; ) );</div></pre></td></tr></table></figure></p>
<p>如果Optional实例有非空的值，方法 isPresent() 返回true否则返回false。方法orElseGet提供了回退机制，当Optional的值为空时接受一个方法返回默认值。map()方法转化Optional当前的值并且返回一个新的Optional实例。orElse方法和orElseGet类似，但是它不接受一个方法，而是接受一个默认值。上面代码运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Full Name is set? false</div><div class="line">Full Name: [none]</div><div class="line">Hey Stranger!</div></pre></td></tr></table></figure></p>
<p>例如，People 类中有一个方法 getMaleList 需要获取男性的列表，这里需要定义一个函数式接口 PersonInterface：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">interface PersonInterface &#123;</div><div class="line">    public boolean test(Person person);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class People &#123;</div><div class="line">    private List&lt;Person&gt; persons= new ArrayList&lt;Person&gt;();</div><div class="line">    public List&lt;Person&gt; getMaleList(PersonInterface filter) &#123;</div><div class="line">        List&lt;Person&gt; res = new ArrayList&lt;Person&gt;();</div><div class="line">        persons.forEach(</div><div class="line">            (Person person) -&gt; </div><div class="line">                &#123;</div><div class="line">                    if (filter.test(person)) &#123;//调用 PersonInterface 的方法</div><div class="line">                        res.add(person);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">        );</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了去除 PersonInterface 这个函数式接口，可以用通用函数式接口 Predicate 替代如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class People&#123;</div><div class="line">    private List&lt;Person&gt; persons= new ArrayList&lt;Person&gt;();</div><div class="line">    public List&lt;Person&gt; getMaleList(Predicate&lt;Person&gt; predicate) &#123;</div><div class="line">        List&lt;Person&gt; res = new ArrayList&lt;Person&gt;();</div><div class="line">        persons.forEach(</div><div class="line">            person -&gt; &#123;</div><div class="line">                if (predicate.test(person)) &#123;//调用 Predicate 的抽象方法 test</div><div class="line">                    res.add(person);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( e -&gt; System.out.println( e ) );</div></pre></td></tr></table></figure></p>
<p>请注意到编译器会根据上下文来推测参数的类型，或者你也可以显示地指定参数类型，只需要将类型包在括号里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( ( String e ) -&gt; System.out.println( e ) );</div></pre></td></tr></table></figure></p>
<p>如果Lambda的功能语句块太复杂，我们可以用大括号包起来，跟普通的Java方法一样，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String separator = &quot;,&quot;;</div><div class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach(</div><div class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</div></pre></td></tr></table></figure></p>
<p>Lambda表达式可能会引用类的成员或者局部变量（会被隐式地转变成final类型），下面两种写法的效果是一样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">String separator = &quot;,&quot;;</div><div class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach(</div><div class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</div><div class="line">    </div><div class="line">final String separator = &quot;,&quot;;</div><div class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach(</div><div class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</div></pre></td></tr></table></figure></p>
<p>Lambda表达式可能会有返回值，编译器会根据上下文推断返回值的类型。如果lambda的语句块只有一行，不需要return关键字。下面两个写法是等价的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).sort( ( e1, e2 ) -&gt; e1.compareTo( e2 ) );</div><div class="line"></div><div class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).sort( ( e1, e2 ) -&gt; &#123;</div><div class="line">    int result = e1.compareTo( e2 );</div><div class="line">    return result;</div><div class="line">&#125; );</div></pre></td></tr></table></figure></p>
<h2 id="接口的增强"><a href="#接口的增强" class="headerlink" title="接口的增强"></a>接口的增强</h2><p>Java 8 对接口做了进一步的增强。在接口中可以添加使用 <code>default</code> 关键字修饰的非抽象方法。还可以在接口中定义静态方法。如今，接口看上去与抽象类的功能越来越类似了。</p>
<h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>Java 8 还允许我们给接口添加一个非抽象的方法实现，只需要使用 default 关键字即可，这个特征又叫做<strong>扩展方法</strong>。在实现该接口时，该默认扩展方法在子类上可以直接使用，它的使用方式类似于抽象类中非抽象成员方法。但扩展方法不能够重载 Object 中的方法。例如：toString、equals、 hashCode 不能在接口中被重载。</p>
<p><strong>一个接口可以包含多个默认方法和静态方法</strong>。</p>
<p>例如，下面接口中定义了一个默认方法 count()，该方法可以在子类中直接使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public interface DefaultFunInterface &#123;</div><div class="line">    //定义默认方法 count</div><div class="line">    default int count()&#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class SubDefaultFunClass implements DefaultFunInterface &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        //实例化一个子类对象，改子类对象可以直接调用父接口中的默认方法 count</div><div class="line">        SubDefaultFunClass sub = new SubDefaultFunClass();</div><div class="line">        sub.count();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>默认方法和抽象方法的区别是抽象方法必须要被实现，默认方法不是。作为替代方式，接口可以提供一个默认的方法实现，所有这个接口的实现类都会通过继承得倒这个方法（如果有需要也可以重写这个方法），让我们来看看下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private interface Defaulable &#123;</div><div class="line">    // Interfaces now allow default methods, the implementer may or</div><div class="line">    // may not implement (override) them.</div><div class="line">    default String notRequired() &#123;</div><div class="line">        return &quot;Default implementation&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">private static class DefaultableImpl implements Defaulable &#123;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">private static class OverridableImpl implements Defaulable &#123;</div><div class="line">    @Override</div><div class="line">    public String notRequired() &#123;</div><div class="line">        return &quot;Overridden implementation&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接口Defaulable使用default关键字声明了一个默认方法notRequired()，类DefaultableImpl实现了Defaulable接口，没有对默认方法做任何修改。另外一个类OverridableImpl重写类默认实现，提供了自己的实现方法。</p>
<p>JVM平台的接口的默认方法实现是很高效的，并且方法调用的字节码指令支持默认方法。默认方法使已经存在的接口可以修改而不会影响编译的过程。java.util.Collection中添加的额外方法就是最好的例子：stream(), parallelStream(), forEach(), removeIf()</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>在接口中，还允许定义静态的方法。接口中的静态方法可以直接用接口来调用。</p>
<p>例如，下面接口中定义了一个静态方法 find，该方法可以直接用 StaticFunInterface .find() 来调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public interface StaticFunInterface &#123;</div><div class="line">    public static int find()&#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class TestStaticFun &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        //接口中定义了静态方法 find 直接被调用</div><div class="line">        StaticFunInterface.fine();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="集合之流式操作"><a href="#集合之流式操作" class="headerlink" title="集合之流式操作"></a>集合之流式操作</h2><p>Java 8 引入了流式操作（Stream），通过该操作可以实现对集合（Collection）的并行处理和函数式操作。根据操作返回的结果不同，流式操作分为中间操作和最终操作两种。最终操作返回一特定类型的结果，而中间操作返回流本身，这样就可以将多个操作依次串联起来。根据流的并发性，流又可以分为串行和并行两种。<strong>流式操作实现了集合的过滤、排序、映射等功能</strong>。</p>
<p><strong>Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算</strong>。</p>
<h3 id="串行和并行的流"><a href="#串行和并行的流" class="headerlink" title="串行和并行的流"></a>串行和并行的流</h3><p>流有串行和并行两种，串行流上的操作是在一个线程中依次完成，而并行流则是在多个线程上同时执行。并行与串行的流可以相互切换：通过 stream.sequential() 返回串行的流，通过 stream.parallel() 返回并行的流。相比较串行的流，并行的流可以很大程度上提高程序的执行效率。</p>
<p>下面是分别用串行和并行的方式对集合进行排序。</p>
<h6 id="串行排序："><a href="#串行排序：" class="headerlink" title="串行排序："></a>串行排序：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line">for(int i=0;i&lt;1000000;i++)&#123;</div><div class="line">    double d = Math.random()*1000;</div><div class="line">    list.add(d+&quot;&quot;);</div><div class="line">&#125;</div><div class="line">long start = System.nanoTime();//获取系统开始排序的时间点</div><div class="line">int count= (int) ((Stream) list.stream().sequential()).sorted().count();</div><div class="line">long end = System.nanoTime();//获取系统结束排序的时间点</div><div class="line">long ms = TimeUnit.NANOSECONDS.toMillis(end-start);//得到串行排序所用的时间</div><div class="line">System.out.println(ms+”ms”);</div></pre></td></tr></table></figure>
<h6 id="并行排序："><a href="#并行排序：" class="headerlink" title="并行排序："></a>并行排序：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line">for(int i=0;i&lt;1000000;i++)&#123;</div><div class="line">    double d = Math.random()*1000;</div><div class="line">    list.add(d+&quot;&quot;);</div><div class="line">&#125;</div><div class="line">long start = System.nanoTime();//获取系统开始排序的时间点</div><div class="line">int count = (int)((Stream) list.stream().parallel()).sorted().count();</div><div class="line">long end = System.nanoTime();//获取系统结束排序的时间点</div><div class="line">long ms = TimeUnit.NANOSECONDS.toMillis(end-start);//得到并行排序所用的时间</div><div class="line">System.out.println(ms+”ms”);</div><div class="line">//串行输出为 1200ms，并行输出为 800ms。可见，并行排序的时间相比较串行排序时间要少不少。</div></pre></td></tr></table></figure>
<h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><p>该操作会保持 stream 处于中间状态，允许做进一步的操作。它返回的还是的 Stream，允许更多的链式操作。常见的中间操作有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();</div><div class="line">stringCollection.add(&quot;ddd2&quot;);</div><div class="line">stringCollection.add(&quot;aaa2&quot;);</div><div class="line">stringCollection.add(&quot;bbb1&quot;);</div><div class="line">stringCollection.add(&quot;aaa1&quot;);</div><div class="line">stringCollection.add(&quot;bbb3&quot;);</div><div class="line">stringCollection.add(&quot;ccc&quot;);</div><div class="line">stringCollection.add(&quot;bbb2&quot;);</div><div class="line">stringCollection.add(&quot;ddd1&quot;);</div></pre></td></tr></table></figure></p>
<ul>
<li><p><code>filter()</code>：对元素进行过滤；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">stringCollection</div><div class="line">    .stream()</div><div class="line">    .filter((s) -&gt; s.startsWith(&quot;a&quot;))</div><div class="line">    .forEach(System.out::println);</div><div class="line"></div><div class="line">// &quot;aaa2&quot;, &quot;aaa1&quot;</div></pre></td></tr></table></figure>
</li>
<li><p><code>sorted()</code>：对元素排序,排序只创建流的排序视图，原来集合顺序不变；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">stringCollection</div><div class="line">    .stream()</div><div class="line">    .sorted()</div><div class="line">    .filter((s) -&gt; s.startsWith(&quot;a&quot;))</div><div class="line">    .forEach(System.out::println);</div><div class="line"></div><div class="line">// &quot;aaa1&quot;, &quot;aaa2&quot;</div><div class="line"></div><div class="line">System.out.println(stringCollection);</div><div class="line">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</div></pre></td></tr></table></figure>
</li>
<li><p><code>map()</code>：元素的映射,中间操作映射通过给定的函数将每个元素转换成另一个对象。下面的示例将每个字符串转换为一个大写字符串。但是您也可以使用map将每个对象转换成另一个类型。生成的流的泛型类型取决于您传递给映射的函数的泛型类型。原来的集合不受影响；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">stringCollection</div><div class="line">    .stream()</div><div class="line">    .map(String::toUpperCase)</div><div class="line">    .sorted((a, b) -&gt; b.compareTo(a))</div><div class="line">    .forEach(System.out::println);</div><div class="line"></div><div class="line">// &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;AAA2&quot;, &quot;AAA1&quot;</div></pre></td></tr></table></figure>
</li>
<li><p><code>distinct()</code>：去除重复元素；</p>
</li>
<li><code>subStream()</code>：获取子 Stream 等。</li>
</ul>
<p>例如，下面是对一个字符串集合进行过滤，返回以“s”开头的字符串集合，并将该集合依次打印出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">list.stream()</div><div class="line">    .filter((s) -&gt; s.startsWith(&quot;s&quot;))</div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<p>这里的 filter(…) 就是一个中间操作，该中间操作可以链式地应用其他 Stream 操作。</p>
<h3 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h3><p>该操作必须是流的最后一个操作，一旦被调用，Stream 就到了一个终止状态，而且不能再使用了。常见的终止操作有：</p>
<ul>
<li><code>forEach()</code>：对每个元素做处理；</li>
<li><code>toArray()</code>：把元素导出到数组；</li>
<li><code>findFirst()</code>：返回第一个匹配的元素；</li>
<li><p><code>Match</code>：可以使用各种匹配操作检查某个谓词是否与流匹配。所有这些操作都是终端，并返回一个布尔结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">boolean anyStartsWithA =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .anyMatch((s) -&gt; s.startsWith(&quot;a&quot;));</div><div class="line"></div><div class="line">System.out.println(anyStartsWithA);      // true</div><div class="line"></div><div class="line">boolean allStartsWithA =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .allMatch((s) -&gt; s.startsWith(&quot;a&quot;));</div><div class="line"></div><div class="line">System.out.println(allStartsWithA);      // false</div><div class="line"></div><div class="line">boolean noneStartsWithZ =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .noneMatch((s) -&gt; s.startsWith(&quot;z&quot;));</div><div class="line"></div><div class="line">System.out.println(noneStartsWithZ);      // true</div></pre></td></tr></table></figure>
</li>
<li><p><code>Count</code>：返回流中元素的数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">long startsWithB =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .filter((s) -&gt; s.startsWith(&quot;b&quot;))</div><div class="line">        .count();</div><div class="line"></div><div class="line">System.out.println(startsWithB);    // 3</div></pre></td></tr></table></figure>
</li>
<li><p><code>Reduce</code>：通过给定的函数对流的元素进行还原。结果是存于Optional中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Optional&lt;String&gt; reduced =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .sorted()</div><div class="line">        .reduce((s1, s2) -&gt; s1 + &quot;#&quot; + s2);</div><div class="line"></div><div class="line">reduced.ifPresent(System.out::println);</div><div class="line">// &quot;aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>例如，下面是对一个字符串集合进行过滤，返回以“s”开头的字符串集合，并将该集合依次打印出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">list.stream() //获取列表的 stream 操作对象</div><div class="line">    .filter((s) -&gt; s.startsWith(&quot;s&quot;))//对这个流做过滤操作</div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<p>这里的 forEach(…) 就是一个终止操作，该操作之后不能再链式的添加其他操作了。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>现在Map支持用于执行常见任务的各种新的和有用的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</div><div class="line"></div><div class="line">for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">    map.putIfAbsent(i, &quot;val&quot; + i);</div><div class="line">&#125;</div><div class="line"></div><div class="line">map.forEach((id, val) -&gt; System.out.println(val));</div></pre></td></tr></table></figure></p>
<p>map的计算:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">map.computeIfPresent(3, (num, val) -&gt; val + num);</div><div class="line">map.get(3);             // val33</div><div class="line"></div><div class="line">map.computeIfPresent(9, (num, val) -&gt; null);</div><div class="line">map.containsKey(9);     // false</div><div class="line"></div><div class="line">map.computeIfAbsent(23, num -&gt; &quot;val&quot; + num);</div><div class="line">map.containsKey(23);    // true</div><div class="line"></div><div class="line">map.computeIfAbsent(3, num -&gt; &quot;bam&quot;);</div><div class="line">map.get(3);             // val33</div></pre></td></tr></table></figure></p>
<p>通过给定的key来删除元素，只有value值匹配才会删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">map.remove(3, &quot;val3&quot;);</div><div class="line">map.get(3);             // val33</div><div class="line"></div><div class="line">map.remove(3, &quot;val33&quot;);</div><div class="line">map.get(3);             // null</div></pre></td></tr></table></figure></p>
<p>其他有用的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">map.getOrDefault(42, &quot;not found&quot;);  // not found</div></pre></td></tr></table></figure></p>
<p>合并：如果不存在则插入，存在则合并<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">map.merge(9, &quot;val9&quot;, (value, newValue) -&gt; value.concat(newValue));</div><div class="line">map.get(9);             // val9</div><div class="line"></div><div class="line">map.merge(9, &quot;concat&quot;, (value, newValue) -&gt; value.concat(newValue));</div><div class="line">map.get(9);             // val9concat</div></pre></td></tr></table></figure></p>
<h2 id="注解的更新"><a href="#注解的更新" class="headerlink" title="注解的更新"></a>注解的更新</h2><p>对于注解，Java 8 主要有两点改进：<strong>类型注解</strong>和<strong>重复注解</strong>。</p>
<p>Java 8 的类型注解扩展了注解使用的范围。在该版本之前，注解只能是在声明的地方使用。现在几乎可以为任何东西添加注解：局部变量、类与接口，就连方法的异常也能添加注解。</p>
<p>新增的两个注释的程序元素类型： <code>ElementType.TYPE_USE</code> 和 <code>ElementType.TYPE_PARAMETER</code> 用来描述注解的新场合。ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中。而 ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中（例如声明语句、泛型和强制转换语句中的类型）。</p>
<p>对类型注解的支持，增强了通过静态分析工具发现错误的能力。原先只能在运行时发现的问题可以提前在编译的时候被排查出来。Java 8 本身虽然没有自带类型检测的框架，但可以通过使用 Checker Framework 这样的第三方工具，自动检查和确认软件的缺陷，提高生产效率。</p>
<p>例如，下面的代码可以通过编译，但是运行时会报 NullPointerException 的异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class TestAnno &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Object obj = null;</div><div class="line">        obj.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了能在编译期间就自动检查出这类异常，可以通过类型注解结合 Checker Framework 提前排查出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import org.checkerframework.checker.nullness.qual.NonNull;</div><div class="line">public class TestAnno &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        @NonNull Object obj = null;</div><div class="line">        obj.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译时自动检测结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">C:\workspace\TestJava8\src\TestAnno.java:4: Warning:</div><div class="line">  (assignment.type.incompatible) $$ 2 $$ null $$ @UnknownInitialization @NonNull Object $$ ( 152, 156 )</div><div class="line">  $$ incompatible types in assignment.</div><div class="line">@NonNull Object obj = null;</div><div class="line"> ^</div><div class="line"> found : null</div><div class="line"> required: @UnknownInitialization @NonNull Object</div></pre></td></tr></table></figure></p>
<p>另外，在该版本之前使用注解的一个限制是相同的注解在同一位置只能声明一次，不能声明多次。Java 8 引入了重复注解机制，这样相同的注解可以在同一地方声明多次。重复注解机制本身必须用 <code>@Repeatable</code> 注解。</p>
<p>例如，下面就是用 @Repeatable 重复注解的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@Retention(RetentionPolicy.RUNTIME) \\该注解存在于类文件中并在运行时可以通过反射获取</div><div class="line">@interface Annots &#123;</div><div class="line">    Annot[] value();</div><div class="line">&#125; </div><div class="line"></div><div class="line">@Retention(RetentionPolicy.RUNTIME) \\该注解存在于类文件中并在运行时可以通过反射获取</div><div class="line">@Repeatable(Annots.class)</div><div class="line">@interface Annot &#123;</div><div class="line">    String value();</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Annot(&quot;a1&quot;)</div><div class="line">@Annot(&quot;a2&quot;)</div><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Annots annots1 = Test.class.getAnnotation(Annots.class);</div><div class="line">        System.out.println(annots1.value()[0]+&quot;,&quot;+annots1.value()[1]); </div><div class="line">        // 输出: @Annot(value=a1),@Annot(value=a2)</div><div class="line">        Annot[] annots2 = Test.class.getAnnotationsByType(Annot.class);</div><div class="line">        System.out.println(annots2[0]+&quot;,&quot;+annots2[1]); </div><div class="line">        // 输出: @Annot(value=a1),@Annot(value=a2)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注释 Annot 被 @Repeatable( Annots.class ) 注解。Annots 只是一个容器，它包含 Annot 数组, 编译器尽力向程序员隐藏它的存在。通过这样的方式，Test 类可以被 Annot 注解两次。重复注释的类型可以通过 getAnnotationsByType() 方法来返回。</p>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>现今，互联网环境中存在各种各种潜在的威胁，对于 Java 平台来说，安全显得特别重要。为了保证新版本具有更高的安全性，Java 8 在安全性上对许多方面进行了增强，也为此推迟了它的发布日期。下面例举其中几个关于安全性的更新：</p>
<p>支持更强的基于密码的加密算法。基于 AES 的加密算法，例如 PBEWithSHA256AndAES_128 和 PBEWithSHA512AndAES_256，已经被加入进来。</p>
<p>在客户端，TLS1.1 和 TLS1.2 被设为默认启动。并且可以通过新的系统属性包 jdk.tls.client.protocols 来对它进行配置。</p>
<p>Keystore 的增强，包含新的 Keystore 类型 java.security.DomainLoadStoreParameter 和为 Keytool 这个安全钥匙和证书的管理工具添加新的命令行选项-importpassword。同时，添加和更新了一些关于安全性的 API 来支持 KeyStore 的更新。</p>
<p>支持安全的随机数发生器。如果随机数来源于随机性不高的种子，那么那些用随机数来产生密钥或者散列敏感信息的系统就更易受攻击。SecureRandom 这个类的 getInstanceStrong 方法如今可以获取各个平台最强的随机数对象实例，通过这个实例生成像 RSA 私钥和公钥这样具有较高熵的随机数。</p>
<p>JSSE（Java(TM) Secure Socket Extension）服务器端开始支持 SSL/TLS 服务器名字识别 SNI（Server Name Indication）扩展。SNI 扩展目的是 SSL/TLS 协议可以通过 SNI 扩展来识别客户端试图通过握手协议连接的服务器名字。在 Java 7 中只在客户端默认启动 SNI 扩展。如今，在 JSSE 服务器端也开始支持 SNI 扩展了。</p>
<p>安全性比较差的加密方法被默认禁用。默认不支持 DES 相关的 Kerberos 5 加密方法。如果一定要使用这类弱加密方法需要在 krb5.conf 文件中添加 allow_weak_crypto=true。考虑到这类加密方法安全性极差，开发者应该尽量避免使用它。</p>
<h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><p>对Base64的支持最终成了Java 8标准库的一部分，非常简单易用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package com.javacodegeeks.java8.base64;</div><div class="line"> </div><div class="line">import java.nio.charset.StandardCharsets;</div><div class="line">import java.util.Base64;</div><div class="line"> </div><div class="line">public class Base64s &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        final String text = &quot;Base64 finally in Java 8!&quot;;</div><div class="line">         </div><div class="line">        final String encoded = Base64</div><div class="line">        .getEncoder()</div><div class="line">        .encodeToString( text.getBytes( StandardCharsets.UTF_8 ) );</div><div class="line">        System.out.println( encoded );</div><div class="line">         </div><div class="line">        final String decoded = new String(</div><div class="line">        Base64.getDecoder().decode( encoded ),</div><div class="line">        StandardCharsets.UTF_8 );</div><div class="line">        System.out.println( decoded );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>控制台输出的编码和解码的字符串:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">QmFzZTY0IGZpbmFsbHkgaW4gSmF2YSA4IQ==</div><div class="line">Base64 finally in Java 8!</div></pre></td></tr></table></figure></p>
<p>新的Base64API也支持URL和MINE的编码解码。</p>
<p><strong>(Base64.getUrlEncoder() / Base64.getUrlDecoder(), Base64.getMimeEncoder() / Base64.getMimeDecoder())</strong></p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>在新增Stream机制与lambda的基础之上，在java.util.concurrent.ConcurrentHashMap中加入了一些新方法来支持聚集操作。同时也在java.util.concurrent.ForkJoinPool类中加入了一些新方法来支持共有资源池（common pool）。</p>
<p>新增的java.util.concurrent.locks.StampedLock类提供一直基于容量的锁，这种锁有三个模型来控制读写操作（它被认为是不太有名的java.util.concurrent.locks.ReadWriteLock类的替代者）。</p>
<p>在java.util.concurrent.atomic包中还增加了下面这些类：</p>
<ul>
<li>DoubleAccumulator</li>
<li>DoubleAdder</li>
<li>LongAccumulator</li>
<li>LongAdder</li>
</ul>
<h2 id="IO-NIO-的改进"><a href="#IO-NIO-的改进" class="headerlink" title="IO/NIO 的改进"></a>IO/NIO 的改进</h2><p>Java 8 对 IO/NIO 也做了一些改进。主要包括：改进了 java.nio.charset.Charset 的实现，使编码和解码的效率得以提升，也精简了 jre/lib/charsets.jar 包；优化了 String(byte[],*) 构造方法和 String.getBytes() 方法的性能；还增加了一些新的 IO/NIO 方法，使用这些方法可以从文件或者输入流中获取流（java.util.stream.Stream），通过对流的操作，可以简化文本行处理、目录遍历和文件查找。</p>
<p>新增的 API 如下：</p>
<ul>
<li>BufferedReader.line(): 返回文本行的流 Stream<string></string></li>
<li>File.lines(Path, Charset):返回文本行的流 Stream<string></string></li>
<li>File.list(Path): 遍历当前目录下的文件和目录</li>
<li>File.walk(Path, int, FileVisitOption): 遍历某一个目录下的所有文件和指定深度的子目录</li>
<li>File.find(Path, int, BiPredicate, FileVisitOption… ): 查找相应的文件</li>
</ul>
<p>下面就是用流式操作列出当前目录下的所有文件和目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Files.list(new File(&quot;.&quot;).toPath())</div><div class="line">     .forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<h2 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h2><p>Java 8 版本还完善了全球化功能：支持新的 Unicode 6.2.0 标准，新增了日历和本地化的 API，改进了日期时间的管理等。</p>
<p>Java 的日期与时间 API 问题由来已久，Java 8 之前的版本中关于时间、日期及其他时间日期格式化类由于线程安全、重量级、序列化成本高等问题而饱受批评。Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。</p>
<p>新的 java.time 中包含了所有关于<code>时钟（Clock）</code>，<code>本地日期（LocalDate）</code>、<code>本地时间（LocalTime）</code>、<code>本地日期时间（LocalDateTime）</code>、<code>时区（ZonedDateTime）</code>和<code>持续时间（Duration）</code>的类。历史悠久的 Date 类新增了 toInstant() 方法，用于把 Date 转换成新的表示形式。这些新增的本地化时间日期 API 大大简化了了日期时间和本地化的管理。</p>
<h3 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h3><p>时钟提供对当前日期和时间的访问。时钟知道一个时区，可以代替System.currentTimeMillis()来检索当前的毫秒。时间线上的瞬时点也由类Instants表示。Instants可以用来创建遗留java.util.Date对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Clock clock = Clock.systemDefaultZone();</div><div class="line">long millis = clock.millis();</div><div class="line"></div><div class="line">Instant instant = clock.instant();</div><div class="line">Date legacyDate = Date.from(instant);</div></pre></td></tr></table></figure></p>
<h3 id="Timezones"><a href="#Timezones" class="headerlink" title="Timezones"></a>Timezones</h3><p>时区由ZoneId表示。可以通过静态工厂方法轻松地访问它们。时区定义了在instant和本地日期和时间之间转换重要的偏移量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">System.out.println(ZoneId.getAvailableZoneIds());</div><div class="line">// prints all available timezone ids</div><div class="line"></div><div class="line">ZoneId zone1 = ZoneId.of(&quot;Europe/Berlin&quot;);</div><div class="line">ZoneId zone2 = ZoneId.of(&quot;Brazil/East&quot;);</div><div class="line">System.out.println(zone1.getRules());</div><div class="line">System.out.println(zone2.getRules());</div><div class="line"></div><div class="line">// ZoneRules[currentStandardOffset=+01:00]</div><div class="line">// ZoneRules[currentStandardOffset=-03:00]</div></pre></td></tr></table></figure></p>
<h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><p>LocalTime表示没有时区的时间，例如:10pm或17:30:15。下面的示例为上面定义的时区创建了两个本地时间。然后我们比较两种情况，并计算两种时间之间的小时数和分钟数的差值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LocalTime now1 = LocalTime.now(zone1);</div><div class="line">LocalTime now2 = LocalTime.now(zone2);</div><div class="line"></div><div class="line">System.out.println(now1.isBefore(now2));  // false</div><div class="line"></div><div class="line">long hoursBetween = ChronoUnit.HOURS.between(now1, now2);</div><div class="line">long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</div><div class="line"></div><div class="line">System.out.println(hoursBetween);       // -3</div><div class="line">System.out.println(minutesBetween);     // -239</div></pre></td></tr></table></figure></p>
<p>LocalTime提供了各种工厂方法来简化新实例的创建，包括对时间字符串的解析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LocalTime late = LocalTime.of(23, 59, 59);</div><div class="line">System.out.println(late);       // 23:59:59</div><div class="line"></div><div class="line">DateTimeFormatter germanFormatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofLocalizedTime(FormatStyle.SHORT)</div><div class="line">        .withLocale(Locale.GERMAN);</div><div class="line"></div><div class="line">LocalTime leetTime = LocalTime.parse(&quot;13:37&quot;, germanFormatter);</div><div class="line">System.out.println(leetTime);   // 13:37</div></pre></td></tr></table></figure></p>
<h3 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h3><p>LocalDate表示一个不同的日期，如2014-03-11。它是不可变的，和LocalTime完全一样。该示例演示了如何通过添加或减少日、月或年来计算新的日期。请记住，每个操作都返回一个新实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">LocalDate today = LocalDate.now();</div><div class="line">LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);</div><div class="line">LocalDate yesterday = tomorrow.minusDays(2);</div><div class="line"></div><div class="line">LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);</div><div class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</div><div class="line">System.out.println(dayOfWeek);    // FRIDAY</div></pre></td></tr></table></figure></p>
<p>从字符串解析LocalDate就像解析LocalTime一样简单:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">DateTimeFormatter germanFormatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofLocalizedDate(FormatStyle.MEDIUM)</div><div class="line">        .withLocale(Locale.GERMAN);</div><div class="line"></div><div class="line">LocalDate xmas = LocalDate.parse(&quot;24.12.2014&quot;, germanFormatter);</div><div class="line">System.out.println(xmas);   // 2014-12-24</div></pre></td></tr></table></figure></p>
<h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p>LocalDateTime代表日期时间。它将上面几节中所看到的日期和时间合并为一个实例。LocalDateTime是不可变的，与LocalTime和LocalDate类似。我们可以利用方法来从数据时间检索某些字段:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);</div><div class="line"></div><div class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</div><div class="line">System.out.println(dayOfWeek);      // WEDNESDAY</div><div class="line"></div><div class="line">Month month = sylvester.getMonth();</div><div class="line">System.out.println(month);          // DECEMBER</div><div class="line"></div><div class="line">long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</div><div class="line">System.out.println(minuteOfDay);    // 1439</div></pre></td></tr></table></figure></p>
<p>有了一个时区的额外信息，它可以转换为实例。可以很容易地将Instants转换为java.util.Date类型的遗留日期。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Instant instant = sylvester</div><div class="line">        .atZone(ZoneId.systemDefault())</div><div class="line">        .toInstant();</div><div class="line"></div><div class="line">Date legacyDate = Date.from(instant);</div><div class="line">System.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014</div></pre></td></tr></table></figure></p>
<p>格式化日期时间就像格式化日期或时间一样。我们可以创建自定义模式的格式化程序，而不是使用预定义的格式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">DateTimeFormatter formatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofPattern(&quot;MMM dd, yyyy - HH:mm&quot;);</div><div class="line"></div><div class="line">LocalDateTime parsed = LocalDateTime.parse(&quot;Nov 03, 2014 - 07:13&quot;, formatter);</div><div class="line">String string = formatter.format(parsed);</div><div class="line">System.out.println(string);     // Nov 03, 2014 - 07:13</div></pre></td></tr></table></figure></p>
<p>不像java.text.NumberFormat新的DateTimeFormatter是不可变的和线程安全的。</p>
<p>例如，下面是对 Clock, LocalDate，LocalTime, LocalDateTime 的简单应用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">//Clock 时钟</div><div class="line">Clock clock = Clock.systemDefaultZone();//获取系统默认时区 (当前瞬时时间 )</div><div class="line">System.out.println( clock.instant() );//2014-04-12T15:19:29.282Z</div><div class="line">System.out.println( clock.millis() );//1397315969360</div><div class="line"></div><div class="line">// LocalDate: Get the local date and local time</div><div class="line">final LocalDate date = LocalDate.now();</div><div class="line">final LocalDate dateFromClock = LocalDate.now( clock );</div><div class="line">System.out.println( date );//2014-04-12</div><div class="line">System.out.println( dateFromClock );//2014-04-12</div><div class="line"> </div><div class="line">// LocalTime: Get the local date and local time</div><div class="line">final LocalTime time = LocalTime.now();</div><div class="line">final LocalTime timeFromClock = LocalTime.now( clock );</div><div class="line">System.out.println( time );//</div><div class="line">System.out.println( timeFromClock );//11:25:54.568</div><div class="line"></div><div class="line">// LocalDateTime: Get the local date/time</div><div class="line">final LocalDateTime datetime = LocalDateTime.now();</div><div class="line">final LocalDateTime datetimeFromClock = LocalDateTime.now( clock );</div><div class="line">System.out.println( datetime );//2014-04-12T11:37:52.309</div><div class="line">System.out.println( datetimeFromClock );//2014-04-12T15:37:52.309</div><div class="line"></div><div class="line">// 日期格式化：DateTimeFormatter是不可变的，是线程安全的</div><div class="line">DateTimeFormatter formatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofPattern(&quot;MMM dd, yyyy - HH:mm&quot;);</div><div class="line"></div><div class="line">LocalDateTime parsed = LocalDateTime.parse(&quot;Nov 03, 2014 - 07:13&quot;, formatter);</div><div class="line">String string = formatter.format(parsed);</div><div class="line">System.out.println(string);     // Nov 03, 2014 - 07:13</div></pre></td></tr></table></figure></p>
<p>如果您需要一个类持有日期时间和时区信息，可以使用ZonedDateTime，它保存有ISO-8601日期系统的日期和时间，而且有时区信息。让我们看一些例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// Get the zoned date/time</div><div class="line">final ZonedDateTime zonedDatetime = ZonedDateTime.now();</div><div class="line">final ZonedDateTime zonedDatetimeFromClock = ZonedDateTime.now( clock );</div><div class="line">final ZonedDateTime zonedDatetimeFromZone = ZonedDateTime.now( ZoneId.of( &quot;America/Los_Angeles&quot; ) );</div><div class="line"> </div><div class="line">System.out.println( zonedDatetime );</div><div class="line">System.out.println( zonedDatetimeFromClock );</div><div class="line">System.out.println( zonedDatetimeFromZone );</div></pre></td></tr></table></figure></p>
<p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2014-04-12T11:47:01.017-04:00[America/New_York]</div><div class="line">2014-04-12T15:47:01.017Z</div><div class="line">2014-04-12T08:47:01.017-07:00[America/Los_Angeles]</div></pre></td></tr></table></figure></p>
<p>最后让我们看看Duration类，Duration持有的时间精确到纳秒。它让我们很容易计算两个日期中间的差异。让我们来看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// Get duration between two dates</div><div class="line">final LocalDateTime from = LocalDateTime.of( 2014, Month.APRIL, 16, 0, 0, 0 );</div><div class="line">final LocalDateTime to = LocalDateTime.of( 2015, Month.APRIL, 16, 23, 59, 59 );</div><div class="line"> </div><div class="line">final Duration duration = Duration.between( from, to );</div><div class="line">System.out.println( &quot;Duration in days: &quot; + duration.toDays() );</div><div class="line">System.out.println( &quot;Duration in hours: &quot; + duration.toHours() );</div></pre></td></tr></table></figure></p>
<p>上面的例子计算了两个日期（2014年4月16日和2014年5月16日）之间的持续时间（基于天数和小时）输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Duration in days: 365</div><div class="line">Duration in hours: 8783</div></pre></td></tr></table></figure></p>
<h2 id="Nashorn-javascript引擎"><a href="#Nashorn-javascript引擎" class="headerlink" title="Nashorn javascript引擎"></a>Nashorn javascript引擎</h2><p>Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。Nashorn javascript引擎只是javax.script.ScriptEngine另一个实现，而且规则也一样，允许Java和JavaScript互相操作。这里有个小例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ScriptEngineManager manager = new ScriptEngineManager();</div><div class="line">ScriptEngine engine = manager.getEngineByName( &quot;JavaScript&quot; );</div><div class="line"> </div><div class="line">System.out.println( engine.getClass().getName() );//jdk.nashorn.api.scripting.NashornScriptEngine</div><div class="line">System.out.println( &quot;Result:&quot; + engine.eval( &quot;function f() &#123; return 1; &#125;; f() + 1;&quot; ) );//Result: 2</div></pre></td></tr></table></figure></p>
<h2 id="并行数组"><a href="#并行数组" class="headerlink" title="并行数组"></a>并行数组</h2><p>Java 8新增加了很多方法支持并行的数组处理。最重要的大概是parallelSort()这个方法显著地使排序在多核计算机上速度加快。下面的小例子演示了这个新的方法（parallelXXX）的行为。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.javacodegeeks.java8.parallel.arrays;</div><div class="line"> </div><div class="line">import java.util.Arrays;</div><div class="line">import java.util.concurrent.ThreadLocalRandom;</div><div class="line"> </div><div class="line">public class ParallelArrays &#123;</div><div class="line">    public static void main( String[] args ) &#123;</div><div class="line">        long[] arrayOfLong = new long [ 20000 ];        </div><div class="line"> </div><div class="line">        Arrays.parallelSetAll( arrayOfLong,</div><div class="line">            index -&gt; ThreadLocalRandom.current().nextInt( 1000000 ) );</div><div class="line">        Arrays.stream( arrayOfLong ).limit( 10 ).forEach(</div><div class="line">            i -&gt; System.out.print( i + &quot; &quot; ) );</div><div class="line">        System.out.println();</div><div class="line"> </div><div class="line">        Arrays.parallelSort( arrayOfLong );</div><div class="line">        Arrays.stream( arrayOfLong ).limit( 10 ).forEach(</div><div class="line">            i -&gt; System.out.print( i + &quot; &quot; ) );</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这一小段代码使用parallelSetAll() t方法填充这个长度是2000的数组，然后使用parallelSort() 排序。这个程序输出了排序前和排序后的10个数字来验证数组真的已经被排序了。示例可能的输出如下（请注意这些数字是随机产生的）</p>
<p>Unsorted: 591217 891976 443951 424479 766825 351964 242997 642839 119108 552378<br>Sorted: 39 220 263 268 325 607 655 678 723 793</p>
<h2 id="新的工具"><a href="#新的工具" class="headerlink" title="新的工具"></a>新的工具</h2><h3 id="Nashorn引擎：jjs"><a href="#Nashorn引擎：jjs" class="headerlink" title="Nashorn引擎：jjs"></a>Nashorn引擎：jjs</h3><p>jjs是个基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。例如，我们创建一个具有如下内容的func.js文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function f() &#123;</div><div class="line">    return 1;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">print( f() + 1 );</div></pre></td></tr></table></figure></p>
<p>我们可以把这个文件作为参数传递给jjs使得这个文件可以在命令行中执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jjs func.js   //结果输出：2</div></pre></td></tr></table></figure></p>
<h3 id="类依赖分析工具：jdeps"><a href="#类依赖分析工具：jdeps" class="headerlink" title="类依赖分析工具：jdeps"></a>类依赖分析工具：jdeps</h3><p>Jdeps是一个功能强大的命令行工具，它可以帮我们显示出包层级或者类层级java类文件的依赖关系。它接受class文件、目录、jar文件作为输入，默认情况下，jdeps会输出到控制台。</p>
<p>例如分析Notepad.jar：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">$ jdeps demo/jfc/Notepad/Notepad.jar</div><div class="line"> </div><div class="line">demo/jfc/Notepad/Notepad.jar -&gt; /usr/java/jre/lib/rt.jar</div><div class="line">   &lt;unnamed&gt; (Notepad.jar)</div><div class="line">      -&gt; java.awt                                           </div><div class="line">      -&gt; java.awt.event                                     </div><div class="line">      -&gt; java.beans                                         </div><div class="line">      -&gt; java.io                                            </div><div class="line">      -&gt; java.lang                                          </div><div class="line">      -&gt; java.net                                           </div><div class="line">      -&gt; java.util                                          </div><div class="line">      -&gt; java.util.logging                                  </div><div class="line">      -&gt; javax.swing                                        </div><div class="line">      -&gt; javax.swing.border                                 </div><div class="line">      -&gt; javax.swing.event                                  </div><div class="line">      -&gt; javax.swing.text                                   </div><div class="line">      -&gt; javax.swing.tree                                   </div><div class="line">      -&gt; javax.swing.undo</div></pre></td></tr></table></figure></p>
<p>更多的详细信息请参考<a href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/jdeps.html" target="_blank" rel="external">官方文档</a>。</p>
<h2 id="JVM的新特性"><a href="#JVM的新特性" class="headerlink" title="JVM的新特性"></a>JVM的新特性</h2><p>JVM内存永久区已经被metaspace替换（JEP 122）。JVM参数 -XX:PermSize 和 –XX:MaxPermSize被XX:MetaSpaceSize 和 -XX:MaxMetaspaceSize代替。</p>
<h2 id="Java-8-开发环境"><a href="#Java-8-开发环境" class="headerlink" title="Java 8 开发环境"></a>Java 8 开发环境</h2><p>随着 Java 8 正式发布，许多 IDE 也开始提供对 Java 8 的支持。Eclipse 是 Java 开发人员最为常用集成开发环境，在最新的 Eclipse Kepler 4.3.2 版本中已经默认增加了对 Java 8 的支持。要想在 Eclipse Kepler 的前期版本中添加对 Java 8 的支持，可以通过下面步骤来完成：</p>
<ol>
<li><p>选择 “Help &gt; Eclipse Marketplace…”。</p>
</li>
<li><p>在搜索框中输入 “Java 8 Kepler”。</p>
</li>
<li><p>点击安装 Java 8 support for Eclipse Kepler SR2。</p>
</li>
</ol>
<p>图 1. 安装 Java 8 support for Eclipse Kepler SR2<br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-jdk8newfeature/img001.png" alt="image"><br>接下来，就可以开启 Java 8 编程之旅。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>Java 8 正式版是一个有重大改变的版本，该版本对 Java 做了重大改进。本文通过文字描述及代码实例对新版本中主要新特性做了介绍：函数式接口、Lambda 表达式、集合的流式操作、注解、安全性、IO/NIO、全球化功能。除了文中介绍的这些重要的新功能之外，Java 8 还对 java 工具包 JDBC、Java DB、JavaFX 等方面都有许多改进和增强。这些新增功能简化了开发，提升了代码可读性，增强了代码的安全性，提高了代码的执行效率，为开发者带来了全新的 Java 开发体验，从而推动了 Java 这个平台的前进。</p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="http://winterbe.com/posts/2014/03/16/java-8-tutorial/" target="_blank" rel="external">Java 8 Tutorial</a></p>
<p>Part 1: <a href="http://winterbe.com/posts/2015/04/07/java8-concurrency-tutorial-thread-executor-examples/" target="_blank" rel="external">Threads and Executors</a><br>Part 2: <a href="http://winterbe.com/posts/2015/04/30/java8-concurrency-tutorial-synchronized-locks-examples/" target="_blank" rel="external">Synchronization and Locks</a><br>Part 3: <a href="http://winterbe.com/posts/2015/05/22/java8-concurrency-tutorial-atomic-concurrent-map-examples/" target="_blank" rel="external">Atomic Variables and ConcurrentMap</a>  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/基础/java8新特性/" data-id="cjfvvphkk005qm9fy127ipogf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Eclipse/">Eclipse</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Github/">Github</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Cookie/">Cookie</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JAXB/">JAXB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JavaMail/">JavaMail</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/基础/">基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/数据类型/">数据类型</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/日记/">日记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/时间日期/">时间日期</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/线程/">线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/网络NIO/">网络NIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/队列/">队列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/集合/">集合</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Application-Event/">Application Event</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/JPA/">JPA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Security/">Security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Spring-Boot/">Spring Boot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Spring-Session/">Spring Session</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Task/">Task</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-MVC/">spring MVC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-data-redis/">spring data redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/基础/">基础</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/">前端技术相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/forever/">forever</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/javascript/">javascript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库相关/">数据库相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据库相关/mysql/">mysql</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/">服务器相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hessian/">Hessian</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hudson-Jenkins/">Hudson & Jenkins</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Memcached/">Memcached</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Nginx/">Nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Tomcat/">Tomcat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/red5/">red5</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/resin/">resin</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/正则表达式/">正则表达式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/12/服务器相关/Tomcat/TOMCAT原理详解及请求过程/">TOMCAT原理详解及请求过程</a>
          </li>
        
          <li>
            <a href="/2018/04/12/网络/HTTPS工作原理/">HTTPS工作原理</a>
          </li>
        
          <li>
            <a href="/2018/04/12/网络/三次握手和四次挥手/">三次握手和四次挥手</a>
          </li>
        
          <li>
            <a href="/2018/04/12/服务器相关/Tomcat/内存分配/">内存分配</a>
          </li>
        
          <li>
            <a href="/2018/04/12/服务器相关/Tomcat/Tomcat整体架构浅析/">Tomcat整体架构浅析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 LeoChan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>