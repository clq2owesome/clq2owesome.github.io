<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LeoChan&#39;s 个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="描述啊">
<meta property="og:type" content="website">
<meta property="og:title" content="LeoChan&#39;s 个人博客">
<meta property="og:url" content="https://clq2owesome.github.io/index.html">
<meta property="og:site_name" content="LeoChan&#39;s 个人博客">
<meta property="og:description" content="描述啊">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeoChan&#39;s 个人博客">
<meta name="twitter:description" content="描述啊">
  
    <link rel="alternate" href="/atom.xml" title="LeoChan&#39;s 个人博客" type="application/atom+xml">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  

</head>

<body>
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class="active"
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">LeoChan&#39;s 个人博客</h1>
  
    <p class="lead blog-description">技术都是通用的，重要的是是否具有自主解决问题的能力！</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-Java/基础/java三大特性" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/28/Java/基础/java三大特性/">java三大特性</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/28/Java/基础/java三大特性/" class="article-date"><time datetime="2017-08-28T02:09:45.000Z" itemprop="datePublished">2017-08-28</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。    </p>
<p>指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。    </p>
<p>多态有两种表现形式：编译时多态（方法重载）和运行时多态（方法重写）</p>
<p>Java实现多态有三个必要条件（运行时多态）：继承、重写、向上转型（子类引用指向父类）。</p>
<ul>
<li>继承：在多态中必须存在有继承关系的子类和父类。</li>
<li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li>
<li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</li>
</ul>
<p>方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。</p>
<p>使用封装有三大好处：</p>
<ol>
<li>良好的封装能够减少耦合</li>
<li>类内部的结构可以自由修改，模块之间互不干扰</li>
<li>隐藏信息，对外只提供接口，提高安全性</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>通过继承实现代码复用。Java中所有的类都是通过直接或间接地继承java.lang.Object类得到的。继承而得到的类称为子类，被继承的类称为父类。子类不能继承父类中访问权限为private的成员变量和方法。子类可以重写父类的方法，及命名与父类同名的成员变量。但Java不支持多重继承，即一个类从多个超类派生的能力。在开发中尽量减少继承关系，这样做是为了把程序的耦合度降低。  </p>
<h3 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h3><ol>
<li><p>构造函数<br>当子类继承一个父类时，构造子类时需要调用父类的构造函数，存在三种情况:<br>（1），父类无构造函数或者一个无参数构造函数，子类若无构造函数或者有无参数构造函数，子类构造函数中不需要显式调用父类的构造函数，系统会自动在调用子类构造函数前调用父类的构造函数<br>（2），父类只有有参数构造函数，子类在构造方法中必须要显示调用父类的构造函数，否则编译出错<br>（3），父类既有无参数构造函数，也有有参构造函数，子类可以不在构造方法中调用父类的构造函数，这时使用的是父类的无参数构造函数    </p>
</li>
<li><p>方法覆盖<br>（1）子类覆盖父类的方法，在jdk1.5后，参数返回类可以是父类方法返回类的子类<br>（2）子类覆盖父类方法，可以修改方法作用域修饰符，但只能把方法的作用域放大，而不能把public修改为private<br>(3) 子类方法能够访问父类的protected作用域成员，不能够访问默认的作用域成员<br>（4）子类的静态方法不能隐藏同名的父类实例方法<br>（5）继承的方法具有多态性    </p>
</li>
<li><p>成员覆盖<br>（1）当子类覆盖父类的成员变量时，父类方法使用的是父类的成员变量，子类方法使用的是子类的成员变量    </p>
</li>
</ol>
<h3 id="类的继承知识点"><a href="#类的继承知识点" class="headerlink" title="类的继承知识点"></a>类的继承知识点</h3><ol>
<li>java不支持多重继承，也就是说子类至多只能有一个父类</li>
<li>子类继承了其父类中不是私有的成员变量和成员方法，作为自己的成员变量和方法</li>
<li>子类中定义的成员变量和父类中定义的成员变量相同时，则父类中的成员变量不能被继承</li>
<li>子类中定义的成员方法，并且这个成员方法的名字，返回类型，及参数个数和类型与父类的某个成员方法完全相同，则父类的成员方法不能被继承。</li>
</ol>
<h3 id="谨慎继承"><a href="#谨慎继承" class="headerlink" title="谨慎继承"></a>谨慎继承</h3><p>首先我们需要明确，继承存在如下缺陷：</p>
<ol>
<li>父类变，子类就必须变。</li>
<li>继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。</li>
<li>继承是一种强耦合关系。</li>
</ol>
<p>所以说当我们使用继承的时候，我们需要确信使用继承确实是有效可行的办法。那么到底要不要使用继承呢？《Think in java》中提供了解决办法：问一问自己是否需要从子类向父类进行向上转型。如果必须向上转型，则继承是必要的，但是如果不需要，则应当好好考虑自己是否需要继承。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/28/Java/基础/java三大特性/" data-id="cj6vztsba002toabla7dlwc65" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/基础/Filter过滤器" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/28/Java/基础/Filter过滤器/">Filter过滤器</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/28/Java/基础/Filter过滤器/" class="article-date"><time datetime="2017-08-28T02:09:45.000Z" itemprop="datePublished">2017-08-28</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Filter也称之为过滤器，它是Servlet技术中最激动人心的技术之一，WEB开发人员通过Filter技术，对web服务器管理的所有web资源：例如Jsp,Servlet,静态图片文件或静态html文件等进行拦截，从而实现一些特殊的功能。例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。  </p>
<p>Servlet API中提供了一个Filter接口，开发web应用时，如果编写的Java类实现了这个接口，则把这个java类称之为过滤器Filter。通过Filter技术，开发人员可以实现用户在访问某个目标资源之前，对访问的请求和响应进行拦截，Filter接口源代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public abstract interface Filter&#123;  </div><div class="line">    public abstract void init(FilterConfig paramFilterConfig) throws ServletException;  </div><div class="line">    public abstract void doFilter(ServletRequest paramServletRequest, ServletResponse paramServletResponse, FilterChain   </div><div class="line">        paramFilterChain) throws IOException, ServletException;  </div><div class="line">    public abstract void destroy();  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Servlet API中提供了一个Filter接口，开发web应用时，如果编写的Java类实现了这个接口，则把这个java类称之为过滤器Filter。通过Filter技术，开发人员可以实现用户在访问某个目标资源之前，对访问的请求和响应进行拦截，如下所示：<br><img src="http://images2015.cnblogs.com/blog/892393/201604/892393-20160425211729548-1717874729.png" alt="image"><br>filter是如何实现过滤的：<br>Filter接口中有一个doFilter方法，当我们编写好Filter，并配置对哪个web资源进行拦截后，WEB服务器每次在调用web资源的service方法之前，都会先调用一下filter的doFilter方法，因此，在该方法内编写代码可达到如下目的：</p>
<ol>
<li>调用目标资源之前，让一段代码执行。</li>
<li>是否调用目标资源（即是否让用户访问web资源）。</li>
<li>调用目标资源之后，让一段代码执行。</li>
</ol>
<p>web服务器在调用doFilter方法时，会传递一个filterChain对象进来，filterChain对象是filter接口中最重要的一个对 象，它也提供了一个doFilter方法，开发人员可以根据需求决定是否调用此方法，调用该方法，则web服务器就会调用web资源的service方 法，即web资源就会被访问，否则web资源不会被访问。</p>
<h4 id="Filter链"><a href="#Filter链" class="headerlink" title="Filter链"></a>Filter链</h4><p>在一个web应用中，可以开发编写多个Filter，这些Filter组合起来称之为一个Filter链。web服务器根据Filter在web.xml文件中的注册顺序，决定先调用哪个Filter，当第一个Filter的doFilter方法被调用时，web服务器会创建一个代表Filter链的FilterChain对象传递给该方法。在doFilter方法中，开发人员如果调用了FilterChain对象的doFilter方法，则web服务器会检查FilterChain对象中是否还有filter，如果有，则调用第2个filter，如果没有，则调用目标资源。</p>
<h2 id="Filter的生命周期"><a href="#Filter的生命周期" class="headerlink" title="Filter的生命周期"></a>Filter的生命周期</h2><h4 id="Filter的创建"><a href="#Filter的创建" class="headerlink" title="Filter的创建"></a>Filter的创建</h4><p>Filter的创建和销毁由web服务器负责。 web应用程序启动时，web服务器将创建Filter的实例对象，并调用其init方法，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作，filter对象只会创建一次，init方法也只会执行一次。通过init方法的参数，可获得代表当前filter配置信息的FilterConfig对象。</p>
<h4 id="Filter的销毁"><a href="#Filter的销毁" class="headerlink" title="Filter的销毁"></a>Filter的销毁</h4><p>web容器调用destroy方法销毁Filter。destroy方法在Filter的生命周期中仅执行一次。在destroy方法中，可以释放过滤器使用的资源。</p>
<h4 id="FilterConfig接口"><a href="#FilterConfig接口" class="headerlink" title="FilterConfig接口"></a>FilterConfig接口</h4><p>用户在配置filter时，可以使用<init-param>为filter配置一些初始化参数，当web容器实例化Filter对象，调用其init方法时，会把封装了filter初始化参数的filterConfig对象传递进来。因此开发人员在编写filter时，通过filterConfig对象的方法，就可获得：</init-param></p>
<ul>
<li>String getFilterName()：得到filter的名称。</li>
<li>String getInitParameter(String name)： 返回在部署描述中指定名称的初始化参数的值。如果不存在返回null.</li>
<li>Enumeration getInitParameterNames()：返回过滤器的所有初始化参数的名字的枚举集合。</li>
<li>public ServletContext getServletContext()：返回Servlet上下文对象的引用。</li>
</ul>
<h2 id="Filter配置"><a href="#Filter配置" class="headerlink" title="Filter配置"></a>Filter配置</h2><h4 id="Filter实现"><a href="#Filter实现" class="headerlink" title="Filter实现"></a>Filter实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class EncodingFilter implements Filter &#123;  </div><div class="line">    private String encoding;  </div><div class="line">    private Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();  </div><div class="line">    // 项目结束时就已经进行销毁  </div><div class="line">    public void destroy() &#123;  </div><div class="line">        //进行资源回收等，只调用一次</div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    public void doFilter(ServletRequest req, ServletResponse resp,  </div><div class="line">            FilterChain chain) throws IOException, ServletException &#123;  </div><div class="line">        //调用资源前的逻辑处理</div><div class="line">        ...</div><div class="line">        </div><div class="line">        //调用下一个过滤器，如果没有过滤器，则调用真正的service方法</div><div class="line">        chain.doFilter(req, resp);   </div><div class="line">        </div><div class="line">        //调用资源后的逻辑处理</div><div class="line">        ...</div><div class="line">    &#125;  </div><div class="line">   </div><div class="line">    // 项目启动时就已经进行读取  </div><div class="line">    public void init(FilterConfig config) throws ServletException &#123;  </div><div class="line">        //初始化资源，在web容器启动时只调用一次</div><div class="line">    &#125;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h4 id="注册Filter"><a href="#注册Filter" class="headerlink" title="注册Filter"></a>注册Filter</h4><p>开发好Filter之后，需要在web.xml文件中进行注册，这样才能够被web服务器调用。在web.xml文件中注册Filter范例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;filter&gt;  </div><div class="line">    &lt;description&gt;过滤器描述&lt;/description&gt;  </div><div class="line">    &lt;filter-name&gt;过滤器名称&lt;/filter-name&gt;  </div><div class="line">    &lt;filter-class&gt;过滤器地址&lt;/filter-class&gt;  </div><div class="line">    &lt;!--配置FilterTest过滤器的初始化参数--&gt;  </div><div class="line">    &lt;init-param&gt;  </div><div class="line">        &lt;description&gt;配置过滤器的初始化参数&lt;/description&gt;  </div><div class="line">        &lt;param-name&gt;name&lt;/param-name&gt;  </div><div class="line">        &lt;param-value&gt;gacl&lt;/param-value&gt;  </div><div class="line">    &lt;/init-param&gt;  </div><div class="line">    &lt;init-param&gt;  </div><div class="line">        &lt;description&gt;配置FilterTest过滤器的初始化参数&lt;/description&gt;  </div><div class="line">        &lt;param-name&gt;like&lt;/param-name&gt;  </div><div class="line">        &lt;param-value&gt;java&lt;/param-value&gt;  </div><div class="line">    &lt;/init-param&gt;  </div><div class="line">&lt;/filter&gt;</div></pre></td></tr></table></figure></p>
<ul>
<li><description>用于添加描述信息，该元素的内容可为空，<description>可以不配置。</description></description></li>
<li><filter-name>用于为过滤器指定一个名字，该元素的内容不能为空。</filter-name></li>
<li><filter-class>元素用于指定过滤器的完整的限定类名。</filter-class></li>
<li><init-param>元素用于为过滤器指定初始化参数，它的子元素<param-name>指定参数的名字，<param-value>指定参数的值。</param-value></param-name></init-param></li>
</ul>
<p>在过滤器中，<br>可以使用FilterConfig接口对象来访问初始化参数。如果过滤器不需要指定初始化参数，那么<init-param>元素可以不配置。</init-param></p>
<h4 id="映射Filter"><a href="#映射Filter" class="headerlink" title="映射Filter"></a>映射Filter</h4><p>在web.xml文件中注册了Filter之后，还要在web.xml文件中映射Filter<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;!--映射过滤器--&gt;</div><div class="line">&lt;filter-mapping&gt;</div><div class="line">  &lt;filter-name&gt;FilterTest&lt;/filter-name&gt;</div><div class="line">  &lt;!--“/*”表示拦截所有的请求 --&gt;</div><div class="line">  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">&lt;/filter-mapping&gt;</div></pre></td></tr></table></figure></p>
<ul>
<li><filter-mapping>元素用于设置一个 Filter 所负责拦截的资源。一个Filter拦截的资源可通过两种方式来指定：Servlet 名称和资源访问的请求路径</filter-mapping></li>
<li><filter-name>子元素用于设置filter的注册名称。该值必须是在<filter>元素中声明过的过滤器的名字</filter></filter-name></li>
<li><url-pattern>设置 filter 所拦截的请求路径(过滤器关联的URL样式)</url-pattern></li>
<li><servlet-name>指定过滤器所拦截的Servlet名称。</servlet-name></li>
<li><p><dispatcher>指定过滤器所拦截的资源被 Servlet 容器调用的方式，可以是<code>REQUEST</code>,<code>INCLUDE</code>,<code>FORWARD</code>和<code>ERROR</code>之一，<strong>默认REQUEST</strong>。用户可以设置多个<dispatcher> 子元素用来指定 Filter 对资源的多种调用方式进行拦截。如下：</dispatcher></dispatcher></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;filter-mapping&gt;</div><div class="line">    &lt;filter-name&gt;testFilter&lt;/filter-name&gt;</div><div class="line">    &lt;url-pattern&gt;/index.jsp&lt;/url-pattern&gt;</div><div class="line">    &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;</div><div class="line">    &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;</div><div class="line">&lt;/filter-mapping&gt;</div></pre></td></tr></table></figure>
<p>  <dispatcher> 子元素可以设置的值及其意义：</dispatcher></p>
<ul>
<li>REQUEST：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过RequestDispatcher的include()或forward()方法访问<br>时，那么该过滤器就不会被调用。</li>
<li>INCLUDE：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。</li>
<li>FORWARD：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。</li>
<li>ERROR：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。</li>
</ul>
</li>
</ul>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/28/Java/基础/Filter过滤器/" data-id="cj6vztsb5002hoabljj48fv7s" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/基础/泛型" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/27/Java/基础/泛型/">泛型</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/27/Java/基础/泛型/" class="article-date"><time datetime="2017-08-27T02:09:45.000Z" itemprop="datePublished">2017-08-27</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>泛型，即“参数化类型”</strong>。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p>
<p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，<strong>这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法</strong>。</p>
<h4 id="类型的好处"><a href="#类型的好处" class="headerlink" title="类型的好处"></a>类型的好处</h4><ul>
<li><strong>类型安全</strong>。泛型的主要目标是提高Java程序的类型安全。通过知道使用泛型定义的变量的类型限制，编译器可以在一个高得多的程度上验证类型假设。没有泛型，这些假设就只存在于程序员的头脑中（或者如果幸运的话，还存在于代码注释中）。通过在变量声明中捕获这一附加的类型信息，泛型允许编译器实施这些附加的类型约束。类型错误现在就可以在编译时被捕获了，而不是在运行时当作 ClassCastException 展示出来。将类型检查从运行时挪到编译时有助于您更容易找到错误，并可提高程序的可靠性。</li>
<li><strong>消除强制类型转换</strong>。泛型的一个附带好处是，消除源代码中的许多强制类型转换。这使得代码更加可读，并且减少了出错机会。</li>
</ul>
<h2 id="泛型的产生"><a href="#泛型的产生" class="headerlink" title="泛型的产生"></a>泛型的产生</h2><p>一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">List arrayList = new ArrayList();</div><div class="line">arrayList.add(&quot;aaaa&quot;);</div><div class="line">arrayList.add(100);</div><div class="line"></div><div class="line">for(int i = 0; i&lt; arrayList.size();i++)&#123;</div><div class="line">    String item = (String)arrayList.get(i);</div><div class="line">    Log.d(&quot;泛型测试&quot;,&quot;item = &quot; + item);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>毫无疑问，程序的运行结果会以崩溃结束：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</div></pre></td></tr></table></figure></p>
<p>ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。    </p>
<p>我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();</div><div class="line">...</div><div class="line">//arrayList.add(100); 在编译阶段，编译器就会报错</div></pre></td></tr></table></figure></p>
<h2 id="泛型的特性"><a href="#泛型的特性" class="headerlink" title="泛型的特性"></a>泛型的特性</h2><p><strong>泛型只在编译阶段有效</strong>。看下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;();</div><div class="line">List&lt;Integer&gt; integerArrayList = new ArrayList&lt;Integer&gt;();</div><div class="line"></div><div class="line">Class classStringArrayList = stringArrayList.getClass();</div><div class="line">Class classIntegerArrayList = integerArrayList.getClass();</div><div class="line"></div><div class="line">if(classStringArrayList.equals(classIntegerArrayList))&#123;</div><div class="line">    Log.d(&quot;泛型测试&quot;,&quot;类型相同&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：D/泛型测试: 类型相同。    </p>
<p>通过上面的例子可以证明，<strong>在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段</strong>。  </p>
<p>对此总结成一句话：<strong>泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</strong></p>
<h2 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h2><p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法</p>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。  </p>
<p>一个最普通的泛型类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</div><div class="line">//在实例化泛型类时，必须指定T的具体类型</div><div class="line">public class Generic&lt;T&gt;&#123; </div><div class="line">    //key这个成员变量的类型为T,T的类型由外部指定  </div><div class="line">    private T key;</div><div class="line"></div><div class="line">    public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定</div><div class="line">        this.key = key;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定</div><div class="line">        return key;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型</div><div class="line">//传入的实参类型需与泛型的类型参数类型相同，即为Integer.</div><div class="line">Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456);</div><div class="line"></div><div class="line">//传入的实参类型需与泛型的类型参数类型相同，即为String.</div><div class="line">Generic&lt;String&gt; genericString = new Generic&lt;String&gt;(&quot;key_vlaue&quot;);</div><div class="line">Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericInteger.getKey());</div><div class="line">Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericString.getKey());</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">泛型测试: key is 123456</div><div class="line">泛型测试: key is key_vlaue</div></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>泛型的类型参数只能是类类型，不能是简单类型。</li>
<li>不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if(ex_num instanceof Generic&lt;Number&gt;)&#123;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//定义一个泛型接口</div><div class="line">public interface Generator&lt;T&gt; &#123;</div><div class="line">    public T next();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当实现泛型接口的类，未传入泛型实参时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</div><div class="line"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</div><div class="line"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;</div><div class="line"> */</div><div class="line">class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</div><div class="line">    @Override</div><div class="line">    public T next() &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当实现泛型接口的类，传入泛型实参时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 传入泛型实参时：</div><div class="line"> * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</div><div class="line"> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</div><div class="line"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</div><div class="line"> * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</div><div class="line"> */</div><div class="line">public class FruitGenerator implements Generator&lt;String&gt; &#123;</div><div class="line"></div><div class="line">    private String[] fruits = new String[]&#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;&#125;;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String next() &#123;</div><div class="line">        Random rand = new Random();</div><div class="line">        return fruits[rand.nextInt(3)];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><p>我们知道Ingeter是Number的一个子类，同时在特性章节中我们也验证过Generic<ingeter>与Generic<number>实际上是相同的一种基本类型。那么问题来了，在使用Generic<number>作为形参的方法中，能否使用Generic<ingeter>的实例传入呢？在逻辑上类似于Generic<number>和Generic<ingeter>是否可以看成具有父子关系的泛型类型呢？    </ingeter></number></ingeter></number></number></ingeter></p>
<p>为了弄清楚这个问题，我们使用Generic<t>这个泛型类继续看下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void showKeyValue1(Generic&lt;Number&gt; obj)&#123;</div><div class="line">    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</div><div class="line">&#125;</div></pre></td></tr></table></figure></t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Generic&lt;Integer&gt; gInteger = new Generic&lt;Integer&gt;(123);</div><div class="line">Generic&lt;Number&gt; gNumber = new Generic&lt;Number&gt;(456);</div><div class="line"></div><div class="line">showKeyValue(gNumber);</div><div class="line"></div><div class="line">// showKeyValue这个方法编译器会为我们报错：Generic&lt;java.lang.Integer&gt; </div><div class="line">// cannot be applied to Generic&lt;java.lang.Number&gt;</div><div class="line">// showKeyValue(gInteger);</div></pre></td></tr></table></figure>
<p>通过提示信息我们可以看到Generic<integer>不能被看作为`Generic<number>的子类。由此可以看出:<strong>同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的</strong>。  </number></integer></p>
<p>回到上面的例子，如何解决上面的问题？总不能为了定义一个新的方法来处理Generic<integer>类型的类，这显然与java中的多台理念相违背。因此我们需要一个在逻辑上可以表示同时是Generic<integer>和Generic<number>父类的引用类型。由此类型通配符应运而生。 </number></integer></integer></p>
<p>我们可以将上面的方法改一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void showKeyValue1(Generic&lt;?&gt; obj)&#123;</div><div class="line">    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>类型通配符一般是使用？代替具体的类型实参，注意了，此处’？’是类型实参，而不是类型形参 。再直白点的意思就是，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。</p>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>在java中,泛型类的定义非常简单，但是泛型方法就比较复杂了。<br>尤其是我们见到的大多数泛型类中的成员方法也都使用了泛型，有的甚至泛型类中也包含着泛型方法，这样在初学者中非常容易将泛型方法理解错了。    </p>
<p><strong>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 </strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 泛型方法的基本介绍</div><div class="line"> * @param tClass 传入的泛型实参</div><div class="line"> * @return T 返回值为T类型</div><div class="line"> * 说明：</div><div class="line"> *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</div><div class="line"> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</div><div class="line"> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</div><div class="line"> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</div><div class="line"> */</div><div class="line">public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException ,</div><div class="line">  IllegalAccessException&#123;</div><div class="line">        T instance = tClass.newInstance();</div><div class="line">        return instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="泛型方法的基本用法"><a href="#泛型方法的基本用法" class="headerlink" title="泛型方法的基本用法"></a>泛型方法的基本用法</h4><p>光看上面的例子有的同学可能依然会非常迷糊，我们再通过一个例子，把泛型方法再总结一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">public class GenericTest &#123;</div><div class="line">   //这个类是个泛型类，在上面已经介绍过</div><div class="line">   public class Generic&lt;T&gt;&#123;     </div><div class="line">        private T key;</div><div class="line"></div><div class="line">        public Generic(T key) &#123;</div><div class="line">            this.key = key;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。</div><div class="line">        //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</div><div class="line">        //所以在这个方法中才可以继续使用 T 这个泛型。</div><div class="line">        public T getKey()&#123;</div><div class="line">            return key;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息&quot;cannot reslove symbol E&quot;</div><div class="line">         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。</div><div class="line">        public E setKey(E key)&#123;</div><div class="line">             this.key = keu</div><div class="line">        &#125;</div><div class="line">        */</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** </div><div class="line">     * 这才是一个真正的泛型方法。</div><div class="line">     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T</div><div class="line">     * 这个T可以出现在这个泛型方法的任意位置.</div><div class="line">     * 泛型的数量也可以为任意多个 </div><div class="line">     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</div><div class="line">     *        ...</div><div class="line">     *        &#125;</div><div class="line">     */</div><div class="line">    public &lt;T&gt; T showKeyName(Generic&lt;T&gt; container)&#123;</div><div class="line">        System.out.println(&quot;container key :&quot; + container.getKey());</div><div class="line">        //当然这个例子举的不太合适，只是为了说明泛型方法的特性。</div><div class="line">        T test = container.getKey();</div><div class="line">        return test;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。</div><div class="line">    public void showKeyValue1(Generic&lt;Number&gt; obj)&#123;</div><div class="line">        Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?</div><div class="line">    //同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类</div><div class="line">    public void showKeyValue2(Generic&lt;?&gt; obj)&#123;</div><div class="line">        Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     /**</div><div class="line">     * 这个方法是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &apos;E&apos; &quot;</div><div class="line">     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。</div><div class="line">     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。</div><div class="line">    public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;</div><div class="line">        ...</div><div class="line">    &#125;  </div><div class="line">    */</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 这个方法也是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &apos;T&apos; &quot;</div><div class="line">     * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。</div><div class="line">     * 所以这也不是一个正确的泛型方法声明。</div><div class="line">    public void showkey(T genericObj)&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    */</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="类中的泛型方法"><a href="#类中的泛型方法" class="headerlink" title="类中的泛型方法"></a>类中的泛型方法</h4><p>当然这并不是泛型方法的全部，泛型方法可以出现杂任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，我们再通过一个例子看一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">public class GenericFruit &#123;</div><div class="line">    class Fruit&#123;</div><div class="line">        @Override</div><div class="line">        public String toString() &#123;</div><div class="line">            return &quot;fruit&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class Apple extends Fruit&#123;</div><div class="line">        @Override</div><div class="line">        public String toString() &#123;</div><div class="line">            return &quot;apple&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class Person&#123;</div><div class="line">        @Override</div><div class="line">        public String toString() &#123;</div><div class="line">            return &quot;Person&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class GenerateTest&lt;T&gt;&#123;</div><div class="line">        public void show_1(T t)&#123;</div><div class="line">            System.out.println(t.toString());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</div><div class="line">        //由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</div><div class="line">        public &lt;E&gt; void show_3(E t)&#123;</div><div class="line">            System.out.println(t.toString());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</div><div class="line">        public &lt;T&gt; void show_2(T t)&#123;</div><div class="line">            System.out.println(t.toString());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Apple apple = new Apple();</div><div class="line">        Person person = new Person();</div><div class="line"></div><div class="line">        GenerateTest&lt;Fruit&gt; generateTest = new GenerateTest&lt;Fruit&gt;();</div><div class="line">        //apple是Fruit的子类，所以这里可以</div><div class="line">        generateTest.show_1(apple);</div><div class="line">        //编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person</div><div class="line">        //generateTest.show_1(person);</div><div class="line"></div><div class="line">        //使用这两个方法都可以成功</div><div class="line">        generateTest.show_2(apple);</div><div class="line">        generateTest.show_2(person);</div><div class="line"></div><div class="line">        //使用这两个方法也都可以成功</div><div class="line">        generateTest.show_3(apple);</div><div class="line">        generateTest.show_3(person);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="泛型方法与可变参数"><a href="#泛型方法与可变参数" class="headerlink" title="泛型方法与可变参数"></a>泛型方法与可变参数</h4><p>再看一个泛型方法和可变参数的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public &lt;T&gt; void printMsg( T... args)&#123;</div><div class="line">    for(T t : args)&#123;</div><div class="line">        Log.d(&quot;泛型测试&quot;,&quot;t is &quot; + t);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">printMsg(&quot;111&quot;,222,&quot;aaaa&quot;,&quot;2323.4&quot;,55.55);</div></pre></td></tr></table></figure>
<h4 id="静态方法与泛型"><a href="#静态方法与泛型" class="headerlink" title="静态方法与泛型"></a>静态方法与泛型</h4><p>静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：<strong>静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上</strong>。    </p>
<p>即：<strong>如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 </strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class StaticGenerator&lt;T&gt; &#123;</div><div class="line">    ....</div><div class="line">    ....</div><div class="line">    /**</div><div class="line">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</div><div class="line">     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。</div><div class="line">     * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：</div><div class="line">          &quot;StaticGenerator cannot be refrenced from static context&quot;</div><div class="line">     */</div><div class="line">    public static &lt;T&gt; void show(T t)&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="泛型上下边界"><a href="#泛型上下边界" class="headerlink" title="泛型上下边界"></a>泛型上下边界</h3><p><strong>泛型添加上边界，即传入的类型实参必须是指定类型的子类型</strong></p>
<p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void showKeyValue1(Generic&lt;? extends Number&gt; obj)&#123;</div><div class="line">    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;(&quot;11111&quot;);</div><div class="line">Generic&lt;Integer&gt; generic2 = new Generic&lt;Integer&gt;(2222);</div><div class="line">Generic&lt;Float&gt; generic3 = new Generic&lt;Float&gt;(2.4f);</div><div class="line">Generic&lt;Double&gt; generic4 = new Generic&lt;Double&gt;(2.56);</div><div class="line"></div><div class="line">//这一行代码编译器会提示错误，因为String类型并不是Number类型的子类</div><div class="line">//showKeyValue1(generic1);</div><div class="line"></div><div class="line">showKeyValue1(generic2);</div><div class="line">showKeyValue1(generic3);</div><div class="line">showKeyValue1(generic4);</div></pre></td></tr></table></figure>
<p>如果我们把泛型类的定义也改一下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Generic&lt;T extends Number&gt;&#123;</div><div class="line">    private T key;</div><div class="line"></div><div class="line">    public Generic(T key) &#123;</div><div class="line">        this.key = key;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public T getKey()&#123;</div><div class="line">        return key;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//这一行代码也会报错，因为String不是Number的子类</div><div class="line">Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;(&quot;11111&quot;);</div></pre></td></tr></table></figure>
<p>再来一个泛型方法的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加</div><div class="line">//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错：&quot;Unexpected bound&quot;</div><div class="line">public &lt;T extends Number&gt; T showKeyName(Generic&lt;T&gt; container)&#123;</div><div class="line">    System.out.println(&quot;container key :&quot; + container.getKey());</div><div class="line">    T test = container.getKey();</div><div class="line">    return test;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过上面的两个例子可以看出：<strong>泛型的上下边界添加，必须与泛型的声明在一起</strong>。</p>
<h4 id="泛型方法总结"><a href="#泛型方法总结" class="headerlink" title="泛型方法总结"></a>泛型方法总结</h4><p>泛型方法能使方法独立于类而产生变化，以下是一个基本的指导原则：<br><code>无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。所以如果static方法要使用泛型能力，就必须使其成为泛型方法。</code></p>
<h4 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h4><p>看到了很多文章中都会提起泛型数组，经过查看sun的说明文档，在java中是”<strong>不能创建一个确切的泛型类型的数组</strong>”的。    </p>
<p>也就是说下面的这个例子是不可以的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt;[] ls = new ArrayList&lt;String&gt;[10];</div></pre></td></tr></table></figure></p>
<p>而使用通配符创建泛型数组是可以的，如下面这个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;?&gt;[] ls = new ArrayList&lt;?&gt;[10];</div></pre></td></tr></table></figure></p>
<p>这样也是可以的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt;[] ls = new ArrayList[10];</div></pre></td></tr></table></figure></p>
<p>下面使用Sun的一篇文档的一个例子来说明这个问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt;[] lsa = new List&lt;String&gt;[10]; // Not really allowed.    </div><div class="line">Object o = lsa;    </div><div class="line">Object[] oa = (Object[]) o;    </div><div class="line">List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;();    </div><div class="line">li.add(new Integer(3));    </div><div class="line">oa[1] = li; // Unsound, but passes run time store check    </div><div class="line">String s = lsa[1].get(0); // Run-time error: ClassCastException.</div></pre></td></tr></table></figure></p>
<p>这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。</p>
<p>而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。</p>
<p>下面采用通配符的方式是被允许的:数组的类型不可以是类型变量，除非是采用通配符的方式，因为对于通配符的方式，最后取出数据是要做显式的类型转换的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">List&lt;?&gt;[] lsa = new List&lt;?&gt;[10]; // OK, array of unbounded wildcard type.    </div><div class="line">Object o = lsa;    </div><div class="line">Object[] oa = (Object[]) o;    </div><div class="line">List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;();    </div><div class="line">li.add(new Integer(3));    </div><div class="line">oa[1] = li; // Correct.    </div><div class="line">Integer i = (Integer) lsa[1].get(0); // OK</div></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/27/Java/基础/泛型/" data-id="cj6vztsbi0033oabld195sv7d" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/基础/面向对象7大原则" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/27/Java/基础/面向对象7大原则/">面向对象7大原则</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/27/Java/基础/面向对象7大原则/" class="article-date"><time datetime="2017-08-27T02:09:45.000Z" itemprop="datePublished">2017-08-27</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>七大原则总脉络图：<br><img src="http://my.csdn.net/uploads/201205/15/1337080249_5362.jpg" alt="image">  </p>
<ol>
<li><p><strong>单一职责原则</strong>（Single Responsibility Principle）  </p>
<p> 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；提高类的可读性，提高系统的可维护性；变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。</p>
</li>
<li><p><strong>里氏替换原则</strong>（Liskov Substitution Principle）    </p>
<p> 里氏替换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。里氏替换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。  </p>
<p> 使用里氏替换原则时需要注意，子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。  </p>
<p> 从大局看Java的多态就属于这个原则。</p>
</li>
<li><p><strong>依赖倒置原则</strong>（Dependence Inversion Principle）  </p>
<p> 具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类；而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口；这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。</p>
<p> 采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，减少并行开发引起的风险，提高代码的可读性和可维护性。</p>
<p> 从大局看Java的多态就属于这个原则。</p>
</li>
<li><p><strong>接口隔离原则</strong>（Interface Segregation Principle） </p>
<p> 建立单一接口，不要建立庞大的接口，尽量细化接口，接口中的方法尽量少。也就是要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的约定，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p>
<p> 从大局来说Java的接口可以实现多继承就是接口隔离原则的基础保障。</p>
</li>
<li><p><strong>迪米特法则</strong>（Law Of Demeter）   </p>
<p> 类与类之间的关系越密切，耦合度也就越来越大，只有尽量降低类与类之间的耦合才符合设计模式；对于被依赖的类来说，无论逻辑多复杂都要尽量封装在类的内部；每个对象都会与其他对象有耦合关系，我们称出现成员变量、方法参数、方法返回值中的类为直接的耦合依赖，而出现在局部变量中的类则不是直接耦合依赖，也就是说，不是直接耦合依赖的类最好不要作为局部变量的形式出现在类的内部。</p>
<p> 一个对象对另一个对象知道的越少越好，即一个软件实体应当尽可能少的与其他实体发生相互作用，在一个类里能少用多少其他类就少用多少，尤其是局部变量的依赖类，能省略尽量省略。同时如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一方法的话，可以通过第三者转发这个调用。</p>
</li>
<li><p><strong>开闭原则</strong>（Open Close Principle）</p>
<p> 开放封闭原则主要体现在对扩展开放、对修改封闭，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。软件需求总是变化的，世界上没有一个软件的是不变的，因此对软件设计人员来说，必须在不需要对原有系统进行修改的情况下，实现灵活的系统扩展。</p>
<p> 可以通过Template Method模式和Strategy模式进行重构，实现对修改封闭，对扩展开放的设计思路。<br> 封装变化，是实现开放封闭原则的重要手段，对于经常发生变化的状态，一般将其封装为一个抽象，拒绝滥用抽象，只将经常变化的部分进行抽象。</p>
</li>
<li><p><strong>组合/聚合复用原则</strong>（Composite/Aggregate Reuse Principle CARP）  </p>
<p> 其实整个设计模式就是在讲如何类与类之间的组合/聚合。在一个新的对象里面通过关联关系（包括组合关系和聚合关系）使用一些已有的对象，使之成为新对象的一部分，新对象通过委派调用已有对象的方法达到复用其已有功能的目的。也就是，要尽量使用类的合成复用，尽量不要使用继承。</p>
<p> 如果为了复用，便使用继承的方式将两个不相干的类联系在一起，违反里氏代换原则，哪是生搬硬套，忽略了继承了缺点。继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，基类的内部细节常常对派生类是透明的，白箱复用；虽然简单，但不安全，不能在程序的运行过程中随便改变；基类的实现发生了改变，派生类的实现也不得不改变；从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。</p>
<p> 组合/聚合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</p>
</li>
</ol>
<p>　</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/27/Java/基础/面向对象7大原则/" data-id="cj6vztsbn003doabl4b1xkq3s" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/基础/java动态代理" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/16/Java/基础/java动态代理/">java动态代理</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/16/Java/基础/java动态代理/" class="article-date"><time datetime="2017-08-16T02:09:45.000Z" itemprop="datePublished">2017-08-16</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="class文件简介及加载"><a href="#class文件简介及加载" class="headerlink" title="class文件简介及加载"></a>class文件简介及加载</h2><p> Java编译器编译好Java文件之后，产生.class 文件在磁盘中。这种class文件是二进制文件，内容是只有JVM虚拟机能够识别的机器码。JVM虚拟机读取字节码文件，取出二进制数据，加载到内存中，解析.class 文件内的信息，生成对应的 Class对象:<br><img src="http://img.blog.csdn.net/20140427155129031" alt="image"></p>
<h3 id="在运行期的代码中生成二进制字节码"><a href="#在运行期的代码中生成二进制字节码" class="headerlink" title="在运行期的代码中生成二进制字节码"></a>在运行期的代码中生成二进制字节码</h3><p>由于JVM通过字节码的二进制信息加载类的，那么，如果我们在运行期系统中，遵循Java编译系统组织.class文件的格式和结构，生成相应的二进制数据，然后再把这个二进制数据加载转换成对应的类，这样，就完成了在代码中，动态创建一个类的能力了。<br><img src="http://img.blog.csdn.net/20140427160344203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVhbmxvdWlz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"><br>在运行时期可以按照Java虚拟机规范对class文件的组织规则生成对应的二进制字节码。当前有很多开源框架可以完成这些功能，如ASM，Javassist。</p>
<h4 id="在运行时期可以按照Java虚拟机规范对class文件的组织规则生成对应的二进制字节码。当前有很多开源框架可以完成这些功能，如ASM，Javassist。"><a href="#在运行时期可以按照Java虚拟机规范对class文件的组织规则生成对应的二进制字节码。当前有很多开源框架可以完成这些功能，如ASM，Javassist。" class="headerlink" title="在运行时期可以按照Java虚拟机规范对class文件的组织规则生成对应的二进制字节码。当前有很多开源框架可以完成这些功能，如ASM，Javassist。"></a>在运行时期可以按照Java虚拟机规范对class文件的组织规则生成对应的二进制字节码。当前有很多开源框架可以完成这些功能，如ASM，Javassist。</h4><p>ASM 是一个 Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。  </p>
<p><strong>不过ASM在创建class字节码的过程中，操纵的级别是底层JVM的汇编指令级别，这要求ASM使用者要对class组织结构和JVM汇编指令有一定的了解。</strong></p>
<h4 id="Java字节码生成开源框架介绍–Javassist："><a href="#Java字节码生成开源框架介绍–Javassist：" class="headerlink" title="Java字节码生成开源框架介绍–Javassist："></a>Java字节码生成开源框架介绍–Javassist：</h4><p>Javassist是一个开源的分析、编辑和创建Java字节码的类库。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶 滋）所创建的。它已加入了开放源代码JBoss 应用服务器项目,通过使用Javassist对字节码操作为JBoss实现动态AOP框架。javassist是jboss的一个子项目，其主要的优点，在于简单，而且快速。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>代理模式上，基本上有Subject角色，RealSubject角色，Proxy角色。其中：Subject角色负责定义RealSubject和Proxy角色应该实现的接口；RealSubject角色用来真正完成业务服务功能；Proxy角色负责将自身的Request请求，调用realsubject 对应的request功能来实现业务功能，自己不真正做业务。   <img src="http://img.blog.csdn.net/20140526164603234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVhbmxvdWlz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"><br>上面的这幅代理结构图是典型的静态的代理模式：<br><strong>当在代码阶段规定这种代理关系，Proxy类通过编译器编译成class文件，当系统运行时，此class已经存在了。这种静态的代理模式固然在访问无法访问的资源，增强现有的接口业务功能方面有很大的优点，但是大量使用这种静态代理，会使我们系统内的类的规模增大，并且不易维护；并且由于Proxy和RealSubject的功能 本质上是相同的，Proxy只是起到了中介的作用，这种代理在系统中的存在，导致系统结构比较臃肿和松散。</strong>  </p>
<p>为了解决这个问题，就有了动态地创建Proxy的想法：在运行状态中，需要代理的地方，根据Subject 和RealSubject，动态地创建一个Proxy，用完之后，就会销毁，这样就可以避免了Proxy 角色的class在系统中冗杂的问题了。</p>
<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>仔细思考代理模式中的代理Proxy角色。Proxy角色在执行代理业务的时候，无非是在调用真正业务之前或者之后做一些“额外”业务。<br><img src="http://img.blog.csdn.net/20140603152131484?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM0OTE2OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"><br>有上图可以看出，代理类处理的逻辑很简单：<strong>在调用某个方法前及方法后做一些额外的业务</strong>。换一种思路就是：<strong>在触发（invoke）真实角色的方法之前或者之后做一些额外的业务</strong>。那么，为了构造出具有通用性和简单性的代理类，可以将所有的触发真实角色动作交给一个触发的管理器，让这个管理器统一地管理触发。这种管理器就是InvocationHandler。<br>动态代理模式的结构跟上面的静态代理模式稍微有所不同，多引入了一个InvocationHandler角色。    </p>
<p>动态代理工作的基本模式就是将自己的方法功能的实现交给 InvocationHandler角色，外界对Proxy角色中的每一个方法的调用，Proxy角色都会交给InvocationHandler来处理，而InvocationHandler则调用具体对象角色的方法。如下图所示：<br><img src="http://img.blog.csdn.net/20140515134257500?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVhbmxvdWlz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"><br>在这种模式之中：代理Proxy 和RealSubject 应该实现相同的功能，这一点相当重要。（我这里说的功能，可以理解为某个类的public方法）  </p>
<p>在面向对象的编程之中，如果我们想要约定Proxy 和RealSubject可以实现相同的功能，有两种方式：</p>
<ol>
<li>JDK动态代理模式：就是定义一个功能接口，然后让Proxy 和RealSubject来实现这个接口。</li>
<li>CGLIB模式：通过继承。因为如果Proxy 继承自RealSubject，这样Proxy则拥有了RealSubject的功能，Proxy还可以通过重写RealSubject中的方法，来实现多态。</li>
</ol>
<p>Java 动态代理机制的一些特点：</p>
<ol>
<li>包：如果所代理的接口都是 public 的，那么它将被定义在顶层包（即包路径为空），如果所代理的接口中有非 public 的接口（因为接口不能被定义为 protect 或 private，所以除 public 之外就是默认的 package 访问级别），那么它将被定义在该接口所在包（假设代理了 com.ibm.developerworks 包中的某非 public 接口 A，那么新生成的代理类所在的包就是 com.ibm.developerworks），这样设计的目的是为了最大程度的保证动态代理类不会因为包管理的问题而无法被成功定义并访问；</li>
<li>类名：格式是“$ProxyN”，其中 N 是一个逐一递增的阿拉伯数字，代表 Proxy 类第 N 次生成的动态代理类，值得注意的一点是，并不是每次调用 Proxy 的静态方法创建动态代理类都会使得 N 值增加，原因是如果对同一组接口（包括接口排列的顺序相同）试图重复创建动态代理类，它会很聪明地返回先前已经创建好的代理类的类对象，而不会再尝试去创建一个全新的代理类，这样可以节省不必要的代码重复生成，提高了代理类的创建效率。</li>
<li>要注意不能有重复的接口，以避免动态代理类代码生成时的编译错误。</li>
<li>这些接口对于类装载器必须可见，否则类装载器将无法链接它们，将会导致类定义失败。再次，需被代理的所有非public的接口必须在同一个包中，否则代理类生成也会失败。</li>
<li>接口的数目不能超过 65535，这是 JVM 设定的限制。</li>
</ol>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="目标接口TargetInterface"><a href="#目标接口TargetInterface" class="headerlink" title="目标接口TargetInterface"></a>目标接口TargetInterface</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface TargetInterface &#123; </div><div class="line">    public int targetMethodA(int number); </div><div class="line">    public int targetMethodB(int number); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="实现该接口的委托类ConcreteClass"><a href="#实现该接口的委托类ConcreteClass" class="headerlink" title="实现该接口的委托类ConcreteClass"></a>实现该接口的委托类ConcreteClass</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class ConcreteClass implements TargetInterface&#123; </div><div class="line"> </div><div class="line">    public int targetMethodA(int number) &#123; </div><div class="line">        System.out.println(&quot;开始调用目标类的方法targetMethodA...&quot;); </div><div class="line">        System.out.println(&quot;操作-打印数字:&quot;+number); </div><div class="line">        System.out.println(&quot;结束调用目标类的方法targetMethodA...&quot;); </div><div class="line">        return number; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    public int targetMethodB(int number)&#123; </div><div class="line">        System.out.println(&quot;开始调用目标类的方法targetMethodB...&quot;); </div><div class="line">        System.out.println(&quot;操作-打印数字:&quot;+number); </div><div class="line">        System.out.println(&quot;结束调用目标类的方法targetMethodB...&quot;); </div><div class="line">        return number; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很简单，一个普通的类，实现了目标接口。</p>
<h4 id="代理处理器类ProxyHandler"><a href="#代理处理器类ProxyHandler" class="headerlink" title="代理处理器类ProxyHandler"></a>代理处理器类ProxyHandler</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class ProxyHandler implements InvocationHandler&#123; </div><div class="line">    private Object concreteClass; </div><div class="line"> </div><div class="line">    public ProxyHandler(Object concreteClass)&#123; </div><div class="line">        this.concreteClass=concreteClass; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; </div><div class="line">        System.out.println(&quot;proxy:&quot;+proxy.getClass().getName()); </div><div class="line">        System.out.println(&quot;method:&quot;+method.getName()); </div><div class="line">        System.out.println(&quot;args:&quot;+args[0].getClass().getName());  </div><div class="line">        System.out.println(&quot;Before invoke method...&quot;); </div><div class="line">        Object object=method.invoke(concreteClass, args);//普通的Java反射代码,通过反射执行某个类的某方法 </div><div class="line"></div><div class="line">        System.out.println(&quot;After invoke method...&quot;); </div><div class="line">        return object; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该类实现了Java反射包中的InvocationHandler接口。代理实例调用方法时，将对方法调用指派到它的代理处理器程序的invoke方法中。invoke方法内部实现预处理，对委托类方法调用，事后处理等逻辑。</p>
<h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class DynamicProxyExample &#123; </div><div class="line">    public static void main(String[] args)&#123; </div><div class="line">        ConcreteClass c = new ConcreteClass();//元对象(被代理对象) </div><div class="line">        InvocationHandler ih = new ProxyHandler(c);//代理实例的调用处理程序。 </div><div class="line">        //创建一个实现业务接口的代理类,用于访问业务类(见代理模式)。 </div><div class="line">        //返回一个指定接口的代理类实例，该接口可以将方法调用指派到指定的调用处理程序，如ProxyHandler。 </div><div class="line">        TargetInterface targetInterface = (TargetInterface)Proxy.newProxyInstance(c.getClass().getClassLoader(),c.getClass().getInterfaces(),ih); </div><div class="line">        //调用代理类方法,Java执行InvocationHandler接口的方法. </div><div class="line">        int i = targetInterface.targetMethodA(5); </div><div class="line">        System.out.println(i); </div><div class="line">        System.out.println(); </div><div class="line">        int j = targetInterface.targetMethodB(15); </div><div class="line">        System.out.println(j); </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先创建委托类对象，将其以构造函数传入代理处理器，代理处理器ProxyHandler中会以Java反射方式调用该委托类对应的方法。然后使用Java反射机制中的Proxy.newProxyInstance方式创建一个代理类实例，创建该实例需要指定该实例的类加载器，需要实现的接口(即目标接口)，以及处理代理实例接口调用的处理器。<br>最后，调用代理类目标接口方法时，会自动将其转发到代理处理器中的invoke方法内，invoke方法内部实现预处理，对委托类方法调用，事后处理等逻辑。</p>
<h2 id="CGlib（Code-Generation-Library）动态代理"><a href="#CGlib（Code-Generation-Library）动态代理" class="headerlink" title="CGlib（Code Generation Library）动态代理"></a>CGlib（Code Generation Library）动态代理</h2><p>CGLIB（Code Generation Library），是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。</p>
<p>JDK中提供的生成动态代理类的机制有个鲜明的特点是： <strong>某个类必须有实现的接口，而生成的代理类也只能代理某个类接口定义的方法</strong><br>如果某个类没有实现接口，那么这个类就不能同JDK产生动态代理了！<br>此时，cglib可以通过继承的方式实现动态代理。</p>
<p>使用CGLib实现动态代理，完全不受代理类必须实现接口的限制，而且CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的方法进行代理，因为CGLib原理是动态生成被代理类的子类。</p>
<p>cglib 创建某个类A的动态代理类的模式是：</p>
<ol>
<li>查找A上的所有非final 的public类型的方法定义；</li>
<li>将这些方法的定义转换成字节码；</li>
<li>将组成的字节码转换成相应的代理的class对象；</li>
<li>实现 MethodInterceptor接口，用来处理 对代理类上所有方法的请求（这个接口和JDK动态代理InvocationHandler的功能和角色是一样的）</li>
</ol>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><h5 id="被代理类-首先，定义一个类，该类没有实现任何接口。"><a href="#被代理类-首先，定义一个类，该类没有实现任何接口。" class="headerlink" title="被代理类:首先，定义一个类，该类没有实现任何接口。"></a>被代理类:首先，定义一个类，该类没有实现任何接口。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class ConcreteClassNoInterface &#123; </div><div class="line">    public String getConcreteMethodA(String str)&#123; </div><div class="line">        System.out.println(&quot;ConcreteMethod A ... &quot;+str); </div><div class="line">        return str; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="拦截器：定义一个拦截器。在调用目标方法时，CGLib会回调MethodInterceptor接口方法拦截，来实现你自己的代理逻辑，类似于JDK中的InvocationHandler接口。"><a href="#拦截器：定义一个拦截器。在调用目标方法时，CGLib会回调MethodInterceptor接口方法拦截，来实现你自己的代理逻辑，类似于JDK中的InvocationHandler接口。" class="headerlink" title="拦截器：定义一个拦截器。在调用目标方法时，CGLib会回调MethodInterceptor接口方法拦截，来实现你自己的代理逻辑，类似于JDK中的InvocationHandler接口。"></a>拦截器：定义一个拦截器。在调用目标方法时，CGLib会回调MethodInterceptor接口方法拦截，来实现你自己的代理逻辑，类似于JDK中的InvocationHandler接口。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class ConcreteClassInterceptor implements MethodInterceptor&#123; </div><div class="line">    public Object intercept(Object obj, Method method, Object[] arg, MethodProxy proxy) throws Throwable &#123; </div><div class="line">        System.out.println(&quot;Before:&quot;+method); </div><div class="line">        Object object=proxy.invokeSuper(obj, arg); </div><div class="line">        System.out.println(&quot;After:&quot;+method); </div><div class="line">        return object; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数：  </p>
<ul>
<li>Object为由CGLib动态生成的代理类实例</li>
<li>Method为上文中实体类所调用的被代理的方法引用</li>
<li>Object[]为参数值列表，MethodProxy为生成的代理类对方法的代理引用。</li>
<li>proxy.invokeSuper(obj,arg)：调用代理类实例上的proxy方法的父类方法（即实体类ConcreteClassNoInterface中对应的方法）</li>
<li>返回：从代理实例的方法调用返回的值。</li>
</ul>
<h5 id="生成动态代理类"><a href="#生成动态代理类" class="headerlink" title="生成动态代理类"></a>生成动态代理类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Enhancer enhancer=new Enhancer(); </div><div class="line">enhancer.setSuperclass(ConcreteClassNoInterface.class); </div><div class="line">enhancer.setCallback(new ConcreteClassInterceptor()); </div><div class="line">ConcreteClassNoInterface ccni = (ConcreteClassNoInterface)enhancer.create();</div></pre></td></tr></table></figure>
<p>这里Enhancer类是CGLib中的一个字节码增强器，它可以方便的对你想要处理的类进行扩展。<br>首先将被代理类ConcreteClassNoInterface设置成父类，然后设置拦截器ConcreteClassInterceptor，最后执行enhancer.create()动态生成一个代理类，并从Object强制转型成父类型ConcreteClassNoInterface。<br>最后，在代理类上调用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ccni.getConcreteMethodA(&quot;haha&quot;);</div></pre></td></tr></table></figure></p>
<p>调用getConcreteMethodA()是在拦截器中的intercept方法中调用的，在调用前后，进行了一些逻辑处理，这里只是简单的打印了一些语句</p>
<p>　　</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/16/Java/基础/java动态代理/" data-id="cj6vztsbd002woablzk6k4k69" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/基础/重载与重写" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/16/Java/基础/重载与重写/">重载与重写</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/16/Java/基础/重载与重写/" class="article-date"><time datetime="2017-08-16T02:09:45.000Z" itemprop="datePublished">2017-08-16</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="重载-overloading"><a href="#重载-overloading" class="headerlink" title="重载 overloading"></a>重载 overloading</h2><ol>
<li>方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。重载是一个类中多态性的一种表现。</li>
<li>Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。调用方法时通过传递给它们的不同参数个数和参数类型给它们的不同参数个数和参数类型给它们的不同参数个数和参数类型来决定具体使用哪个方法,这就是多态性。</li>
<li>重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。</li>
</ol>
<h3 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h3><ol>
<li>必须具有不同的参数列表；</li>
<li>可以有相同的返回类型，只要参数列表不同就可以了；</li>
<li>可以有不同的访问修饰符；</li>
<li>可以抛出不同的异常；</li>
</ol>
<h2 id="重写overriding"><a href="#重写overriding" class="headerlink" title="重写overriding"></a>重写overriding</h2><ol>
<li>父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写(Overriding)。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。方法重写又称方法覆盖。</li>
<li>若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。</li>
<li>子类函数的访问修饰权限不能小于父类的</li>
</ol>
<h3 id="规则：-1"><a href="#规则：-1" class="headerlink" title="规则："></a>规则：</h3><ol>
<li>参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。</li>
<li>返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。</li>
<li>访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private）</li>
<li>重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：<br>父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。</li>
</ol>
<p>　　</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/16/Java/基础/重载与重写/" data-id="cj6vztsbn003boabl74iuriny" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Spring/Security/配置十二：Remember-Me功能" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Spring/Security/配置十二：Remember-Me功能/">配置十二：Remember-Me功能</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/15/Spring/Security/配置十二：Remember-Me功能/" class="article-date"><time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a> / <a class="article-category-link" href="/categories/Spring/Security/">Security</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>一. <strong>概述</strong><br>&emsp;&emsp;Remember-Me是指网站能够在Session之间记住登录用户的身份，具体来说就是我成功认证一次之后在一定的时间内我可以不用再输入用户名和密码进行登录了，系统会自动给我登录。这通常是通过服务端发送一个cookie给客户端浏览器，下次浏览器再访问服务端时服务端能够自动检测客户端的cookie，根据cookie值触发自动登录操作。Spring Security为这些操作的发生提供必要的钩子，并且针对于Remember-Me功能有两种实现。一种是简单的使用加密来保证基于cookie的token的安全，另一种是通过数据库或其它持久化存储机制来保存生成的token。<br>&emsp;&emsp;需要注意的是两种实现都需要一个UserDetailsService。如果你使用的AuthenticationProvider不使用UserDetailsService，那么记住我将会不起作用，除非在你的ApplicationContext中拥有一个UserDetailsService类型的bean。</p>
<p>二. <strong>基于简单加密token的方法</strong><br>&emsp;&emsp;当用户选择了记住我成功登录后，Spring Security将会生成一个cookie发送给客户端浏览器。cookie值由如下方式组成：<br>base64(username+”:”+expirationTime+”:”+md5Hex(username+”:”+expirationTime+”:”+password+”:”+key))  </p>
<ul>
<li>username：登录的用户名。</li>
<li>password：登录的密码。</li>
<li>expirationTime：token失效的日期和时间，以毫秒表示。</li>
<li>key：用来防止修改token的一个key。</li>
</ul>
<p>&emsp;&emsp;这样用来实现Remember-Me功能的token只能在指定的时间内有效，且必须保证token中所包含的username、password和key没有被改变才行。需要注意的是，这样做其实是存在安全隐患的，那就是在用户获取到实现记住我功能的token后，任何用户都可以在该token过期之前通过该token进行自动登录。如果用户发现自己的token被盗用了，那么他可以通过改变自己的登录密码来立即使其所有的记住我token失效。如果希望我们的应用能够更安全一点，可以使用接下来要介绍的持久化token方式，或者不使用Remember-Me功能，因为Remember-Me功能总是有点不安全的。<br>&emsp;&emsp;使用这种方式时，我们只需要在http元素下定义一个remember-me元素，同时指定其key属性即可。key属性是用来标记存放token的cookie的，对应上文提到的生成token时的那个key。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span> <span class="attr">auto-config</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:form-login</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 定义记住我功能 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:remember-me</span> <span class="attr">key</span>=<span class="string">"elim"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这里有两个需要注意的地方：</p>
<ol>
<li>如果你的登录页面是自定义的，那么需要在登录页面上新增一个名为“_spring_security_remember_me”的checkbox，这是基于NameSpace定义提供的默认名称，如果要自定义可以自己定义TokenBasedRememberMeServices或PersistentTokenBasedRememberMeServices对应的bean，然后通过其parameter属性进行指定。</li>
<li>上述功能需要一个UserDetailsService，如果在你的ApplicationContext中已经拥有一个了，那么Spring Security将自动获取；如果没有，那么当然你需要定义一个；如果拥有在ApplicationContext中拥有多个UserDetailsService定义，那么你需要通过remember-me元素的user-service-ref属性指定将要使用的那个。如：<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">  <span class="tag">&lt;<span class="name">security:http</span> <span class="attr">auto-config</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:form-login</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 定义记住我功能，通过user-service-ref指定将要使用的UserDetailsService--&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:remember-me</span> <span class="attr">key</span>=<span class="string">"elim"</span> <span class="attr">user-service-ref</span>=<span class="string">"userDetailsService"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDetailsService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>三. <strong>基于持久化token的方法</strong><br>&emsp;&emsp;持久化token的方法跟简单加密token的方法在实现Remember-Me功能上大体相同，都是在用户选择了“记住我”成功登录后，将生成的token存入cookie中并发送到客户端浏览器，待到下次用户访问系统时，系统将直接从客户端cookie中读取token进行认证。所不同的是基于简单加密token的方法，一旦用户登录成功后，生成的token将在客户端保存一段时间，如果用户不点击退出登录，或者不修改密码，那么在cookie失效之前，他都可以使用该token进行登录，哪怕该token被别人盗用了，用户与盗用者都同样可以进行登录。而基于持久化token的方法采用这样的实现逻辑：<br>（1）用户选择了“记住我”成功登录后，将会把username、随机产生的序列号、生成的token存入一个数据库表中，同时将它们的组合生成一个cookie发送给客户端浏览器。<br>（2）当下一次没有登录的用户访问系统时，首先检查cookie，如果对应cookie中包含的username、序列号和token与数据库中保存的一致，则表示其通过验证，系统将重新生成一个新的token替换数据库中对应组合的旧token，序列号保持不变，同时删除旧的cookie，重新生成包含新生成的token，旧的序列号和username的cookie发送给客户端。<br>（3）如果检查cookie时，cookie中包含的username和序列号跟数据库中保存的匹配，但是token不匹配。这种情况极有可能是因为你的cookie被人盗用了，由于盗用者使用你原本通过认证的cookie进行登录了导致旧的token失效，而产生了新的token。这个时候Spring Security就可以发现cookie被盗用的情况，它将删除数据库中与当前用户相关的所有token记录，这样盗用者使用原有的cookie将不能再登录，同时提醒用户其帐号有被盗用的可能性。<br>（4）如果对应cookie不存在，或者包含的username和序列号与数据库中保存的不一致，那么将会引导用户到登录页面。</p>
<p>&emsp;&emsp;从以上逻辑我们可以看出持久化token的方法比简单加密token的方法更安全，因为一旦你的cookie被人盗用了，你只要再利用原有的cookie试图自动登录一次，原有的token将失效导致盗用者不能再使用原来盗用的cookie进行登录了，同时用户可以发现自己的cookie有被盗用的可能性。但因为cookie被盗用后盗用者还可以在用户下一次登录前顺利的进行登录，所以如果你的应用对安全性要求比较高就不要使用Remember-Me功能了。<br>&emsp;&emsp;使用持久化token方法时需要我们的数据库中拥有如下表及其表结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">create table persistent_logins (username varchar(64) not null,</div><div class="line">    series varchar(64) primary key,</div><div class="line">    token varchar(64) not null,</div><div class="line">    last_used timestamp not null)</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;然后还是通过remember-me元素来使用，只是这个时候我们需要其data-source-ref属性指定对应的数据源，同时别忘了它也同样需要ApplicationContext中拥有UserDetailsService，如果拥有多个，请使用user-service-ref属性指定remember-me使用的是哪一个。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">security:http</span> <span class="attr">auto-config</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:form-login</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 定义记住我功能 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:remember-me</span> <span class="attr">data-source-ref</span>=<span class="string">"dataSource"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>四. <strong>Remember-Me相关接口和实现类</strong><br>&emsp;&emsp;在上述介绍中，我们实现Remember-Me功能是通过Spring Security为了简化Remember-Me而提供的NameSpace进行定义的。而底层实际上还是通过RememberMeServices、UsernamePasswordAuthenticationFilter和RememberMeAuthenticationFilter的协作来完成的。RememberMeServices是Spring Security为Remember-Me提供的一个服务接口，其定义如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">publicinterface RememberMeServices &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 自动登录。在实现这个方法的时候应该判断用户提供的Remember-Me cookie是否有效，如果无效，应当直接忽略。</div><div class="line">     * 如果认证成功应当返回一个AuthenticationToken，推荐返回RememberMeAuthenticationToken；</div><div class="line">     * 如果认证不成功应当返回null。</div><div class="line">     */</div><div class="line">    <span class="function">Authentication <span class="title">autoLogin</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在用户登录失败时调用。实现者应当做一些类似于删除cookie之类的处理。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loginFail</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在用户成功登录后调用。实现者可以在这里判断用户是否选择了“Remember-Me”登录，然后做相应的处理。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loginSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></div><div class="line">        Authentication successfulAuthentication);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;UsernamePasswordAuthenticationFilter拥有一个RememberMeServices的引用，默认是一个空实现的NullRememberMeServices，而实际当我们通过remember-me定义启用Remember-Me时，它会是一个具体的实现。用户的请求会先通过UsernamePasswordAuthenticationFilter，如认证成功会调用RememberMeServices的loginSuccess()方法，否则调用RememberMeServices的loginFail()方法。UsernamePasswordAuthenticationFilter是不会调用RememberMeServices的autoLogin()方法进行自动登录的。之后运行到RememberMeAuthenticationFilter时如果检测到还没有登录，那么RememberMeAuthenticationFilter会尝试着调用所包含的RememberMeServices的autoLogin()方法进行自动登录。关于RememberMeServices Spring Security已经为我们提供了两种实现，分别对应于前文提到的基于简单加密token和基于持久化token的方法。</p>
<p>五. <strong>TokenBasedRememberMeServices</strong><br>&emsp;&emsp;TokenBasedRememberMeServices对应于前文介绍的使用namespace时基于简单加密token的实现。TokenBasedRememberMeServices会在用户选择了记住我成功登录后，生成一个包含token信息的cookie发送到客户端；如果用户登录失败则会删除客户端保存的实现Remember-Me的cookie。需要自动登录时，它会判断cookie中所包含的关于Remember-Me的信息是否与系统一致，一致则返回一个RememberMeAuthenticationToken供RememberMeAuthenticationProvider处理，不一致则会删除客户端的Remember-Me cookie。TokenBasedRememberMeServices还实现了Spring Security的LogoutHandler接口，所以它可以在用户退出登录时立即清除Remember-Me cookie。<br>&emsp;&emsp; 如果把使用namespace定义Remember-Me改为直接定义RememberMeServices和对应的Filter来使用的话，那么我们可以如下定义。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">security:http</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:form-login</span> <span class="attr">login-page</span>=<span class="string">"/login.jsp"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/login*.jsp*"</span> <span class="attr">access</span>=<span class="string">"IS_AUTHENTICATED_ANONYMOUSLY"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 把usernamePasswordAuthenticationFilter加入FilterChain --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:custom-filter</span> <span class="attr">ref</span>=<span class="string">"usernamePasswordAuthenticationFilter"</span> <span class="attr">before</span>=<span class="string">"FORM_LOGIN_FILTER"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:custom-filter</span> <span class="attr">ref</span>=<span class="string">"rememberMeFilter"</span> <span class="attr">position</span>=<span class="string">"REMEMBER_ME_FILTER"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 用于认证的AuthenticationManager --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">security:authentication-manager</span> <span class="attr">alias</span>=<span class="string">"authenticationManager"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:authentication-provider</span></span></div><div class="line">     <span class="attr">user-service-ref</span>=<span class="string">"userDetailsService"</span>/&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">security:authentication-provider</span> <span class="attr">ref</span>=<span class="string">"rememberMeAuthenticationProvider"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDetailsService"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"usernamePasswordAuthenticationFilter"</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"rememberMeServices"</span> <span class="attr">ref</span>=<span class="string">"rememberMeServices"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationManager"</span> <span class="attr">ref</span>=<span class="string">"authenticationManager"</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 指定request中包含的用户名对应的参数名 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"usernameParameter"</span> <span class="attr">value</span>=<span class="string">"username"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"passwordParameter"</span> <span class="attr">value</span>=<span class="string">"password"</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 指定登录的提交地址 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filterProcessesUrl"</span> <span class="attr">value</span>=<span class="string">"/login.do"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- Remember-Me对应的Filter --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"rememberMeFilter"</span></span></div><div class="line"><span class="attr">class</span>=<span class="string">"org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"rememberMeServices"</span> <span class="attr">ref</span>=<span class="string">"rememberMeServices"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationManager"</span> <span class="attr">ref</span>=<span class="string">"authenticationManager"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- RememberMeServices的实现 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"rememberMeServices"</span></span></div><div class="line"><span class="attr">class</span>=<span class="string">"org.springframework.security.web.authentication.rememberme.TokenBasedRememberMeServices"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDetailsService"</span> <span class="attr">ref</span>=<span class="string">"userDetailsService"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"key"</span> <span class="attr">value</span>=<span class="string">"elim"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 指定request中包含的用户是否选择了记住我的参数名 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"parameter"</span> <span class="attr">value</span>=<span class="string">"rememberMe"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- key值需与对应的RememberMeServices保持一致 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"rememberMeAuthenticationProvider"</span></span></div><div class="line"><span class="attr">class</span>=<span class="string">"org.springframework.security.authentication.RememberMeAuthenticationProvider"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"key"</span> <span class="attr">value</span>=<span class="string">"elim"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;需要注意的是RememberMeAuthenticationProvider在认证RememberMeAuthenticationToken的时候是比较它们拥有的key是否相等，而RememberMeAuthenticationToken的key是TokenBasedRememberMeServices提供的，所以在使用时需要保证RememberMeAuthenticationProvider和TokenBasedRememberMeServices的key属性值保持一致。需要配置UsernamePasswordAuthenticationFilter的rememberMeServices为我们定义好的TokenBasedRememberMeServices，把RememberMeAuthenticationProvider加入AuthenticationManager的providers列表，并添加RememberMeAuthenticationFilter和UsernamePasswordAuthenticationFilter到FilterChainProxy。  </p>
<p>六. <strong>PersistentTokenBasedRememberMeServices</strong><br>&emsp;&emsp;PersistentTokenBasedRememberMeServices是RememberMeServices基于前文提到的持久化token的方式实现的。具体实现逻辑跟前文介绍的以NameSpace的方式使用基于持久化token的Remember-Me是一样的，这里就不再赘述了。此外，如果单独使用，其使用方式和上文描述的TokenBasedRememberMeServices是一样的，这里也不再赘述了。<br>&emsp;&emsp;需要注意的是PersistentTokenBasedRememberMeServices是需要将token进行持久化的，所以我们必须为其指定存储token的PersistentTokenRepository。Spring Security对此有两种实现，InMemoryTokenRepositoryImpl和JdbcTokenRepositoryImpl。前者是将token存放在内存中的，通常用于测试，而后者是将token存放在数据库中。PersistentTokenBasedRememberMeServices默认使用的是前者，我们可以通过其tokenRepository属性来指定使用的PersistentTokenRepository。<br>&emsp;&emsp;使用JdbcTokenRepositoryImpl时我们可以使用在前文提到的默认表结构。如果需要使用自定义的表，那么我们可以对JdbcTokenRepositoryImpl进行重写。定义JdbcTokenRepositoryImpl时需要指定一个数据源dataSource，同时可以通过设置参数createTableOnStartup的值来控制是否要在系统启动时创建对应的存入token的表，默认创建语句为“create table persistent_logins (username varchar(64) not null, series varchar(64) primary key, token varchar(64) not null, last_used timestamp not null)”，但是如果自动创建时对应的表已经存在于数据库中，则会抛出异常。createTableOnStartup属性默认为false。<br>&emsp;&emsp;直接显示地使用PersistentTokenBasedRememberMeServices和上文提到的直接显示地使用TokenBasedRememberMeServices的方式是一样的，我们只需要将上文提到的配置中RememberMeServices实现类TokenBasedRememberMeServices换成PersistentTokenBasedRememberMeServices即可。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- RememberMeServices的实现 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"rememberMeServices"</span></span></div><div class="line">   <span class="attr">class</span>=<span class="string">"org.springframework.security.web.authentication.rememberme.PersistentTokenBasedRememberMeServices"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDetailsService"</span> <span class="attr">ref</span>=<span class="string">"userDetailsService"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"key"</span> <span class="attr">value</span>=<span class="string">"elim"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 指定request中包含的用户是否选择了记住我的参数名 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"parameter"</span> <span class="attr">value</span>=<span class="string">"rememberMe"</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 指定PersistentTokenRepository --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tokenRepository"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.web.authentication.rememberme.JdbcTokenRepositoryImpl"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 数据源 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 是否在系统启动时创建持久化token的数据库表 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"createTableOnStartup"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Spring/Security/配置十二：Remember-Me功能/" data-id="cj6vztsdr0084oabl46egq9ub" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Spring/Security/配置十九：对Acl的支持" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Spring/Security/配置十九：对Acl的支持/">配置十九：对Acl的支持</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/15/Spring/Security/配置十九：对Acl的支持/" class="article-date"><time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a> / <a class="article-category-link" href="/categories/Spring/Security/">Security</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;Acl的全称是Access Control List，俗称访问控制列表，是用以控制对象的访问权限的。其主要思想是将某个对象的某种权限授予给某个用户，或某种GrantedAuthority（可以简单的理解为某种角色），它们之间的关系都是多对多。如果某一个对象的某一操作是受保护的，那么在对该对象进行某种操作时就需要有对应的权限。</p>
<p>一. <strong>准备工作</strong><br>使用Spring Security的Acl功能需要引入Acl相关的jar包。如果我们的应用是使用Maven构建的，则可以在应用的pom.xml文件中加入如下依赖。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-acl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.security.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>此外，使用Spring Security的Acl时需要在数据库中建立四张表。在其官方文档中给出了一个基于数据库HSQLDB的建表语句。其脚本如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">create table acl_sid (</div><div class="line">  id bigint generated by default as identity(start with 100) not null primary key,</div><div class="line">  principal boolean not null,</div><div class="line">  sid varchar_ignorecase(100) not null,</div><div class="line">  constraint unique_uk_1 unique(sid,principal) );</div><div class="line"> </div><div class="line">create table acl_class (</div><div class="line">  id bigint generated by default as identity(start with 100) not null primary key,</div><div class="line">  class varchar_ignorecase(100) not null,</div><div class="line">  constraint unique_uk_2 unique(class) );</div><div class="line"> </div><div class="line">create table acl_object_identity (</div><div class="line">  id bigint generated by default as identity(start with 100) not null primary key,</div><div class="line">  object_id_class bigint not null,</div><div class="line">  object_id_identity bigint not null,</div><div class="line">  parent_object bigint,</div><div class="line">  owner_sid bigint not null,</div><div class="line">  entries_inheriting boolean not null,</div><div class="line">  constraint unique_uk_3 unique(object_id_class,object_id_identity),</div><div class="line">  constraint foreign_fk_1 foreign key(parent_object)references acl_object_identity(id),</div><div class="line">  constraint foreign_fk_2 foreign key(object_id_class)references acl_class(id),</div><div class="line">  constraint foreign_fk_3 foreign key(owner_sid)references acl_sid(id) );</div><div class="line"> </div><div class="line">create table acl_entry (</div><div class="line">  id bigint generated by default as identity(start with 100) not null primary key,</div><div class="line">  acl_object_identity bigint not null,ace_order int not null,sid bigint not null,</div><div class="line">  mask integer not null,granting boolean not null,audit_success boolean not null,</div><div class="line">  audit_failure boolean not null,</div><div class="line">  constraint unique_uk_4 unique(acl_object_identity,ace_order),</div><div class="line">  constraint foreign_fk_4 foreign key(acl_object_identity)</div><div class="line">      references acl_object_identity(id),</div><div class="line">  constraint foreign_fk_5 foreign key(sid) references acl_sid(id) );</div></pre></td></tr></table></figure></p>
<p>笔者使用的是Oracle数据库，其中没有boolean和主键自增功能，对于boolean类型都使用一位number表示。具体建表语句如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">create table acl_sid (</div><div class="line">  id number not null primary key,</div><div class="line">  principal number(1) not null,</div><div class="line">  sid varchar(100) not null,</div><div class="line">  constraint unique_uk_1 unique(sid,principal) );</div><div class="line"> </div><div class="line">create table acl_class (</div><div class="line">  id number not null primary key,</div><div class="line">  class varchar(100) not null,</div><div class="line">  constraint unique_uk_2 unique(class) );</div><div class="line"> </div><div class="line">create table acl_object_identity (</div><div class="line">  id number not null primary key,</div><div class="line">  object_id_class number not null,</div><div class="line">  object_id_identity number not null,</div><div class="line">  parent_object number,</div><div class="line">  owner_sid number not null,</div><div class="line">  entries_inheriting number(1) not null,</div><div class="line">  constraint unique_uk_3 unique(object_id_class,object_id_identity),</div><div class="line">  constraint foreign_fk_1 foreign key(parent_object)references acl_object_identity(id),</div><div class="line">  constraint foreign_fk_2 foreign key(object_id_class)references acl_class(id),</div><div class="line">  constraint foreign_fk_3 foreign key(owner_sid)references acl_sid(id) );</div><div class="line"> </div><div class="line">create table acl_entry (</div><div class="line">  id number not null primary key,</div><div class="line">  acl_object_identity number not null,ace_order int not null,sid number not null,</div><div class="line">  mask number(3) not null,granting number(1) not null,audit_success number(1) not null,</div><div class="line">  audit_failure number(1) not null,</div><div class="line">  constraint unique_uk_4 unique(acl_object_identity,ace_order),</div><div class="line">  constraint foreign_fk_4 foreign key(acl_object_identity)</div><div class="line">      references acl_object_identity(id),</div><div class="line">  constraint foreign_fk_5 foreign key(sid) references acl_sid(id) );</div><div class="line"> </div><div class="line"> 新增记录时用于生成主键的sequence定义为：</div><div class="line">  create or replace sequence seq_acl_sid start with 1 increment by 1;</div><div class="line">  create or replace sequence seq_acl_class start with 1 increment by 1;</div><div class="line">  create or replace sequence seq_acl_object_identity start with 1 increment by 1;</div><div class="line">  create or replace sequence seq_acl_entry start with 1 increment by 1;</div></pre></td></tr></table></figure></p>
<p>二. <strong>表功能介绍</strong><br>如上所示，Spring Security的Acl功能需要使用到四张数据库表，分别为acl_sid、acl_class、acl_object_identity和acl_entry。<br>2.1 <strong>表acl_sid</strong><br>表acl_sid的结构如下所示：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>number</td>
<td>主键</td>
</tr>
<tr>
<td>sid</td>
<td>varchar</td>
<td>字符串类型的sid</td>
</tr>
<tr>
<td>principal</td>
<td>boolean</td>
<td>是否用户</td>
</tr>
</tbody>
</table>
<p>表acl_sid是用来保存Sid的。对于Acl而言，有两种类型的Sid，一种是基于用户的Sid，叫PrincipalSid；另一种是基于GrantedAuthority的Sid，叫GrantedAuthoritySid。acl_sid表的sid字段存放的是用户名或者是GrantedAuthority的字符串表示。prinpal是用来区分对应的Sid是用户还是GrantedAuthority的。正如在前文所描述的那样，Acl中对象的权限是用来授予给Sid的，Sid有用户和GrantedAuthority之分，所以我们的对象权限是可以用来授予给用户或GrantedAuthority的。</p>
<p>2.2 <strong>表acl_class</strong><br>表acl_class的结构如下所示：<br>| 字段名   | 类型      | 说明        |<br>| —– | ——- | ——— |<br>| id    | number  | 主键        |<br>| class | varchar | 对象类型的全限定名 |<br>表acl_class是用来保存对象类型的，字段class中保存的是对应对象的全限定名。Acl需要使用它来区分不同的对象类型。</p>
<p>2.3 <strong>表acl_object_identity</strong><br>表acl_object_identity的结构如下：<br>| 字段名                | 类型      | 说明                                       |<br>| —————— | ——- | —————————————- |<br>| id                 | number  | 主键                                       |<br>| object_id_class    | number  | 关联acl_class，表示对象类型                       |<br>| object_id_identity | number  | 对象的主键，对于相同的class而言，其需要是唯一的。对象的主键默认需要是Long型，或者可以转换为Long型的对象，如Integer、Short等。 |<br>| parent_object      | number  | 父对象的id，关联acl_object_identity             |<br>| owner_sid          | number  | 拥有者的sid，关联acl_sid                        |<br>| entries_inheriting | boolean | 是否继承父对象的权限。打个比方，删除对象childObj需要有delete权限，用户A他没有childObj的delete权限，但是他有childObj的父对象parentObj的delete权限，当entries_inheriting为true时，用户A同样可以删除childObj。 |<br>表acl_object_identity是用来存放需要进行访问控制的对象的信息的。其保存的信息有对象的拥有者、对象的类型、对象的主键、对象的父对象和是否继承父对象的权限。</p>
<p>2.4 <strong>表acl_entry</strong><br>表acl_entry的结构如下：<br>| 字段名                 | 类型      | 说明                             |<br>| ——————- | ——- | —————————— |<br>| id                  | number  | 主键                             |<br>| acl_object_identity | number  | 对应acl_object_identity的id       |<br>| ace_order           | number  | 所属Acl的权限顺序                     |<br>| sid                 | number  | 对应acl_sid的id                   |<br>| mask                | number  | 权限对应的掩码                        |<br>| granting            | boolean | 是否授权                           |<br>| audit_success       | boolean | 暂未发现其作用，Acl中有一个更新其值的方法，但未见被调用。 |<br>| audit_failure       | boolean |                                |<br>表acl_entry是用于存放具体的权限信息的，从表结构我们也可以看出来，其描述的就是某个主体（Sid）对某个对象（acl_object_identity）是否（granting）拥有某种权限（mask）。当同一对象acl_object_identity在acl_entry表中拥有多条记录时，就会使用ace_order来标记对应的顺序，其对应于往Acl中插入AccessControlEntry时的位置，在进行权限判断时也是依靠ace_order的顺序来进行的，ace_order越小的越先进行判断。ace是Access Control Entry的简称。</p>
<p>三. <strong>Acl主要接口</strong><br>&emsp;&emsp;对于Acl而言，有两块比较核心的功能，一块是往对应的数据库表里面插数据，另一块是从数据库表里面取出对应的数据进行权限鉴定。要了解这些功能我们先来了解Acl中用到的主要接口。<br>3.1 <strong>Sid</strong>：可以用来表示一个principal，或者是一个GrantedAuthority。其对应的实现类有表示principal的PrincipalSid和表示GrantedAuthority的GrantedAuthoritySid。其信息会保存在acl_sid表中。<br>3.2  <strong>ObjectIdentity</strong>：ObjectIdentity表示Spring Security Acl中一个域对象，其默认实现类是ObjectIdentityImpl。ObjectIdentity并不是直接与acl_object_identity表相对应的，真正与acl_object_identity表直接相对应的是Acl。<br>3.3 <strong>Acl</strong>：每一个领域对象都会对应一个Acl，而且只会对应一个Acl。Acl是将Spring Security Acl中使用到的四个表串联起来的一个接口，其中会包含对象信息ObjectIdentity、对象的拥有者Sid和对象的访问控制信息AccessControlEntry。在Spring Security Acl中直接与acl_object_identity表相关联的是Acl接口，因为acl_object_identity表中的数据是通过保存Acl来进行的。一个Acl对应于一个ObjectIdentity，但是会包含有多个Sid和多个AccessControlEntry，即一个Acl表示所有Sid对一个ObjectIdentity的所有AccessControlEntry。Acl的默认实现类是AclImpl，该类实现Acl接口、MutableAcl接口、AuditableAcl接口和OwnershipAcl接口。<br>3.4 <strong>AccessControlEntry</strong>：一个AccessControlEntry表示一条访问控制信息，一个Acl中可以拥有多个AccessControlEntry。在Spring Security Acl中很多地方会使用ACE来简单的表示AccessControlEntry这个概念，比如insertAce其实表示的就是insert AccessControlEntry。每一个AccessControlEntry表示对应的Sid对于对应的对象ObjectIdentity是否被授权某一项权限Permission，是否被授权将使用granting进行区分。AccessControlEntry对应表acl_entry。<br>3.5 <strong>Permission</strong>：在Acl中使用一个bit掩码来表示一个Permission。Spring Security的Acl中默认使用的是BasePermission，其中已经定义了0-4五个bit掩码，分别对应于1、2、4、8、16，代表五种不同的Permission，分别是read (bit 0)、write (bit 1)、create (bit 2)、delete (bit 3)和administer (bit 4)。如果已经定义好的这五个bit掩码不能满足需求，我们可以对BasePermission进行扩展，也可以实现自己的Permission。Spring Security Acl默认的实现最多可以支持32个不同的掩码。<br>3.6 <strong>AclService</strong>：AclService是用来通过ObjectIdentity解析Acl的，其默认实现类是JdbcAclService。JdbcAclService底层操作是通过LookupStrategy来进行的，LookupStrategy的默认实现是BasicLookupStrategy。<br>3.7 <strong>MutableAclService</strong>：MutableAclService是用来对Acl进行持久化的，其默认实现类是JdbcMutableAclService。JdbcMutableAclService是继承自JdbcAclService的，所以我们可以同时通过JdbcMutableAclService对Acl进行读取和保存。如果我们希望自己来实现Acl信息的保存的话，我们也可以不使用该接口。</p>
<p>四. <strong>配置AclService</strong><br>&emsp;&emsp;AclService是使用Spring Security Acl功能的主入口。这里选择一个既可以从数据库读取Acl信息，又可以保存Acl信息到数据库的JdbcMutableAclService做示例。<br>&emsp;&emsp;JdbcMutableAclService只有一个构造方法，它接收三个参数，DataSource、LookupStrategy和AclCache。其对应配置信息如下所示：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aclService"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.jdbc.JdbcMutableAclService"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"lookupStrategy"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"aclCache"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;配置JdbcMutableAclService有一点需要注意的地方，那就是其在与数据库进行交互的时候所基于的脚本是本文开始部分我们提到的那些脚本。其对应的数据库表的主键是自增的，所以在保存Acl时所给出的脚本中没有新增主键id。比如在新增sid时默认使用的脚本是“insert into acl_sid (principal, sid) values (?, ?)”，显然对于使用Oracle数据库作为示例的我们来说这条SQL是有问题的，因为新增的时候主键不能为空，所以如果我们需要使用JdbcMutableAclService来创建Acl的话我们得给JdbcMutableAclService指定新增记录时使用的脚本。这里我们将在新增的时候从之前建立好的Sequence获取值作为主键，示例如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aclService"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.jdbc.JdbcMutableAclService"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"lookupStrategy"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"aclCache"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 指定新增acl_sid的脚本 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"insertSidSql"</span></span></div><div class="line">     <span class="attr">value</span>=<span class="string">"insert into acl_sid(id, principal, sid) values (seq_acl_sid.nextval, ?, ?)"</span> /&gt;</div><div class="line">  <span class="comment">&lt;!-- 指定新增acl_class的脚本 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"insertClassSql"</span></span></div><div class="line">     <span class="attr">value</span>=<span class="string">"insert into acl_class(id, class) values (seq_acl_class.nextval, ?)"</span> /&gt;</div><div class="line">  <span class="comment">&lt;!-- 指定新增acl_object_identity的脚本 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"insertObjectIdentitySql"</span></span></div><div class="line">     <span class="attr">value</span>=<span class="string">"insert into acl_object_identity(id, object_id_class, object_id_identity, owner_sid, entries_inheriting) values(seq_acl_object_identity.nextval, ?, ?, ?, ?)"</span> /&gt;</div><div class="line">  <span class="comment">&lt;!-- 指定新增acl_entry的脚本 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"insertEntrySql"</span></span></div><div class="line">     <span class="attr">value</span>=<span class="string">"insert into acl_entry(id, acl_object_identity, ace_order, sid, mask, granting, audit_success, audit_failure) values (seq_acl_entry.nextval, ?, ?, ?, ?, ?, ?, ?)"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;除了上述四个SQL之外，我们还需要指定两个属性对应的查询SQL，sidIdentityQuery和classIdentityQuery。因为JdbcMutableAclService在创建Acl时，如果当前用户在acl_sid表中不存在或当前对象类型在acl_class表中不存在，其会先将对应的信息存入acl_sid表和acl_class表，然后需要取出刚刚新增的acl_sid的主键和acl_class的主键以往acl_object_identity表中插入数据，对应acl_object_identity表中的owner_sid和object_id_class字段。这两个属性的默认值是“call identity()”，显然对于Oracle数据库来说这是行不通的，所以我们需要自己指定它们。这里我们通过对应Sequence的当前值来获取刚刚新增的记录的主键。如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aclService"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.jdbc.JdbcMutableAclService"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"lookupStrategy"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"aclCache"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 指定新增acl_sid的脚本 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"insertSidSql"</span></span></div><div class="line">     <span class="attr">value</span>=<span class="string">"insert into acl_sid(id, principal, sid) values (seq_acl_sid.nextval, ?, ?)"</span> /&gt;</div><div class="line">  <span class="comment">&lt;!-- 指定新增acl_class的脚本 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"insertClassSql"</span></span></div><div class="line">     <span class="attr">value</span>=<span class="string">"insert into acl_class(id, class) values (seq_acl_class.nextval, ?)"</span> /&gt;</div><div class="line">  <span class="comment">&lt;!-- 指定新增acl_object_identity的脚本 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"insertObjectIdentitySql"</span></span></div><div class="line">     <span class="attr">value</span>=<span class="string">"insert into acl_object_identity(id, object_id_class, object_id_identity, owner_sid, entries_inheriting) values(seq_acl_object_identity.nextval, ?, ?, ?, ?)"</span> /&gt;</div><div class="line">  <span class="comment">&lt;!-- 指定新增acl_entry的脚本 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"insertEntrySql"</span></span></div><div class="line">     <span class="attr">value</span>=<span class="string">"insert into acl_entry(id, acl_object_identity, ace_order, sid, mask, granting, audit_success, audit_failure) values (seq_acl_entry.nextval, ?, ?, ?, ?, ?, ?, ?)"</span> /&gt;</div><div class="line">  <span class="comment">&lt;!-- 查询刚刚新增的acl_sid的主键的SQL --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sidIdentityQuery"</span> <span class="attr">value</span>=<span class="string">"select seq_acl_sid.currval from dual"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 查询刚刚新增的acl_class的主键的SQL --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"classIdentityQuery"</span> <span class="attr">value</span>=<span class="string">"select seq_acl_class.currval from dual"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>4.1 <strong>配置DataSource</strong><br>&emsp;&emsp;配置数据源这个没什么好说的，大家都见惯了，为保持文章的完整性，我这里还是把它列一下。直接上代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"/WEB-INF/config/jdbc.properties"</span> /&gt;</span></div><div class="line"> </div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp2.BasicDataSource"</span></span></div><div class="line">  <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driverClassName&#125;"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>4.2 <strong>配置LookupStrategy</strong><br>&emsp;&emsp;LookupStrategy是用来通过ObjectIdentity解析为对应的Acl的。Spring Security Acl中的默认实现类是BasicLookupStrategy，其的构造需要接收四个参数。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lookupStrategy"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.jdbc.BasicLookupStrategy"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"aclCache"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"aclAuthorizationStrategy"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"grantingStrategy"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>4.3 <strong>配置AclAuthorizationStrategy</strong><br>&emsp;&emsp;aclAuthorizationStrategy是在构造Acl的实现类AclImpl时必须给定的一个参数，其会用来在对Acl进行某些操作时检查当前用户是否具有对应的权限。AclAuthorizationStrategy的默认实现类是AclAuthorizationStrategyImpl，其构造需要接收一个或三个GrantedAuthority参数，用来对Acl进行相关操作时所需要的权限，包括更改Acl对应对象的所有者需要的权限、更改Acl中包含的某个AccessControlEntry的audit信息（对应acl_entry表中的is_audit_success和is_audit_failure字段）需要的权限以及其它如增、删、改Acl中所包含的AccessControlEntry等需要的权限。这些权限的鉴定是我们在操作Acl时由Spring Security Acl内部进行判断的，我们只需要在这里定义就好。当Acl对应的所有者对Acl进行操作时，不管其是否拥有指定需要的权限，除了改变audit信息之外的所有操作默认都是被允许的。当只有一个参数时表示三者共用一个GrantedAuthority。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aclAuthorizationStrategy"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.domain.AclAuthorizationStrategyImpl"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.core.authority.SimpleGrantedAuthority"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"ROLE_ADMIN"</span> /&gt;</span><span class="comment">&lt;!-- 改变所有权需要的权限 --&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.core.authority.SimpleGrantedAuthority"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"gaModifyAuditing"</span> /&gt;</span><span class="comment">&lt;!-- 改变授权需要的权限 --&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.core.authority.SimpleGrantedAuthority"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"gaGeneralChanges"</span> /&gt;</span><span class="comment">&lt;!-- 改变其它信息所需要的权限 --&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>4.4 <strong>配置grantingStrategy</strong><br>&emsp;&emsp;grantingStrategy对应类型为PermissionGrantingStrategy接口，其中只定义了一个isGranted方法，用于判断基于指定的Permission列表和Sid列表指定的Acl是否被授予了访问权限。其默认实现类是DefaultPermissionGrantingStrategy。DefaultPermissionGrantingStrategy对于isGranted的实现逻辑是依次遍历Permission列表、Sid列表和Acl中包含的AccessControlEntry列表，找到第一个三者能够匹配的AccessControlEntry的isGranting（对应acl_entry表的granting字段）作为isGranted的返回结果。如果在当前Acl中没有找到匹配的AccessControlEntry，同时Acl对应的entriesInheriting为true时将继续使用父级的Acl进行匹配，并依次进行，如果都没有匹配到，则将抛出异常。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"grantingStrategy"</span></span></div><div class="line">   <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.domain.DefaultPermissionGrantingStrategy"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.domain.ConsoleAuditLogger"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>4.5 <strong>配置AclCache</strong><br>&emsp;&emsp;AclCache是用来缓存Acl信息的，Spring Security Acl中对于AclCache的默认实现是基于Ehcache的实现类EhCacheBasedAclCache。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aclCache"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.domain.EhCacheBasedAclCache"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"cache"</span> /&gt;</span><span class="comment">&lt;!-- 对应于Ehcache --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"grantingStrategy"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"aclAuthorizationStrategy"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 定义一个Ehcache --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cache"</span> <span class="attr">class</span>=<span class="string">"org.springframework.cache.ehcache.EhCacheFactoryBean"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheName"</span> <span class="attr">value</span>=<span class="string">"aclCache"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManager"</span> <span class="attr">ref</span>=<span class="string">"aclCacheManager"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 定义CacheManager --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aclCacheManager"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.cache.ehcache.EhCacheManagerFactoryBean"</span>&gt;</div><div class="line">  <span class="comment">&lt;!-- 指定配置文件的位置 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/config/ehcache.xml"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 指定新建的CacheManager的名称 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManagerName"</span> <span class="attr">value</span>=<span class="string">"aclCacheManager"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>为保持本文的完整性，这里贴出上述使用到的配置文件ehcache.xml的内容。具体如下所示：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line">   <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">"http://ehcache.org/ehcache.xsd"</span></div><div class="line">   <span class="attr">maxBytesLocalHeap</span>=<span class="string">"100M"</span>&gt;</div><div class="line"> </div><div class="line">   <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">"d:\\ehcache"</span> /&gt;</span></div><div class="line"> </div><div class="line">   <span class="tag">&lt;<span class="name">defaultCache</span> <span class="attr">maxEntriesLocalHeap</span>=<span class="string">"200"</span> /&gt;</span></div><div class="line"> </div><div class="line">   <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"aclCache"</span> <span class="attr">maxBytesLocalHeap</span>=<span class="string">"50M"</span> <span class="attr">maxBytesLocalDisk</span>=<span class="string">"5G"</span></span></div><div class="line">      <span class="attr">timeToIdleSeconds</span>=<span class="string">"120"</span> <span class="attr">timeToLiveSeconds</span>=<span class="string">"600"</span> /&gt;</div><div class="line"> </div><div class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>关于Ehcache的更多内容不在本文讨论范围之内，有需要的读者可以参考官方文档，也可以参考我的另一个关于Ehcache的系列文章。<br>至此，关于AclService配置的内容就讲完了，AclService配置的完整内容如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aclService"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.jdbc.JdbcMutableAclService"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"lookupStrategy"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"aclCache"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 指定新增acl_sid的脚本 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"insertSidSql"</span></span></div><div class="line">     <span class="attr">value</span>=<span class="string">"insert into acl_sid(id, principal, sid) values (seq_acl_sid.nextval, ?, ?)"</span> /&gt;</div><div class="line">  <span class="comment">&lt;!-- 指定新增acl_class的脚本 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"insertClassSql"</span></span></div><div class="line">     <span class="attr">value</span>=<span class="string">"insert into acl_class(id, class) values (seq_acl_class.nextval, ?)"</span> /&gt;</div><div class="line">  <span class="comment">&lt;!-- 指定新增acl_object_identity的脚本 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"insertObjectIdentitySql"</span></span></div><div class="line">     <span class="attr">value</span>=<span class="string">"insert into acl_object_identity(id, object_id_class, object_id_identity, owner_sid, entries_inheriting) values(seq_acl_object_identity.nextval, ?, ?, ?, ?)"</span> /&gt;</div><div class="line">  <span class="comment">&lt;!-- 指定新增acl_entry的脚本 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"insertEntrySql"</span></span></div><div class="line">     <span class="attr">value</span>=<span class="string">"insert into acl_entry(id, acl_object_identity, ace_order, sid, mask, granting, audit_success, audit_failure) values (seq_acl_entry.nextval, ?, ?, ?, ?, ?, ?, ?)"</span> /&gt;</div><div class="line">  <span class="comment">&lt;!-- 查询刚刚新增的acl_sid的主键的SQL --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sidIdentityQuery"</span> <span class="attr">value</span>=<span class="string">"select seq_acl_sid.currval from dual"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 查询刚刚新增的acl_class的主键的SQL --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"classIdentityQuery"</span> <span class="attr">value</span>=<span class="string">"select seq_acl_class.currval from dual"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lookupStrategy"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.jdbc.BasicLookupStrategy"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"aclCache"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"aclAuthorizationStrategy"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"grantingStrategy"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aclCache"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.domain.EhCacheBasedAclCache"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"cache"</span> /&gt;</span><span class="comment">&lt;!-- 对应于Ehcache --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"grantingStrategy"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"aclAuthorizationStrategy"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 定义一个Ehcache --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cache"</span> <span class="attr">class</span>=<span class="string">"org.springframework.cache.ehcache.EhCacheFactoryBean"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheName"</span> <span class="attr">value</span>=<span class="string">"aclCache"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManager"</span> <span class="attr">ref</span>=<span class="string">"aclCacheManager"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 定义CacheManager --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aclCacheManager"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.cache.ehcache.EhCacheManagerFactoryBean"</span>&gt;</div><div class="line">  <span class="comment">&lt;!-- 指定配置文件的位置 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/config/ehcache.xml"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 指定新建的CacheManager的名称 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManagerName"</span> <span class="attr">value</span>=<span class="string">"aclCacheManager"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aclAuthorizationStrategy"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.domain.AclAuthorizationStrategyImpl"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.core.authority.SimpleGrantedAuthority"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"ROLE_ADMIN"</span> /&gt;</span><span class="comment">&lt;!-- 改变所有权需要的权限 --&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.core.authority.SimpleGrantedAuthority"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"gaModifyAuditing"</span> /&gt;</span><span class="comment">&lt;!-- 改变授权需要的权限 --&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.core.authority.SimpleGrantedAuthority"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"gaGeneralChanges"</span> /&gt;</span><span class="comment">&lt;!-- 改变其它信息所需要的权限 --&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"grantingStrategy"</span></span></div><div class="line"><span class="attr">class</span>=<span class="string">"org.springframework.security.acls.domain.DefaultPermissionGrantingStrategy"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.domain.ConsoleAuditLogger"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>五. <strong>使用AclService</strong><br>&emsp;&emsp;配置好AclService之后我们就可以使用该JdbcMutableAclService来创建、更新和查找Acl了。在Spring Security Acl中Acl接口的默认实现类是AclImpl，该类实现Acl接口、MutableAcl接口、AuditableAcl接口和OwnershipAcl接口，当有必要在这几种接口之间切换时可以任意切换。<br>5.1 <strong>创建Acl</strong><br>&emsp;&emsp;可以通过调用JdbcMutableAclService的createAcl()方法来创建一个Acl，其对应返回的是一个MutableAcl，该方法接收一个ObjectIdentity作为参数。在创建的时候如果ObjectIdentity对应的类型在acl_class表中不存在，则会把ObjectIdentity对应的类型添加到acl_class表中；如果当前用户对应的Sid在acl_sid表中不存在则会将其添加到acl_sid中。最后会将ObjectIdentity保存到acl_object_identity表中。正如在本文开始部分所描述的那样，一个Acl对应于一个ObjectIdentity，创建Acl就是创建ObjectIdentity的过程。在这三部分都完成之后，会重新从数据库查询出一个Acl，只是此时该Acl对应的AccessControlEntry列表为空。通常如果我们的对象是需要利用Acl进行访问控制的话，那么我们可以在创建该对象的时候一并创建该对象对应的Acl。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> MutableAclService aclService;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">  ...</div><div class="line"> </div><div class="line">  <span class="comment">//1、构建一个ObjectIdentity</span></div><div class="line">  ObjectIdentity oi = <span class="keyword">new</span> ObjectIdentityImpl(User.class, user.getId());</div><div class="line"></div><div class="line">  <span class="comment">//2、创建一个Acl、此时会如果对应的信息不存在会依次创建，如当前用户对应的Sid、ObjectIdentity对应于acl_class表中的类型</span></div><div class="line">  <span class="comment">//最后是往acl_object_identity中插入对应的数据</span></div><div class="line">  MutableAcl acl = aclService.createAcl(oi);</div><div class="line"></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ObjectIdentityImpl拥有多个构造方法，具体可以参考Spring Security的API文档。</p>
<p>5.2 <strong>查找Acl</strong><br>&emsp;&emsp;通过AclService的系列readAclById()方法可以通过给定的ObjectIdentity查找对应的Acl。此外通过findChildren()方法可以查找指定ObjectIdentity的子ObjectIdentity。关于这些方法的具体信息可以参考Spring Security的API文档。以下是一个简单的示例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ObjectIdentity oi = <span class="keyword">new</span> ObjectIdentityImpl(User.class, user.getId());</div><div class="line"><span class="comment">//获取ObjectIdentity对应的Acl</span></div><div class="line">MutableAcl acl = (MutableAcl) aclService.readAclById(oi);</div></pre></td></tr></table></figure></p>
<p>5.3 <strong>更新Acl</strong><br>&emsp;&emsp;Acl的更新主要是对应AccessControlEntry的更新，即对AccessControlEntry的增、删、改；此外还包括对Acl对应的ObjectIdentity信息的变更，如更改所有者、父子关系等。<br>&emsp;&emsp; 如下是一些更新Acl的示例，需要注意的是在调用MutableAclService的updateAcl()方法将对应信息同步到数据库之前，对Acl所做的所有修改都只是在内存中的。使用updateAcl()更新Acl信息到数据库时，其底层实现会先将数据库中所有对应的AccessControlEntry都删除，然后再将内存中的AccessControlEntry列表保存到数据库中。以下是其实现代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> MutableAcl <span class="title">updateAcl</span><span class="params">(MutableAcl acl)</span> <span class="keyword">throws</span> NotFoundException </span>&#123;</div><div class="line">    Assert.notNull(acl.getId(), <span class="string">"Object Identity doesn't provide an identifier"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Delete this ACL's ACEs in the acl_entry table</span></div><div class="line">    deleteEntries(retrieveObjectIdentityPrimaryKey(acl.getObjectIdentity()));</div><div class="line"></div><div class="line">    <span class="comment">// Create this ACL's ACEs in the acl_entry table</span></div><div class="line">    createEntries(acl);</div><div class="line"></div><div class="line">    <span class="comment">// Change the mutable columns in acl_object_identity</span></div><div class="line">    updateObjectIdentity(acl);</div><div class="line"></div><div class="line">    <span class="comment">// Clear the cache, including children</span></div><div class="line">    clearCacheIncludingChildren(acl.getObjectIdentity());</div><div class="line"></div><div class="line">    <span class="comment">// Retrieve the ACL via superclass (ensures cache registration, proper retrieval etc)</span></div><div class="line">    <span class="keyword">return</span> (MutableAcl) <span class="keyword">super</span>.readAclById(acl.getObjectIdentity());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5.3.1 <strong>添加AccessControlEntry</strong><br>&emsp;&emsp;添加AccessControlEntry是通过MutableAcl的insertAce()方法进行的，该方法的定义如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/**</span></div><div class="line">  *</div><div class="line">  * <span class="doctag">@param</span> atIndexLocation 添加的位置，对应于acl_entry表中的ace_order字段</div><div class="line">  * <span class="doctag">@param</span> permission 对应的Permission</div><div class="line">  * <span class="doctag">@param</span> sid 对应Sid</div><div class="line">  * <span class="doctag">@param</span> granting 是否赋予</div><div class="line">  */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertAce</span><span class="params">(<span class="keyword">int</span> atIndexLocation, Permission permission, Sid sid, <span class="keyword">boolean</span> granting)</span></span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;参数atIndexLocation对应的是需要插入的AccessControlEntry在Acl对应的AccessControlEntry列表（java.util.List类型）中的位置，对应于acl_entry表中ace_order，而一个Acl代表其对应ObjectIdentity的所有关联Sid关联的所有AccessControlEntry，这个ace_order是在这个范围内的order。以下是一个添加AccessControlEntry的示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">MutableAcl acl = ...;</div><div class="line"> </div><div class="line"><span class="comment">//基于principal的Sid</span></div><div class="line">Sid sid = <span class="keyword">new</span> PrincipalSid(SecurityContextHolder.getContext().getAuthentication());</div><div class="line">Permission p = BasePermission.ADMINISTRATION;<span class="comment">//管理员权限</span></div><div class="line"><span class="comment">//将当前Acl的管理员权限赋予给指定的Sid</span></div><div class="line">acl.insertAce(acl.getEntries().size(), p, sid, <span class="keyword">true</span>);   <span class="comment">//添加AccessControlEntry到内存</span></div><div class="line"><span class="comment">//保存到数据库</span></div><div class="line">acl = aclService.updateAcl(acl);</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上述的Sid，也可以是一个GrantedAuthoritySid，当把一个Acl的某Permission赋予给一个GrantedAuthoritySid时表示拥有该GrantedAuthority的用户都将拥有对应的Permission。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">MutableAcl acl = ...;</div><div class="line"> </div><div class="line"><span class="comment">//基于GrantedAuthority的Sid</span></div><div class="line">Sid sid = <span class="keyword">new</span> GrantedAuthoritySid(<span class="string">"ROLE_ADMIN"</span>);</div><div class="line">Permission p = BasePermission.ADMINISTRATION;<span class="comment">//管理员权限</span></div><div class="line"><span class="comment">//将当前Acl的管理员权限赋予给指定的Sid</span></div><div class="line">acl.insertAce(acl.getEntries().size(), p, sid, <span class="keyword">true</span>);   <span class="comment">//添加AccessControlEntry到内存</span></div><div class="line"><span class="comment">//保存到数据库</span></div><div class="line">acl = aclService.updateAcl(acl);</div></pre></td></tr></table></figure></p>
<p>5.3.2 <strong>删除AccessControlEntry</strong><br>&emsp;&emsp;通过调用MutableAcl的deleteAce(int aceIndex)方法可以删除Acl中指定位置的AccessControlEntry，aceIndex是从0开始的，底层是使用的List的remove(int index)方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ObjectIdentity oi = <span class="keyword">new</span> ObjectIdentityImpl(User.class, user.getId());</div><div class="line"><span class="comment">//获取ObjectIdentity对应的Acl</span></div><div class="line">MutableAcl acl = (MutableAcl) aclService.readAclById(oi);</div><div class="line">acl.deleteAce(<span class="number">0</span>);<span class="comment">//内存中删除第一个AccessControlEntry</span></div><div class="line">aclService.updateAcl(acl);<span class="comment">//同步到数据库</span></div></pre></td></tr></table></figure></p>
<p>5.3.3 <strong>更新AccessControlEntry</strong><br>&emsp;&emsp;通过MutableAcl的updateAce()可以更新指定位置的AccessControlEntry的Permission。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ObjectIdentity oi = <span class="keyword">new</span> ObjectIdentityImpl(User.class, user.getId());</div><div class="line"><span class="comment">//获取ObjectIdentity对应的Acl</span></div><div class="line">MutableAcl acl = (MutableAcl) aclService.readAclById(oi);</div><div class="line">acl.updateAce(<span class="number">0</span>, BasePermission.CREATE);<span class="comment">//内存中更新第一个AccessControlEntry对应的Permission</span></div><div class="line">aclService.updateAcl(acl);<span class="comment">//同步到数据库</span></div></pre></td></tr></table></figure></p>
<p>5.3.4 <strong>修改所有者</strong><br>&emsp;&emsp;可以通过Acl的getOwner()方法获取Acl对应ObjectIdentity的拥有者Sid。通过MutableAcl的setOwner()方法可以在内存中更新对应Acl的拥有者。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ObjectIdentity oi = <span class="keyword">new</span> ObjectIdentityImpl(User.class, user.getId());</div><div class="line"><span class="comment">//获取ObjectIdentity对应的Acl</span></div><div class="line">MutableAcl acl = (MutableAcl) aclService.readAclById(oi);</div><div class="line">acl.setOwner(<span class="keyword">new</span> PrincipalSid(<span class="string">"user"</span>));<span class="comment">//内存中更改拥有者</span></div><div class="line">aclService.updateAcl(acl);<span class="comment">//同步到数据库</span></div></pre></td></tr></table></figure></p>
<p>5.3.5 <strong>修改父Acl</strong><br>&emsp;&emsp;通过Acl的getParentAcl()方法可以获取到Acl对应ObjectIdentity对应的父ObjectIdentity对应的Acl。通过MutableAcl的setParent()方法可以在内存中修改Acl对应的父Acl，即修改Acl对应ObjectIdentity对应的父ObjectIdentity。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ObjectIdentity oi = <span class="keyword">new</span> ObjectIdentityImpl(User.class, user.getId());</div><div class="line"><span class="comment">//获取ObjectIdentity对应的Acl</span></div><div class="line">MutableAcl acl = (MutableAcl) aclService.readAclById(oi);</div><div class="line">Acl newParent = ...;<span class="comment">//以某种方式获取到Acl</span></div><div class="line">acl.setParent(newParent);<span class="comment">//内存中更改父Acl</span></div><div class="line">aclService.updateAcl(acl);<span class="comment">//同步到数据库</span></div></pre></td></tr></table></figure></p>
<p>5.3.6 <strong>修改继承策略</strong><br>&emsp;&emsp;通过Acl的isEntriesInheriting()可以获取到当前Acl对应ObjectIdentity的继承策略，创建Acl时该值默认为true。通过MutableAcl的setEntriesInheriting()方法可以在内存中修改该Acl对应ObjectIdentity的继承策略。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ObjectIdentity oi = new ObjectIdentityImpl(User.class, user.getId());</div><div class="line">//获取ObjectIdentity对应的Acl</div><div class="line">MutableAcl acl = (MutableAcl) aclService.readAclById(oi);</div><div class="line">acl.setEntriesInheriting(false);//内存中修改为不从父Acl继承AccessControlEntry</div><div class="line">aclService.updateAcl(acl);//同步到数据库</div></pre></td></tr></table></figure></p>
<p>5.4 <strong>删除Acl</strong><br>&emsp;&emsp;当我们删除对象的时候应该连同对应的Acl也一起删除。使用MutableAclService的deleteAcl(ObjectIdentity oi, boolean deleteChildren)方法可以删除指定ObjectIdentity对应的Acl，deleteChildren表示是否连同子ObjectIdentity对应的Acl也一起删除。deleteAcl将删除对应的ObjectIdentity，以及对应的AccessControlEntry，即其会删除acl_object_identity表和acl_entry表中与当前Acl对应的ObjectIdentity相关的记录。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ObjectIdentity objectIdentity = <span class="keyword">new</span> ObjectIdentityImpl(User.class, id);</div><div class="line">aclService.deleteAcl(objectIdentity, <span class="keyword">true</span>);</div></pre></td></tr></table></figure></p>
<p>六. <strong>注入到AclPermissionEvaluator</strong><br>&emsp;&emsp;AclPermissionEvaluator是PermissionEvaluator的一个实现类。在之前关于使用基于表达式的权限控制一文中有提到过，PermissionEvaluator是为表达式hasPermission提供支持的。此外，PermissionEvaluator还为标签accesscontrollist提供支持。本节将就使用AclPermissionEvaluator支持在方法上使用@PreAuthorize进行权限控制时使用表达式hasPermission做一个简单讲解。<br>&emsp;&emsp;AclPermissionEvaluator的构造需要接收一个AclService参数，在进行权限鉴定时其需要通过AclService获取到对应对象对应的Acl，然后判断该Acl中是否具有指定的Sid和指定的Permission。<br>&emsp;&emsp;对于方法使用hasPermission表达式进行权限鉴定时需要做两个事情，首先需要指定global-method-security的pre-post-annotations=”enabled”。其次需要手工定义DefaultMethodSecurityExpressionHandler并指定其permissionEvaluator为我们定义的AclPermissionEvaluator。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:global-method-security</span> <span class="attr">pre-post-annotations</span>=<span class="string">"enabled"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:expression-handler</span> <span class="attr">ref</span>=<span class="string">"expressionHandler"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:global-method-security</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"expressionHandler"</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"permissionEvaluator"</span> <span class="attr">ref</span>=<span class="string">"aclPermissionEvaluator"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aclPermissionEvaluator"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.AclPermissionEvaluator"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"aclService"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;定义后之后我们就可以在方法上使用@PreAuthorize和hasPermission表达式了。关于PermissionEvaluator和hasPermission的更多介绍可以参考《基于表达式的权限控制》一文。hasPermission有两种用法，一种是直接传一个对象和对应需要的权限，如hasPermission(object,permission)；另一种是传对象的id、对应类型和需要的权限，如hasPermission(targetId,targetType,permission)。传入的Permission是Spring Security Acl中的Permission接口实现类，而不是Spring Security的GrantedAuthority。传入的permission参数可以是一个Permission对象或Permission对象数组，也可以是一个整数或字符串。当传入的permission是整数或字符串时将由AclPermissionEvaluator的PermissionFactory进行解析，AclPermissionEvaluator默认拥有的PermissionFactory是DefaultPermissionFactory，其会将整形或字符串类型的permission解析成对应的BasePermission。如前所述，BasePermission中定义了五个BasePermission，其对应的名称和掩码分别为：READ (1)、WRITE (2)、CREATE (4)、DELETE (8)和ADMINISTER (16)。当permission使用字符串时我们只能使用这五种字符串，不区分大小写，表示当前用户或其所拥有的GrantedAuthority必须拥有指定对象的指定Permission才允许访问。但是当使用掩码时我们可以使用1、2、4、8和16。<br>&emsp;&emsp;接下来将简单的介绍一个使用@PreAuthorize和hasPermission表达式在方法上进行权限控制的示例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@PreAuthorize(&quot;hasPermission(#id, &apos;com.spring.security.entity.User&apos;, 1)&quot;)</div><div class="line">public User find(int id) &#123;</div><div class="line">  User user = new User();</div><div class="line">  user.setId(id);</div><div class="line">  return user;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上述配置即表示调用find方法查看指定id对应的User对象时必须拥有掩码为1对应的Permission才行，或者在继续策略为true时拥有指定id父对象掩码为1对应的Permission也行。这时哪怕你是该User对象的拥有者，或者你拥有ADMINISTER权限，如果你没有对应的READ权限，你也不能访问该方法。如果觉得这种实现不符合你的要求，你可以实现自己的PermissionGrantingStrategy，然后将实现类bean注入到BasicLookupStrategy和EhcacheBasedAclCache中，这样在判断一个用户是否具有指定Acl的指定Permission时就可以使用自己的逻辑了。<br>&emsp;&emsp;上面的定义如果改成permission参数直接使用对象，可以这样定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PreAuthorize</span>(<span class="string">"hasPermission(#id, 'com.spring.security.entity.User', T(org.springframework.security.acls.domain.BasePermission).READ)"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">  User user = <span class="keyword">new</span> User();</div><div class="line">  user.setId(id);</div><div class="line">  <span class="keyword">return</span> user;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;当permission参数定义为一个Permission数组时，会根据顺序依次匹配当前用户在指定的Acl中是否拥有对应Permission的AccessControlEntry，如果拥有则以第一个匹配到的AccessControlEntry的granting属性作为判断结果，没有匹配到还可以根据继承策略决定是否利用父级Acl进行匹配，都没匹配到就会抛异常了。<br>&emsp;&emsp;默认使用的BasePermission中只定义了五种Permission，如果这不能满足你的要求，那么我们可以实现自己的Permission，然后把它们注册到DefaultPermissionFactory中，并手工将该DefaultPermissionFactory注入到AclPermissionEvaluator中。前文已经说过AclPermissionEvaluator中使用的PermissionFactory默认是DefaultPermissionFactory，DefaultPermissionFactory中默认只注册了BasePermission中对应的五种Permission。以下是一个扩展Permission的简单示例。<br>&emsp;&emsp;首先实现自己的Permission类，这里简单的定义一个自己的类，然后继承BasePermission类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePermissionExt</span> <span class="keyword">extends</span> <span class="title">BasePermission</span> </span>&#123;</div><div class="line"> </div><div class="line"><span class="comment">/**</span></div><div class="line">* serialVersionUID</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">BasePermissionExt</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</div><div class="line">  <span class="keyword">super</span>(mask);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">BasePermissionExt</span><span class="params">(<span class="keyword">int</span> mask, <span class="keyword">char</span> code)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(mask, code);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;然后在DefaultPermissionFactory中注册基于我们自己实现的Permission对象，并将该DefaultPermissionFactory注入到AclPermissionEvaluator中。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aclPermissionEvaluator"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.AclPermissionEvaluator"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"aclService"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 手工注册DefaultPermissionFactory和其中的Permission --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"permissionFactory"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.domain.DefaultPermissionFactory"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"READ"</span>&gt;</span></div><div class="line">                  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.xxx.spring.security.BasePermissionExt"</span>&gt;</span></div><div class="line">                     <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></div><div class="line">                  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">               <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"WRITE"</span>&gt;</span></div><div class="line">                  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.xxx.spring.security.BasePermissionExt"</span>&gt;</span></div><div class="line">                     <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"2"</span>/&gt;</span></div><div class="line">                  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">               <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>此外，还可以将我们的BasePermissionExt改成如下这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePermissionExt</span> <span class="keyword">extends</span> <span class="title">BasePermission</span> </span>&#123;</div><div class="line"> </div><div class="line">   <span class="comment">/**</span></div><div class="line">    * serialVersionUID</div><div class="line">    */</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> longserialVersionUID = <span class="number">1L</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Permission READ = <span class="keyword">new</span> BasePermissionExt(<span class="number">1</span> &lt;&lt; <span class="number">0</span>, <span class="string">'R'</span>); <span class="comment">// 1</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Permission WRITE = <span class="keyword">new</span> BasePermissionExt(<span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="string">'W'</span>); <span class="comment">// 2</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Permission CREATE = <span class="keyword">new</span> BasePermissionExt(<span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="string">'C'</span>); <span class="comment">// 4</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Permission DELETE = <span class="keyword">new</span> BasePermissionExt(<span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="string">'D'</span>); <span class="comment">// 8</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Permission ADMINISTRATION = <span class="keyword">new</span> BasePermissionExt(<span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="string">'A'</span>); <span class="comment">// 16</span></div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BasePermissionExt</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</div><div class="line">      <span class="keyword">super</span>(mask);</div><div class="line">   &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasePermissionExt</span><span class="params">(<span class="keyword">int</span> mask, <span class="keyword">char</span> code)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(mask, code);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后通过传入Class参数来构造DefaultPermissionFactory。这个时候会将对应Class中所有类型为Permission的字段分别以字段名和字段值Permission对应的掩码为Key，以字段值Permission为Value进行注册。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aclPermissionEvaluator"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.AclPermissionEvaluator"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"aclService"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 手工注册DefaultPermissionFactory和其中的Permission --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"permissionFactory"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.domain.DefaultPermissionFactory"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"com.spring.security.BasePermissionExt"</span>/&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Spring/Security/配置十九：对Acl的支持/" data-id="cj6vztsdq0081oablchjkc0c4" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Spring/Security/配置十三：session管理" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Spring/Security/配置十三：session管理/">配置十三：session管理</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/15/Spring/Security/配置十三：session管理/" class="article-date"><time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a> / <a class="article-category-link" href="/categories/Spring/Security/">Security</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p> &emsp;&emsp;Spring Security通过http元素下的子元素session-management提供了对Http Session管理的支持。</p>
<p> 一. <strong>检测session超时</strong><br>&emsp;&emsp;Spring Security可以在用户使用已经超时的sessionId进行请求时将用户引导到指定的页面。这个可以通过如下配置来实现。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">security:http</span>&gt;</span></div><div class="line">      ...</div><div class="line">  <span class="comment">&lt;!-- session管理，invalid-session-url指定使用已经超时的sessionId进行请求需要重定向的页面 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:session-management</span> <span class="attr">invalid-session-url</span>=<span class="string">"/session_timeout.jsp"</span>/&gt;</span></div><div class="line">  ...</div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;需要注意的是session超时的重定向页面应当是不需要认证的，否则再重定向到session超时页面时会直接转到用户登录页面。此外如果你使用这种方式来检测session超时，当你退出了登录，然后在没有关闭浏览器的情况下又重新进行了登录，Spring Security可能会错误的报告session已经超时。这是因为即使你已经退出登录了，但当你设置session无效时，对应保存session信息的cookie并没有被清除，等下次请求时还是会使用之前的sessionId进行请求。解决办法是显示的定义用户在退出登录时删除对应的保存session信息的cookie。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span>&gt;</span></div><div class="line">  ...</div><div class="line">  <span class="comment">&lt;!-- 退出登录时删除session对应的cookie --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:logout</span> <span class="attr">delete-cookies</span>=<span class="string">"JSESSIONID"</span>/&gt;</span></div><div class="line">  ...</div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;此外，Spring Security并不保证这对所有的Servlet容器都有效，到底在你的容器上有没有效，需要你自己进行实验。</p>
<p>二. <strong>concurrency-control</strong><br>&emsp;&emsp;通常情况下，在你的应用中你可能只希望同一用户在同时登录多次时只能有一个是成功登入你的系统的，通常对应的行为是后一次登录将使前一次登录失效，或者直接限制后一次登录。Spring Security的session-management为我们提供了这种限制。<br>&emsp;&emsp;首先需要我们在web.xml中定义如下监听器。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">listener</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.security.web.session.HttpSessionEventPublisher<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在session-management元素下有一个concurrency-control元素是用来限制同一用户在应用中同时允许存在的已经通过认证的session数量。这个值默认是1，可以通过concurrency-control元素的max-sessions属性来指定。<br> <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">security:http</span> <span class="attr">auto-config</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">      ...</div><div class="line">      <span class="tag">&lt;<span class="name">security:session-management</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">security:concurrency-control</span> <span class="attr">max-sessions</span>=<span class="string">"1"</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">security:session-management</span>&gt;</span></div><div class="line">      ...</div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;当同一用户同时存在的已经通过认证的session数量超过了max-sessions所指定的值时，Spring Security的默认策略是将先前的设为无效。如果要限制用户再次登录可以设置concurrency-control的error-if-maximum-exceeded的值为true。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">security:http</span> <span class="attr">auto-config</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">      ...</div><div class="line">      <span class="tag">&lt;<span class="name">security:session-management</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">security:concurrency-control</span> <span class="attr">max-sessions</span>=<span class="string">"1"</span> <span class="attr">error-if-maximum-exceeded</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">security:session-management</span>&gt;</span></div><div class="line">      ...</div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;设置error-if-maximum-exceeded为true后如果你之前已经登录了，然后想再次登录，那么系统将会拒绝你的登录，同时将重定向到由form-login指定的authentication-failure-url。如果你的再次登录是通过Remember-Me来完成的，那么将不会转到authentication-failure-url，而是返回未授权的错误码401给客户端，如果你还是想重定向一个指定的页面，那么你可以通过session-management的session-authentication-error-url属性来指定，同时需要指定该url为不受Spring Security管理，即通过http元素设置其secure=”none”。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">security:http</span> <span class="attr">security</span>=<span class="string">"none"</span> <span class="attr">pattern</span>=<span class="string">"/none/**"</span> /&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">security:http</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:form-login</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:logout</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span>/&gt;</span></div><div class="line">      <span class="comment">&lt;!-- session-authentication-error-url必须是不受Spring Security管理的 --&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:session-management</span> <span class="attr">session-authentication-error-url</span>=<span class="string">"/none/session_authentication_error.jsp"</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">security:concurrency-control</span> <span class="attr">max-sessions</span>=<span class="string">"1"</span> <span class="attr">error-if-maximum-exceeded</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">security:session-management</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:remember-me</span> <span class="attr">data-source-ref</span>=<span class="string">"dataSource"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在上述配置中我们配置了session-authentication-error-url为“/none/session_authentication_error.jsp”，同时我们通过<code>&lt;security:http security=&quot;none&quot; pattern=&quot;/none/**&quot; /&gt;</code>指定了以“/none”开始的所有URL都不受Spring Security控制，这样当用户进行登录以后，再次通过Remember-Me进行自动登录时就会重定向到“/none/session_authentication_error.jsp”了。<br>&emsp;&emsp;在上述配置中为什么我们需要通过<code>&lt;security:http security=&quot;none&quot; pattern=&quot;/none/**&quot; /&gt;</code>指定我们的session-authentication-error-url不受Spring Security控制呢？把它换成<code>&lt;security:intercept-url pattern=&quot;/none/**&quot; access=&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot;/&gt;</code>不行吗？这就涉及到之前所介绍的它们两者之间的区别了。前者表示不使用任何Spring Security过滤器，自然也就不需要通过Spring Security的认证了，而后者是会被Spring Security的FilterChain进行过滤的，只是其对应的URL可以匿名访问，即不需要登录就可访问。使用后者时，REMEMBER_ME_FILTER检测到用户没有登录，同时其又提供了Remember-Me的相关信息，这将使得REMEMBER_ME_FILTER进行自动登录，那么在自动登录时由于我们限制了同一用户同一时间只能登录一次，后来者将被拒绝登录，这个时候将重定向到session-authentication-error-url，重定向访问session-authentication-error-url时，经过REMEMBER_ME_FILTER时又会自动登录，这样就形成了一个死循环。所以session-authentication-error-url应当使用<code>&lt;security:http security=&quot;none&quot; pattern=&quot;/none/**&quot; /&gt;</code>设置为不受Spring Security控制，而不是使用<code>&lt;security:intercept-url pattern=&quot;/none/**&quot; access=&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot;/&gt;</code>。<br>&emsp;&emsp;此外，可以通过expired-url属性指定当用户尝试使用一个由于其再次登录导致session超时的session时所要跳转的页面。同时需要注意设置该URL为不需要进行认证。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span> <span class="attr">auto-config</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:form-login</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:logout</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/expired.jsp"</span> <span class="attr">access</span>=<span class="string">"IS_AUTHENTICATED_ANONYMOUSLY"</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:session-management</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">security:concurrency-control</span> <span class="attr">max-sessions</span>=<span class="string">"1"</span> <span class="attr">expired-url</span>=<span class="string">"/expired.jsp"</span> /&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">security:session-management</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>三. <strong>session 固定攻击保护</strong><br>&emsp;&emsp;session固定是指服务器在给客户端创建session后，在该session过期之前，它们都将通过该session进行通信。session 固定攻击是指恶意攻击者先通过访问应用来创建一个session，然后再让其他用户使用相同的session进行登录（比如通过发送一个包含该sessionId参数的链接），待其他用户成功登录后，攻击者利用原来的sessionId访问系统将和原用户获得同样的权限。Spring Security默认是对session固定攻击采取了保护措施的，它会在用户登录的时候重新为其生成一个新的session。如果你的应用不需要这种保护或者该保护措施与你的某些需求相冲突，你可以通过session-management的session-fixation-protection属性来改变其保护策略。该属性的可选值有如下三个。  </p>
<ul>
<li><strong>migrateSession</strong>：这是默认值。其表示在用户登录后将新建一个session，同时将原session中的attribute都copy到新的session中。</li>
<li><strong>none</strong>：表示继续使用原来的session。</li>
<li><strong>newSession</strong>：表示重新创建一个新的session，但是不copy原session拥有的attribute。</li>
</ul>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Spring/Security/配置十三：session管理/" data-id="cj6vztsdp007zoablzqsy3xu8" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Spring/Security/配置五：异常信息本地化" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Spring/Security/配置五：异常信息本地化/">配置五：异常信息本地化</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/15/Spring/Security/配置五：异常信息本地化/" class="article-date"><time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a> / <a class="article-category-link" href="/categories/Spring/Security/">Security</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;Spring Security支持将展现给终端用户看的异常信息本地化，这些信息包括认证失败、访问被拒绝等。而对于展现给开发者看的异常信息和日志信息（如配置错误）则是不能够进行本地化的，它们是以英文硬编码在Spring Security的代码中的。在Spring-Security-core-xxx.jar包的org.springframework.security包下拥有一个以英文异常信息为基础的messages.properties文件，以及其它一些常用语言的异常信息对应的文件，如messages_zh_CN.properties文件。那么对于用户而言所需要做的就是在自己的ApplicationContext中定义如下这样一个bean。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageSource"</span></span></div><div class="line">    <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ReloadableResourceBundleMessageSource"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basename"</span></span></div><div class="line">         <span class="attr">value</span>=<span class="string">"classpath:org/springframework/security/messages"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果要自己定制messages.properties文件，或者需要新增本地化支持文件，则可以copy Spring Security提供的默认messages.properties文件，将其中的内容进行修改后再注入到上述bean中。比如我要定制一些中文的提示信息，那么我可以在copy一个messages.properties文件到类路径的“com/xxx”下，然后将其重命名为messages_zh_CN.properties，并修改其中的提示信息。然后通过basenames属性注入到上述bean中，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> &lt;bean id=&quot;messageSource&quot;</div><div class="line">   class=&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot;&gt;</div><div class="line">  &lt;property name=&quot;basenames&quot;&gt;</div><div class="line">     &lt;array&gt;</div><div class="line">        &lt;!-- 将自定义的放在Spring Security内置的之前 --&gt;</div><div class="line">        &lt;value&gt;classpath:com/xxx/messages&lt;/value&gt;</div><div class="line">        &lt;value&gt;classpath:org/springframework/security/messages&lt;/value&gt;</div><div class="line">     &lt;/array&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;有一点需要注意的是将自定义的messages.properties文件路径定义在Spring Security内置的message.properties路径定义之前。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Spring/Security/配置五：异常信息本地化/" data-id="cj6vztsdi007foabllcd31log" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  


  <div id="page-nav">
    <nav><ul class="pagination"><li class="disabled"><span class="page-prev"><i class="fa fa-chevron-left"></i> Prev</a></li><li class="active"><span class="page-number">1</span></li><li><a class="page-number" href="/page/2/">2</a></li><li><a class="page-number" href="/page/3/">3</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/19/">19</a></li><li><a class="page-next" rel="next" href="/page/2/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-module-inset">
  <h4>关于</h4>
  <p>该博客内的文章是博主在日常工作或者学习中总结出来，部分内容来自网络.</p>

</div>


  
  <div class="sidebar-module">
    <h4>分类</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Eclipse/">Eclipse</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Github/">Github</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/">Java</a><span class="sidebar-module-list-count">67</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/Cookie/">Cookie</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/JAXB/">JAXB</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/JavaMail/">JavaMail</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/基础/">基础</a><span class="sidebar-module-list-count">15</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/数据类型/">数据类型</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/日记/">日记</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/线程/">线程</a><span class="sidebar-module-list-count">16</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/网络NIO/">网络NIO</a><span class="sidebar-module-list-count">12</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/队列/">队列</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/集合/">集合</a><span class="sidebar-module-list-count">3</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Linux/">Linux</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Maven/">Maven</a><span class="sidebar-module-list-count">9</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/">Spring</a><span class="sidebar-module-list-count">56</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Application-Event/">Application Event</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/JPA/">JPA</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Security/">Security</a><span class="sidebar-module-list-count">22</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Task/">Task</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/spring-MVC/">spring MVC</a><span class="sidebar-module-list-count">17</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/spring-data-redis/">spring data redis</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/基础/">基础</a><span class="sidebar-module-list-count">5</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/前端技术相关/">前端技术相关</a><span class="sidebar-module-list-count">3</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/前端技术相关/forever/">forever</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/前端技术相关/javascript/">javascript</a><span class="sidebar-module-list-count">1</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/数据库相关/">数据库相关</a><span class="sidebar-module-list-count">11</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/数据库相关/mysql/">mysql</a><span class="sidebar-module-list-count">11</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/">服务器相关</a><span class="sidebar-module-list-count">22</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Hessian/">Hessian</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Hudson-Jenkins/">Hudson & Jenkins</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Memcached/">Memcached</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Tomcat/">Tomcat</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/red5/">red5</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/redis/">redis</a><span class="sidebar-module-list-count">9</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/resin/">resin</a><span class="sidebar-module-list-count">3</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/网络/">网络</a><span class="sidebar-module-list-count">7</span></li></ul>
  </div>



  


  

  
  <div class="sidebar-module">
    <h4>归档</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">60</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">124</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>最近文章</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/2017/08/28/Java/基础/java三大特性/">java三大特性</a>
        </li>
      
        <li>
          <a href="/2017/08/28/Java/基础/Filter过滤器/">Filter过滤器</a>
        </li>
      
        <li>
          <a href="/2017/08/27/Java/基础/泛型/">泛型</a>
        </li>
      
        <li>
          <a href="/2017/08/27/Java/基础/面向对象7大原则/">面向对象7大原则</a>
        </li>
      
        <li>
          <a href="/2017/08/16/Java/基础/java动态代理/">java动态代理</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2017 LeoChan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>



<script src="/js/script.js"></script>

</body>
</html>
