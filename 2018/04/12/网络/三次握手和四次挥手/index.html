<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>三次握手和四次挥手 | LeoChan&#39;s 个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="建立TCP需要三次握手才能建立，而断开连接则需要四次握手。整个过程如下图所示：     Client端所经历的状态：  Server端所经历的状态：  三次握手      seq（Sequence Number）：发送序列号 ，占4个字节，范围[0,4284967296],由于TCP是面向字节流的，在一个1个TCP连接中传送字节流中国的每一个字节都按照顺序编号，此外序号是循环使用的  ACK（Ac">
<meta property="og:type" content="article">
<meta property="og:title" content="三次握手和四次挥手">
<meta property="og:url" content="https://clq2owesome.github.io/2018/04/12/网络/三次握手和四次挥手/index.html">
<meta property="og:site_name" content="LeoChan&#39;s 个人博客">
<meta property="og:description" content="建立TCP需要三次握手才能建立，而断开连接则需要四次握手。整个过程如下图所示：     Client端所经历的状态：  Server端所经历的状态：  三次握手      seq（Sequence Number）：发送序列号 ，占4个字节，范围[0,4284967296],由于TCP是面向字节流的，在一个1个TCP连接中传送字节流中国的每一个字节都按照顺序编号，此外序号是循环使用的  ACK（Ac">
<meta property="og:image" content="https://raw.githubusercontent.com/clq2owesome/image/master/tcp.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/clq2owesome/image/master/client4.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/clq2owesome/image/master/server4.jpg">
<meta property="og:image" content="http://s3.51cto.com/wyfs02/M01/11/7C/wKioL1LSW6rjI1nhAAE63Uv8ZRY731.jpg?_=5959335">
<meta property="og:image" content="https://raw.githubusercontent.com/clq2owesome/image/master/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg">
<meta property="og:updated_time" content="2018-04-12T01:54:37.144Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="三次握手和四次挥手">
<meta name="twitter:description" content="建立TCP需要三次握手才能建立，而断开连接则需要四次握手。整个过程如下图所示：     Client端所经历的状态：  Server端所经历的状态：  三次握手      seq（Sequence Number）：发送序列号 ，占4个字节，范围[0,4284967296],由于TCP是面向字节流的，在一个1个TCP连接中传送字节流中国的每一个字节都按照顺序编号，此外序号是循环使用的  ACK（Ac">
<meta name="twitter:image" content="https://raw.githubusercontent.com/clq2owesome/image/master/tcp.jpg">
  
    <link rel="alternate" href="/atom.xml" title="LeoChan&#39;s 个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LeoChan&#39;s 个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术都是通用的，重要的是是否具有自主解决问题的能力！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://clq2owesome.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-网络/三次握手和四次挥手" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/12/网络/三次握手和四次挥手/" class="article-date">
  <time datetime="2018-04-12T02:09:45.000Z" itemprop="datePublished">2018-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络/">网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      三次握手和四次挥手
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>建立TCP需要三次握手才能建立，而断开连接则需要四次握手。整个过程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/clq2owesome/image/master/tcp.jpg" alt="image">   </p>
<p>Client端所经历的状态：</p>
<p><img src="https://raw.githubusercontent.com/clq2owesome/image/master/client4.jpg" alt="image"></p>
<p>Server端所经历的状态：</p>
<p><img src="https://raw.githubusercontent.com/clq2owesome/image/master/server4.jpg" alt="image"></p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="http://s3.51cto.com/wyfs02/M01/11/7C/wKioL1LSW6rjI1nhAAE63Uv8ZRY731.jpg?_=5959335" alt="image">    </p>
<ul>
<li><strong>seq（Sequence Number）</strong>：发送序列号 ，占4个字节，范围[0,4284967296],由于TCP是面向字节流的，在一个1个TCP连接中传送字节流中国的每一个字节都按照顺序编号，此外序号是循环使用的 </li>
<li><strong>ACK（Acknowledgment Number）</strong>：确认序列号， 仅当ACK=1时确认字段才有效，当ACK=0时确认字段无效，<strong>并且TCP规定，在连接建立后所有的传送报文段都必须要把ACK置为1</strong></li>
<li><strong>SYN</strong>：同步序列号，用来发起一个连接。<strong>当SYN=1而ACK=0时表明这是一个请求报文段；若对方同意连接，则响应报文中SYN=1，ACK=1</strong></li>
<li><strong>FIN</strong> ：用来释放一个连接，<strong>当FIN=1表示此报文段的发送方已经发送完毕。并要求释放链接</strong></li>
</ul>
<ol>
<li><p>客户端的TCP进程也首先创建传输控制模块TCB，然后向服务端发出连接请求报文段，<strong>该报文段首部中的SYN=1，ACK=0</strong>，同时选择一个初始序号 seq=x。<strong>TCP规定，SYN=1的报文段不能携带数据，但要消耗掉一个序号</strong>。这时，<strong>TCP客户进程进入SYN—SENT（同步已发送）状态，这是 TCP连接的第一次握手</strong>。</p>
</li>
<li><p>Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN=1，ACK=1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server 自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。同样该报文段也是SYN=1的报文段，不能携带数据，但同样要消耗掉一个序号。这时<strong>服务器进入SYN—RCVD（同 步收到），表示服务器已经收到Client的连接请求，等待client的确认，这是TCP连接的第二次握手</strong>。</p>
</li>
<li><p>TCP客户端进程收到服务端进程的确认后，还要向服务端给出确认。确认报文段的ACK=1，确认号ack=y+1，而自己的序号为seq=x+1。 <strong>TCP的标准规定，ACK报文段可以携带数据，但如果不携带数据则不消耗序号，因此，如果不携带数据，则下一个报文段的序号仍为seq=x+1</strong>。这 时，<strong>TCP连接已经建立，客户端进入ESTABLISHED（已建立连接）状态。这是TCP连接的第三次握手，可以看出第三次握手客户端已经可以发送携带 数据的报文段了</strong></p>
<p> 当服务端收到确认后，也进入ESTABLISHED（已建立连接）状态。</p>
</li>
</ol>
<h4 id="三次握手的一些问题"><a href="#三次握手的一些问题" class="headerlink" title="三次握手的一些问题"></a>三次握手的一些问题</h4><h6 id="为什么要进行第三次握手"><a href="#为什么要进行第三次握手" class="headerlink" title="为什么要进行第三次握手"></a>为什么要进行第三次握手</h6><p>前俩比较容易理解，第三次握手看似多余其实不然，这<strong>主要是为了防止已失效的请求报文段突然又传送到了服务端而产生连接的误判</strong> </p>
<p>比如：客户端发送了一个连接请求报文段A到服务端，但是在某些网络节点上长时间滞留了，而后客户端又超时重发了一个连接请求报文段B该服务端，而后 正常建立连接，数据传输完毕，并释放了连接。但是请求报文段A延迟了一段时间后，又到了服务端，这本是一个早已失效的报文段，但是服务端收到后会误以为客户端又发出了一次连接请求，于是向客户端发出确认报文段，并同意建立连接。那么问题来了，假如这里没有三次握手，这时服务端只要发送了确认，新的连接就建立了，但由于客户端没有发出建立连接的请求，因此不会理会服务端的确认，也不会向服务端发送数据，而服务端却认为新的连接已经建立了，并在 一直等待客户端发送数据，这样服务端就会一直等待下去，直到超出保活计数器的设定值，而将客户端判定为出了问题，才会关闭这个连接。这样就浪费了很多服务 器的资源。而如果采用三次握手，客户端就不会向服务端发出确认，服务端由于收不到确认，就知道客户端没有要求建立连接，从而不建立该连接。</p>
<h6 id="SYN-Flood-攻击"><a href="#SYN-Flood-攻击" class="headerlink" title="SYN Flood 攻击"></a>SYN Flood 攻击</h6><p>SYN- Flood攻击是当前网络上最为常见的DDoS攻击，也是最为经典的拒绝服务攻击，它就是利用了TCP协议实现上的一个缺陷，通过向网络服务所在端口发送大量 的伪造源地址的攻击报文，就可能造成目标服务器中的半开连接队列被占满，从而阻止其他合法用户进行访问。这种攻击早在1996年就被发现，但至今仍然显示 出强大的生命力。很多操作系统，甚至防火墙、路由器都无法有效地防御这种攻击，而且由于它可以方便地伪造源地址，追查起来非常困难。它的数据包特征通常 是，源发送了大量的SYN包，并且缺少三次握手的最后一步握手ACK回复。 </p>
<p><strong>原理</strong>：攻击者首先伪造地址对 服务器发起SYN请求，服务器回应(SYN+ACK)包，而真实的IP会认为，我没有发送请求，不作回应。服务 器没有收到回应，这样的话，服务器不知 道(SYN+ACK)是否发送成功，默认情况下会重试5次（tcp_syn_retries）。这样的话，对于服务器的内存，带宽都有很大的消耗。攻击者 如果处于公网，可以伪造IP的话，对于服务器就很难根据IP来判断攻击者，给防护带来很大的困难。</p>
<p><strong>SYN Flood 防护措施</strong>：</p>
<ul>
<li><p>无效连接监视释放 </p>
<p>  这种方法不停的监视系统中半开连接和不活动连接，当达到一定阈值时拆除这些连接，释放系统资源。这种绝对公平的方法往往也会将正常的连接的请求也会被释放掉，”伤敌一千，自损八百”</p>
</li>
<li><p>延缓TCB分配方法 </p>
<p>  SYN Flood关键是利用了，SYN数据报文一到，系统立即分配TCB资源，从而占用了系统资源，因此有俩种技术来解决这一问题 </p>
<ul>
<li><p>Syn Cache技术 </p>
<p>  这种技术在收到SYN时不急着去分配TCB，而是先回应一个ACK报文，并在一个专用的HASH表中（Cache）中保存这种半开连接，直到收到正确的ACK报文再去分配TCB </p>
</li>
<li><p>Syn Cookie技术 </p>
<p>  Syn Cookie技术则完全不使用任何存储资源，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS、时间等，在收到对方 的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源 </p>
</li>
</ul>
</li>
<li><p>使用SYN Proxy防火墙</p>
<p>  对试图穿越的SYN请求进行验证之后才放行</p>
</li>
</ul>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://raw.githubusercontent.com/clq2owesome/image/master/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg" alt="image"></p>
<p><strong>第一次挥手</strong>：主机1向主机2，发送FIN报文段，表示关闭数据传送，并主机1进入FIN_WAIT_1状态，表示没有数据要传输了 </p>
<p><strong>第二次挥手</strong>：主机2收到FIN报文段后进入CLOSE_WAIT状态（被动关闭），然后发送ACK确认，表示同意你关闭请求了，主机到主机的数据链路关闭，主机进入FIN_WAIT_2状态 </p>
<p><strong>第三次挥手</strong>：主机2等待主机1发送完数据，发送FIN到主机1请求关闭，主机2进入LAST_ACK状态 </p>
<p><strong>第四次挥手</strong>：主机1收到主机2发送的FIN后，回复ACK确认到主机2，主机1进入TIME_WAIT状态。主机2收到主机1的ACK后就关闭连接了，状态为CLOSED。主机1等待2MSL，仍然没有收到主机2的回复，说明主机2已经正常关闭了，主机1关闭连接。</p>
<h4 id="状态解析"><a href="#状态解析" class="headerlink" title="状态解析"></a>状态解析</h4><ul>
<li><p><strong>FIN_WAIT_1</strong>:<br>FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是： FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。（主动方）</p>
</li>
<li><p><strong>FIN_WAIT_2</strong>：<br>上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外一方告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方）</p>
</li>
<li><p><strong>TIME_WAIT</strong>:<br>表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方）</p>
</li>
<li><p><strong>CLOSING（比较少见）</strong>:<br>这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。</p>
</li>
<li><p><strong>CLOSE_WAIT</strong>:<br>这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是查看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。（被动方）</p>
</li>
<li><p><strong>LAST_ACK</strong>:<br>这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）</p>
</li>
<li><p><strong>CLOSED</strong>:<br>表示连接中断。</p>
</li>
</ul>
<h4 id="四次挥手的问题"><a href="#四次挥手的问题" class="headerlink" title="四次挥手的问题"></a>四次挥手的问题</h4><h6 id="什么是孤儿连接"><a href="#什么是孤儿连接" class="headerlink" title="什么是孤儿连接"></a>什么是孤儿连接</h6><p>连续停留在FIN_WAIT2状态可能发生，客户端执行半关闭状态后，未等服务器关闭连接就直接退出了，此时客户端连接由内核接管。Linux为防止孤儿连接长时间存在内核中，定义了两个变量指定孤儿连接数目和生存时间。</p>
<h6 id="为什么要四次挥手而不是三次呢？"><a href="#为什么要四次挥手而不是三次呢？" class="headerlink" title="为什么要四次挥手而不是三次呢？"></a>为什么要四次挥手而不是三次呢？</h6><p>当主机2发送ACK确认主机1的FIN时，并不代表主机2的数据发送完毕，主机1发送完FIN处于半关闭状态（不能发送数据，但可以接收数据），所以要等待主机2的数据发送完毕后，发出FIN关闭连接请求时，主机2才进入CLOSED状态，主机1再ACK确认关闭进入CLOSE状态。</p>
<h6 id="为什么TIME-WAIT-状态要等2MSL才进入CLOSED状态？"><a href="#为什么TIME-WAIT-状态要等2MSL才进入CLOSED状态？" class="headerlink" title="为什么TIME_WAIT 状态要等2MSL才进入CLOSED状态？"></a>为什么TIME_WAIT 状态要等2MSL才进入CLOSED状态？</h6><p>MSL（Maximum Segment Lifetime）：报文最大生存时间，是任何报文段被丢弃前在网络内的最长时间。当主机1回复主机2的FIN后，等待(2-4分钟)，即使两端的应用程序结束。</p>
<p>如果主机1直接进入CLOSED状态，由于IP协议不可靠性或网络问题，导致主机1最后发出的ACK报文未被主机2接收到，那么主机2在超时后继续向主机1重新发送FIN，而主机1已经关闭，那么找不到向主机1发送FIN的连接，主机2这时收到RST并把错误报告给高层，不符合TCP协议的可靠性特点。<br>如果主机1直接进入CLOSED状态，而主机2还有数据滞留在网络中，当有一个新连接的端口和原来主机2的相同，那么当原来滞留的数据到达后，主机1认为这些数据是新连接的。等待2MSL确保本次连接所有数据消失。</p>
<h6 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h6><p>从以上TCP连接关闭的状态转换图可以看出，主动关闭的一方在发送完对对方FIN报文的确认(ACK)报文后，会进入TIME_WAIT状态。TIME_WAIT状态也称为2MSL状态。</p>
<p>什么是2MSL？MSL即Maximum Segment Lifetime，也就是报文最大生存时间，引用《TCP/IP详解》中的话：“它(MSL)是任何报文段被丢弃前在网络内的最长时间。”那么，2MSL也就是这个时间的2倍。其实我觉得没必要把这个MSL的确切含义搞明白，你所需要明白的是，当TCP连接完成四个报文段的交换时，主动关闭的一方将继续等待一定时间(2-4分钟)，即使两端的应用程序结束。</p>
<p>为什么需要2MSL？根据《TCP/IP详解》和《The TCP/IP Guide》中的说法，有两个原因：<br>其一，保证发送的ACK会成功发送到对方，如何保证？我觉得可能是通过超时计时器发送。这个就很难用代码演示了。</p>
<p>其二，报文可能会被混淆，意思是说，其他时候的连接可能会被当作本次的连接。直接引用《The TCP/IP Guide》的说法：The second is to provide a“buffering period” between the end of this connection and any subsequent ones. If not for this period, it is possible that packets from different connections could be mixed, creating confusion.</p>
<p>TIME_WAIT状态所带来的影响：<br>当某个连接的一端处于TIME_WAIT状态时，该连接将不能再被使用。事实上，对于我们比较有现实意义的是，这个端口将不能再被使用。某个端口处于TIME_WAIT状态(其实应该是这个连接)时，这意味着这个TCP连接并没有断开(完全断开)，那么，如果你bind这个端口，就会失败。对于服务器而言，如果服务器突然crash掉了，那么它将无法再2MSL内重新启动，因为bind会失败。解决这个问题的一个方法就是设置socket的SO_REUSEADDR选项。这个选项意味着你可以重用一个地址。</p>
<p>特别注意：<br>当建立一个TCP连接时，服务器端会继续用原有端口监听，同时用这个端口与客户端通信。而客户端默认情况下会使用一个随机端口与服务器端的监听端口通信。有时候，为了服务器端的安全性，我们需要对客户端进行验证，即限定某个IP某个特定端口的客户端。客户端可以使用bind来使用特定的端口。对于服务器端，当设置了SO_REUSEADDR选项时，它可以在2MSL内启动并listen成功。<br>但是对于客户端，当使用bind并设置SO_REUSEADDR时，如果在2MSL内启动，虽然bind会成功，但是在windows平台上connect会失败。而在linux上则不存在这个问题。(我的实验平台：winxp, ubuntu7.10)</p>
<p>要解决windows平台的这个问题，可以设置SO_LINGER选项。SO_LINGER选项决定调用close时TCP的行为。SO_LINGER涉及到linger结构体，如果设置结构体中l_onoff为非0，l_linger为0，那么调用close时TCP连接会立刻断开，TCP不会将发送缓冲中未发送的数据发送，而是立即发送一个RST报文给对方，这个时候TCP连接就不会进入TIME_WAIT状态。如你所见，这样做虽然解决了问题，但是并不安全。通过以上方式设置SO_LINGER状态，等同于设置SO_DONTLINGER状态。</p>
<p>断开连接时的意外：<br>这个算不上断开连接时的意外，当TCP连接发生一些物理上的意外情况时，例如网线断开，linux上的TCP实现会依然认为该连接有效，而windows则会在一定时间后返回错误信息。这似乎可以通过设置SO_KEEPALIVE选项来解决，不过不知道这个选项是否对于所有平台都有效。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/04/12/网络/三次握手和四次挥手/" data-id="cjfvvphhw002em9fyqzlddt4m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/04/12/网络/HTTPS工作原理/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          HTTPS工作原理
        
      </div>
    </a>
  
  
    <a href="/2018/04/12/服务器相关/Tomcat/内存分配/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">内存分配</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Eclipse/">Eclipse</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Github/">Github</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Cookie/">Cookie</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JAXB/">JAXB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JavaMail/">JavaMail</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/基础/">基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/数据类型/">数据类型</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/日记/">日记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/时间日期/">时间日期</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/线程/">线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/网络NIO/">网络NIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/队列/">队列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/集合/">集合</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Application-Event/">Application Event</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/JPA/">JPA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Security/">Security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Spring-Boot/">Spring Boot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Spring-Session/">Spring Session</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Task/">Task</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-MVC/">spring MVC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-data-redis/">spring data redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/基础/">基础</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/">前端技术相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/forever/">forever</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/javascript/">javascript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库相关/">数据库相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据库相关/mysql/">mysql</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/">服务器相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hessian/">Hessian</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hudson-Jenkins/">Hudson & Jenkins</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Memcached/">Memcached</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Nginx/">Nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Tomcat/">Tomcat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/red5/">red5</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/resin/">resin</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/正则表达式/">正则表达式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/12/服务器相关/Tomcat/TOMCAT原理详解及请求过程/">TOMCAT原理详解及请求过程</a>
          </li>
        
          <li>
            <a href="/2018/04/12/网络/HTTPS工作原理/">HTTPS工作原理</a>
          </li>
        
          <li>
            <a href="/2018/04/12/网络/三次握手和四次挥手/">三次握手和四次挥手</a>
          </li>
        
          <li>
            <a href="/2018/04/12/服务器相关/Tomcat/内存分配/">内存分配</a>
          </li>
        
          <li>
            <a href="/2018/04/12/服务器相关/Tomcat/Tomcat整体架构浅析/">Tomcat整体架构浅析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 LeoChan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>