<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="描述啊">
  <meta name="keywords" content="undefined">
  
    <link rel="icon" href="">
  
    
  <title>存储过程 | LeoChan&#39;s 个人博客</title>
  <link rel="stylesheet" href="/style.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.1.20/jquery.fancybox.min.css" />
</head>

<body>
  <header>
  <div class="header-container">
    <a class='logo' href="/">
      <span>LeoChan's 个人博客</span>
    </a>
    <ul class="right-header">
      
        <li class="nav-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/about" class="item-link">关于</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/archives" class="item-link">归档</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/tags" class="item-link">标签</a>
          
        </li>
      
    </ul>
  </div>
</header>

  <main id='post'>
  <div class="content">
    <article>
        <section class="content markdown-body">
          <h1>存储过程</h1>
          <div class='post-meta'>
            <i class="fa fa-calendar" aria-hidden="true"></i> <time>2017年07月29日</time>
            
              | <i class="fa fa-folder-open-o" aria-hidden="true"></i> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库相关/">数据库相关</a>/ <a class="article-category-link" href="/categories/数据库相关/mysql/">mysql</a>
  </div>



            
            
          </div>
          <h3 id="那么存储过程与一般的SQL语句有什么区别呢"><a href="#那么存储过程与一般的SQL语句有什么区别呢" class="headerlink" title="那么存储过程与一般的SQL语句有什么区别呢?"></a>那么存储过程与一般的SQL语句有什么区别呢?</h3><h4 id="存储过程的优点："><a href="#存储过程的优点：" class="headerlink" title="存储过程的优点："></a>存储过程的优点：</h4><ol>
<li>存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般SQL语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度。</li>
<li>当对数据库进行复杂操作时(如对多个表进行Update,Insert,Query,Delete时)，可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用。</li>
<li>存储过程可以重复使用,可减少数据库开发人员的工作量</li>
<li>安全性高,可设定只有某此用户才具有对指定存储过程的使用权</li>
</ol>
<h4 id="存储过程的种类："><a href="#存储过程的种类：" class="headerlink" title="存储过程的种类："></a>存储过程的种类：</h4><ol>
<li>系统存储过程：以sp_开头,用来进行系统的各项设定.取得信息.相关管理工作,<br>如 sp_help就是取得指定对象的相关信息</li>
<li>扩展存储过程 以XP_开头,用来调用操作系统提供的功能<br>以下为引用的内容：<br>exec master..xp_cmdshell ‘ping 10.8.16.1’</li>
<li>用户自定义的存储过程,这是我们所指的存储过程</li>
</ol>
<h4 id="常用格式"><a href="#常用格式" class="headerlink" title="常用格式"></a>常用格式</h4><p>以下为引用的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Create procedure procedue_name</div><div class="line">[@parameter data_type][output]</div><div class="line">[with]&#123;recompile|encryption&#125;</div><div class="line">as</div><div class="line">sql_statement</div></pre></td></tr></table></figure></p>
<p>解释:<br>output：表示此参数是可传回的<br>with {recompile|encryption}<br>recompile:表示每次执行此存储过程时都重新编译一次<br>encryption:所创建的存储过程的内容会被加密   </p>
<h3 id="存储过程的创建"><a href="#存储过程的创建" class="headerlink" title="存储过程的创建"></a>存储过程的创建</h3><p>实例1:查询表Book的内容的存储过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">create proc query_book</div><div class="line">as</div><div class="line">select * from book</div><div class="line">go</div><div class="line">exec query_book</div></pre></td></tr></table></figure></p>
<p>实例2:加入一笔记录到表book,并查询此表中所有书籍的总金额<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Create proc insert_book</div><div class="line">@param1 char(10),@param2 varchar(20),@param3 money,@param4 money output</div><div class="line">with encryption ---------加密</div><div class="line">as</div><div class="line">insert book(编号,书名，价格) Values(@param1,@param2,@param3)</div><div class="line">select @param4=sum(价格) from book</div><div class="line">go</div></pre></td></tr></table></figure></p>
<h4 id="存储过程的3种传回值"><a href="#存储过程的3种传回值" class="headerlink" title="存储过程的3种传回值:"></a>存储过程的3种传回值:</h4><ol>
<li>以Return传回整数</li>
<li>以output格式传回参数</li>
<li>Recordset</li>
</ol>
<h5 id="传回值的区别"><a href="#传回值的区别" class="headerlink" title="传回值的区别:"></a>传回值的区别:</h5><p>output和return都可在批次程式中用变量接收,而recordset则传回到执行批次的客户端中</p>
<p>实例3：设有两个表为Product,Order,其表内容如下：<br>以下为引用的内容：<br>Product<br>| 产品编号 | 产品名称 | 客户订数 |<br>| —- | —- | —- |<br>| 001  | 钢笔   | 30   |<br>| 002  | 毛笔   | 50   |<br>| 003  | 铅笔   | 100  |</p>
<p>order<br>| 产品编号 | 客户名  | 客户订金 |<br>| —- | —- | —- |<br>| 001  | 南山区  | $30  |<br>| 002  | 罗湖区  | $50  |<br>| 003  | 宝安区  | $4   |</p>
<p>请实现按编号为连接条件,将两个表连接成一个临时表,该表只含编号.产品名.客户名.订金.总金额<br>总金额=订金*订数,临时表放在存储过程中<br>代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Create proc temp_sale</div><div class="line">as</div><div class="line">select a.产品编号,a.产品名称,b.客户名,b.客户订金,a.客户订数* b.客户订金 as总金额</div><div class="line">into #temptable from Product a inner join order b on a.产品编号=b.产品编号</div><div class="line">if @@error=0</div><div class="line">print &apos;Good&apos;</div><div class="line">else</div><div class="line">print &apos;Fail&apos;</div><div class="line">go</div></pre></td></tr></table></figure></p>
<h3 id="存储过程的调用"><a href="#存储过程的调用" class="headerlink" title="存储过程的调用"></a>存储过程的调用</h3><h4 id="调用带参数存储过程的几种方式"><a href="#调用带参数存储过程的几种方式" class="headerlink" title="调用带参数存储过程的几种方式"></a>调用带参数存储过程的几种方式</h4><ol>
<li><p>这也是最简单的方法,两个输入参数，无返回值,用于Insert,Update,Delete操作较多。<br>以下为引用的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">conn.Execute &quot;procname varvalue1,varvalue2&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>如果要返回 Recordset 集:<br>以下为引用的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">set rs = server.createobject(&quot;adodb.recordset&quot;)</div><div class="line">rs.Open &quot;Exec procname varvalue1, varvalue2&quot;,conn</div></pre></td></tr></table></figure>
</li>
<li><p>以上两种方法都不能有返回值，(Recordset除外)，如果要得到返回值，需要用Command的方法。</p>
</li>
</ol>
<p>首先说明，返回值有两种。一种是在存储过程中直接return一个值，就象C和VB的函数返回值那样;另一种是可以返回多个值，存储这些值的变量名称需要在调用参数中先行指定。</p>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><h4 id="触发器的概念及作用"><a href="#触发器的概念及作用" class="headerlink" title="触发器的概念及作用"></a>触发器的概念及作用</h4><p>触发器是一种特殊类型的存储过程，它不同于我们前面介绍过的存储过程。触发器主要是通过事件进行触发而被执行的，而存储过程可以通过存储过程名字而被直接调用。当对某一表进行诸如Update、 Insert、 Delete 这些操作时，SQL Server 就会自动执行触发器所定义的SQL 语句，从而确保对数据的处理必须符合由这些SQL 语句所定义的规则。<br>触发器的主要作用就是其能够实现由主键和外键所不能保证的复杂的参照完整性和数据的一致性。除此之外，触发器还有其它许多不同的功能：</p>
<ol>
<li>强化约束(Enforce restriction)<br>触发器能够实现比CHECK 语句更为复杂的约束。</li>
<li>跟踪变化Auditing changes<br>触发器可以侦测数据库内的操作，从而不允许数据库中未经许可的指定更新和变化。</li>
<li>级联运行(Cascaded operation)。<br>触发器可以侦测数据库内的操作，并自动地级联影响整个数据库的各项内容。例如，某个表上的触发器中包含有对另外一个表的数据操作(如删除，更新，插入)而该操作又导致该表上触发器被触发。</li>
<li>存储过程的调用(Stored procedure invocation)。    </li>
</ol>
<p>为了响应数据库更新，触发器可以调用一个或多个存储过程，甚至可以通过外部过程的调用而在DBMS( 数据库管理系统)本身之外进行操作。   </p>
<p>由此可见，触发器可以解决高级形式的业务规则或复杂行为限制以及实现定制记录等一些方面的问题。例如，触发器能够找出某一表在数据修改前后状态发生的差异，并根据这种差异执行一定的处理。此外一个表的同一类型(Insert、 Update、 Delete)的多个触发器能够对同一种数据操作采取多种不同的处理。</p>
<p>总体而言，触发器性能通常比较低。当运行触发器时，系统处理的大部分时间花费在参照其它表的这一处理上，因为这些表既不在内存中也不在数据库设备上，而删除表和插入表总是位于内存中。可见触发器所参照的其它表的位置决定了操作要花费的时间长短。    </p>
<h4 id="触发器的种类"><a href="#触发器的种类" class="headerlink" title="触发器的种类"></a>触发器的种类</h4><p>SQL Server 2000 支持两种类型的触发器：AFTER 触发器和INSTEAD OF 触发器。其中AFTER 触发器即为SQL Server 2000 版本以前所介绍的触发器。该类型触发器要求只有执行某一操作(Insert Update Delete) 之后，触发器才被触发，且只能在表上定义。可以为针对表的同一操作定义多个触发器。对于AFTER 触发器，可以定义哪一个触发器被最先触发，哪一个被最后触发，通常使用系统过程sp_settriggerorder 来完成此任务。</p>
<p>INSTEAD OF 触发器表示并不执行其所定义的操作(Insert、 Update、 Delete)，而仅是执行触发器本身。既可在表上定义INSTEAD OF 触发器，也可以在视图上定义INSTEAD OF 触发器，但对同一操作只能定义一个INSTEAD OF 触发器。</p>

        </section>
    </article>
    
        
  </div>
  <aside>
    
    <div class="toc-container">
        <h1>目录</h1>
        <div class="content">
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#那么存储过程与一般的SQL语句有什么区别呢"><span class="toc-number">1.</span> <span class="toc-text">那么存储过程与一般的SQL语句有什么区别呢?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#存储过程的优点："><span class="toc-number">1.1.</span> <span class="toc-text">存储过程的优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#存储过程的种类："><span class="toc-number">1.2.</span> <span class="toc-text">存储过程的种类：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常用格式"><span class="toc-number">1.3.</span> <span class="toc-text">常用格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存储过程的创建"><span class="toc-number">2.</span> <span class="toc-text">存储过程的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#存储过程的3种传回值"><span class="toc-number">2.1.</span> <span class="toc-text">存储过程的3种传回值:</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#传回值的区别"><span class="toc-number">2.1.1.</span> <span class="toc-text">传回值的区别:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存储过程的调用"><span class="toc-number">3.</span> <span class="toc-text">存储过程的调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#调用带参数存储过程的几种方式"><span class="toc-number">3.1.</span> <span class="toc-text">调用带参数存储过程的几种方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#触发器"><span class="toc-number">4.</span> <span class="toc-text">触发器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#触发器的概念及作用"><span class="toc-number">4.1.</span> <span class="toc-text">触发器的概念及作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#触发器的种类"><span class="toc-number">4.2.</span> <span class="toc-text">触发器的种类</span></a></li></ol></li></ol>
        </div>
    </div>
    
  </aside>
</main>



  <footer>
  <div class="copyright">
    <div>
      &copy; 2018 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a>&nbsp
    </div>
    <div>
      Theme by <a href="https://github.com/lewis-geek/hexo-theme-Aath" target="_blank">Aath</a>
    </div>
  </div>
</footer>


<script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script src="/lib/in-view.min.js"></script>
<script src="/lib/lodash.min.js"></script>
<script>
  var isDown = true
  var oldY = 0
  inView.offset(50)

  document.body.addEventListener('touchstart', function(){});
  
  window.addEventListener('scroll', _.throttle(e => {
    var currentY = window.scrollY
    if((oldY - currentY) < 0) {
      isDown = true
    } else {
      isDown = false
    }
    oldY = currentY
  }, 250))

  $("article img").each(function() {
      var strA = "<a data-fancybox='gallery' href='" + this.src + "'></a>";
      $(this).wrapAll(strA);
  });

  $('.toc-link').each(function() {
      var href = $(this).attr("href");
      
      inView(href).on('exit', () => {
        if (isDown) {
          handleActive(href)
        }
      })

      inView(href).on('enter', () => {
        if (!isDown) {
          handleActive(href)
        }
      })

      this.onclick = function(e) {
        var pos = $(href).offset().top - 10;
        $("html,body").animate({scrollTop: pos}, 300);
        setTimeout(() => {
          handleActive(href)
        }, 350)
        return false
      }
  })

  function handleActive(href) {
    document.querySelectorAll('.toc-link').forEach(elm => {
      elm.classList.remove('active')
    })
    document.querySelector(".toc [href='"+ href +"']").classList.add('active')
  }
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.1.20/jquery.fancybox.min.js"></script>


</body>
</html>
