<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="描述啊">
  <meta name="keywords" content="undefined">
  
    <link rel="icon" href="">
  
    
  <title>RequestMapping详解 | LeoChan&#39;s 个人博客</title>
  <link rel="stylesheet" href="/style.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.1.20/jquery.fancybox.min.css" />
</head>

<body>
  <header>
  <div class="header-container">
    <a class='logo' href="/">
      <span>LeoChan's 个人博客</span>
    </a>
    <ul class="right-header">
      
        <li class="nav-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/about" class="item-link">关于</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/archives" class="item-link">归档</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/tags" class="item-link">标签</a>
          
        </li>
      
    </ul>
  </div>
</header>

  <main id='post'>
  <div class="content">
    <article>
        <section class="content markdown-body">
          <h1>RequestMapping详解</h1>
          <div class='post-meta'>
            <i class="fa fa-calendar" aria-hidden="true"></i> <time>2017年07月19日</time>
            
              | <i class="fa fa-folder-open-o" aria-hidden="true"></i> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>/ <a class="article-category-link" href="/categories/Spring/spring-MVC/">spring MVC</a>
  </div>



            
            
          </div>
          <p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
<hr>
<p>RequestMapping注解有六个属性：</p>
<h2 id="value："><a href="#value：" class="headerlink" title="value："></a>value：</h2><p>指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）</p>
<p>value的uri值为以下三类：</p>
<ol>
<li><p>可以指定为普通的具体值；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(value=&quot;/owners&#125;&quot;, method=RequestMethod.GET)</div></pre></td></tr></table></figure>
</li>
<li><p>可以指定为含有某变量的一类值(URI Template Patterns with Path Variables)；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(value=&quot;/owners/&#123;ownerId&#125;&quot;, method=RequestMethod.GET)</div></pre></td></tr></table></figure>
</li>
<li><p>可以指定为含正则表达式的一类值( URI Template Patterns with Regular Expressions);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(&quot;/spring-web/&#123;symbolicName:[a-z-]+&#125;-&#123;version:\d\.\d\.\d&#125;.&#123;extension:\.[a-z]&#125;&quot;)</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="method："><a href="#method：" class="headerlink" title="method："></a>method：</h3><p>指定请求的method类型， GET、POST、PUT、DELETE等</p>
<h3 id="consumes"><a href="#consumes" class="headerlink" title="consumes"></a>consumes</h3><p>指定处理请求的提交内容类型（Content-Type），例如application/json, text/html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(value = &quot;/pets&quot;, method = RequestMethod.POST, consumes=&quot;application/json&quot;)</div><div class="line">注：方法仅处理request Content-Type为“application/json”类型的请求。</div></pre></td></tr></table></figure></p>
<h3 id="produces"><a href="#produces" class="headerlink" title="produces"></a>produces</h3><p>指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(value = &quot;/pets/&#123;petId&#125;&quot;, method = RequestMethod.GET, produces=&quot;application/json&quot;)  </div><div class="line">@ResponseBody </div><div class="line">注：方法仅处理request请求中Accept头中包含了&quot;application/json&quot;的请求，同时暗示了返回的内容类型为application/json</div></pre></td></tr></table></figure></p>
<h3 id="params"><a href="#params" class="headerlink" title="params"></a>params</h3><p>指定request中必须包含某些参数值是，才让该方法处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(value = &quot;/pets/&#123;petId&#125;&quot;, method = RequestMethod.GET, params=&quot;myParam=myValue&quot;)</div><div class="line">注：仅处理请求中包含了名为“myParam”，值为“myValue”的请求；</div></pre></td></tr></table></figure></p>
<h3 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h3><p>指定request中必须包含某些指定的header值，才能让该方法处理请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(value = &quot;/pets&quot;, method = RequestMethod.GET, headers=&quot;Referer=http://www.ifeng.com/&quot;)</div><div class="line">注：仅处理request的header中包含了指定“Refer”请求头和对应值为“http://www.ifeng.com/”的请求</div></pre></td></tr></table></figure></p>
<h2 id="使用-RequestMapping-的一些高级用法"><a href="#使用-RequestMapping-的一些高级用法" class="headerlink" title="使用 @RequestMapping 的一些高级用法"></a>使用 @RequestMapping 的一些高级用法</h2><h3 id="params属性"><a href="#params属性" class="headerlink" title="params属性"></a>params属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@RequestMapping (value= &quot;testParams&quot; , params=&#123; &quot;param1=value1&quot; , &quot;param2&quot; , &quot;!param3&quot; &#125;)</div><div class="line">public String testParams() &#123;</div><div class="line">   System. out .println( &quot;test Params...........&quot; );</div><div class="line">   return &quot;testParams&quot; ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用@RequestMapping 的params 属性指定了三个参数，这些参数都是针对请求参数而言的，它们分别表示参数param1 的值必须等于value1 ，参数param2 必须存在，值无所谓，参数param3 必须不存在，只有当请求/testParams.do 并且满足指定的三个参数条件的时候才能访问到该方法。所以当请求/testParams.do?param1=value1&amp;param2=value2 的时候能够正确访问到该testParams 方法，当请求/testParams.do?param1=value1&amp;param2=value2&amp;param3=value3 的时候就不能够正常的访问到该方法，因为在@RequestMapping 的params 参数里面指定了参数param3 是不能存在的。 </p>
<h3 id="method属性"><a href="#method属性" class="headerlink" title="method属性"></a>method属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@RequestMapping (value= &quot;testMethod&quot; , method=&#123;RequestMethod. GET , RequestMethod. DELETE &#125;)</div><div class="line">public String testMethod() &#123;</div><div class="line">   return &quot;method&quot; ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的代码中就使用method 参数限制了以GET 或DELETE 方法请求/testMethod 的时候才能访问到该Controller 的testMethod 方法。      </p>
<h3 id="headers属性"><a href="#headers属性" class="headerlink" title="headers属性"></a>headers属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@RequestMapping (value= &quot;testHeaders&quot; , headers=&#123; &quot;host=localhost&quot; , &quot;Accept&quot; &#125;)</div><div class="line">public String testHeaders() &#123;</div><div class="line">   return &quot;headers&quot; ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>headers 属性的用法和功能与params 属性相似。在上面的代码中当请求/testHeaders.do 的时候只有当请求头包含Accept 信息，且请求的host 为localhost 的时候才能正确的访问到testHeaders 方法。</p>
<h2 id="RequestMapping-标记的处理器方法支持的方法参数和返回类型"><a href="#RequestMapping-标记的处理器方法支持的方法参数和返回类型" class="headerlink" title="@RequestMapping 标记的处理器方法支持的方法参数和返回类型"></a>@RequestMapping 标记的处理器方法支持的方法参数和返回类型</h2><h3 id="支持的方法参数类型"><a href="#支持的方法参数类型" class="headerlink" title="支持的方法参数类型:"></a>支持的方法参数类型:</h3><ol>
<li>HttpServlet 对象，主要包括HttpServletRequest 、HttpServletResponse 和HttpSession 对象。 这些参数Spring 在调用处理器方法的时候会自动给它们赋值，所以当在处理器方法中需要使用到这些对象的时候，可以直接在方法上给定一个方法参数的申明，然后在方法体里面直接用就可以了。但是有一点需要注意的是在使用HttpSession 对象的时候，如果此时HttpSession 对象还没有建立起来的话就会有问题。</li>
<li>Spring 自己的WebRequest 对象。 使用该对象可以访问到存放在HttpServletRequest 和HttpSession 中的属性值。</li>
<li>InputStream 、OutputStream 、Reader 和Writer 。 InputStream 和Reader 是针对HttpServletRequest 而言的，可以从里面取数据；OutputStream 和Writer 是针对HttpServletResponse 而言的，可以往里面写数据。</li>
<li>使用@PathVariable 、@RequestParam 、@CookieValue 和@RequestHeader 标记的参数。</li>
<li>使用@ModelAttribute 标记的参数。</li>
<li>java.util.Map 、Spring 封装的Model 和ModelMap 。 这些都可以用来封装模型数据，用来给视图做展示。</li>
<li>实体类。 可以用来接收上传的参数。</li>
<li>Spring 封装的MultipartFile 。 用来接收上传文件的。</li>
<li>Spring 封装的Errors 和BindingResult 对象。 这两个对象参数必须紧接在需要验证的实体对象参数之后，它里面包含了实体对象的验证结果。</li>
</ol>
<h3 id="支持的返回类型"><a href="#支持的返回类型" class="headerlink" title="支持的返回类型:"></a>支持的返回类型:</h3><ol>
<li>一个包含模型和视图的ModelAndView 对象。</li>
<li>一个模型对象，这主要包括Spring 封装好的Model 和ModelMap ，以及java.util.Map ，当没有视图返回的时候视图名称将由RequestToViewNameTranslator 来决定。</li>
<li>一个View 对象。这个时候如果在渲染视图的过程中模型的话就可以给处理器方法定义一个模型参数，然后在方法体里面往模型中添加值。</li>
<li>一个String 字符串。这往往代表的是一个视图名称。这个时候如果需要在渲染视图的过程中需要模型的话就可以给处理器方法一个模型参数，然后在方法体里面往模型中添加值就可以了。</li>
<li>返回值是void 。这种情况一般是我们直接把返回结果写到HttpServletResponse 中了，如果没有写的话，那么Spring 将会利用RequestToViewNameTranslator 来返回一个对应的视图名称。如果视图中需要模型的话，处理方法与返回字符串的情况相同。</li>
<li>如果处理器方法被注解@ResponseBody 标记的话，那么处理器方法的任何返回类型都会通过HttpMessageConverters 转换之后写到HttpServletResponse 中，而不会像上面的那些情况一样当做视图或者模型来处理。</li>
<li>除以上几种情况之外的其他任何返回类型都会被当做模型中的一个属性来处理，而返回的视图还是由RequestToViewNameTranslator 来决定，添加到模型中的属性名称可以在该方法上用@ModelAttribute(“attributeName”) 来定义，否则将使用返回类型的类名称的首字母小写形式来表示。使用@ModelAttribute 标记的方法会在@RequestMapping 标记的方法执行之前执行。</li>
</ol>

        </section>
    </article>
    
        
  </div>
  <aside>
    
    <div class="toc-container">
        <h1>目录</h1>
        <div class="content">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#value："><span class="toc-number">1.</span> <span class="toc-text">value：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#method："><span class="toc-number">1.1.</span> <span class="toc-text">method：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#consumes"><span class="toc-number">1.2.</span> <span class="toc-text">consumes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#produces"><span class="toc-number">1.3.</span> <span class="toc-text">produces</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#params"><span class="toc-number">1.4.</span> <span class="toc-text">params</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#headers"><span class="toc-number">1.5.</span> <span class="toc-text">headers</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-RequestMapping-的一些高级用法"><span class="toc-number">2.</span> <span class="toc-text">使用 @RequestMapping 的一些高级用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#params属性"><span class="toc-number">2.1.</span> <span class="toc-text">params属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#method属性"><span class="toc-number">2.2.</span> <span class="toc-text">method属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#headers属性"><span class="toc-number">2.3.</span> <span class="toc-text">headers属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RequestMapping-标记的处理器方法支持的方法参数和返回类型"><span class="toc-number">3.</span> <span class="toc-text">@RequestMapping 标记的处理器方法支持的方法参数和返回类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#支持的方法参数类型"><span class="toc-number">3.1.</span> <span class="toc-text">支持的方法参数类型:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#支持的返回类型"><span class="toc-number">3.2.</span> <span class="toc-text">支持的返回类型:</span></a></li></ol></li></ol>
        </div>
    </div>
    
  </aside>
</main>



  <footer>
  <div class="copyright">
    <div>
      &copy; 2018 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a>&nbsp
    </div>
    <div>
      Theme by <a href="https://github.com/lewis-geek/hexo-theme-Aath" target="_blank">Aath</a>
    </div>
  </div>
</footer>


<script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script src="/lib/in-view.min.js"></script>
<script src="/lib/lodash.min.js"></script>
<script>
  var isDown = true
  var oldY = 0
  inView.offset(50)

  document.body.addEventListener('touchstart', function(){});
  
  window.addEventListener('scroll', _.throttle(e => {
    var currentY = window.scrollY
    if((oldY - currentY) < 0) {
      isDown = true
    } else {
      isDown = false
    }
    oldY = currentY
  }, 250))

  $("article img").each(function() {
      var strA = "<a data-fancybox='gallery' href='" + this.src + "'></a>";
      $(this).wrapAll(strA);
  });

  $('.toc-link').each(function() {
      var href = $(this).attr("href");
      
      inView(href).on('exit', () => {
        if (isDown) {
          handleActive(href)
        }
      })

      inView(href).on('enter', () => {
        if (!isDown) {
          handleActive(href)
        }
      })

      this.onclick = function(e) {
        var pos = $(href).offset().top - 10;
        $("html,body").animate({scrollTop: pos}, 300);
        setTimeout(() => {
          handleActive(href)
        }, 350)
        return false
      }
  })

  function handleActive(href) {
    document.querySelectorAll('.toc-link').forEach(elm => {
      elm.classList.remove('active')
    })
    document.querySelector(".toc [href='"+ href +"']").classList.add('active')
  }
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.1.20/jquery.fancybox.min.js"></script>


</body>
</html>
