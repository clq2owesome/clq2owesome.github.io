<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="描述啊">
  <meta name="keywords" content="undefined">
  
    <link rel="icon" href="">
  
    
  <title>Fork  、Join框架 | LeoChan&#39;s 个人博客</title>
  <link rel="stylesheet" href="/style.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.1.20/jquery.fancybox.min.css" />
</head>

<body>
  <header>
  <div class="header-container">
    <a class='logo' href="/">
      <span>LeoChan's 个人博客</span>
    </a>
    <ul class="right-header">
      
        <li class="nav-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/about" class="item-link">关于</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/archives" class="item-link">归档</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/tags" class="item-link">标签</a>
          
        </li>
      
    </ul>
  </div>
</header>

  <main id='post'>
  <div class="content">
    <article>
        <section class="content markdown-body">
          <h1>Fork  、Join框架</h1>
          <div class='post-meta'>
            <i class="fa fa-calendar" aria-hidden="true"></i> <time>2017年02月25日</time>
            
              | <i class="fa fa-folder-open-o" aria-hidden="true"></i> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>/ <a class="article-category-link" href="/categories/Java/线程/">线程</a>
  </div>



            
            
          </div>
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>通常，使用Java来开发一个简单的并发应用程序时，会创建一些Runnable对象，然后创建对应的Thread 对象来控制程序中这些线程的创建、执行以及线程的状态。自从Java 5开始引入了Executor和ExecutorService接口以及实现这两个接口的类（比如ThreadPoolExecutor）之后，使得Java在并发支持上得到了进一步的提升。</p>
<p><strong>执行器框架</strong>（Executor Framework）将任务的创建和执行进行了分离，通过这个框架，只需要实现Runnable接口的对象和使用Executor对象，然后将Runnable对象发送给执行器。执行器再负责运行这些任务所需要的线程，包括线程的创建，线程的管理以及线程的结束。</p>
<p>Java 7则又更进了一步，它包括了ExecutorService接口的另一种实现，用来解决特殊类型的问题，它就是<strong>Fork/Join框架</strong>，有时也称<strong>分解/合并框架</strong>。</p>
<p><strong>Fork/Join框架是用来解决能够通过分治技术（Divide and Conquer Technique）将问题拆分成小任务的问题。在一个任务中，先检查将要解决的问题的大小，如果大于一个设定的大小，那就将问题拆分成可以通过框架来执行的小任务。如果问题的大小比设定的大小要小，就可以直接在任务里解决这个问题，然后，根据需要返回任务的结果</strong>。下面的图形总结了这个原理。<br><img src="http://ifeve.com/wp-content/uploads/2014/02/Java-Concurrency-Cook-Book-5.1.png" alt="image">   </p>
<p>没有固定的公式来决定问题的<strong>参考大小</strong>（Reference Size），从而决定一个任务是需要进行拆分或不需要拆分，拆分与否仍是依赖于任务本身的特性。可以使用在任务中将要处理的元素的数目和任务执行所需要的时间来决定参考大小。测试不同的参考大小来决定解决问题最好的一个方案，将<strong>ForkJoinPool</strong>类看作一个特殊的 Executor 执行器类型。这个框架基于以下两种操作。  </p>
<ul>
<li><strong>分解（Fork）操作</strong>：当需要将一个任务拆分成更小的多个任务时，在框架中执行这些任务；</li>
<li><strong>合并（Join）操作</strong>：当一个主任务等待其创建的多个子任务的完成执行。</li>
</ul>
<p><strong>Fork/Join框架和执行器框架（Executor Framework）主要的区别在于工作窃取算法（Work-Stealing Algorithm）</strong>。与执行器框架不同，使用Join操作让一个主任务等待它所创建的子任务的完成，执行这个任务的线程称之为<strong>工作者线程</strong>（Worker Thread）。工作者线程寻找其他仍未被执行的任务，然后开始执行。通过这种方式，这些线程在运行时拥有所有的优点，进而提升应用程序的性能。</p>
<p>为了达到这个目标，通过Fork/Join框架执行的任务有以下限制。</p>
<ul>
<li>任务只能使用fork()和join() 操作当作同步机制。如果使用其他的同步机制，工作者线程就不能执行其他任务，当然这些任务是在同步操作里时。比如，如果在Fork/Join 框架中将一个任务休眠，正在执行这个任务的工作者线程在休眠期内不能执行另一个任务。</li>
<li>任务不能执行I/O操作，比如文件数据的读取与写入。</li>
<li>任务不能抛出非运行时异常（Checked Exception），必须在代码中处理掉这些异常。</li>
</ul>
<p>Fork/Join框架的核心是由下列两个类组成的。</p>
<ul>
<li><strong>ForkJoinPool</strong>：这个类实现了ExecutorService接口和工作窃取算法（Work-Stealing Algorithm）。它管理工作者线程，并提供任务的状态信息，以及任务的执行信息。</li>
<li><strong>ForkJoinTask</strong>：这个类是一个将在ForkJoinPool中执行的任务的基类。</li>
</ul>
<p>Fork/Join框架提供了在一个任务里执行fork()和join()操作的机制和控制任务状态的方法。通常，为了实现Fork/Join任务，需要实现一个以下两个类之一的子类。</p>
<ul>
<li><strong>RecursiveAction</strong>：用于任务没有返回结果的场景。</li>
<li><strong>RecursiveTask</strong>：用于任务有返回结果的场景。</li>
</ul>
<h2 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h2><p>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程图如下：<br><img src="http://ifeve.com/wp-content/uploads/2013/12/fj.png" alt="image"><br>那么为什么需要使用工作窃取算法呢？假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p>
<p>工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p>
<h2 id="创建Fork-Join线程池"><a href="#创建Fork-Join线程池" class="headerlink" title="创建Fork/Join线程池"></a>创建Fork/Join线程池</h2><p>在本节，我们将学习如何使用Fork／Join框架的基本元素。它包括：</p>
<ul>
<li>创建用来执行任务的ForkJoinPool对象；</li>
<li>创建即将在线程池中被执行的任务ForkJoinTask子类。</li>
</ul>
<p>本范例中即将使用的Fork/Join框架的主要特性如下：</p>
<ul>
<li>采用默认的构造器创建ForkJoinPool对象；</li>
<li>在任务中将使用JavaAPI文档推荐的结构。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">if (problem size &gt; default size)&#123;</div><div class="line"></div><div class="line">    tasks = divide(task);</div><div class="line">    </div><div class="line">    execute(tasks);</div><div class="line"></div><div class="line">&#125; else &#123;</div><div class="line"></div><div class="line">    resolve problem using another algorithm;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>我们将以同步的方式执行任务。当一个主任务执行两个或更多的子任务时，这个主任务将等待子任务的完成。用这种方法，执行主任务的线程，称之为<strong>工作者线程</strong>（Worker Thread），它将寻找其他的子任务来执行，并在子任务执行的时间里利用所有的线程优势。</p>
<p>如果将要实现的任务没有返回任何结果，那么，采用RecursiveAction类作为实现任务的基类。</p>
<h3 id="范例实现"><a href="#范例实现" class="headerlink" title="范例实现"></a>范例实现</h3><p>在本节，我们将实现一项更新产品价格的任务。最初的任务将负责更新列表中的所有元素。我们使用10来作为参考大小（ReferenceSize），如果一个任务需要更新大于10个元素，它会将这个列表分解成为两部分，然后分别创建两个任务用来更新各自部分的产品价格。</p>
<p>创建一个名为Product的类，用来存储产品的名称和价格。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Product &#123;</div><div class="line">	</div><div class="line">	//声明一个名为name的私有String属性，一个名为price的私有double属性。</div><div class="line">	private String name;</div><div class="line">	private double price;</div><div class="line">	</div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">	public double getPrice() &#123;</div><div class="line">		return price;</div><div class="line">	&#125;</div><div class="line">	public void setPrice(double price) &#123;</div><div class="line">		this.price = price;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建一个名为ProductListGenerator的类，用来生成一个随机产品列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class ProductListGenerator &#123;</div><div class="line">	</div><div class="line">	//实现generate()方法。接收一个表示列表大小的int参数，并返回一个生成产品的List&lt;Product&gt;列表。</div><div class="line">	public List&lt;Product&gt; generate (int size) &#123;</div><div class="line">		List&lt;Product&gt; ret=new ArrayList&lt;Product&gt;();</div><div class="line">		for (int i=0; i&lt;size; i++) &#123;</div><div class="line">			Product product=new Product();</div><div class="line">			product.setName(&quot;Product &quot;+i);</div><div class="line">			product.setPrice(10);</div><div class="line">			ret.add(product);</div><div class="line">		&#125;</div><div class="line">		return ret;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建一个名为Task的类，并继承RecursiveAction类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">public class Task  extends RecursiveAction &#123;</div><div class="line">	private static final long serialVersionUID = 1L;</div><div class="line">	</div><div class="line">	private List&lt;Product&gt; products;</div><div class="line"></div><div class="line">	//声明两个私有的int属性，分别命名为first和last。这两个属性将决定任务执行时对产品的分块。</div><div class="line">	private int first;</div><div class="line">	private int last;</div><div class="line">	</div><div class="line">	//声明一个名为increment的私有double属性，用来存储产品价格的增加额。</div><div class="line">	private double increment;</div><div class="line"></div><div class="line">	public Task (List&lt;Product&gt; products, int first, int last, double increment) &#123;</div><div class="line">		this.products=products;</div><div class="line">		this.first=first;</div><div class="line">		this.last=last;</div><div class="line">		this.increment=increment;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void compute() &#123;</div><div class="line">		//如果last和first属性值的差异小于10（一个任务只能更新少于10件产品的价格），</div><div class="line">		//则调用updatePrices()方法增加这些产品的价格。</div><div class="line">		if (last-first&lt;10) &#123;</div><div class="line">			updatePrices();</div><div class="line">			</div><div class="line">		&#125; else &#123;</div><div class="line">			//如果last和first属性值的差异大于或等于10，就创建两个新的Task对象，一个处理前一半的产品，</div><div class="line">			//另一个处理后一半的产品，然后调用ForkJoinPool的invokeAll()方法来执行这两个新的任务。</div><div class="line">			int middle=(last+first)/2;</div><div class="line">			System.out.printf(&quot;Task: Pending tasks:%s\n&quot;,getQueuedTaskCount());</div><div class="line">			Task t1=new Task(products, first,middle+1, increment);</div><div class="line">			Task t2=new Task(products, middle+1,last, increment);</div><div class="line">			invokeAll(t1, t2);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//实现updatePrices()方法。这个方法用来更新在产品列表中处于first和last属性之间的产品。</div><div class="line">	private void updatePrices() &#123;</div><div class="line">		for (int i=first; i&lt;last; i++)&#123;</div><div class="line">			Product product=products.get(i);</div><div class="line">			product.setPrice(product.getPrice()*(1+increment));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ProductListGenerator generator=new ProductListGenerator();</div><div class="line">		List&lt;Product&gt; products=generator.generate(100);</div><div class="line">		Task task=new Task(products, 0, products.size(), 0.20);</div><div class="line"></div><div class="line">		ForkJoinPool pool=new ForkJoinPool();</div><div class="line">		pool.execute(task);</div><div class="line">		</div><div class="line">		//实现代码块，显示关于线程池演变的信息，</div><div class="line">		//每5毫秒在控制台上输出线程池的一些参数值，直到任务执行结束。</div><div class="line">		do &#123;</div><div class="line">			System.out.printf(&quot;Main: Thread Count: %d\n&quot;,pool.getActiveThreadCount());</div><div class="line">			System.out.printf(&quot;Main: Thread Steal: %d\n&quot;,pool.getStealCount());</div><div class="line">			System.out.printf(&quot;Main: Parallelism: %d\n&quot;,pool.getParallelism());</div><div class="line">			try &#123;</div><div class="line">				TimeUnit.MILLISECONDS.sleep(5);</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125; while (!task.isDone());</div><div class="line">		</div><div class="line">		pool.shutdown();</div><div class="line">		</div><div class="line">		//调用isCompletedNormally()方法，检查任务是否已经完成并且没有错误，</div><div class="line">		//在这个示例中，在控制台输出信息表示任务已经处理结束。</div><div class="line">		if (task.isCompletedNormally())&#123;</div><div class="line">			System.out.printf(&quot;Main: The process has completed normally.\n&quot;);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		//在增加之后，所有产品的期望价格是12元。在控制台输出所有产品的名称和价格，</div><div class="line">		//如果产品的价格不是12元，就将产品信息打印出来，以便确认所有的产品价格都正确地增加了。</div><div class="line">		for (int i=0; i&lt;products.size(); i++)&#123;</div><div class="line">			Product product=products.get(i);</div><div class="line">			if (product.getPrice()!=12) &#123;</div><div class="line">				System.out.printf(&quot;Product %s: %f\n&quot;,product.</div><div class="line">				getName(),product.getPrice());</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		System.out.println(&quot;Main: End of the program.\n&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Main: Thread Count: 1</div><div class="line">Task: Pending tasks:0</div><div class="line">Task: Pending tasks:1</div><div class="line">Task: Pending tasks:1</div><div class="line">Task: Pending tasks:2</div><div class="line">Main: Thread Steal: 0</div><div class="line">Main: Parallelism: 4</div><div class="line">Task: Pending tasks:0</div><div class="line">Task: Pending tasks:1</div><div class="line">Task: Pending tasks:1</div><div class="line">Task: Pending tasks:0</div><div class="line">Task: Pending tasks:0</div><div class="line">Task: Pending tasks:0</div><div class="line">Task: Pending tasks:1</div><div class="line">Task: Pending tasks:0</div><div class="line">Task: Pending tasks:0</div><div class="line">Task: Pending tasks:1</div><div class="line">Task: Pending tasks:0</div><div class="line">Main: The process has completed normally.</div><div class="line">Main: End of the program.</div></pre></td></tr></table></figure></p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>在这个范例中，我们创建了ForkJoinPool对象，和一个将在线程池中执行的ForkJoinTask的子类。使用了无参的类构造器创建了ForkJoinPool对象，因此它将执行默认的配置。创建一个线程数等于计算机CPU数目的线程池，创建好ForkJoinPool对象之后，那些线程也创建就绪了，在线程池中等待任务的到达，然后开始执行。</p>
<p>由于Task类继承了RecursiveAction类，因此不返回结果。在本节，我们使用了推荐的结构来实现任务。如果任务需要更新大于10个产品，它将拆分这些元素为两部分，创建两个任务，并将拆分的部分相应地分配给新创建的任务。通过使用Task类的first和last属性，来获知任务将要更新的产品列表所在的位置范围。我们已经使用first和last属性，来操作产品列表中仅有的一份副本，而没有为每一个任务去创建不同的产品列表。</p>
<p><strong>调用invokeAll()方法来执行一个主任务所创建的多个子任务。这是一个同步调用，这个任务将等待子任务完成，然后继续执行（也可能是结束）</strong>。当一个主任务等待它的子任务时，执行这个主任务的工作者线程接收另一个等待执行的任务并开始执行。正因为有了这个行为，所以说Fork／Join框架提供了一种比Runnable和Callable对象更加高效的任务管理机制。</p>
<p><strong>ForkJoinTask类的invokeAll()方法是执行器框架（ExecutorFramework）和Fork／Join框架之间的主要差异之一</strong>。在执行器框架中，所有的任务必须发送给执行器，然而，在这个示例中，线程池中包含了待执行方法的任务，任务的控制也是在线程池中进行的。我们在Task类中使用了invokeAll()方法，Task类继承了RecursiveAction类，而RecursiveAction类则继承了ForkJoinTask类。</p>
<p>我们已经发送一个唯一的任务到线程池中，通过使用execute()方法来更新所有产品的列表。在这个示例中，它是一个同步调用，主线程一直等待调用的执行。</p>
<p>我们已经使用了ForkJoinPool类的一些方法，来检查正在运行的任务的状态和演变情况。这个类包含更多的方法，可以用于任务状态的检测。</p>
<p><strong>最后，像执行器框架一样，必须调用shutdown()方法来结束ForkJoinPool的执行</strong>。</p>
<h4 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h4><p>ForkJoinPool类还提供了以下方法用于执行任务。</p>
<ul>
<li><strong>execute (Runnabletask)</strong>：这是本范例中使用的execute()方法的另一种版本。这个方法发送一个Runnable任务给ForkJoinPool类。需要注意的是，<strong>使用Runnable对象时ForkJoinPool类就不采用工作窃取算法（Work-StealingAlgorithm），ForkJoinPool类仅在使用ForkJoinTask类时才采用工作窃取算法</strong>。</li>
<li><strong>invoke(ForkJoinTask<t>task)</t></strong>：正如范例所示，ForkJoinPool类的execute()方法是异步调用的，而ForkJoinPool类的invoke()方法则是同步调用的。这个方法直到传递进来的任务执行结束后才会返回。</li>
<li>也可以使用在ExecutorService类中声明的invokeAll()和invokeAny()方法，这些方法接收Callable对象作为参数。<strong>使用Callable对象时ForkJoinPool类就不采用工作窃取算法（Work-StealingAlgorithm）</strong>，因此，<strong>最好使用执行器来执行Callable对象</strong>。</li>
</ul>
<p>ForkJoinTask类也包含了在范例中所使用的invokeAll()方法的其他版本，这些版本如下。</p>
<ul>
<li><strong>invokeAll(ForkJoinTask&lt;?&gt;… tasks)</strong>：这个版本的方法接收一个可变的参数列表，可以传递尽可能多的ForkJoinTask对象给这个方法作为参数。</li>
<li><strong>invokeAll(Collection<t>tasks)</t></strong>：这个版本的方法接受一个泛型类型T的对象集合（比如，ArrayList对象、LinkedList对象或者TreeSet对象）。这个泛型类型T必须是ForkJoinTask类或者它的子类。</li>
</ul>
<p><strong>虽然ForkJoinPool类是设计用来执行ForkJoinTask对象的，但也可以直接用来执行Runnable和Callable对象。当然，也可以使用ForkJoinTask类的adapt()方法来接收一个Callable对象或者一个Runnable对象，然后将之转化为一个ForkJoinTask对象，然后再去执行</strong>。</p>
<h2 id="合并任务的结果"><a href="#合并任务的结果" class="headerlink" title="合并任务的结果"></a>合并任务的结果</h2><p>Fork／Join框架提供了执行任务并返回结果的能力。这些类型的任务都是通过RecursiveTask类来实现的。RecursiveTask类继承了ForkJoinTask类，并且实现了由执行器框架（Executor Framework）提供的Future接口。</p>
<p>在任务中，必须使用Java API文档推荐的如下结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">if (problem size &gt; size)&#123;</div><div class="line"></div><div class="line">    tasks=Divide(task);</div><div class="line">    </div><div class="line">    execute(tasks);</div><div class="line">    </div><div class="line">    groupResults()</div><div class="line">    </div><div class="line">    return result;</div><div class="line"></div><div class="line">&#125; else &#123;</div><div class="line"></div><div class="line">    resolve problem;</div><div class="line">    </div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果任务需要解决的问题大于预先定义的大小，那么就要将这个问题拆分成多个子任务，并使用Fork／Join框架来执行这些子任务。执行完成后，原始任务获取到由所有这些子任务产生的结果，合并这些结果，返回最终的结果。当原始任务在线程池中执行结束后，将高效地获取到整个问题的最终结果。</p>
<p>在本节，我们将学习如何使用Fork／Join框架来解决这种问题，开发一个应用程序，在文档中查找一个词。我们将实现以下两种任务：</p>
<ul>
<li>一个文档任务，它将遍历文档中的每一行来查找这个词；</li>
<li>一个行任务，它将在文档的一部分当中查找这个词。</li>
</ul>
<p>所有这些任务将返回文档或行中所出现这个词的次数。</p>
<p>创建一个名为DocumentMock的类。它将生成一个字符串矩阵来模拟一个文档。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class DocumentMock &#123;</div><div class="line">	private String words[]=&#123;&quot;the&quot;,&quot;hello&quot;,&quot;goodbye&quot;,&quot;packt&quot;, &quot;java&quot;,&quot;thread&quot;,</div><div class="line">			&quot;pool&quot;,&quot;random&quot;,&quot;class&quot;,&quot;main&quot;&#125;;</div><div class="line">	</div><div class="line">	//实现generateDocument()方法。它接收3个参数，分别是行数numLines，每一行词的个数numWords，</div><div class="line">	//和准备查找的词word。然后返回一个字符串矩阵。</div><div class="line">	public String[][] generateDocument(int numLines, int numWords, String word) &#123;</div><div class="line">		int counter=0;</div><div class="line">		String document[][]=new String[numLines][numWords];</div><div class="line">		Random random=new Random();</div><div class="line">		</div><div class="line">		//为字符串矩阵填上字符串。通过随机数取得数组words中的某一字符串，</div><div class="line">		//然后存入到字符串矩阵document对应的位置上，同时计算生成的字符串矩阵中将要查找的词出现的次数。</div><div class="line">		//这个值可以用来与后续程序运行查找任务时统计的次数相比较，检查两个值是否相同。</div><div class="line">		for (int i=0; i&lt;numLines; i++)&#123;</div><div class="line">			for (int j=0; j&lt;numWords; j++) &#123;</div><div class="line">				int index=random.nextInt(words.length);</div><div class="line">				document[i][j]=words[index];</div><div class="line">				if (document[i][j].equals(word))&#123;</div><div class="line">					counter++;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;DocumentMock: The word appears &quot;+counter+&quot; times in the document&quot;);</div><div class="line">		return document;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建名为DocumentTask的类，并继承RecursiveTask类，RecursiveTask类的泛型参数为Integer类型。这个DocumentTask类将实现一个任务，用来计算所要查找的词在行中出现的次数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">public class DocumentTask extends RecursiveTask&lt;Integer&gt; &#123;</div><div class="line">	private static final long serialVersionUID = 1L;</div><div class="line">	</div><div class="line">	private String document[][];</div><div class="line">	private int start, end;</div><div class="line">	private String word;</div><div class="line">	</div><div class="line">	public DocumentTask (String document[][], int start, int end, String word)&#123;</div><div class="line">		this.document=document;</div><div class="line">		this.start=start;</div><div class="line">		this.end=end;</div><div class="line">		this.word=word;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected Integer compute() &#123;</div><div class="line">		int result = 0;</div><div class="line">		//实现compute()方法。如果end和start的差异小于10，</div><div class="line">		//则调用processLines()方法，来计算这两个位置之间要查找的词出现的次数。</div><div class="line">		if (end-start&lt;10)&#123;</div><div class="line">			result=processLines(document, start, end, word);</div><div class="line">			</div><div class="line">		//否则，拆分这些行成为两个对象，并创建两个新的DocumentTask对象来处理这两个对象，</div><div class="line">		//然后调用invokeAll()方法在线程池里执行它们。</div><div class="line">		&#125; else &#123;</div><div class="line">			int mid=(start+end)/2;</div><div class="line">			DocumentTask task1=new DocumentTask(document,start,mid,word);</div><div class="line">			DocumentTask task2=new DocumentTask(document,mid,end,word);</div><div class="line">			invokeAll(task1,task2);</div><div class="line">			</div><div class="line">			try &#123;</div><div class="line">				result=groupResults(task1.get(),task2.get());</div><div class="line">			&#125; catch (InterruptedException | ExecutionException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//实现processLines()方法。接收4个参数，一个字符串document矩阵，</div><div class="line">	//start属性，end属性和任务将要查找的词word的属性。</div><div class="line">	private Integer processLines(String[][] document, int start, int end, String word) &#123;</div><div class="line">		//为任务所要处理的每一行，创建一个LineTask对象，然后存储在任务列表里。</div><div class="line">		List&lt;LineTask&gt; tasks=new ArrayList&lt;LineTask&gt;();</div><div class="line">		for (int i=start; i&lt;end; i++) &#123;</div><div class="line">			LineTask task=new LineTask(document[i], 0, document[i].length, word);</div><div class="line">			tasks.add(task);</div><div class="line">		&#125;</div><div class="line">		invokeAll(tasks);</div><div class="line">		</div><div class="line">		//合计这些任务返回的值，并返回结果。</div><div class="line">		int result=0;</div><div class="line">		for (int i=0; i&lt;tasks.size(); i++) &#123;</div><div class="line">			LineTask task=tasks.get(i);</div><div class="line">			try &#123;</div><div class="line">				result=result+task.get();</div><div class="line">			&#125; catch (InterruptedException | ExecutionException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return new Integer(result);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//实现groupResults()方法。它将两个数字相加并返回结果。</div><div class="line">	private Integer groupResults(Integer number1, Integer number2) &#123;</div><div class="line">		Integer result;</div><div class="line">		result=number1+number2;</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建名为LineTask的类，并继承RecursiveTask类，RecursiveTask类的泛型参数为Integer类型。这个RecursiveTask类实现了一个任务，用来计算所要查找的词在一行中出现的次数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line">public class LineTask extends RecursiveTask&lt;Integer&gt; &#123;</div><div class="line">	private static final long serialVersionUID = 1L;</div><div class="line">	</div><div class="line">	//声明一个名为line的私有String数组属性和两个名为start和end的私有int属性。</div><div class="line">	//最后，声明一个名为word的私有String属性。</div><div class="line">	private String line[];</div><div class="line">	private int start, end;</div><div class="line">	private String word;</div><div class="line">	</div><div class="line">	public LineTask(String line[], int start, int end, String word) &#123;</div><div class="line">		this.line=line;</div><div class="line">		this.start=start;</div><div class="line">		this.end=end;</div><div class="line">		this.word=word;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected Integer compute() &#123;</div><div class="line">		Integer result=null;</div><div class="line"></div><div class="line">		if (end-start&lt;100) &#123;</div><div class="line">			result=count(line, start, end, word);</div><div class="line">			</div><div class="line">		&#125; else &#123;</div><div class="line">			int mid=(start+end)/2;</div><div class="line">			LineTask task1=new LineTask(line, start, mid, word);</div><div class="line">			LineTask task2=new LineTask(line, mid, end, word);</div><div class="line">			invokeAll(task1, task2);</div><div class="line"></div><div class="line">			try &#123;</div><div class="line">				result=groupResults(task1.get(),task2.get());</div><div class="line">				&#125; catch (InterruptedException | ExecutionException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//实现count()方法。它接收4个参数，一个完整行字符串line数组，</div><div class="line">	//start属性，end属性和任务将要查找的词word的属性。</div><div class="line">	private Integer count(String[] line, int start, int end, String word) &#123;</div><div class="line">		int counter;</div><div class="line">		counter=0;</div><div class="line">		for (int i=start; i&lt;end; i++)&#123;</div><div class="line">			if (line[i].equals(word))&#123;</div><div class="line">				counter++;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		//为了延缓范例的执行，将任务休眠10毫秒。</div><div class="line">		try &#123;</div><div class="line">			Thread.sleep(10);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		return counter;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private Integer groupResults(Integer number1, Integer number2) &#123;</div><div class="line">		Integer result;</div><div class="line">		result=number1+number2;</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		//创建Document对象，包含100行，每行1,000个词。</div><div class="line">		DocumentMock mock=new DocumentMock();</div><div class="line">		String[][] document=mock.generateDocument(100, 1000, &quot;the&quot;);</div><div class="line">		//创建一个DocumentTask对象，用来更新整个文档。传递数字0给参数start，以及数字100给参数end。</div><div class="line">		DocumentTask task=new DocumentTask(document, 0, 100, &quot;the&quot;);</div><div class="line"></div><div class="line">		ForkJoinPool pool=new ForkJoinPool();</div><div class="line">		pool.execute(task);</div><div class="line">		</div><div class="line">		do &#123;</div><div class="line">			System.out.printf(&quot;******************************************\n&quot;);</div><div class="line">			System.out.printf(&quot;Main: Parallelism: %d\n&quot;,pool.getParallelism());</div><div class="line">			System.out.printf(&quot;Main: Active Threads: %d\n&quot;,pool.getActiveThreadCount());</div><div class="line">			System.out.printf(&quot;Main: Task Count: %d\n&quot;,pool.getQueuedTaskCount());</div><div class="line">			System.out.printf(&quot;Main: Steal Count: %d\n&quot;,pool.getStealCount());</div><div class="line">			System.out.printf(&quot;******************************************\n&quot;);</div><div class="line"></div><div class="line">			try &#123;</div><div class="line">				TimeUnit.SECONDS.sleep(1);</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125; while (!task.isDone());</div><div class="line"></div><div class="line">		pool.shutdown();</div><div class="line"></div><div class="line">		//调用awaitTermination()等待任务执行结束。</div><div class="line">		try &#123;</div><div class="line">			pool.awaitTermination(1, TimeUnit.DAYS);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		try &#123;</div><div class="line">			System.out.printf(&quot;Main: The word appears %d in the document&quot;,task.get());</div><div class="line">		&#125; catch (InterruptedException | ExecutionException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">DocumentMock: The word appears 9921 times in the document</div><div class="line">******************************************</div><div class="line">Main: Parallelism: 4</div><div class="line">Main: Active Threads: 4</div><div class="line">Main: Task Count: 31</div><div class="line">Main: Steal Count: 0</div><div class="line">******************************************</div><div class="line">******************************************</div><div class="line">Main: Parallelism: 4</div><div class="line">Main: Active Threads: 4</div><div class="line">Main: Task Count: 32</div><div class="line">Main: Steal Count: 0</div><div class="line">******************************************</div><div class="line">******************************************</div><div class="line">Main: Parallelism: 4</div><div class="line">Main: Active Threads: 4</div><div class="line">Main: Task Count: 12</div><div class="line">Main: Steal Count: 0</div><div class="line">******************************************</div><div class="line">******************************************</div><div class="line">Main: Parallelism: 4</div><div class="line">Main: Active Threads: 4</div><div class="line">Main: Task Count: 18</div><div class="line">Main: Steal Count: 0</div><div class="line">******************************************</div><div class="line">******************************************</div><div class="line">Main: Parallelism: 4</div><div class="line">Main: Active Threads: 4</div><div class="line">Main: Task Count: 15</div><div class="line">Main: Steal Count: 0</div><div class="line">******************************************</div><div class="line">Main: The word appears 9921 in the document</div></pre></td></tr></table></figure></p>
<h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h4><p>在这个范例中，我们实现了两个不同的任务。</p>
<ul>
<li>DocumentTask类：这个类的任务需要处理由start和end属性决定的文档行。如果这些行数小于10，那么，就每行创建一个LineTask对象，然后在任务执行结束后，合计返回的结果，并返回总数。如果任务要处理的行数大于10，那么，将任务拆分成两组，并创建两个DocumentTask对象来处理这两组对象。当这些任务执行结束后，同样合计返回的结果，并返回总数。</li>
<li>LineTask类：这个类的任务需要处理文档中一行的某一组词。如果一组词的个数小100，那么任务将直接在这一组词里搜索特定词，然后返回查找词在这一组词中出现的次数。否则，任务将拆分这些词为两组，并创建两个LineTask对象来处理这两组词。当这些任务执行完成后，合计返回的结果，并返回总数。</li>
</ul>
<p>在Main主类中，我们通过默认的构造器创建了ForkJoinPool对象，然后执行DocumentTask类，来处理一个共有100行，每行1,000字的文档。这个任务将问题拆分成DocumentTask对象和LineTask对象，然后当所有的任务执行完成后，使用原始的任务来获取整个文档中所要查找的词出现的次数。由于任务继承了RecursiveTask类，因此能够返回结果。</p>
<p>调用get()方法来获得Task返回的结果。这个方法声明在Future接口里，并由RecursiveTask类实现。</p>
<p>执行程序时，在控制台上，我们可以比较第一行与最后一行的输出信息。第一行是文档生成时被查找的词出现的次数，最后一行则是通过Fork／Join任务计算而来的被查找的词出现的次数，而且这两个数字相同。</p>
<h4 id="更多信息-1"><a href="#更多信息-1" class="headerlink" title="更多信息"></a>更多信息</h4><p><strong>ForkJoinTask类提供了另一个complete()方法来结束任务的执行并返回结果。这个方法接收一个对象，对象的类型就是RecursiveTask类的泛型参数，然后在任务调用join()方法后返回这个对象作为结果。这一过程采用了推荐的异步任务来返回任务的结果</strong>。</p>
<p>由于RecursiveTask类实现了Future接口，因此还有get()方法调用的其他版本：</p>
<ul>
<li>get(long timeout, TimeUnit unit)：这个版本中，如果任务的结果未准备好，将等待指定的时间。如果等待时间超出，而结果仍未准备好，那方法就会返回null值。</li>
</ul>
<p><strong>TimeUnit是一个枚举类，有如下的常量：DAYS、HOURS、MICROSECONDS、MILLISECONDS、MINUTES、NANOSECONDS和SECONDS</strong>。</p>
<h2 id="异步运行任务"><a href="#异步运行任务" class="headerlink" title="异步运行任务"></a>异步运行任务</h2><p><strong>在ForkJoinPool中执行 ForkJoinTask时，可以采用同步或异步方式。当采用同步方式执行时，发送任务给Fork/Join线程池的方法直到任务执行完成后才会返回结果。而采用异步方式执行时，发送任务给执行器的方法将立即返回结果，但是任务仍能够继续执行</strong>。</p>
<p>需要明白这两种方式在执行任务时的一个很大的区别。<strong>当采用同步方式，调用这些方法（比如，invokeAll()方法）时，任务被挂起，直到任务被发送到Fork/Join线程池中执行完成。这种方式允许ForkJoinPool类采用工作窃取算法（Work-StealingAlgorithm）来分配一个新任务给在执行休眠任务的工作者线程（WorkerThread）。相反，当采用异步方法（比如，fork()方法）时，任务将继续执行，因此ForkJoinPool类无法使用工作窃取算法来提升应用程序的性能</strong>。在这个示例中，只有调用join()或get()方法来等待任务的结束时，ForkJoinPool类才可以使用工作窃取算法。</p>
<p>本节将学习如何使用ForkJoinPool和ForkJoinTask类所提供的异步方法来管理任务。我们将实现一个程序：在一个文件夹及其子文件夹中来搜索带有指定扩展名的文件。ForkJoinTask类将实现处理这个文件夹的内容。而对于这个文件夹中的每一个子文件，任务将以异步的方式发送一个新的任务给ForkJoinPool类。对于每个文件夹中的文件，任务将检查任务文件的扩展名，如果符合条件就将其增加到结果列表中。</p>
<h4 id="范例实现-1"><a href="#范例实现-1" class="headerlink" title="范例实现"></a>范例实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">public class FolderProcessor  extends RecursiveTask&lt;List&lt;String&gt;&gt; &#123;</div><div class="line">	private static final long serialVersionUID = 1L;</div><div class="line">	</div><div class="line">	//声明一个名为path的私有String属性，用来存储任务将要处理的文件夹的完整路径。</div><div class="line">	private String path;</div><div class="line">	//声明一个名为extension的私有String属性，用来存储任务将要查找的文件的扩展名。</div><div class="line">	private String extension;</div><div class="line"></div><div class="line">	public FolderProcessor (String path, String extension) &#123;</div><div class="line">		this.path=path;</div><div class="line">		this.extension=extension;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected List&lt;String&gt; compute() &#123;</div><div class="line">		//声明一个名为list的String对象列表，用来存储文件夹中文件的名称。</div><div class="line">		List&lt;String&gt; list=new ArrayList&lt;&gt;();</div><div class="line">		//声明一个名为tasks的FolderProcessor任务列表，用来存储子任务，这些子任务将处理文件夹中的子文件夹。</div><div class="line">		List&lt;FolderProcessor&gt; tasks=new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">		File file=new File(path);</div><div class="line">		File content[] = file.listFiles();</div><div class="line">		</div><div class="line">		if (content != null) &#123;</div><div class="line">			for (int i = 0; i &lt; content.length; i++) &#123;</div><div class="line">				//对于文件夹中的每一个元素，如果它是子文件夹，就创建一个新的FolderProcessor对象，</div><div class="line">				//然后调用fork()方法采用异步方式来执行它。</div><div class="line">				if (content[i].isDirectory()) &#123;</div><div class="line">					FolderProcessor task=new FolderProcessor(content[i].getAbsolutePath(), extension);</div><div class="line">					task.fork();</div><div class="line">					tasks.add(task);</div><div class="line">					</div><div class="line">				&#125; else &#123;</div><div class="line">					//否则，调用checkFile()方法来比较文件的扩展名。如果文件的扩展名与将要搜索的扩展名相同，</div><div class="line">					//就将文件的完整路径存储到列表中。</div><div class="line">					if (checkFile(content[i].getName()))&#123;</div><div class="line">						list.add(content[i].getAbsolutePath());</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			if (tasks.size()&gt;50) &#123;</div><div class="line">				System.out.printf(&quot;%s: %d tasks ran.\n&quot;, file.getAbsolutePath(), tasks.size());</div><div class="line">			&#125;</div><div class="line">			//调用addResultsFromTask()辅助方法。它把通过这个任务而启动的子任务返回的结果增加到文件列表中。</div><div class="line">			//传递两个参数给这个方法，一个是字符串列表list，一个是FolderProcessor子任务列表tasks。</div><div class="line">			addResultsFromTasks(list,tasks);</div><div class="line">		&#125;</div><div class="line">		return list;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//实现addResultsFromTasks()方法。遍历任务列表中存储的每一个任务，调用join()方法等待任务执行结束，并且返回任务的结果。</div><div class="line">	//然后，调用addAll()方法将任务的结果增加到字符串列表中。</div><div class="line">	private void addResultsFromTasks(List&lt;String&gt; list, List&lt;FolderProcessor&gt; tasks) &#123;</div><div class="line">		for (FolderProcessor item: tasks) &#123;</div><div class="line">			list.addAll(item.join());</div><div class="line">		&#125;</div><div class="line">	 &#125;</div><div class="line">	</div><div class="line">	private boolean checkFile(String name) &#123;</div><div class="line">		return name.endsWith(extension);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ForkJoinPool pool=new ForkJoinPool();</div><div class="line"></div><div class="line">		//创建3个FolderProcessor任务，并使用不同的文件夹路径来初始化这些任务。</div><div class="line">		FolderProcessor system=new FolderProcessor(&quot;/Users/chenliqiang/Documents/git/b2b&quot;, &quot;java&quot;);</div><div class="line">		FolderProcessor apps=new FolderProcessor(&quot;/Users/chenliqiang/Documents/git/oss&quot;,&quot;java&quot;);</div><div class="line">		FolderProcessor documents=new FolderProcessor(&quot;/Users/chenliqiang/Documents/git/logistics&quot;,&quot;java&quot;);</div><div class="line">		</div><div class="line">		pool.execute(system);</div><div class="line">		pool.execute(apps);</div><div class="line">		pool.execute(documents);</div><div class="line"></div><div class="line">		do &#123;</div><div class="line">			System.out.printf(&quot;******************************************\n&quot;);</div><div class="line">			System.out.printf(&quot;Main: Parallelism: %d\n&quot;,pool.getParallelism());</div><div class="line">			System.out.printf(&quot;Main: Active Threads: %d\n&quot;,pool.getActiveThreadCount());</div><div class="line">			System.out.printf(&quot;Main: Task Count: %d\n&quot;,pool.getQueuedTaskCount());</div><div class="line">			System.out.printf(&quot;Main: Steal Count: %d\n&quot;,pool.getStealCount());</div><div class="line">			System.out.printf(&quot;******************************************\n&quot;);</div><div class="line"></div><div class="line">			try &#123;</div><div class="line">				TimeUnit.SECONDS.sleep(1);</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125; while ((!system.isDone())||(!apps.isDone())||(!documents.isDone()));</div><div class="line"></div><div class="line">		pool.shutdown();</div><div class="line"></div><div class="line">		List&lt;String&gt; results;</div><div class="line">		results = system.join();</div><div class="line">		System.out.printf(&quot;System: %d files found.\n&quot;,results.size());</div><div class="line">		results=apps.join();</div><div class="line">		System.out.printf(&quot;Apps: %d files found.\n&quot;,results.size());</div><div class="line">		results=documents.join();</div><div class="line">		System.out.printf(&quot;Documents: %d files found.\n&quot;,results.size());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">******************************************</div><div class="line">/Users/chenliqiang/Documents/git/oss/src/main/webapp/WEB-INF/template/admin: 68 tasks ran.</div><div class="line">/Users/chenliqiang/Documents/git/b2b/.git/objects: 79 tasks ran.</div><div class="line">/Users/chenliqiang/Documents/git/oss/target/oss/WEB-INF/template/admin: 67 tasks ran.</div><div class="line">/Users/chenliqiang/Documents/git/oss/target/oss/resources/admin: 63 tasks ran.</div><div class="line">/Users/chenliqiang/Documents/git/oss/.git/objects: 258 tasks ran.</div><div class="line">/Users/chenliqiang/Documents/git/oss/src/main/webapp/resources/admin: 64 tasks ran.</div><div class="line">/Users/chenliqiang/Documents/git/logistics/.git/objects: 258 tasks ran.</div><div class="line">Main: Parallelism: 4</div><div class="line">Main: Active Threads: 3</div><div class="line">Main: Task Count: 0</div><div class="line">Main: Steal Count: 809</div><div class="line">******************************************</div><div class="line">System: 1503 files found.</div><div class="line">Apps: 1123 files found.</div><div class="line">Documents: 335 files found.</div></pre></td></tr></table></figure></p>
<h4 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h4><p>这个范例的重点在于FolderProcessor类。每一个任务处理一个文件夹中的内容。文件夹中的内容有以下两种类型的元素：</p>
<ul>
<li>文件；</li>
<li>其他文件夹。</li>
</ul>
<p>如果主任务发现一个文件夹，它将创建另一个Task对象来处理这个文件夹，调用fork()方法把这个新对象发送到线程池中。fork()方法发送任务到线程池时，如果线程池中有空闲的工作者线程（WorkerThread）或者将创建一个新的线程，那么开始执行这个任务，fork()方法会立即返回，因此，主任务可以继续处理文件夹里的其他内容。对于每一个文件，任务开始比较它的文件扩展名，如果与要搜索的扩展名相同，那么将文件的完整路径增加到结果列表中。</p>
<p>一旦主任务处理完指定文件夹里的所有内容，它将调用join()方法等待发送到线程池中的所有子任务执行完成。join()方法在主任务中被调用，然后等待任务执行结束，并通过compute()方法返回值。主任务将所有的子任务结果进行合并，这些子任务发送到线程池中时带有自己的结果列表，然后通过调用compute()方法返回这个列表并作为主任务的返回值。</p>
<p>ForkJoinPool类也允许以异步的方式执行任务。调用execute()方法发送3个初始任务到线程池中。在Main主类中，调用shutdown()方法结束线程池，并在控制台输出线程池中任务的状态及其变化的过程。ForkJoinPool类包含了多个方法可以实现这个目的。</p>
<h4 id="更多信息-2"><a href="#更多信息-2" class="headerlink" title="更多信息"></a>更多信息</h4><p>本范例使用join()方法来等待任务的结束，然后获取它们的结果。也可以使用get()方法以下的两个版本来完成这个目的。</p>
<ul>
<li>get()：如果ForkJoinTask类执行结束，或者一直等到结束，那么get()方法的这个版本则返回由compute()方法返回的结果。</li>
<li>get(long timeout, TimeUnit unit)：如果任务的结果未准备好，那么get()方法的  这个版本将等待指定的时间。如果超过指定的时间了，任务的结果仍未准备好，那么这    个方法将返回 null值。TimeUnit是一个枚举类，有如下的常量：DAYS、HOURS、MICROSECONDS、MILLISECONDS、MINUTES、NANOSECONDS和SECONDS。</li>
</ul>
<p>get()方法和join()方法还存在两个主要的区别：</p>
<ul>
<li>join()方法不能被中断，如果中断调用join()方法的线程，方法将抛出InterruptedException异常；</li>
<li>如果任务抛出任何运行时异常，那么 get()方法将返回ExecutionException异常，但是join()方法将返回RuntimeException异常。</li>
</ul>
<h2 id="在任务中抛出异常"><a href="#在任务中抛出异常" class="headerlink" title="在任务中抛出异常"></a>在任务中抛出异常</h2><p>Java有两种类型的异常。</p>
<ul>
<li>非运行时异常（Checked Exception）：这些异常必须在方法上通过throws子句抛出，或者在方法体内通过try{…}catch{…}方式进行捕捉处理。比如IOException或ClassNotFoundException异常。</li>
<li>运行时异常（Unchecked Exception）：这些异常不需要在方法上通过throws子句抛出，也不需要在方法体内通过try{…}catch{…}方式进行捕捉处理。比如NumberFormatException异常。</li>
</ul>
<p><strong>不能在ForkJoinTask类的compute()方法中抛出任务非运行时异常，因为这个方法的实现没有包含任何throws声明。因此，需要包含必需的代码来处理相关的异常</strong>。另一方面，<strong>compute()方法可以抛出运行时异常（它可以是任何方法或者方法内的对象抛出的异常）</strong>。ForkJoinTask类和ForkJoinPool类的行为与我们期待的可能不同。在控制台上，程序没有结束执行，不能看到任务异常信息。如果异常不被抛出，那么它只是简单地将异常吞噬掉。然而，我们能够利用ForkJoinTask类的一些方法来获知任务是否有异常抛出，以及抛出哪一种类型的异常。在本节，我们将学习如何获取这些异常信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">public class Task extends RecursiveTask&lt;Integer&gt;  &#123;</div><div class="line">	private static final long serialVersionUID = 1L;</div><div class="line"></div><div class="line">	//声明一个名为array的私有int数组。用来模拟在这个范例中即将处理的数据数组。</div><div class="line">	private int array[];</div><div class="line"></div><div class="line">	//声明两个分别名为start和end的私有int属性。这些属性将决定任务要处理的数组元素。</div><div class="line">	private int start, end;</div><div class="line"></div><div class="line">	public Task(int array[], int start, int end)&#123;</div><div class="line">		this.array=array;</div><div class="line">		this.start=start;</div><div class="line">		this.end=end;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected Integer compute() &#123;</div><div class="line">		System.out.printf(&quot;Task: Start from %d to %d\n&quot;,start,end);</div><div class="line">		//如果由start和end属性所决定的元素块规模小于10，那么直接检查元素，</div><div class="line">		//当碰到元素块的第4个元素（索引位为3）时，就抛出RuntimeException异常。然后将任务休眠1秒钟。</div><div class="line">		if (end-start&lt;10) &#123;</div><div class="line">			if ((3&gt;start)&amp;&amp;(3&lt;end))&#123;</div><div class="line">				throw new RuntimeException(&quot;This task throws an Exception: Task from &quot;+start+&quot; to &quot;+end);</div><div class="line">			&#125;</div><div class="line">			try &#123;</div><div class="line">				TimeUnit.SECONDS.sleep(1);</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">		&#125; else &#123;</div><div class="line">			//如果要处理的元素块规模大于或等于10，就拆分这个元素块为两部分，</div><div class="line">			//并创建两个Task对象来处理这两部分，然后调用invokeAll()方法在线程池中执行这两个Task对象。</div><div class="line">			int mid=(end+start)/2;</div><div class="line">			Task task1=new Task(array,start,mid);</div><div class="line">			Task task2=new Task(array,mid,end);</div><div class="line">			invokeAll(task1, task2);</div><div class="line">		&#125;</div><div class="line">		System.out.printf(&quot;Task: End form %d to %d\n&quot;,start,end);</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int array[]=new int[20];</div><div class="line">		Task task=new Task(array,0,20);</div><div class="line">		ForkJoinPool pool=new ForkJoinPool();</div><div class="line">		pool.execute(task);</div><div class="line">		pool.shutdown();</div><div class="line"></div><div class="line">		//调用awaitTermination()方法等待任务执行结束。如果想一直等待到任务执行完成，</div><div class="line">		//那就传递值1和TimeUnit.DAYS作为参数给这个方法。</div><div class="line">		try &#123;</div><div class="line">			pool.awaitTermination(1, TimeUnit.DAYS);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		//调用isCompletedAbnormally()方法来检查主任务或者它的子任务之一是否抛出了异常。</div><div class="line">		//在这个示例中，在控制台输出信息就表示有异常抛出。调用ForkJoinTask类的getException()方法来获取异常信息。</div><div class="line">		if (task.isCompletedAbnormally()) &#123;</div><div class="line">			System.out.printf(&quot;Main: An exception has ocurred\n&quot;);</div><div class="line">			System.out.printf(&quot;Main: %s\n&quot;,task.getException());</div><div class="line">		&#125;</div><div class="line">		System.out.printf(&quot;Main: Result: %d&quot;,task.join());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">Task: Start from 0 to 20</div><div class="line">Task: Start from 0 to 10</div><div class="line">Task: Start from 10 to 20</div><div class="line">Task: Start from 5 to 10</div><div class="line">Task: Start from 0 to 5</div><div class="line">Task: Start from 15 to 20</div><div class="line">Task: Start from 10 to 15</div><div class="line">Task: End form 5 to 10</div><div class="line">Task: End form 15 to 20</div><div class="line">Task: End form 10 to 15</div><div class="line">Task: End form 10 to 20</div><div class="line">Main: An exception has ocurred</div><div class="line">Main: java.lang.RuntimeException: java.lang.RuntimeException: This task throws an Exception: Task from 0 to 5</div><div class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: java.lang.RuntimeException: This task throws an Exception: Task from 0 to 5</div><div class="line">	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</div><div class="line">	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</div><div class="line">	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</div><div class="line">	at java.lang.reflect.Constructor.newInstance(Constructor.java:422)</div><div class="line">	at java.util.concurrent.ForkJoinTask.getThrowableException(ForkJoinTask.java:593)</div><div class="line">	at java.util.concurrent.ForkJoinTask.reportException(ForkJoinTask.java:677)</div><div class="line">	at java.util.concurrent.ForkJoinTask.join(ForkJoinTask.java:720)</div><div class="line">	at com.highsunbuy.message.bean.Task.main(Task.java:72)</div><div class="line">Caused by: java.lang.RuntimeException: This task throws an Exception: Task from 0 to 5</div><div class="line">	at com.highsunbuy.message.bean.Task.compute(Task.java:31)</div><div class="line">	at com.highsunbuy.message.bean.Task.compute(Task.java:1)</div><div class="line">	at java.util.concurrent.RecursiveTask.exec(RecursiveTask.java:94)</div><div class="line">	at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)</div><div class="line">	at java.util.concurrent.ForkJoinTask.doInvoke(ForkJoinTask.java:401)</div><div class="line">	at java.util.concurrent.ForkJoinTask.invokeAll(ForkJoinTask.java:759)</div><div class="line">	at com.highsunbuy.message.bean.Task.compute(Task.java:45)</div><div class="line">	at com.highsunbuy.message.bean.Task.compute(Task.java:1)</div><div class="line">	at java.util.concurrent.RecursiveTask.exec(RecursiveTask.java:94)</div><div class="line">	at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)</div><div class="line">	at java.util.concurrent.ForkJoinTask.doInvoke(ForkJoinTask.java:401)</div><div class="line">	at java.util.concurrent.ForkJoinTask.invokeAll(ForkJoinTask.java:759)</div><div class="line">	at com.highsunbuy.message.bean.Task.compute(Task.java:45)</div><div class="line">	at com.highsunbuy.message.bean.Task.compute(Task.java:1)</div><div class="line">	at java.util.concurrent.RecursiveTask.exec(RecursiveTask.java:94)</div><div class="line">	at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)</div><div class="line">	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)</div><div class="line">	at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1689)</div><div class="line">	at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)</div></pre></td></tr></table></figure></p>
<h4 id="工作原理-3"><a href="#工作原理-3" class="headerlink" title="工作原理"></a>工作原理</h4><p>在本节，我们实现的Task类用来处理一个数字数组。它检查要处理的数字块规模是否包含有10个或更多个元素。在这个情况下，Task类拆分这个数字块为两部分，然后创建两个新的Task对象用来处理这两部分。否则，它将寻找位于数组中第4个位置（索引位为3）的元素。如果这个元素位于任务处理块中，它将抛出一个RuntimeException异常。</p>
<p>虽然运行这个程序时将抛出异常，但是程序不会停止。在Main主类中，调用原始任务ForkJoinTask类的isCompletedAbnormally()方法，如果主任务或者它的子任务之一抛出了异常，这个方法将返回true。也可以使用getException()方法来获得抛出的Exception对象。</p>
<p>当任务抛出运行时异常时，会影响它的父任务（发送到ForkJoinPool类的任务），以及父任务的父任务，以此类推。查阅程序的输出结果，将会发现有一些任务没有结束的信息。那些任务的开始信息如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Task: Start from 0 to 20</div><div class="line">Task: Start from 0 to 10</div><div class="line">Task: Start from 0 to 5</div></pre></td></tr></table></figure></p>
<p>这些任务是那些抛出异常的任务和它的父任务。所有这些任务都是异常结束的。记住一点：<strong>在用ForkJoinPool对象和ForkJoinTask对象开发一个程序时，它们是会抛出异常的，如果不想要这种行为，就得采用其他方式</strong>。</p>
<h4 id="更多信息-3"><a href="#更多信息-3" class="headerlink" title="更多信息"></a>更多信息</h4><p>在范例中，不采用抛出异常，而调用ForkJoinTask类的completeExceptionally()方法也可以获得同样的结果。代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Exception e=new Exception(&quot;This task throws an Exception: &quot;+ &quot;Task</div><div class="line">from &quot;+start+&quot; to &quot;+end);</div><div class="line"></div><div class="line">completeExceptionally(e);</div></pre></td></tr></table></figure></p>
<h2 id="取消任务"><a href="#取消任务" class="headerlink" title="取消任务"></a>取消任务</h2><p>在ForkJoinPool类中执行ForkJoinTask对象时，在任务开始执行前可以取消它。ForkJoinTask类提供了cancel()方法来达到取消任务的目的。在取消一个任务时必须要注意以下两点：</p>
<ul>
<li>ForkJoinPool类不提供任何方法来取消线程池中正在运行或者等待运行的所有任务；</li>
<li>取消任务时，不能取消已经被执行的任务。</li>
</ul>
<p>在本节，我们将实现一个取消ForkJoinTask对象的范例。该范例将寻找数组中某个数字所处的位置。第一个任务是寻找可以被取消的剩余任务数。由于Fork／Join框架没有提供取消功能，我们将创建一个辅助类来实现取消任务的操作。</p>
<h4 id="范例实现-2"><a href="#范例实现-2" class="headerlink" title="范例实现"></a>范例实现</h4><p>创建一个名为ArrayGenerator的类。这个类将生成一个指定大小的随机整数数组。实现generateArray()方法，它将生成数字数组，接收一个int参数表示数组的大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class ArrayGenerator &#123;</div><div class="line">	public int[] generateArray(int size) &#123;</div><div class="line">		int array[]=new int[size];</div><div class="line">		Random random=new Random();</div><div class="line">		for (int i=0; i&lt;size; i++)&#123;</div><div class="line">			array[i]=random.nextInt(10);</div><div class="line">		&#125;</div><div class="line">		return array;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建一个名为TaskManager的类。本示例将利用这个类来存储在ForkJoinPool中执行的任务。由于ForkJoinPool和ForkJoinTask类的局限性，将利用TaskManager类来取消ForkJoinPool类中所有的任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class TaskManager &#123;</div><div class="line">	//声明一个名为tasks的对象列表，带有ForkJoinTask泛型参数，并且ForkJoinTask带有Integer泛型参数。</div><div class="line">	private List&lt;ForkJoinTask&lt;Integer&gt;&gt; tasks;</div><div class="line"></div><div class="line">	public TaskManager()&#123;</div><div class="line">		tasks=new ArrayList&lt;&gt;();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void addTask(ForkJoinTask&lt;Integer&gt; task)&#123;</div><div class="line">		tasks.add(task);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//实现cancelTasks()方法。遍历存储在列表中的所有ForkJoinTask对象，然后调用cancel()方法取消之。</div><div class="line">	//cancelTasks()方法接收一个要取消剩余任务的ForkJoinTask对象作为参数，然后取消所有的任务。</div><div class="line">	public void cancelTasks(ForkJoinTask&lt;Integer&gt; cancelTask)&#123;</div><div class="line">		for (ForkJoinTask&lt;Integer&gt; task :tasks) &#123;</div><div class="line">			if (task!=cancelTask) &#123;</div><div class="line">				task.cancel(true);</div><div class="line">				((SearchNumberTask)task).writeCancelMessage();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现SearchNumberTask类，并继承RecursiveTask类，RecursiveTask类的泛型参数为Integer类型。这个类将寻找在整数数组元素块中的一个数字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">public class SearchNumberTask  extends RecursiveTask&lt;Integer&gt; &#123;</div><div class="line">	private static final long serialVersionUID = 1L;</div><div class="line">	private int numbers[];</div><div class="line">	private int start, end;</div><div class="line">	private int number;</div><div class="line">	</div><div class="line">	private TaskManager manager;</div><div class="line">	private final static int NOT_FOUND=-1;</div><div class="line"></div><div class="line">	public SearchNumberTask (int numbers[], int start, int end, int number, TaskManager manager)&#123;</div><div class="line">		this.numbers=numbers;</div><div class="line">		this.start=start;</div><div class="line">		this.end=end;</div><div class="line">		this.number=number;</div><div class="line">		this.manager=manager;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected Integer compute() &#123;</div><div class="line">		System.out.println(&quot;Task: &quot;+start+&quot;:&quot;+end);</div><div class="line"></div><div class="line">		int ret;</div><div class="line">		//如果start和end属性值的差异大于10（任务必须处理大于10个元素的数组），</div><div class="line">		//那么，就调用launchTasks()方法将这个任务拆分为两个子任务。</div><div class="line">		if (end-start&gt;10) &#123;</div><div class="line">			ret=launchTasks();</div><div class="line">			</div><div class="line">		&#125; else &#123;</div><div class="line">			//否则，寻找在数组块中的数字，调用lookForNumber()方法处理这个任务。</div><div class="line">			ret=lookForNumber();</div><div class="line">		&#125;</div><div class="line">		return ret;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private int lookForNumber() &#123;</div><div class="line">		//遍历任务所要处理的数组块中的所有元素，将元素中存储的数字和将要寻找的数字进行比较。</div><div class="line">		//如果它们相等，就在控制台输出信息表示找到了，并用TaskManager对象的cancelTasks()方法取消所有的任务，然后返回已找到的这个元素所在的位置。</div><div class="line">		for (int i=start; i&lt;end; i++)&#123;</div><div class="line">			if (numbers[i]==number) &#123;</div><div class="line">				System.out.printf(&quot;Task: Number %d found in position %d\n&quot;,number,i);</div><div class="line">				manager.cancelTasks(this);</div><div class="line">				return i;</div><div class="line">			&#125;</div><div class="line">			try &#123;</div><div class="line">				TimeUnit.SECONDS.sleep(1);</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return NOT_FOUND;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//实现launchTasks()方法。将这个任务要处理的元素块拆分成两部分，然后创建两个Task对象来处理它们。</div><div class="line">	private int launchTasks() &#123;</div><div class="line">		int mid=(start+end)/2;</div><div class="line">		SearchNumberTask task1=new SearchNumberTask(numbers,start,mid,number,manager);</div><div class="line">		SearchNumberTask task2=new SearchNumberTask(numbers,mid,end,number,manager);</div><div class="line">		manager.addTask(task1);</div><div class="line">		manager.addTask(task2);</div><div class="line">		//调用fork()方法采用异步方式执行这两个任务。</div><div class="line">		task1.fork();</div><div class="line">		task2.fork();</div><div class="line">		</div><div class="line">		//等待任务结束，如果第一个任务返回的结果不为-1，则返回第一个任务的结果；否则返回第二个任务的结果。</div><div class="line">		int returnValue;</div><div class="line">		returnValue=task1.join();</div><div class="line">		if (returnValue!=-1) &#123;</div><div class="line">			return returnValue;</div><div class="line">		&#125;</div><div class="line">		returnValue=task2.join();</div><div class="line">		return returnValue;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//实现writeCancelMessage()方法，在控制台输入信息表示任务已经取消了。</div><div class="line">	public void writeCancelMessage()&#123;</div><div class="line">		System.out.printf(&quot;Task: Cancelled task from %d to %d&quot;,start,end);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ArrayGenerator generator=new ArrayGenerator();</div><div class="line">		int array[]=generator.generateArray(20);</div><div class="line">		TaskManager manager=new TaskManager();</div><div class="line">		ForkJoinPool pool=new ForkJoinPool();</div><div class="line">		SearchNumberTask task=new SearchNumberTask (array,0,20,5,manager);</div><div class="line">		pool.execute(task);</div><div class="line">		pool.shutdown();</div><div class="line"></div><div class="line">		//调用ForkJoinPool类的awaitTermination()方法等待任务执行结束。</div><div class="line">		try &#123;</div><div class="line">			pool.awaitTermination(1, TimeUnit.DAYS);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.printf(&quot;Main: The program has finished\n&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Task: 0:20</div><div class="line">Task: 10:20</div><div class="line">Task: 0:10</div><div class="line">Task: Number 5 found in position 12</div><div class="line">Task: Cancelled task from 0 to 10Task: Number 5 found in position 5</div><div class="line">Task: Cancelled task from 10 to 20Main: The program has finished</div></pre></td></tr></table></figure></p>
<h4 id="工作原理-4"><a href="#工作原理-4" class="headerlink" title="工作原理"></a>工作原理</h4><p>ForkJoinTask类提供的cancel()方法允许取消一个仍没有被执行的任务，这是非常重要的一点。如果任务已经开始执行，那么调用cancel()方法也无法取消。这个方法接收一个名为mayInterruptIfRunning的boolean值参数。顾名思义，如果传递true值给这个方法，即使任务正在运行也将被取消。JavaAPI文档指出，ForkJoinTask类的默认实现，这个属性没有起作用。如果任务还没有开始执行，那么这些任务将被取消。任务的取消对于已发送到线程池中的任务没有影响，它们将继续执行。</p>
<p><strong>Fork／Join框架的局限性在于，ForkJoinPool线程池中的任务不允许被取消</strong>。为了克服这种局限性，我们实现了TaskManager类，它存储发送到线程池中的所有任务，可以用一个方法来取消存储的所有任务。如果任务正在运行或者已经执行结束，那么任务就不能被取消，cancel()方法返回false值，因此可以尝试去取消所有的任务而不用担心可能带来的间接影响。</p>
<p>这个范例实现在数字数组中寻找一个数字。根据Fork／Join框架的推荐，我们将问题拆分为更小的子问题。由于我们仅关心数字的一次出现，因此，当找到它时，就会取消其他的所有任务。</p>

        </section>
    </article>
    
        
  </div>
  <aside>
    
    <div class="toc-container">
        <h1>目录</h1>
        <div class="content">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作窃取算法"><span class="toc-number">2.</span> <span class="toc-text">工作窃取算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建Fork-Join线程池"><span class="toc-number">3.</span> <span class="toc-text">创建Fork/Join线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#范例实现"><span class="toc-number">3.1.</span> <span class="toc-text">范例实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#工作原理"><span class="toc-number">3.1.1.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#更多信息"><span class="toc-number">3.1.2.</span> <span class="toc-text">更多信息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#合并任务的结果"><span class="toc-number">4.</span> <span class="toc-text">合并任务的结果</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#工作原理-1"><span class="toc-number">4.0.1.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#更多信息-1"><span class="toc-number">4.0.2.</span> <span class="toc-text">更多信息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步运行任务"><span class="toc-number">5.</span> <span class="toc-text">异步运行任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#范例实现-1"><span class="toc-number">5.0.1.</span> <span class="toc-text">范例实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#工作原理-2"><span class="toc-number">5.0.2.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#更多信息-2"><span class="toc-number">5.0.3.</span> <span class="toc-text">更多信息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在任务中抛出异常"><span class="toc-number">6.</span> <span class="toc-text">在任务中抛出异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#工作原理-3"><span class="toc-number">6.0.1.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#更多信息-3"><span class="toc-number">6.0.2.</span> <span class="toc-text">更多信息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#取消任务"><span class="toc-number">7.</span> <span class="toc-text">取消任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#范例实现-2"><span class="toc-number">7.0.1.</span> <span class="toc-text">范例实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#工作原理-4"><span class="toc-number">7.0.2.</span> <span class="toc-text">工作原理</span></a></li></ol></li></ol></li></ol>
        </div>
    </div>
    
  </aside>
</main>



  <footer>
  <div class="copyright">
    <div>
      &copy; 2018 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a>&nbsp
    </div>
    <div>
      Theme by <a href="https://github.com/lewis-geek/hexo-theme-Aath" target="_blank">Aath</a>
    </div>
  </div>
</footer>


<script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script src="/lib/in-view.min.js"></script>
<script src="/lib/lodash.min.js"></script>
<script>
  var isDown = true
  var oldY = 0
  inView.offset(50)

  document.body.addEventListener('touchstart', function(){});
  
  window.addEventListener('scroll', _.throttle(e => {
    var currentY = window.scrollY
    if((oldY - currentY) < 0) {
      isDown = true
    } else {
      isDown = false
    }
    oldY = currentY
  }, 250))

  $("article img").each(function() {
      var strA = "<a data-fancybox='gallery' href='" + this.src + "'></a>";
      $(this).wrapAll(strA);
  });

  $('.toc-link').each(function() {
      var href = $(this).attr("href");
      
      inView(href).on('exit', () => {
        if (isDown) {
          handleActive(href)
        }
      })

      inView(href).on('enter', () => {
        if (!isDown) {
          handleActive(href)
        }
      })

      this.onclick = function(e) {
        var pos = $(href).offset().top - 10;
        $("html,body").animate({scrollTop: pos}, 300);
        setTimeout(() => {
          handleActive(href)
        }, 350)
        return false
      }
  })

  function handleActive(href) {
    document.querySelectorAll('.toc-link').forEach(elm => {
      elm.classList.remove('active')
    })
    document.querySelector(".toc [href='"+ href +"']").classList.add('active')
  }
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.1.20/jquery.fancybox.min.js"></script>


</body>
</html>
