<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LeoChan&#39;s 个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="描述啊">
<meta property="og:type" content="website">
<meta property="og:title" content="LeoChan&#39;s 个人博客">
<meta property="og:url" content="https://clq2owesome.github.io/page/10/index.html">
<meta property="og:site_name" content="LeoChan&#39;s 个人博客">
<meta property="og:description" content="描述啊">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeoChan&#39;s 个人博客">
<meta name="twitter:description" content="描述啊">
  
    <link rel="alternate" href="/atom.xml" title="LeoChan&#39;s 个人博客" type="application/atom+xml">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  

</head>

<body>
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">LeoChan&#39;s 个人博客</h1>
  
    <p class="lead blog-description">技术都是通用的，重要的是是否具有自主解决问题的能力！</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-服务器相关/Memcached/一致性哈希算法" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/12/服务器相关/Memcached/一致性哈希算法/">一致性哈希算法</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/12/服务器相关/Memcached/一致性哈希算法/" class="article-date"><time datetime="2017-08-12T02:09:45.000Z" itemprop="datePublished">2017-08-12</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a> / <a class="article-category-link" href="/categories/服务器相关/Memcached/">Memcached</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。     </p>
<p>一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义：  </p>
<ol>
<li><strong>平衡性(Balance)</strong>：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</li>
<li><strong>单调性(Monotonicity)</strong>：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。 </li>
<li><strong>分散性(Spread)</strong>：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。 </li>
<li><strong>负载(Load)</strong>：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。  </li>
</ol>
<p>在分布式集群中，对机器的添加删除，或者机器故障后自动脱离集群这些操作是分布式集群管理最基本的功能。如果采用常用的hash(object)%N算法，那么在有机器添加或者删除后，很多原有的数据就无法找到了，这样严重的违反了单调性原则。接下来主要讲解一下一致性哈希算法是如何设计的：    </p>
<h4 id="环形Hash空间"><a href="#环形Hash空间" class="headerlink" title="环形Hash空间"></a>环形Hash空间</h4><p>按照常用的hash算法来将对应的key哈希到一个具有2^32<br>次方个桶的空间中，即0~(2^32)-1 的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。如下图:<br><img src="http://img.blog.csdn.net/20140411000507734?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3l3b3Nw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image">     </p>
<h5 id="把数据通过一定的hash算法处理后映射到环上"><a href="#把数据通过一定的hash算法处理后映射到环上" class="headerlink" title="把数据通过一定的hash算法处理后映射到环上"></a>把数据通过一定的hash算法处理后映射到环上</h5><p>现在我们将object1、object2、object3、object4四个对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上。如下图：<br>Hash(object1) = key1；<br>Hash(object2) = key2；<br>Hash(object3) = key3；<br>Hash(object4) = key4；  </p>
<p><img src="http://img.blog.csdn.net/20140411000620656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3l3b3Nw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"> </p>
<h5 id="将机器通过hash算法映射到环上"><a href="#将机器通过hash算法映射到环上" class="headerlink" title="将机器通过hash算法映射到环上"></a>将机器通过hash算法映射到环上</h5><p>在采用一致性哈希算法的分布式集群中将新的机器加入，其原理是通过使用与对象存储一样的Hash算法将机器也映射到环中（一般情况下对机器的hash计算是采用机器的IP或者机器唯一的别名作为输入值），然后以顺时针的方向计算，将所有对象存储到离自己最近的机器中。    </p>
<p>假设现在有NODE1，NODE2，NODE3三台机器，通过Hash算法得到对应的KEY值，映射到环中，其示意图如下：<br>Hash(NODE1) = KEY1;<br>Hash(NODE2) = KEY2;<br>Hash(NODE3) = KEY3;     </p>
<p><img src="http://img.blog.csdn.net/20140411000853609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3l3b3Nw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"> </p>
<p>通过上图可以看出对象与机器处于同一哈希空间中，这样按顺时针转动object1存储到了NODE1中，object3存储到了NODE2中，object2、object4存储到了NODE3中。在这样的部署环境中，hash环是不会变更的，因此，通过算出对象的hash值就能快速的定位到对应的机器中，这样就能找到对象真正的存储位置了。  </p>
<h5 id="机器的删除与添加"><a href="#机器的删除与添加" class="headerlink" title="机器的删除与添加"></a>机器的删除与添加</h5><p>普通hash求余算法最为不妥的地方就是在有机器的添加或者删除之后会照成大量的对象存储位置失效，这样就大大的不满足单调性了。下面来分析一下一致性哈希算法是如何处理的。    </p>
<ol>
<li>节点（机器）的删除   </li>
</ol>
<p>以上面的分布为例，如果NODE2出现故障被删除了，那么按照顺时针迁移的方法，object3将会被迁移到NODE3中，这样仅仅是object3的映射位置发生了变化，其它的对象没有任何的改动。如下图：<br><img src="http://img.blog.csdn.net/20140411001033656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3l3b3Nw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"> </p>
<ol>
<li>节点（机器）的添加    </li>
</ol>
<p>如果往集群中添加一个新的节点NODE4，通过对应的哈希算法得到KEY4，并映射到环中，如下图：<br><img src="http://img.blog.csdn.net/20140411001211062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3l3b3Nw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"> </p>
<p>通过按顺时针迁移的规则，那么object2被迁移到了NODE4中，其它对象还保持这原有的存储位置。通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。</p>
<h3 id="平衡性"><a href="#平衡性" class="headerlink" title="平衡性"></a>平衡性</h3><p>根据上面的图解分析，一致性哈希算法满足了单调性和负载均衡的特性以及一般hash算法的分散性，但这还并不能当做其被广泛应用的原由，因为还缺少了平衡性。下面将分析一致性哈希算法是如何满足平衡性的。hash算法是不保证平衡的，如上面只部署了NODE1和NODE3的情况（NODE2被删除的图），object1存储到了NODE1中，而object2、object3、object4都存储到了NODE3中，这样就照成了非常不平衡的状态。在一致性哈希算法中，为了尽可能的满足平衡性，其引入了虚拟节点。    </p>
<p><strong>“虚拟节点”（ virtual node ）是实际节点（机器）在 hash 空间的复制品（ replica ），一实际个节点（机器）对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以hash值排列。</strong>  </p>
<p>以上面只部署了NODE1和NODE3的情况（NODE2被删除的图）为例，之前的对象在机器上的分布很不均衡，现在我们以2个副本（复制个数）为例，这样整个hash环中就存在了4个虚拟节点，最后对象映射的关系图如下：<br><img src="http://img.blog.csdn.net/20140411001433375?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3l3b3Nw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"> </p>
<p>根据上图可知对象的映射关系：object1-&gt;NODE1-1，object2-&gt;NODE1-2，object3-&gt;NODE3-2，object4-&gt;NODE3-1。通过虚拟节点的引入，对象的分布就比较均衡了。那么在实际操作中，正真的对象查询是如何工作的呢？对象从hash到虚拟节点到实际节点的转换如下图：    <img src="http://img.blog.csdn.net/20140411001540656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3l3b3Nw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"><br>“虚拟节点”的hash计算可以采用对应节点的IP地址加数字后缀的方式。<br>例如假设NODE1的IP地址为192.168.1.100。引入“虚拟节点”前，计算 cache A 的 hash 值：<br>Hash(“192.168.1.100”);<br>引入“虚拟节点”后，计算“虚拟节”点NODE1-1和NODE1-2的hash值：<br>Hash(“192.168.1.100#1”); // NODE1-1<br>Hash(“192.168.1.100#2”); // NODE1-2 </p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/12/服务器相关/Memcached/一致性哈希算法/" data-id="cje2lrz8200ebpxblw0mwdxet" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/基础/JVM垃圾回收算法与收集器类型" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/12/Java/基础/JVM垃圾回收算法与收集器类型/">JVM垃圾回收算法与收集器类型</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/12/Java/基础/JVM垃圾回收算法与收集器类型/" class="article-date"><time datetime="2017-08-12T02:09:45.000Z" itemprop="datePublished">2017-08-12</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="GC的类型"><a href="#GC的类型" class="headerlink" title="GC的类型"></a>GC的类型</h2><p>当每个代满了之后都会自动促发collection，各收集器触发的条件不一样，当然也可以通过一些参数进行强制设定。主要分为两种类型：</p>
<ul>
<li>Minor Collection：GC用较高的频率对young进行扫描和回收，采用复制算法。</li>
<li>Major Collection：同时对Young和Old进行内存收集，也叫<strong>Full GC</strong>；因为成本关系对Old的检查回收频率要比Young低很多，采用标记清除/标记整理算法。可以通过调用代码System.gc()引发major collection，使用-XX:+DisableExplicitGC禁止它，或设为CMS并发-XX:+ExplicitGCInvokesConcurrent。</li>
</ul>
<p>更为具体的阐述如下：<br>由于年轻代进进出出的人多而频繁，所以年轻代的GC也就频繁一点，但涉及范围也就年轻代这点弹丸之地内的对象，其特点就是少量，多次，但快速，称之为Minor Collection。当年轻代的内存使用达到一定的阀值时，Minor Collection就被触发，Eden及某一Survior space（from space）之内存活的的对象被移到另一个空的Survior space（to space）中，然后from space和to space角色对调。当一个对象在两个survivor space之间移动过一定次数（达到预设的阀值）时，它就足够old了，够资格呆在年老代了。当然，如果survivor space比较小不足以容下所有live objects时，部分live objects也会直接晋升到年老代。 </p>
<p>Survior spaces可以看作是Eden和年老代之间的缓冲，通过该缓冲可以检验一个对象生命周期是否足够的长，因为某些对象虽然逃过了一次Minor Collection，并不能说明其生命周期足够长，说不定在下一次Minor Collection之前就挂了。这样一定程度上确保了进入年老代的对象是货真价实的，减少了年老代空间使用的增长速度，也就降低年老代GC的频率。    </p>
<p><strong>当年老代或者永久代的内存使用达到一定阀值时，一次基于所有代的GC就触发了</strong>，其特定是涉及范围广（量大），耗费的时间相对较长（较慢），但是频率比较低（次数少），称之为Major Collection(Full Collection)。通常，首先使用针对年轻代的GC算法进行年轻代的GC，然后使用针对年老代的GC算法对年老代和永久代进行GC。    </p>
<h2 id="基本GC收集算法"><a href="#基本GC收集算法" class="headerlink" title="基本GC收集算法"></a>基本GC收集算法</h2><p><strong>标记清除(mark-sweep)</strong>：收集器先从根开始访问所有活跃对象，标记为活跃对象。然后再遍历一次整个内存区域，把所有没有标记活跃的对象进行回收处理。该算法遍历整个空间的成本较大暂停时间随空间大小线性增大，而且整理后堆里的碎片很多。可参考如下的示例图：<br><img src="http://note.youdao.com/yws/public/resource/63fd0b1087cd86e931229e472fe87ee0/xmlnote/CCA572C93C2D41698291596531755BB2/7831" alt="image"> </p>
<p>不足之处：</p>
<ul>
<li>效率问题，标记和清除两个过程的效率都不高</li>
<li>空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</li>
</ul>
<p><strong>复制(copying)</strong>：为了解决效率问题，一种成为“复制”的收集算法出现了。将堆内分成两个相同空间，从根(ThreadLocal的对象，静态对象）开始访问每一个关联的活跃对象，将空间A的活跃对象全部复制到空间B，然后一次性回收整个空间A。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来一半，未免太高了一点。</p>
<p>现在一般的虚拟机都是采用这种算法来回收年轻代。<strong>HotSpot虚拟机默认Enden和Survivor的大小比例是8:1</strong>，也就是每次年轻代中可用内存空间为整个年轻代容量的90%（80%+10%），只有10%的内存会被“浪费”。当Survivor空间不够用时，需要依赖其他内存（年老代）<strong>进行分配担保（Handle Promotion）</strong>：如果Survivor空间没有足够空间存放上一次年轻代收集下来的存活对象时，这些对象将直接通过分配担保机制进入年老代。</p>
<p>因为只访问活跃对象，将所有活动对象复制走之后就清空整个空间，不用去访问死对象，所以遍历空间的成本较小，但需要巨大的复制成本和较多的内存。可参考如下的示例图：<br><img src="http://note.youdao.com/yws/public/resource/63fd0b1087cd86e931229e472fe87ee0/xmlnote/B30EF1FE809B4E2AABD3328DD2070A06/7829" alt="image"> </p>
<p><strong>标记整理(mark-sweep-compact)</strong>：综合了上述两者的做法和优点，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。可参考如下的示例图：<br><img src="http://note.youdao.com/yws/public/resource/63fd0b1087cd86e931229e472fe87ee0/xmlnote/0BCD8C3038BE460A8F667934590C8F36/7830" alt="image"> </p>
<p>总结：当前商业虚拟机的垃圾收集都采用“分代收集”算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。<strong>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收</strong>。</p>
<h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>从可达性分析中从GC Roots节点找引用链这个操作为例，可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那必然会消耗很多时间。 </p>
<p>另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个确保一致性的快照中进行-这里“一致性”的意思是指整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证。这点是导致GC进行时必须停顿所有Java执行线程（Sun将这件事称为“Stop The World”）的其中一个重要原因，即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也必须要停顿的</p>
<p>由于目前的主流Java虚拟机使用的都是准确式GC，所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。</p>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对于的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高</p>
<p>实际上，HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为<strong>安全点（Safepoint）</strong>，即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时负荷。所以安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的-因为每条执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用，循环跳转，异常跳转等，所以具有这些功能的指令才会产生Safepoint。</p>
<p>对于Safepoint，另外一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。这里有两种方案可以供选择：<strong>抢先式中断（Preemptive Suspension）</strong>和<strong>主动式中断（Voluntary Suspension）</strong></p>
<ul>
<li>抢先式中断：不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用强先式中断来暂停线程从而响应GC事件。</li>
<li>主动式中断：当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就直接中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方</li>
</ul>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>使用Safepoint似乎已经完美地解决了如何进入GC的问题，但实际情况并不一定。Safepoint机制保证了程序执行时，不不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程被分配CPU时间。对于这种情况，就需要<strong>安全区域</strong>（Safe Region）来解决。</p>
<p><strong>安全区域是指在一段代码片段中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的</strong>。我们可以把Safe Region看做是被扩展了的Safepoint。</p>
<p>在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p>
<h2 id="GC收集器类型"><a href="#GC收集器类型" class="headerlink" title="GC收集器类型"></a>GC收集器类型</h2><p>JDK1.7 Update 14之后的HotSpot虚拟机所包含的所有收集器：<br><img src="http://7xkjk9.com1.z0.glb.clouddn.com/jvm-8.jpg" alt="image"><br>如果两个收集器之间存在连线，就说明它们可以搭配使用  </p>
<p>年轻代收集器：Serial，ParNew，Parallel Scavenge<br>年老代收集器：CMS，Serial Old（MSC），Parallel Old<br>通用收集器：G1</p>
<h3 id="古老的串行收集器-Serial-："><a href="#古老的串行收集器-Serial-：" class="headerlink" title="古老的串行收集器(Serial)："></a>古老的串行收集器(<strong>Serial</strong>)：</h3><p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。  </p>
<p>是虚拟机运行在Client模式下的默认新生代收集器。它有着优于其他收集器的地方：简单而高效（与其他收集器的但线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p>
<p>-XX:+UseSerialGC：策略为年轻代串行复制，年老代串行标记整理。可参考如下的示例图：<br><img src="http://files.jb51.net/file_images/article/201702/2017021415541227.png" alt="image"> </p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio,-XX:PretenureSizeThreshold，-XX:HandlePromotionFailure等），收集算法，Stop The Wrold，对象分配规则，回收策略等都与Serial收集器完全一样。       </p>
<p>ParNew收集器也是使用<code>-XX:+UseConcMarkSweepGC</code>选项后的默认新生代收集器，也可以使用<code>-XX:+UseParNewGC</code>选项来强制指定它。</p>
<p>策略为：  </p>
<ul>
<li>年轻代：暂停应用程序，多个垃圾收集线程并行的复制收集，线程数默认为CPU个数，CPU很多时，可用<code>-XX:ParallelGCThreads</code> 设定线程数。</li>
<li>年老代：暂停应用程序，与串行收集器一样，单垃圾收集线程标记整理。  </li>
</ul>
<p>如上可知该收集器需要2+的CPU时才会优于串行收集器。可参考如下的示例图：<br><img src="http://files.jb51.net/file_images/article/201702/2017021415541328.png" alt="image"> </p>
<h3 id="Parallel-Scavenge-收集器（吞吐量优先）"><a href="#Parallel-Scavenge-收集器（吞吐量优先）" class="headerlink" title="Parallel Scavenge 收集器（吞吐量优先）"></a>Parallel Scavenge 收集器（吞吐量优先）</h3><p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。</p>
<p><strong>Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge 收集器的目标则时达到一个可控制的吞吐量（Throughput）</strong>。所谓的吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。      </p>
<p>Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量，分别是控制<strong>最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数</strong>以及<strong>直接设置吞吐量大小的-XX:GCTimeRatio参数</strong>。</p>
<ul>
<li>-XX:MaxGCPauseMillis参数：该参数允许的值是一个大于0的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。不过大家不要认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变的更快，<strong>GC停顿时间的缩短是以牺牲吞吐量和新生代空间来换取的</strong>：系统把新生代调小一些，比如收集300MB新生代肯定比收集500MB快吧，这也直接导致垃圾收集发生的更频繁一些，原来10秒收集一次，每次停顿100毫秒，现在变成5秒收集一次，每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了</li>
<li>-XX:GCTimeRatio参数：该值应当是一个大于0且小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。如果把此参数设置为19，那允许的最大GC时间就占总时间的5%（即1/（1+19）），默认值为99，就是允许最大1%（即1/（1+99））的垃圾收集时间</li>
<li>-XX:+UseAdaptiveSizePolicy参数：这是一个开关参数，当这个参数打开之后，就不需要人工指定新生代的大小（-Xmn），Eden和Survivor区的比例（-XX:SurvivorRatio）,晋升老年代对象大小（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）   </li>
</ul>
<p><img src="http://files.jb51.net/file_images/article/201702/2017021415541529.png" alt="image"></p>
<h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p>Serial Old 是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。   </p>
<p>这个收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使用，另外一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure使用。 </p>
<p>新生代采用复制算法，暂停所有用户线程；年老代采用标记-整理算法，暂停所有用户线程<br><img src="![image](http://files.jb51.net/file_images/article/201702/2017021415541227.png" alt="image"></p>
<h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p>Parallel Old 收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法，这个收集器是在JDK1.6中才开始提供的。</p>
<p>直到Parallel Old 收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old的组合。<br><img src="http://files.jb51.net/file_images/article/201702/2017021415541529.png" alt="image">   </p>
<h3 id="暂停时间优先的并发收集器-CMS"><a href="#暂停时间优先的并发收集器-CMS" class="headerlink" title="暂停时间优先的并发收集器(CMS)"></a>暂停时间优先的并发收集器(CMS)</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：</p>
<ol>
<li>初始标记：需要“Stop The Wrold”，仅仅只是标记一下GC Roots能直接关联到的对象，速度很快</li>
<li>并发标记：这个阶段就是进行GC Roots Tracing的过程</li>
<li>重新标记：需要“Stop The Wrold”，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短</li>
<li>并发清除             </li>
</ol>
<p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p>-XX:+UseConcMarkSweepGC，策略为：</p>
<ul>
<li>年轻代：同样是暂停应用程序，多个垃圾收集线程并行的复制收集。</li>
<li>年老代：则只有两次短暂停，其他时间应用程序与收集线程并发的清除。</li>
</ul>
<p>可参考如下的示例图：<br><img src="http://files.jb51.net/file_images/article/201702/2017021415541630.png" alt="image">     </p>
<p>CMS3个明显的缺点：</p>
<ol>
<li><strong>CMS收集器对CPU资源非常敏感</strong>：在并发阶段，它虽然不会导致用户线程停顿，但是因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个（譬如2个）时，CMS对用户程序的影响就可能变得很大，如果本来CPU负载就比较大，还分出一般的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%。</li>
<li><p><strong>CMS收集器无法处理浮动垃圾（Floating Garbage）</strong>：可能出现“Conurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在档次收集中处理掉它们，治好留待下一次GC时再清理掉。这一部分垃圾就称为“<strong>浮动垃圾</strong>”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时程序运作使用。      </p>
<p> 在JDK1.5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数<code>-XX:CMSInitiatingOccupancyFraction</code>的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能。</p>
<p> 在JDK1.6中，CMS收集器的启动阀值已经提升到了92%，要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备方案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说<code>-XX:CMSInitiatingOccupancyFraction</code>参数设置的太高很容易导致大量“Concurrent Mode Failure”失败，性能反而降低</p>
</li>
<li><p><strong>CMS是一款基于“标记-清除”算法实现的收集器，这就意味着收集结束时会有大量空间碎片产生</strong>。为了解决这个问题，CMS收集器提供了一个<code>-XX:+UseCMSCompactAtFullCollection</code>开关参数（默认就是开启），用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题就没有了，但停顿时间不得不变长。  </p>
<p> 虚拟机设计者还提供了另外一个参数<code>-XX:CMSFullGCsBeforeCompaction</code>，这个参数是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）</p>
</li>
</ol>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1收集器是一款面向服务端应用的垃圾收集器。在JDK1.7中，才达到足够成熟，HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK1.5中发布的CMS收集器。与其他收集器相比，G1具备如下特点：</p>
<ul>
<li><strong>并行与并发</strong>：G1能充分利用多CPU，多核环境下的硬件优势，使用多个CPU来缩短“Stop the Wrold”停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</li>
<li><strong>分代收集</strong>：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间，熬过多次GC的旧对象以获取更好的收集效果</li>
<li><strong>空间整合</strong>：与CMS的“标记-清理”算法不同，G1从整体来看是基于“标记-整理”算法来实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存</li>
<li><strong>可预测的停顿</strong>：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了</li>
</ul>
<p>在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。<strong>使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代很老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合</strong>。</p>
<p><strong>G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需要时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的region（这也就是GarBage-First名称的由来）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率</strong>。</p>
<p><strong>在G1收集器中，Region之间的对象引用以及其他收集器中的新生代和老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中，如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏</strong>。</p>
<p>如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li>初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短</li>
<li>并发标记：从GC Roots开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。</li>
<li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收：首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。因为只回收一部分Region，时间是用户可控制的，而且停顿用户将大幅提高收集效率，所以需要停顿用户线程。这部分其实也是可以并发执行的。</li>
</ul>
<p><img src="http://files.jb51.net/file_images/article/201702/2017021415541731.png" alt="image"></p>
<h3 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-XX:+&lt;option&gt; 启用选项</div><div class="line">-XX:-&lt;option&gt; 不启用选项</div><div class="line">-XX:&lt;option&gt;=&lt;number&gt; </div><div class="line">-XX:&lt;option&gt;=&lt;string&gt;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-XX:+UseSerialGC</td>
<td>Jvm运行在Client模式下的默认值，打开此开关后，使用Serial + Serial Old的收集器组合进行内存回收</td>
</tr>
<tr>
<td>-XX:+UseParNewGC</td>
<td>打开此开关后，使用ParNew + Serial Old的收集器进行垃圾回收</td>
</tr>
<tr>
<td>-XX:+UseConcMarkSweepGC</td>
<td>使用ParNew + CMS +  Serial Old的收集器组合进行内存回收，Serial Old作为CMS出现“Concurrent Mode Failure”失败后的后备收集器使用。</td>
</tr>
<tr>
<td>-XX:+UseParallelGC</td>
<td>Jvm运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge +  Serial Old的收集器组合进行回收</td>
</tr>
<tr>
<td>-XX:+UseParallelOldGC</td>
<td>使用Parallel Scavenge +  Parallel Old的收集器组合进行回收</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden:Subrvivor = 8:1</td>
</tr>
<tr>
<td><strong>-XX:PretenureSizeThreshold</strong></td>
<td>直接晋升到老年代对象的大小，设置这个参数后，大于这个参数的对象将直接在老年代分配，只对Serial和ParNew两款收集器有效</td>
</tr>
<tr>
<td><strong>-XX:MaxTenuringThreshold</strong></td>
<td>晋升到老年代的对象年龄，每次Minor GC之后，年龄就加1，当超过这个参数的值时进入老年代</td>
</tr>
<tr>
<td>-XX:UseAdaptiveSizePolicy</td>
<td>动态调整java堆中各个区域的大小以及进入老年代的年龄</td>
</tr>
<tr>
<td>-XX:+HandlePromotionFailure</td>
<td>是否允许新生代收集担保，进行一次minor gc后, 另一块Survivor空间不足时，将直接会在老年代中保留</td>
</tr>
<tr>
<td>-XX:ParallelGCThreads</td>
<td>设置并行GC进行内存回收的线程数</td>
</tr>
<tr>
<td>-XX:GCTimeRatio</td>
<td>GC时间占总时间的比列，默认值为99，即允许1%的GC时间，仅在使用Parallel Scavenge 收集器时有效</td>
</tr>
<tr>
<td>-XX:MaxGCPauseMillis</td>
<td>设置GC的最大停顿时间，在Parallel Scavenge 收集器下有效</td>
</tr>
<tr>
<td>-XX:CMSInitiatingOccupancyFraction</td>
<td>设置CMS收集器在老年代空间被使用多少后出发垃圾收集，默认值为68%，仅在CMS收集器时有效，-XX:CMSInitiatingOccupancyFraction=70</td>
</tr>
<tr>
<td>-XX:+UseCMSCompactAtFullCollection</td>
<td>由于CMS收集器会产生碎片，此参数设置在垃圾收集器后是否需要一次内存碎片整理过程，仅在CMS收集器时有效</td>
</tr>
<tr>
<td>-XX:+CMSFullGCBeforeCompaction</td>
<td>设置CMS收集器在进行若干次垃圾收集后再进行一次内存碎片整理过程，通常与UseCMSCompactAtFullCollection参数一起使用</td>
</tr>
<tr>
<td>-XX:+UseFastAccessorMethods</td>
<td>原始类型优化</td>
</tr>
<tr>
<td>-XX:+DisableExplicitGC</td>
<td>是否关闭手动System.gc</td>
</tr>
<tr>
<td>-XX:+CMSParallelRemarkEnabled</td>
<td>降低标记停顿</td>
</tr>
<tr>
<td>-XX:LargePageSizeInBytes</td>
<td>内存页的大小不可设置过大，会影响Perm的大小，-XX:LargePageSizeInBytes=128m</td>
</tr>
</tbody>
</table>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>串行收集器：  </p>
<ul>
<li>适用情况：数据量比较小（100M左右）；单处理器下并且对响应时间无要求的应用。 </li>
<li>缺点：只能用于小型应用</li>
</ul>
</li>
<li><p>并行收集器：</p>
<ul>
<li>适用情况：“对吞吐量有高要求”，多CPU、对应用响应时间无要求的中、大型应用。举例：后台处理、科学计算。</li>
<li>缺点：应用响应时间可能较长</li>
</ul>
</li>
<li><p>并发收集器：</p>
<ul>
<li>适用情况：“对响应时间有高要求”，多CPU、对应用响应时间有较高要求的中、大型应用。举例：Web服务器/应用服务器、电信交换、集成开发环境。</li>
</ul>
</li>
</ul>
<h3 id="并行、并发的区别"><a href="#并行、并发的区别" class="headerlink" title="并行、并发的区别"></a>并行、并发的区别</h3><p>并行(Parallel)与并发(Concurrent)仅一字之差，但体现的意思却完全不同，这可能也是很多同学非常困惑的地方，要想深刻体会这其中的差别，可以多揣摩下上面关于GC收集器的示例图；</p>
<ul>
<li>并行：指多条垃圾收集线程并行，此时用户线程是没有运行的；</li>
<li>并发：指用户线程与垃圾收集线程并发执行，程序在继续运行，而垃圾收集程序运行于另一个CPU上。   </li>
</ul>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>对象的内存分配，往大方向讲，就是在堆上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓存，将线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。</p>
<h6 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h6><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。    </p>
<p>虚拟机提供了<code>-XX:+PrintGCDeails</code>这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各个区域分配情况。</p>
<h6 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h6><p>所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。</p>
<p>虚拟机提供了一个<code>-XX:PretenureSizeThreshold</code>参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。<br>注意：<strong><code>-XX:PretenureSizeThreshold</code>参数只对Serial和ParNew两款收集器有效</strong>，Parallel Scavenge收集器不认识这个参数，Parallel Scavenge收集器一般并不需要设置。如果遇到必须使用此参数的场合，可以考虑ParNew加CMS的收集器组合。</p>
<h6 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h6><p>既然虚拟机采用了分代收集的思想来关联内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor区容纳的话，将被移动到Survivor区中，并且对象的年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（<strong>默认为15岁</strong>），就会被晋升到老年代中。对象晋升老年代的年龄阀值，可以通过参数<code>-XX:MaxTenuringThreshold</code>设置。</p>
<h6 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h6><p>为了能更好的适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，<strong>如果在Survivor空间中相同年龄所有对象大小的综合大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄</strong>。</p>
<h6 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h6><p><strong>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那么此时也要改为进行一次Full GC</strong>。</p>
<p>取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。如果出现了Handle Promotion Failure失败，那就只好在失败后重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/12/Java/基础/JVM垃圾回收算法与收集器类型/" data-id="cje2lrz1m003qpxbldly44eht" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-服务器相关/Memcached/Memcached内存管理和回收机制" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/12/服务器相关/Memcached/Memcached内存管理和回收机制/">Memcached内存管理和回收机制</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/12/服务器相关/Memcached/Memcached内存管理和回收机制/" class="article-date"><time datetime="2017-08-12T02:09:45.000Z" itemprop="datePublished">2017-08-12</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a> / <a class="article-category-link" href="/categories/服务器相关/Memcached/">Memcached</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Memcached介绍"><a href="#Memcached介绍" class="headerlink" title="Memcached介绍"></a>Memcached介绍</h4><p><strong>memcached是高性能的分布式内存缓存服务器</strong>。一般的使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度、提高可扩展性。<br><img src="http://note.youdao.com/yws/public/resource/326d406a081f50818978ca890757f819/WEBRESOURCE1e683dd43b5502e9fc64afff004ffb5f" alt="image"></p>
<h4 id="基本概念：slab，page，chunk"><a href="#基本概念：slab，page，chunk" class="headerlink" title="基本概念：slab，page，chunk"></a>基本概念：slab，page，chunk</h4><ul>
<li><strong>slab</strong>，是一个逻辑概念。它是在启动memcached实例的时候预处理好的，每个slab对应一个chunks 数组，也就是说不同slab有不同的chunks 数组。具体分配多少个slab由参数 -f （增长因子）和 -n （chunk最小尺寸）决定的。</li>
<li><strong>page</strong>，可以理解为内存页。大小固定为1m。slab会在存储请求时向系统申请page，并将page按chunk size进行切割。  </li>
<li><strong>chunk</strong>，是保存用户数据的最小单位。用户数据item（包括key，value）最终会保存到chunk内。chunk规格是固定的，如果用户数据放进来后还有剩余则这剩余部分不能做其他用途。</li>
</ul>
<h4 id="Memcached特征"><a href="#Memcached特征" class="headerlink" title="Memcached特征"></a>Memcached特征</h4><p>memcached作为高速运行的分布式缓存服务器，具有以下的特点：   </p>
<ol>
<li><strong>协议简单</strong>：memcached的服务器客户端通信并不使用复杂的XML等格式，而使用简单的基于文本行的协议。因此，通过telnet也能在memcached上保存数据、取得数据。</li>
<li><strong>基于libevent的事件处理</strong>：libevent是个程序库，它将Linux的epoll、BSD类操作系统的kqueue等事件处理功能封装成统一的接口。即使对服务器的连接数增加，也能发挥O(1)的性能。memcached使用这个libevent库，因此能在Linux、BSD、Solaris等操作系统上发挥其高性能。</li>
<li><strong>内置内存存储方式</strong>：为了提高性能，memcached中保存的数据都存储在memcached内置的内存存储空间中。由于数据仅存在于内存中，因此重启memcached、重启操作系统会导致全部数据消失。另外，内容容量达到指定值之后，就基于LRU(Least Recently Used)算法自动删除不使用的缓存。memcached本身是为缓存而设计的服务器，因此并没有过多考虑数据的永久性问题。</li>
<li><strong>memcached不互相通信的分布式</strong>：memcached尽管是“分布式”缓存服务器，但服务器端并没有分布式功能。各个memcached不会互相通信以共享信息。那么，分布式是完全取决于客户端的实现。memcached之间没有相互通信， 因此不会增加 memcached的负载；没有多播协议，不会网络通信量爆炸（implode）</li>
</ol>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>memcahed实例启动，根据 -f 和 -n 进行预分配slab。以 -n 为最小值开始，以 -f 为比值生成等比数列，直到1m为止（每个slab的chunk size都要按8的倍数进行补全，比如：如果按比值算是556的话，会再加4到560成为8的整倍数）。然后每个slab分配一个page。当用户发来存储请求时（key,value），memcached会计算key+value的大小，看看属于哪个slab。确定slab后看里面的是否有空闲chunk放key+value，如果不够就再向系统申请一个page（如果此时已经达到 -m 参数设置的内存使用上限，则看是否设置了 -M 。如果设置了 -M 则返回错误提示，否则按LRU算法删除数据）。申请后将该page按本slab的chunk size 进行切割，然后分配一个来存放用户数据。</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li>chunk是在page里面划分的，而page固定为1m，所以chunk最大不能超过1m。</li>
<li>chunk实际占用内存要加48B，因为chunk数据结构本身需要占用48B。</li>
<li>如果用户数据大于1m，则memcached会将其切割，放到多个chunk内。</li>
<li>已分配出去的page不能回收。</li>
</ol>
<h4 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h4><ol>
<li>-n 参数的设置，注意将此参数设置为1024可以整除的数（还要考虑48B的差值），否则余下来的部分就浪费了。</li>
<li>不要存储超过1m的数据。因为要拆成多个chunk，计算和时间成本都成倍增加。</li>
<li>善用stats命令查看memcached状态。</li>
<li>消灭eviction（被删除的数据）。造成eviction是因为内存不够，有三个思路：一是在CPU有余力的情况下开启压缩（PHP扩展）；二是增加内存；三是调整 -f 参数，减少内存浪费。</li>
<li>调整业务代码，提高命中率。</li>
<li>缓存小数据。省带宽，省网络I/O时间，省内存。</li>
<li>根据业务特点，为数据尺寸区间小的业务分配专用的memcached实例。这样可以调小 -f 参数，使数据集中存在少数几个slab上，内存浪费较少。</li>
</ol>
<h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><p>Slab Allocation机制：整理内存以便重复使用<br>目前memcached采用Slab Allocator的机制分配、管理内存。<br>Slab Allocator的基本原理是按照预先规定的大小，将分配的内存分割成特定长度的块，以完全解决内存碎片问题。<br>当memcached启动的时候，我们会在系统中给他分配一定大小的内存，假设这里是1个G，但是刚启动的时候memcached不会一下就将这1G的内存全部吃进去，它是按需索取，一点一点增加的。<br><img src="http://up.2cto.com/os/201103/20110304120438975.png" alt="image"></p>
<ol>
<li>如上图所示，Slab Allocation将分配的内存分割成各种尺寸的块（chunk，用于缓存记录的内存空间），并把尺寸相同的块分成组（chunk的集合，每个chunk的大小相同）。默认一个slab（chunks）的大小是1MB，叫1Page。</li>
</ol>
<p>首先，他会创建很多个slab，每个slab的大小应该是一个page，page默认是1M大小。<br>然后每个slab中会分出很多个chunk，chunk的大小是和growth factor（增长因子）参数相关的。<br>比如说，你的growth factor默认的是1.25，那么初始的chunk大小是88k，那下一个级别的就是88*1.25=112k。    </p>
<p>slab就是相同大小的chunk的一个组。比如说，slab1中全是88k大小的chunk，slab2中就全是112k大小的chunk。这样当一个100k大小的数据进来，他会存放在chunk大小为112k的slab2中，选择一个可用的空闲chunk存贮起来。 </p>
<ol>
<li><p>slab allocator有重复使用已分配的内存的目的。也就是说，<strong>分配到的内存不会释放，而是重复利用</strong>。</p>
</li>
<li><p>memcached根据收到的数据的大小，选择最适合数据大小的slab。 memcached中保存着slab内空闲chunk的列表，根据该列表选择chunk， 然后将数据缓存于其中。如当来了100bytes数据，会选择最合适的112bytes的chunk（假如slab classes中chunk的大小包含有88bytes、112bytes、144bytes……）</p>
</li>
<li><p>Slab Allocator解决了当初的内存碎片问题，但由于分配的是特定长度的内存，因此无法有效利用分配的内存。例如，将100字节的数据缓存到128字节的chunk中，剩余的28字节就浪费了。</p>
</li>
</ol>
<h4 id="内存回收机制"><a href="#内存回收机制" class="headerlink" title="内存回收机制"></a>内存回收机制</h4><p>memcached的内存回收机制不是说你设置的key到了生命周期就自动从内存中清除的，这个时候必须有一个新的对象入驻请求这个大小的chunk或者这个过期的对象被get的时候才会清除。那当所有给memcache的内存都被占用了，这个时候，memcache有两个设置，要么报错，要么，就是用LRU方法，把last recently used的数据清除出去，也就是删除近段时间最少使用的同规格chunk。   </p>
<p>这个时候就会引发应外一个问题，就是当你chunk大小设置不合理的时候，比如slab20 chunk大小非常大，一开始占用了很多内存，但是之后不论是否过期，不被再次利用到的时候就一直处于内存中，这样，当比较小的slab1中的chunk满了，也没有内存新建slab并分割和slab1同样规格的chunk的时候，memcached就要启动LRU，来清理这个slab下的数据。那这种情况就会造成在内存的极大程度浪费和cache命中率下降，是某些关键性的数据总是在内存中进进出出，得不到持久的保存。<br>这个时候我们可以调整factor参数，让chunk的大小达到我们的需要，这个需要根据业务来做。  </p>
<p>那slab数量，growth factor大小，LRU频率以及空间浪费情况可以估计出来如下结果：<br>growth factor↑ slab数量 ↓ LRU频率↑ 空间浪费↑<br>growth factor↓ slab数量 ↑ LRU频率↓ 空间浪费↓    </p>
<p>所以我们在使用memcached的时候，需要根据自己的业务，一点一点调整出来相对合适的growth factor,在空间和时间上取得一个折中的点。</p>
<h4 id="Memcached的分布式"><a href="#Memcached的分布式" class="headerlink" title="Memcached的分布式"></a>Memcached的分布式</h4><p>memcached但服务器端并没有“分布式”功能。分布式是完全由客户端程序库实现的。这种分布式是memcached的最大特点</p>
<h5 id="memcached如何实现冗余机制"><a href="#memcached如何实现冗余机制" class="headerlink" title="memcached如何实现冗余机制"></a>memcached如何实现冗余机制</h5><p>不实现！我们对这个问题感到很惊讶。Memcached应该是应用的缓存层。它的设计本身就不带有任何冗余机制。如果一个memcached节点 失去了所 有数据，您应该可以从数据源（比如数据库）再次获取到数据。您应该特别注意，您的应用应该可以容忍节点的失效。不要写一些糟糕的查询代码，寄希望于 memcached来保证一切！如果您担心节点失效会大大加重数据库的负担，那么您可以采取一些办法。比如您可以增加更多的节点（来减少丢失一个节点的影 响），热备节点（在其他节点down了的时候接管IP），等等。  </p>
<h4 id="memcached如何处理容错的"><a href="#memcached如何处理容错的" class="headerlink" title="memcached如何处理容错的"></a>memcached如何处理容错的</h4><p>不处理！在memcached节点失效的情况下，集群没有必要做任何容错处理。如果发生了节点失效，应对的措施完全取决于用户。节点失效时，下面列出几种方案供您选择：   </p>
<ul>
<li>忽略它！ 在失效节点被恢复或替换之前，还有很多其他节点可以应对节点失效带来的影响。 </li>
<li>把失效的节点从节点列表中移除。做这个操作千万要小心！在默认情况下（余数式哈希算法），客户端添加或移除节点，会导致所有的缓存数据不可用！因为哈希参照的节点列表变化了，大部分key会因为哈希值的改变而被映射到（与原来）不同的节点上。 </li>
<li>启动热备节点，接管失效节点所占用的IP。这样可以防止哈希紊乱（hashing chaos）。 </li>
<li>如果希望添加和移除节点，而不影响原先的哈希结果，可以使用一致性哈希算法（consistent hashing）。您可以百度一下一致性哈希算法。支持一致性哈希的客户端已经很成熟，而且被广泛使用。去尝试一下吧！ </li>
<li>两次哈希（reshing）。当客户端存取数据时，如果发现一个节点down了，就再做一次哈希（哈希算法与前一次不同），重新选择另一个节点（需要注意 的时，客户端并没有把down的节点从节点列表中移除，下次还是有可能先哈希到它）。如果某个节点时好时坏，两次哈希的方法就有风险了，好的节点和坏的节 点上都可能存在脏数据（stale data）。</li>
</ul>
<h4 id="memcached的限制"><a href="#memcached的限制" class="headerlink" title="memcached的限制"></a>memcached的限制</h4><ul>
<li><strong>key 的最大长度是250个字符</strong>。需要注意的是，250是memcached服务器端内部的限制，如果您使用的客户端支持”key的前缀”或类似特性，那么 key（前缀+原始key）的最大长度是可以超过250个字符的。我们推荐使用使用较短的key，因为可以节省内存和带宽。</li>
<li><strong>过期时间最大可以达到30天</strong>。memcached把传入的过期时间（时间段）解释成时间点后，一旦到了这个时间点，memcached就把item置为失效状态。这是一个简单但obscure的机制。</li>
<li><strong>memcached最大能存储1MB的单个item</strong>。如果你的数据大于1MB，可以考虑在客户端压缩或拆分到多个key中</li>
</ul>
<h5 id="Memcached并发控制"><a href="#Memcached并发控制" class="headerlink" title="Memcached并发控制"></a>Memcached并发控制</h5><p>gets，cas，add等方法都是线性安全的<br>get，set，replace等方法都是非线性安全的</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/12/服务器相关/Memcached/Memcached内存管理和回收机制/" data-id="cje2lrz7z00e3pxblnlm1y8ij" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/加密解密／编码解码/AES加密算法简单介绍" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/10/Java/加密解密／编码解码/AES加密算法简单介绍/">AES加密算法简单介绍</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/10/Java/加密解密／编码解码/AES加密算法简单介绍/" class="article-date"><time datetime="2017-08-10T02:09:45.000Z" itemprop="datePublished">2017-08-10</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>高级加密标准(AES,Advanced Encryption Standard)为最常见的对称加密算。对称加密算法也就是加密和解密用相同的密钥，具体的加密流程如下图：<br><img src="http://img.blog.csdn.net/20170219082909688?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjgyMDUxNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"><br>下面简单介绍下各个部分的作用与意义： </p>
<ul>
<li><strong>明文P</strong>:没有经过加密的数据</li>
<li><strong>密钥K</strong>:用来加密明文的密码，在对称加密算法中，加密与解密的密钥是相同的。密钥为接收方与发送方协商产生，但不可以直接在网络上传输，否则会导致密钥泄漏，通常是通过非对称加密算法加密密钥，然后再通过网络传输给对方，或者直接面对面商量密钥。密钥是绝对不可以泄漏的，否则会被攻击者还原密文，窃取机密数据</li>
<li><strong>AES加密函数</strong>:设AES加密函数为E，则 C = E(K, P),其中P为明文，K为密钥，C为密文。也就是说，把明文P和密钥K作为加密函数的参数输入，则加密函数E会输出密文C</li>
<li><strong>密文C</strong>:经加密函数处理后的数据</li>
<li><strong>AES解密函数</strong>:设AES解密函数为D，则 P = D(K, C),其中C为密文，K为密钥，P为明文。也就是说，把密文C和密钥K作为解密函数的参数输入，则解密函数会输出明文P。</li>
</ul>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/10/Java/加密解密／编码解码/AES加密算法简单介绍/" data-id="cje2lrz1a0032pxbln12n8okk" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/加密解密／编码解码/AES完整实现（Java）" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/10/Java/加密解密／编码解码/AES完整实现（Java）/">AES完整实现（Java）</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/10/Java/加密解密／编码解码/AES完整实现（Java）/" class="article-date"><time datetime="2017-08-10T02:09:45.000Z" itemprop="datePublished">2017-08-10</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="AES加密解密用到的工具类"><a href="#AES加密解密用到的工具类" class="headerlink" title="AES加密解密用到的工具类"></a>AES加密解密用到的工具类</h2><h3 id="SHA1"><a href="#SHA1" class="headerlink" title="SHA1"></a>SHA1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 对公众平台发送给公众账号的消息加解密示例代码.</div><div class="line"> * </div><div class="line"> * @copyright Copyright (c) 1998-2014 Tencent Inc.</div><div class="line"> */</div><div class="line"></div><div class="line">// ------------------------------------------------------------------------</div><div class="line"></div><div class="line">package com.xx.aes;</div><div class="line"></div><div class="line">import java.security.MessageDigest;</div><div class="line">import java.util.Arrays;</div><div class="line"></div><div class="line">/**</div><div class="line"> * SHA1 class</div><div class="line"> *</div><div class="line"> * 计算公众平台的消息签名接口.</div><div class="line"> */</div><div class="line">class SHA1 &#123;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 用SHA1算法生成安全签名</div><div class="line">	 * @param token 票据</div><div class="line">	 * @param timestamp 时间戳</div><div class="line">	 * @param nonce 随机字符串</div><div class="line">	 * @param encrypt 密文</div><div class="line">	 * @return 安全签名</div><div class="line">	 * @throws AesException </div><div class="line">	 */</div><div class="line">	public static String getSHA1(String token, String timestamp, String nonce, String encrypt) throws AesException &#123;</div><div class="line">		try &#123;</div><div class="line">			String[] array = new String[] &#123; token, timestamp, nonce, encrypt &#125;;</div><div class="line">			StringBuffer sb = new StringBuffer();</div><div class="line">			// 字符串排序</div><div class="line">			Arrays.sort(array);</div><div class="line">			for (int i = 0; i &lt; 4; i++) &#123;</div><div class="line">				sb.append(array[i]);</div><div class="line">			&#125;</div><div class="line">			String str = sb.toString();</div><div class="line">			// SHA1签名生成</div><div class="line">			MessageDigest md = MessageDigest.getInstance(&quot;SHA-1&quot;);</div><div class="line">			md.update(str.getBytes());</div><div class="line">			byte[] digest = md.digest();</div><div class="line"></div><div class="line">			StringBuffer hexstr = new StringBuffer();</div><div class="line">			String shaHex = &quot;&quot;;</div><div class="line">			for (int i = 0; i &lt; digest.length; i++) &#123;</div><div class="line">				shaHex = Integer.toHexString(digest[i] &amp; 0xFF);</div><div class="line">				if (shaHex.length() &lt; 2) &#123;</div><div class="line">					hexstr.append(0);</div><div class="line">				&#125;</div><div class="line">				hexstr.append(shaHex);</div><div class="line">			&#125;</div><div class="line">			return hexstr.toString();</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			throw new AesException(AesException.ComputeSignatureError);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="PKCS7Encoder"><a href="#PKCS7Encoder" class="headerlink" title="PKCS7Encoder"></a>PKCS7Encoder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 对公众平台发送给公众账号的消息加解密示例代码.</div><div class="line"> * </div><div class="line"> * @copyright Copyright (c) 1998-2014 Tencent Inc.</div><div class="line"> */</div><div class="line"></div><div class="line">// ------------------------------------------------------------------------</div><div class="line"></div><div class="line">package com.xx0.aes;</div><div class="line"></div><div class="line">import java.nio.charset.Charset;</div><div class="line">import java.util.Arrays;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 提供基于PKCS7算法的加解密接口.</div><div class="line"> */</div><div class="line">class PKCS7Encoder &#123;</div><div class="line">	static Charset CHARSET = Charset.forName(&quot;utf-8&quot;);</div><div class="line">	static int BLOCK_SIZE = 32;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 获得对明文进行补位填充的字节.</div><div class="line">	 * </div><div class="line">	 * @param count 需要进行填充补位操作的明文字节个数</div><div class="line">	 * @return 补齐用的字节数组</div><div class="line">	 */</div><div class="line">	static byte[] encode(int count) &#123;</div><div class="line">		// 计算需要填充的位数</div><div class="line">		int amountToPad = BLOCK_SIZE - (count % BLOCK_SIZE);</div><div class="line">		if (amountToPad == 0) &#123;</div><div class="line">			amountToPad = BLOCK_SIZE;</div><div class="line">		&#125;</div><div class="line">		// 获得补位所用的字符</div><div class="line">		char padChr = chr(amountToPad);</div><div class="line">		String tmp = new String();</div><div class="line">		for (int index = 0; index &lt; amountToPad; index++) &#123;</div><div class="line">			tmp += padChr;</div><div class="line">		&#125;</div><div class="line">		return tmp.getBytes(CHARSET);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 删除解密后明文的补位字符</div><div class="line">	 * </div><div class="line">	 * @param decrypted 解密后的明文</div><div class="line">	 * @return 删除补位字符后的明文</div><div class="line">	 */</div><div class="line">	static byte[] decode(byte[] decrypted) &#123;</div><div class="line">		int pad = (int) decrypted[decrypted.length - 1];</div><div class="line">		if (pad &lt; 1 || pad &gt; 32) &#123;</div><div class="line">			pad = 0;</div><div class="line">		&#125;</div><div class="line">		return Arrays.copyOfRange(decrypted, 0, decrypted.length - pad);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 将数字转化成ASCII码对应的字符，用于对明文进行补码</div><div class="line">	 * </div><div class="line">	 * @param a 需要转化的数字</div><div class="line">	 * @return 转化得到的字符</div><div class="line">	 */</div><div class="line">	static char chr(int a) &#123;</div><div class="line">		byte target = (byte) (a &amp; 0xFF);</div><div class="line">		return (char) target;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="EncryptedMessage"><a href="#EncryptedMessage" class="headerlink" title="EncryptedMessage"></a>EncryptedMessage</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">package com.xxx.aes;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 携带加密运算后得到的签名、时间戳、随机串和密文的对象</div><div class="line"> */</div><div class="line">public class EncryptedMessage &#123;</div><div class="line"></div><div class="line">	private String signature;</div><div class="line">	private String timestamp;</div><div class="line">	private String nonce;</div><div class="line">	private String data;</div><div class="line">	public EncryptedMessage(String signature, String timestamp, String nonce,</div><div class="line">			String data) &#123;</div><div class="line">		super();</div><div class="line">		this.signature = signature;</div><div class="line">		this.timestamp = timestamp;</div><div class="line">		this.nonce = nonce;</div><div class="line">		this.data = data;</div><div class="line">	&#125;</div><div class="line">	public String getSignature() &#123;</div><div class="line">		return signature;</div><div class="line">	&#125;</div><div class="line">	public void setSignature(String signature) &#123;</div><div class="line">		this.signature = signature;</div><div class="line">	&#125;</div><div class="line">	public String getTimestamp() &#123;</div><div class="line">		return timestamp;</div><div class="line">	&#125;</div><div class="line">	public void setTimestamp(String timeStamp) &#123;</div><div class="line">		this.timestamp = timeStamp;</div><div class="line">	&#125;</div><div class="line">	public String getNonce() &#123;</div><div class="line">		return nonce;</div><div class="line">	&#125;</div><div class="line">	public void setNonce(String nonce) &#123;</div><div class="line">		this.nonce = nonce;</div><div class="line">	&#125;</div><div class="line">	public String getData() &#123;</div><div class="line">		return data;</div><div class="line">	&#125;</div><div class="line">	public void setData(String data) &#123;</div><div class="line">		this.data = data;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public String toString() &#123;</div><div class="line">		return &quot;EncryptedMessage [signature=&quot; + signature + &quot;, timestamp=&quot;</div><div class="line">				+ timestamp + &quot;, nonce=&quot; + nonce + &quot;, data=&quot; + data + &quot;]&quot;;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ByteGroup"><a href="#ByteGroup" class="headerlink" title="ByteGroup"></a>ByteGroup</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">package com.xx.aes;</div><div class="line"></div><div class="line">import java.util.ArrayList;</div><div class="line"></div><div class="line">class ByteGroup &#123;</div><div class="line">	ArrayList&lt;Byte&gt; byteContainer = new ArrayList&lt;Byte&gt;();</div><div class="line"></div><div class="line">	public byte[] toBytes() &#123;</div><div class="line">		byte[] bytes = new byte[byteContainer.size()];</div><div class="line">		for (int i = 0; i &lt; byteContainer.size(); i++) &#123;</div><div class="line">			bytes[i] = byteContainer.get(i);</div><div class="line">		&#125;</div><div class="line">		return bytes;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public ByteGroup addBytes(byte[] bytes) &#123;</div><div class="line">		for (byte b : bytes) &#123;</div><div class="line">			byteContainer.add(b);</div><div class="line">		&#125;</div><div class="line">		return this;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int size() &#123;</div><div class="line">		return byteContainer.size();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="AES加密解密"><a href="#AES加密解密" class="headerlink" title="AES加密解密"></a>AES加密解密</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 针对org.apache.commons.codec.binary.Base64，</div><div class="line"> * 需要导入架包commons-codec-1.9（或commons-codec-1.8等其他版本）</div><div class="line"> * 官方下载地址：http://commons.apache.org/proper/commons-codec/download_codec.cgi</div><div class="line"> */</div><div class="line">package com.xx.aes;</div><div class="line"></div><div class="line">import java.net.URISyntaxException;</div><div class="line">import java.nio.charset.Charset;</div><div class="line">import java.util.Arrays;</div><div class="line">import java.util.Random;</div><div class="line"></div><div class="line">import javax.crypto.Cipher;</div><div class="line">import javax.crypto.spec.IvParameterSpec;</div><div class="line">import javax.crypto.spec.SecretKeySpec;</div><div class="line"></div><div class="line">import org.apache.commons.codec.binary.Base64;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 用于加密和解密网络中互相传送消息，并且验证消息的安全性，消息加密后用Base64进行编码</div><div class="line"> * 说明：异常java.security.InvalidKeyException:illegal Key Size的解决方案</div><div class="line"> * &lt;ol&gt;</div><div class="line"> * 	&lt;li&gt;在官方网站下载JCE无限制权限策略文件（JDK7的下载地址：</div><div class="line"> *      http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html&lt;/li&gt;</div><div class="line"> * 	&lt;li&gt;下载后解压，可以看到local_policy.jar和US_export_policy.jar以及readme.txt&lt;/li&gt;</div><div class="line"> * 	&lt;li&gt;如果安装了JRE，将两个jar文件放到%JRE_HOME%\lib\security目录下覆盖原来的文件&lt;/li&gt;</div><div class="line"> * 	&lt;li&gt;如果安装了JDK，将两个jar文件放到%JDK_HOME%\jre\lib\security目录下覆盖原来文件&lt;/li&gt;</div><div class="line"> * &lt;/ol&gt;</div><div class="line"> */</div><div class="line">public class HBBizMsgCrypt &#123;</div><div class="line">	static Charset CHARSET = Charset.forName(&quot;utf-8&quot;);</div><div class="line">	Base64 base64 = new Base64();</div><div class="line">	byte[] aesKey;</div><div class="line">	String token;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 构造函数</div><div class="line">	 * @param token 开发者设置的token</div><div class="line">	 * @param encodingAesKey 开发者设置的EncodingAESKey</div><div class="line">	 * </div><div class="line">	 * @throws AesException 执行失败，请查看该异常的错误码和具体的错误信息</div><div class="line">	 */</div><div class="line">	public HBBizMsgCrypt(String token, String encodingAesKey) throws AesException &#123;</div><div class="line">		if (encodingAesKey.length() != 43) &#123;</div><div class="line">			throw new AesException(AesException.IllegalAesKey);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		this.token = token;</div><div class="line">		this.aesKey = Base64.decodeBase64(encodingAesKey + &quot;=&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 生成4个字节的网络字节序</div><div class="line">	byte[] getNetworkBytesOrder(int sourceNumber) &#123;</div><div class="line">		byte[] orderBytes = new byte[4];</div><div class="line">		orderBytes[3] = (byte) (sourceNumber &amp; 0xFF);</div><div class="line">		orderBytes[2] = (byte) (sourceNumber &gt;&gt; 8 &amp; 0xFF);</div><div class="line">		orderBytes[1] = (byte) (sourceNumber &gt;&gt; 16 &amp; 0xFF);</div><div class="line">		orderBytes[0] = (byte) (sourceNumber &gt;&gt; 24 &amp; 0xFF);</div><div class="line">		return orderBytes;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 还原4个字节的网络字节序</div><div class="line">	int recoverNetworkBytesOrder(byte[] orderBytes) &#123;</div><div class="line">		int sourceNumber = 0;</div><div class="line">		for (int i = 0; i &lt; 4; i++) &#123;</div><div class="line">			sourceNumber &lt;&lt;= 8;</div><div class="line">			sourceNumber |= orderBytes[i] &amp; 0xff;</div><div class="line">		&#125;</div><div class="line">		return sourceNumber;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 随机生成16位字符串</div><div class="line">	public	String getRandomStr() &#123;</div><div class="line">		String base = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;;</div><div class="line">		Random random = new Random();</div><div class="line">		StringBuffer sb = new StringBuffer();</div><div class="line">		for (int i = 0; i &lt; 16; i++) &#123;</div><div class="line">			int number = random.nextInt(base.length());</div><div class="line">			sb.append(base.charAt(number));</div><div class="line">		&#125;</div><div class="line">		return sb.toString();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 对明文进行加密.</div><div class="line">	 * </div><div class="line">	 * @param randomStr 随机字符串</div><div class="line">	 * @param text 需要加密的明文</div><div class="line">	 * @return 加密后base64编码的字符串</div><div class="line">	 * @throws AesException aes加密失败</div><div class="line">	 */</div><div class="line">	 public String encrypt(String randomStr, String text) throws AesException &#123;</div><div class="line">		ByteGroup byteCollector = new ByteGroup();</div><div class="line">		byte[] randomStrBytes = randomStr.getBytes(CHARSET);</div><div class="line">		byte[] textBytes = text.getBytes(CHARSET);</div><div class="line">		byte[] networkBytesOrder = getNetworkBytesOrder(textBytes.length);</div><div class="line"></div><div class="line">		// randomStr + networkBytesOrder + text</div><div class="line">		byteCollector.addBytes(randomStrBytes);</div><div class="line">		byteCollector.addBytes(networkBytesOrder);</div><div class="line">		byteCollector.addBytes(textBytes);</div><div class="line"></div><div class="line">		// ... + pad: 使用自定义的填充方式对明文进行补位填充</div><div class="line">		byte[] padBytes = PKCS7Encoder.encode(byteCollector.size());</div><div class="line">		byteCollector.addBytes(padBytes);</div><div class="line"></div><div class="line">		// 获得最终的字节流, 未加密</div><div class="line">		byte[] unencrypted = byteCollector.toBytes();</div><div class="line"></div><div class="line">		try &#123;</div><div class="line">			// 设置加密模式为AES的CBC模式</div><div class="line">			Cipher cipher = Cipher.getInstance(&quot;AES/CBC/NoPadding&quot;);</div><div class="line">			SecretKeySpec keySpec = new SecretKeySpec(aesKey, &quot;AES&quot;);</div><div class="line">			IvParameterSpec iv = new IvParameterSpec(aesKey, 0, 16);</div><div class="line">			cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv);</div><div class="line"></div><div class="line">			// 加密</div><div class="line">			byte[] encrypted = cipher.doFinal(unencrypted);</div><div class="line"></div><div class="line">			// 使用BASE64对加密后的字符串进行编码</div><div class="line">			String base64Encrypted = base64.encodeToString(encrypted);</div><div class="line"></div><div class="line">			return base64Encrypted;</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			throw new AesException(AesException.EncryptAESError);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 对密文进行解密.</div><div class="line">	 * </div><div class="line">	 * @param text 需要解密的密文</div><div class="line">	 * @return 解密得到的明文</div><div class="line">	 * @throws AesException aes解密失败</div><div class="line">	 */</div><div class="line">	public String decrypt(String text) throws AesException &#123;</div><div class="line">		byte[] original;</div><div class="line">		try &#123;</div><div class="line">			// 设置解密模式为AES的CBC模式</div><div class="line">			Cipher cipher = Cipher.getInstance(&quot;AES/CBC/NoPadding&quot;);</div><div class="line">			SecretKeySpec key_spec = new SecretKeySpec(aesKey, &quot;AES&quot;);</div><div class="line">			IvParameterSpec iv = new IvParameterSpec(Arrays.copyOfRange(aesKey, 0, 16));</div><div class="line">			cipher.init(Cipher.DECRYPT_MODE, key_spec, iv);</div><div class="line"></div><div class="line">			// 使用BASE64对密文进行解码</div><div class="line">			byte[] encrypted = Base64.decodeBase64(text);</div><div class="line"></div><div class="line">			// 解密</div><div class="line">			original = cipher.doFinal(encrypted);</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			throw new AesException(AesException.DecryptAESError);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		String decrypt;</div><div class="line">		try &#123;</div><div class="line">			// 去除补位字符</div><div class="line">			byte[] bytes = PKCS7Encoder.decode(original);</div><div class="line"></div><div class="line">			// 分离16位随机字符串,网络字节序</div><div class="line">			byte[] networkOrder = Arrays.copyOfRange(bytes, 16, 20);</div><div class="line"></div><div class="line">			int textLength = recoverNetworkBytesOrder(networkOrder);</div><div class="line"></div><div class="line">			decrypt = new String(Arrays.copyOfRange(bytes, 20, 20 + textLength), CHARSET);</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			throw new AesException(AesException.IllegalBuffer);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		return decrypt;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 将发送的消息加密打包.</div><div class="line">	 * &lt;ol&gt;</div><div class="line">	 * 	&lt;li&gt;对要发送的消息进行AES-CBC加密&lt;/li&gt;</div><div class="line">	 * 	&lt;li&gt;生成安全签名&lt;/li&gt;</div><div class="line">	 * &lt;/ol&gt;</div><div class="line">	 * </div><div class="line">	 * @param msg 需要加密的消息</div><div class="line">	 * @param timestamp 时间戳，可以自己生成</div><div class="line">	 * @param nonce 随机串，可以自己生成</div><div class="line">	 * </div><div class="line">	 * @return 加密后的信息载体，包括signature, timestamp, nonce, encrypt的字符串</div><div class="line">	 * @throws AesException 执行失败，请查看该异常的错误码和具体的错误信息</div><div class="line">	 * @throws URISyntaxException URI语法错误</div><div class="line">	 */</div><div class="line">	public EncryptedMessage encryptMsg(String msg, String timestamp, String nonce) throws AesException, URISyntaxException &#123;</div><div class="line">		// 加密</div><div class="line">		String encrypt = encrypt(getRandomStr(), msg);</div><div class="line">		</div><div class="line">		if (timestamp == null || &quot;&quot;.equals(timestamp)) &#123;</div><div class="line">			timestamp = String.valueOf(System.currentTimeMillis());</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		String signature = SHA1.getSHA1(token, timestamp, nonce, encrypt);</div><div class="line"></div><div class="line">		return new EncryptedMessage(signature, timestamp, nonce, encrypt);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 检验消息的真实性，并且获取解密后的明文.</div><div class="line">	 * &lt;ol&gt;</div><div class="line">	 * 	&lt;li&gt;利用收到的密文生成安全签名，进行签名验证&lt;/li&gt;</div><div class="line">	 * 	&lt;li&gt;对消息进行解密&lt;/li&gt;</div><div class="line">	 * &lt;/ol&gt;</div><div class="line">	 * </div><div class="line">	 * @param msgSignature 签名串，对应URL参数的signature</div><div class="line">	 * @param timestamp 时间戳，对应URL参数的timestamp</div><div class="line">	 * @param nonce 随机串，对应URL参数的nonce</div><div class="line">	 * @param data 密文，对应URL参数的data</div><div class="line">	 * </div><div class="line">	 * @return 解密后的原文</div><div class="line">	 * @throws AesException 执行失败，请查看该异常的错误码和具体的错误信息</div><div class="line">	 */</div><div class="line">	public String decryptMsg(String msgSignature, String timestamp, String nonce, String data)</div><div class="line">			throws AesException &#123;</div><div class="line"></div><div class="line">		// 验证安全签名</div><div class="line">		String signature = SHA1.getSHA1(token, timestamp, nonce, data);</div><div class="line"></div><div class="line">		// 和URL中的签名比较是否相等</div><div class="line">		// System.out.println(&quot;URL中的签名：&quot; + msg_sign);</div><div class="line">		// System.out.println(&quot;校验签名：&quot; + signature);</div><div class="line">		if (!signature.equals(msgSignature)) &#123;</div><div class="line">			throw new AesException(AesException.ValidateSignatureError);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// 解密</div><div class="line">		String result = decrypt(data);</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) throws AesException, URISyntaxException &#123;</div><div class="line">		HBBizMsgCrypt hBBizMsgCrypt=new HBBizMsgCrypt(&quot;123456&quot;,&quot;0123456789012345678901234567890123456789123&quot;);</div><div class="line">		</div><div class="line">		String name=&quot;李四&quot;;</div><div class="line">		String idCard=&quot;123456789123456789&quot;;</div><div class="line">		String mobile=&quot;13428825923&quot;;</div><div class="line">		String bankAccount=&quot;123456789&quot;;</div><div class="line">		String s1=hBBizMsgCrypt.encrypt(hBBizMsgCrypt.getRandomStr(), name);</div><div class="line">		String s2=hBBizMsgCrypt.encrypt(hBBizMsgCrypt.getRandomStr(), idCard);</div><div class="line">		String s3=hBBizMsgCrypt.encrypt(hBBizMsgCrypt.getRandomStr(), mobile);</div><div class="line">		String s4=hBBizMsgCrypt.encrypt(hBBizMsgCrypt.getRandomStr(), bankAccount);</div><div class="line">        </div><div class="line"></div><div class="line">		System.out.println(hBBizMsgCrypt.decrypt(s1));</div><div class="line">		System.out.println(hBBizMsgCrypt.decrypt(s2));</div><div class="line">		System.out.println(hBBizMsgCrypt.decrypt(s3));</div><div class="line">		System.out.println(hBBizMsgCrypt.decrypt(s4));</div><div class="line">	</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="加密解密异常类"><a href="#加密解密异常类" class="headerlink" title="加密解密异常类"></a>加密解密异常类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">package com.xx.aes;</div><div class="line"></div><div class="line">@SuppressWarnings(&quot;serial&quot;)</div><div class="line">public class AesException extends Exception &#123;</div><div class="line"></div><div class="line">	public final static int OK = 0;</div><div class="line">	public final static int ValidateSignatureError = -40001;</div><div class="line">	public final static int ParseXmlError = -40002;</div><div class="line">	public final static int ComputeSignatureError = -40003;</div><div class="line">	public final static int IllegalAesKey = -40004;</div><div class="line">	public final static int ValidateAppidError = -40005;</div><div class="line">	public final static int EncryptAESError = -40006;</div><div class="line">	public final static int DecryptAESError = -40007;</div><div class="line">	public final static int IllegalBuffer = -40008;</div><div class="line">	//public final static int EncodeBase64Error = -40009;</div><div class="line">	//public final static int DecodeBase64Error = -40010;</div><div class="line">	//public final static int GenReturnXmlError = -40011;</div><div class="line"></div><div class="line">	private int code;</div><div class="line"></div><div class="line">	private static String getMessage(int code) &#123;</div><div class="line">		switch (code) &#123;</div><div class="line">		case ValidateSignatureError:</div><div class="line">			return &quot;签名验证错误&quot;;</div><div class="line">		case ParseXmlError:</div><div class="line">			return &quot;xml解析失败&quot;;</div><div class="line">		case ComputeSignatureError:</div><div class="line">			return &quot;sha加密生成签名失败&quot;;</div><div class="line">		case IllegalAesKey:</div><div class="line">			return &quot;SymmetricKey非法&quot;;</div><div class="line">		case ValidateAppidError:</div><div class="line">			return &quot;appid校验失败&quot;;</div><div class="line">		case EncryptAESError:</div><div class="line">			return &quot;aes加密失败&quot;;</div><div class="line">		case DecryptAESError:</div><div class="line">			return &quot;aes解密失败&quot;;</div><div class="line">		case IllegalBuffer:</div><div class="line">			return &quot;解密后得到的buffer非法&quot;;</div><div class="line">//		case EncodeBase64Error:</div><div class="line">//			return &quot;base64加密错误&quot;;</div><div class="line">//		case DecodeBase64Error:</div><div class="line">//			return &quot;base64解密错误&quot;;</div><div class="line">//		case GenReturnXmlError:</div><div class="line">//			return &quot;xml生成失败&quot;;</div><div class="line">		default:</div><div class="line">			return null; // cannot be</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int getCode() &#123;</div><div class="line">		return code;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	AesException(int code) &#123;</div><div class="line">		super(getMessage(code));</div><div class="line">		this.code = code;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/10/Java/加密解密／编码解码/AES完整实现（Java）/" data-id="cje2lrz1b0033pxblqscl8lqb" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/加密解密／编码解码/RAS完整实现(Java)" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/10/Java/加密解密／编码解码/RAS完整实现(Java)/">RAS完整实现(Java)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/10/Java/加密解密／编码解码/RAS完整实现(Java)/" class="article-date"><time datetime="2017-08-10T02:09:45.000Z" itemprop="datePublished">2017-08-10</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="解密Service类"><a href="#解密Service类" class="headerlink" title="解密Service类"></a>解密Service类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">package com.xxx.service;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Service - RSA安全</div><div class="line"> * </div><div class="line"> * @version 1.0</div><div class="line"> */</div><div class="line">public interface RSAService &#123;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 解密参数</div><div class="line">	 * </div><div class="line">	 * @param encrypted</div><div class="line">	 *            加密内容（使用base64编码的byte数组，再转换为UTF-8编码的字符串）</div><div class="line">	 * @return 解密内容</div><div class="line">	 */</div><div class="line">	String decrypt(String encrypted);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="解密Service实现类"><a href="#解密Service实现类" class="headerlink" title="解密Service实现类"></a>解密Service实现类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">import com.xx.service.RSAService;</div><div class="line">import com.xx.util.RSAUtils;</div><div class="line">import org.apache.commons.lang3.StringUtils;</div><div class="line">import org.springframework.beans.factory.InitializingBean;</div><div class="line">import org.springframework.beans.factory.annotation.Value;</div><div class="line">import org.springframework.core.io.DefaultResourceLoader;</div><div class="line">import org.springframework.core.io.Resource;</div><div class="line">import org.springframework.core.io.ResourceLoader;</div><div class="line">import org.springframework.stereotype.Service;</div><div class="line"></div><div class="line">import java.security.interfaces.RSAPrivateKey;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Service - RSA解密类</div><div class="line"> * </div><div class="line"> * @version 1.0</div><div class="line"> */</div><div class="line">@Service</div><div class="line">public class RSAServiceImpl implements RSAService, InitializingBean &#123;</div><div class="line"></div><div class="line">        //私匙文件地址</div><div class="line">	private String privateKeyFile;</div><div class="line"></div><div class="line">        //私匙</div><div class="line">	private RSAPrivateKey privateKey;</div><div class="line">	</div><div class="line">	//资源加载器</div><div class="line">	private ResourceLoader resourceLoader = new DefaultResourceLoader();</div><div class="line"></div><div class="line">        //注入私匙文件地址</div><div class="line">	@Value(&quot;$&#123;rsa.key.private&#125;&quot;)</div><div class="line">	public void setPrivateKeyFile(String privateKeyFile) &#123;</div><div class="line">		this.privateKeyFile = privateKeyFile;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public String decrypt(String encrypted) &#123;</div><div class="line">		if (StringUtils.isNotEmpty(encrypted)) &#123;</div><div class="line">			return RSAUtils.decrypt(privateKey, encrypted);</div><div class="line">		&#125;</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    //属性设置值后，会调用该方法加载私匙</div><div class="line">	@Override</div><div class="line">	public void afterPropertiesSet() throws Exception &#123;</div><div class="line"></div><div class="line">		Resource resource = resourceLoader.getResource(privateKeyFile);</div><div class="line">		privateKey = RSAUtils.loadPrivateKey(resource.getFile());</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="RAS工具类"><a href="#RAS工具类" class="headerlink" title="RAS工具类"></a>RAS工具类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div></pre></td><td class="code"><pre><div class="line">package com.xx.util;</div><div class="line"></div><div class="line">import org.apache.commons.io.IOUtils;</div><div class="line">import org.bouncycastle.jce.provider.BouncyCastleProvider;</div><div class="line">import org.springframework.util.Assert;</div><div class="line"></div><div class="line">import javax.crypto.Cipher;</div><div class="line">import javax.xml.bind.DatatypeConverter;</div><div class="line">import java.io.DataInputStream;</div><div class="line">import java.io.File;</div><div class="line">import java.io.FileInputStream;</div><div class="line">import java.io.UnsupportedEncodingException;</div><div class="line">import java.nio.charset.Charset;</div><div class="line">import java.nio.charset.StandardCharsets;</div><div class="line">import java.security.*;</div><div class="line">import java.security.interfaces.RSAPrivateKey;</div><div class="line">import java.security.interfaces.RSAPublicKey;</div><div class="line">import java.security.spec.InvalidKeySpecException;</div><div class="line">import java.security.spec.PKCS8EncodedKeySpec;</div><div class="line">import java.security.spec.X509EncodedKeySpec;</div><div class="line">import java.util.Base64;</div><div class="line">import java.util.HashMap;</div><div class="line">import java.util.List;</div><div class="line">import java.util.Map;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Utils - RSA加密解密</div><div class="line"> * </div><div class="line"> * @version 1.0</div><div class="line"> */</div><div class="line">public final class RSAUtils &#123;</div><div class="line"></div><div class="line">    /** 安全服务提供者 */</div><div class="line">    private static final Provider PROVIDER = new BouncyCastleProvider();</div><div class="line">    </div><div class="line">    /** 密钥大小 */</div><div class="line">    private static final int KEY_SIZE = 1024;</div><div class="line">    private static final String KEY_ALGO_RSA = &quot;RSA&quot;;</div><div class="line">    private static final String SIGN_ALGO_RSA = &quot;SHA1WithRSA&quot;;</div><div class="line">    private static final String DEFAULT_CHARSET = &quot;UTF-8&quot;;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 不可实例化</div><div class="line">     */</div><div class="line">    private RSAUtils() &#123;&#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 生成密钥对</div><div class="line">     * </div><div class="line">     * @return 密钥对</div><div class="line">     */</div><div class="line">    public static KeyPair generateKeyPair() &#123;</div><div class="line">    	try &#123;</div><div class="line">    		KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;, PROVIDER);</div><div class="line">    		keyPairGenerator.initialize(KEY_SIZE, new SecureRandom());</div><div class="line">    		return keyPairGenerator.generateKeyPair();</div><div class="line">    	&#125; catch (NoSuchAlgorithmException e) &#123;</div><div class="line">    		e.printStackTrace();</div><div class="line">    		return null;</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 加密</div><div class="line">     * </div><div class="line">     * @param publicKey</div><div class="line">     *            公钥</div><div class="line">     * @param data</div><div class="line">     *            数据</div><div class="line">     * @return 加密后的数据</div><div class="line">     */</div><div class="line">    public static byte[] encrypt(PublicKey publicKey, byte[] data) &#123;</div><div class="line">    	Assert.notNull(publicKey);</div><div class="line">    	Assert.notNull(data);</div><div class="line">    	try &#123;</div><div class="line">    		Cipher cipher = Cipher.getInstance(&quot;RSA/ECB/PKCS1Padding&quot;, PROVIDER);</div><div class="line">    		cipher.init(Cipher.ENCRYPT_MODE, publicKey);</div><div class="line">    		return cipher.doFinal(data);</div><div class="line">    	&#125; catch (Exception e) &#123;</div><div class="line">    		e.printStackTrace();</div><div class="line">    		return null;</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 加密</div><div class="line">     * </div><div class="line">     * @param publicKey</div><div class="line">     *            公钥</div><div class="line">     * @param text</div><div class="line">     *            字符串</div><div class="line">     * </div><div class="line">     * @return Base64编码字符串</div><div class="line">     */</div><div class="line">    public static String encrypt(PublicKey publicKey, String text) &#123;</div><div class="line">    	Assert.notNull(publicKey);</div><div class="line">    	Assert.notNull(text);</div><div class="line">    	byte[] data = encrypt(publicKey, text.getBytes(StandardCharsets.UTF_8));</div><div class="line">    	return data != null ? new String(Base64.getEncoder().encode(data), StandardCharsets.UTF_8) : null;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 解密</div><div class="line">     * </div><div class="line">     * @param privateKey</div><div class="line">     *            私钥</div><div class="line">     * @param data</div><div class="line">     *            数据</div><div class="line">     * @return 解密后的数据</div><div class="line">     */</div><div class="line">    public static byte[] decrypt(PrivateKey privateKey, byte[] data) &#123;</div><div class="line">    	Assert.notNull(privateKey);</div><div class="line">    	Assert.notNull(data);</div><div class="line">    	try &#123;</div><div class="line">    		Cipher cipher = Cipher.getInstance(&quot;RSA/ECB/PKCS1Padding&quot;, PROVIDER);</div><div class="line">    		cipher.init(Cipher.DECRYPT_MODE, privateKey);</div><div class="line">    		return cipher.doFinal(data);</div><div class="line">    	&#125; catch (Exception e) &#123;</div><div class="line">    		return null;</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 解密</div><div class="line">     * </div><div class="line">     * @param privateKey</div><div class="line">     *            私钥</div><div class="line">     * @param text</div><div class="line">     *            Base64编码字符串</div><div class="line">     * @return 解密后的数据</div><div class="line">     */</div><div class="line">    public static String decrypt(PrivateKey privateKey, String text) &#123;</div><div class="line">    	Assert.notNull(privateKey);</div><div class="line">    	Assert.notNull(text);</div><div class="line">    	byte[] data = decrypt(privateKey, Base64.getDecoder().decode(text.getBytes(StandardCharsets.UTF_8)));</div><div class="line">    	return data != null ? new String(data, StandardCharsets.UTF_8) : null;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static RSAPrivateKey loadPrivateKey(String filename) throws Exception &#123;</div><div class="line">    	File f = new File(filename);</div><div class="line">    	FileInputStream fis = new FileInputStream(f);</div><div class="line">    	DataInputStream dis = new DataInputStream(fis);</div><div class="line">    	byte[] keyBytes = new byte[(int) f.length()];</div><div class="line">    	dis.readFully(keyBytes);</div><div class="line">    	dis.close();</div><div class="line">    </div><div class="line">    	PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);</div><div class="line">    	KeyFactory kf = KeyFactory.getInstance(&quot;RSA&quot;, new BouncyCastleProvider());</div><div class="line">    	return (RSAPrivateKey) kf.generatePrivate(spec);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static RSAPrivateKey loadPrivateKey(File f) throws Exception &#123;</div><div class="line">    	FileInputStream fis = new FileInputStream(f);</div><div class="line">    	DataInputStream dis = new DataInputStream(fis);</div><div class="line">    	byte[] keyBytes = new byte[(int) f.length()];</div><div class="line">    	dis.readFully(keyBytes);</div><div class="line">    	dis.close();</div><div class="line">    </div><div class="line">    	PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);</div><div class="line">    	KeyFactory kf = KeyFactory.getInstance(&quot;RSA&quot;, new BouncyCastleProvider());</div><div class="line">    	return (RSAPrivateKey) kf.generatePrivate(spec);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static RSAPublicKey loadPublicKey(String filename) throws Exception &#123;</div><div class="line">    </div><div class="line">    	File f = new File(filename);</div><div class="line">    	FileInputStream fis = new FileInputStream(f);</div><div class="line">    	DataInputStream dis = new DataInputStream(fis);</div><div class="line">    	byte[] keyBytes = new byte[(int) f.length()];</div><div class="line">    	dis.readFully(keyBytes);</div><div class="line">    	dis.close();</div><div class="line">    </div><div class="line">    	X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);</div><div class="line">    	KeyFactory kf = KeyFactory.getInstance(&quot;RSA&quot;);</div><div class="line">    	return (RSAPublicKey) kf.generatePublic(spec);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static byte[] sign(byte[] data, byte[] privateKeyEncoded) throws Exception &#123;</div><div class="line">        PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(privateKeyEncoded);</div><div class="line">        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGO_RSA);</div><div class="line">        PrivateKey privateKey = keyFactory.generatePrivate(pkcs8KeySpec);</div><div class="line">    </div><div class="line">        return sign(data, privateKey);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static byte[] sign(byte[] data, PrivateKey privateKey) throws Exception &#123;</div><div class="line">        Signature signature = Signature.getInstance(SIGN_ALGO_RSA);</div><div class="line">        signature.initSign(privateKey);</div><div class="line">        signature.update(data);</div><div class="line">        return signature.sign();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 返回sign后的UTF-8编码的base64字符串</div><div class="line">     */</div><div class="line">    public static String signAndBase64(byte[] data, PrivateKey privateKey) throws Exception &#123;</div><div class="line">        byte[] signed = sign(data, privateKey);</div><div class="line">        byte[] base64Str = org.apache.commons.codec.binary</div><div class="line">                .Base64.encodeBase64(signed, false);</div><div class="line">        return new String(base64Str, DEFAULT_CHARSET);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static boolean verify(byte[] data, byte[] publicKey, byte[] sign) throws Exception &#123;</div><div class="line">        KeyFactory keyFactory=KeyFactory.getInstance(KEY_ALGO_RSA);</div><div class="line">        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(publicKey);</div><div class="line">        PublicKey pubKey = keyFactory.generatePublic(x509KeySpec);</div><div class="line">        return verify(data, pubKey, sign);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static boolean verify(byte[] data, PublicKey pubKey, byte[] sign) throws Exception &#123;</div><div class="line">        Signature signature = Signature.getInstance(SIGN_ALGO_RSA);</div><div class="line">        signature.initVerify(pubKey);</div><div class="line">        signature.update(data);</div><div class="line">        return signature.verify(sign);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/10/Java/加密解密／编码解码/RAS完整实现(Java)/" data-id="cje2lrz1c0035pxbld3pk8nwc" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/加密解密／编码解码/RAS简单介绍" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/10/Java/加密解密／编码解码/RAS简单介绍/">RAS简单介绍</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/10/Java/加密解密／编码解码/RAS简单介绍/" class="article-date"><time datetime="2017-08-10T02:09:45.000Z" itemprop="datePublished">2017-08-10</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="基本含义"><a href="#基本含义" class="headerlink" title="基本含义"></a>基本含义</h2><p>在公开密钥密码体制中，加密密钥（即公开密钥）PK是公开信息，而解密密钥（即秘密密钥）SK是需要保密的。加密算法E和解密算法D也都是公开的。虽然解密密钥SK是由公开密钥PK决定的，但却不能根据PK计算出SK。    </p>
<p>正是基于这种理论，1978年出现了著名的RSA算法，它通常是先生成一对RSA 密钥，其中之一是保密密钥，由用户保存；另一个为公开密钥，可对外公开，甚至可在网络服务器中注册。为提高保密强度，RSA密钥至少为500位长，一般推荐使用1024位。这就使加密的计算量很大。<strong>为减少计算量，在传送信息时，常采用传统加密方法与公开密钥加密方法相结合的方式，即信息采用改进的DES或IDEA对话密钥加密，然后使用RSA密钥加密对话密钥和信息摘要。对方收到信息后，用不同的密钥解密并可核对信息摘要。即一般采用AES对传输的信息进行加密，采用RAS对AES的密匙进行加密。</strong></p>
<p><strong>RSA算法是第一个能同时用于加密和数字签名的算法</strong>，也易于理解和操作。RSA是被研究得最广泛的公钥算法，从提出到现今的三十多年里，经历了各种攻击的考验，逐渐为人们接受，普遍认为是目前最优秀的公钥方案之一。</p>
<p>SET(Secure Electronic Transaction)协议中要求CA采用2048bits长的密钥，其他实体使用1024比特的密钥。RSA密钥长度随着保密级别提高，增加很快。下表列出了对同一安全级别所对应的密钥长度。  </p>
<table>
<thead>
<tr>
<th>保密级别</th>
<th>对称密钥长度（bit）</th>
<th>RSA密钥长度（bit）</th>
<th>ECC密钥长度（bit）</th>
<th>保密年限</th>
</tr>
</thead>
<tbody>
<tr>
<td>80</td>
<td>80</td>
<td>1024</td>
<td>160</td>
<td>2010</td>
</tr>
<tr>
<td>112</td>
<td>112</td>
<td>2048</td>
<td>224</td>
<td>2030</td>
</tr>
<tr>
<td>128</td>
<td>128</td>
<td>3072</td>
<td>256</td>
<td>2040</td>
</tr>
<tr>
<td>192</td>
<td>192</td>
<td>7680</td>
<td>384</td>
<td>2080</td>
</tr>
<tr>
<td>256</td>
<td>256</td>
<td>15360</td>
<td>512</td>
<td>2120</td>
</tr>
</tbody>
</table>
<p><strong>RSA算法是一种非对称密码算法，所谓非对称，就是指该算法需要一对密钥，使用其中一个加密，则需要用另一个才能解密。</strong></p>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>RSA的安全性依赖于大数分解，但是否等同于大数分解一直未能得到理论上的证明，因为没有证明破解RSA就一定需要作大数分解。假设存在一种无须分解大数的算法，那它肯定可以修改成为大数分解算法。 RSA 的一些变种算法已被证明等价于大数分解。不管怎样，分解n是最显然的攻击方法。人们已能分解多个十进制位的大素数。因此，模数n必须选大一些，因具体适用情况而定。</p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h3><p>首先要使用概率算法来验证随机产生的大的整数是否质数，这样的算法比较快而且可以消除掉大多数非质数。假如有一个数通过了这个测试的话，那么要使用一个精确的测试来保证它的确是一个质数。    </p>
<p>除此之外这样找到的p和q还要满足一定的要求，首先它们不能太靠近，此外p-1或q-1的因子不能太小，否则的话N也可以被很快地分解。    </p>
<p>此外寻找质数的算法不能给攻击者任何信息，这些质数是怎样找到的，尤其产生随机数的软件必须非常好。要求是随机和不可预测。这两个要求并不相同。一个随机过程可能可以产生一个不相关的数的系列，但假如有人能够预测出（或部分地预测出）这个系列的话，那么它就已经不可靠了。比如有一些非常好的随机数算法，但它们都已经被发表，因此它们不能被使用，因为假如一个攻击者可以猜出p和q一半的位的话，那么他们就已经可以轻而易举地推算出另一半。    </p>
<p>此外密钥d必须足够大，1990年有人证明假如p大于q而小于2q（这是一个很经常的情况）而，那么从N和e可以很有效地推算出d。此外e = 2永远不应该被使用。</p>
<h3 id="运行速度"><a href="#运行速度" class="headerlink" title="运行速度"></a>运行速度</h3><p>由于进行的都是大数计算，使得RSA最快的情况也比DES慢上好几倍，无论是软件还是硬件实现。速度一直是RSA的缺陷。一般来说只用于少量数据加密。RSA的速度比对应同样安全级别的对称密码算法要慢1000倍左右。   </p>
<p>比起DES和其它对称算法来说，RSA要慢得多。实际上Bob一般使用一种对称算法来加密他的信息，然后用RSA来加密他的比较短的对称密码，然后将用RSA加密的对称密码和用对称算法加密的消息送给Alice。 </p>
<p>这样一来对随机数的要求就更高了，尤其对产生对称密码的要求非常高，因为否则的话可以越过RSA来直接攻击对称密码。</p>
<h3 id="密钥分配"><a href="#密钥分配" class="headerlink" title="密钥分配"></a>密钥分配</h3><p>和其它加密过程一样，对RSA来说分配公钥的过程是非常重要的。分配公钥的过程必须能够抵挡一个从中取代的攻击。假设Eve交给Bob一个公钥，并使Bob相信这是Alice的公钥，并且她可以截下Alice和Bob之间的信息传递，那么她可以将她自己的公钥传给Bob，Bob以为这是Alice的公钥。Eve可以将所有Bob传递给Alice的消息截下来，将这个消息用她自己的密钥解密，读这个消息，然后将这个消息再用Alice的公钥加密后传给Alice。理论上Alice和Bob都不会发现Eve在偷听他们的消息。今天人们一般用数字认证来防止这样的攻击。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>产生密钥很麻烦，受到素数产生技术的限制，因而难以做到一次一密。</li>
<li>安全性，RSA的安全性依赖于大数的因子分解，但并没有从理论上证明破译RSA的难度与大数分解难度等价，而且密码学界多数人士倾向于因子分解不是NP问题。现今，人们已能分解140多个十进制位的大素数，这就要求使用更长的密钥，速度更慢；另外，人们正在积极寻找攻击RSA的方法，如选择密文攻击，一般攻击者是将某一信息作一下伪装（Blind），让拥有私钥的实体签署。然后，经过计算就可得到它所想要的信息。实际上，攻击利用的都是同一个弱点，即存在这样一个事实：乘幂保留了输入的乘法结构：    </li>
</ol>
<p>（XM)d = Xd *Md mod n   </p>
<p>前面已经提到，这个固有的问题来自于公钥密码系统的最有用的特征–每个人都能使用公钥。但从算法上无法解决这一问题，主要措施有两条：一条是采用好的公钥协议，保证工作过程中实体不对其他实体任意产生的信息解密，不对自己一无所知的信息签名；另一条是决不对陌生人送来的随机文档签名，签名时首先使用One-Way Hash Function对文档作HASH处理，或同时使用不同的签名算法。除了利用公共模数，人们还尝试一些利用解密指数或φ（n）等等攻击.</p>
<ol>
<li>速度太慢，由于RSA 的分组长度太大，为保证安全性，n 至少也要 600 bits以上，使运算代价很高，尤其是速度较慢，较对称密码算法慢几个数量级；且随着大数分解技术的发展，这个长度还在增加，不利于数据格式的标准化。SET(Secure Electronic Transaction）协议中要求CA采用2048比特长的密钥，其他实体使用1024比特的密钥。为了速度问题，人们广泛使用单，公钥密码结合使用的方法，优缺点互补：单钥密码加密速度快，人们用它来加密较长的文件，然后用RSA来给文件密钥加密，极好的解决了单钥密码的密钥分发问题。</li>
</ol>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div></pre></td><td class="code"><pre><div class="line">import org.apache.commons.codec.binary.Base64;</div><div class="line">import javax.crypto.Cipher;</div><div class="line">import java.security.*;</div><div class="line">import java.security.spec.PKCS8EncodedKeySpec;</div><div class="line">import java.security.spec.X509EncodedKeySpec;</div><div class="line">import java.util.HashMap;</div><div class="line">import java.util.Map;</div><div class="line"> </div><div class="line">/**</div><div class="line"> * Created by humf.需要依赖 commons-codec 包 </div><div class="line"> */</div><div class="line">public class RSACoder &#123;</div><div class="line">    public static final String KEY_ALGORITHM = &quot;RSA&quot;;</div><div class="line">    public static final String SIGNATURE_ALGORITHM = &quot;MD5withRSA&quot;;</div><div class="line"> </div><div class="line">    private static final String PUBLIC_KEY = &quot;RSAPublicKey&quot;;</div><div class="line">    private static final String PRIVATE_KEY = &quot;RSAPrivateKey&quot;;</div><div class="line"> </div><div class="line">    public static byte[] decryptBASE64(String key) &#123;</div><div class="line">        return Base64.decodeBase64(key);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public static String encryptBASE64(byte[] bytes) &#123;</div><div class="line">        return Base64.encodeBase64String(bytes);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    /**</div><div class="line">     * 用私钥对信息生成数字签名</div><div class="line">     *</div><div class="line">     * @param data       加密数据</div><div class="line">     * @param privateKey 私钥</div><div class="line">     * @return</div><div class="line">     * @throws Exception</div><div class="line">     */</div><div class="line">    public static String sign(byte[] data, String privateKey) throws Exception &#123;</div><div class="line">        // 解密由base64编码的私钥</div><div class="line">        byte[] keyBytes = decryptBASE64(privateKey);</div><div class="line">        // 构造PKCS8EncodedKeySpec对象</div><div class="line">        PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes);</div><div class="line">        // KEY_ALGORITHM 指定的加密算法</div><div class="line">        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);</div><div class="line">        // 取私钥匙对象</div><div class="line">        PrivateKey priKey = keyFactory.generatePrivate(pkcs8KeySpec);</div><div class="line">        // 用私钥对信息生成数字签名</div><div class="line">        Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);</div><div class="line">        signature.initSign(priKey);</div><div class="line">        signature.update(data);</div><div class="line">        return encryptBASE64(signature.sign());</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    /**</div><div class="line">     * 校验数字签名</div><div class="line">     *</div><div class="line">     * @param data      加密数据</div><div class="line">     * @param publicKey 公钥</div><div class="line">     * @param sign      数字签名</div><div class="line">     * @return 校验成功返回true 失败返回false</div><div class="line">     * @throws Exception</div><div class="line">     */</div><div class="line">    public static boolean verify(byte[] data, String publicKey, String sign)</div><div class="line">            throws Exception &#123;</div><div class="line">        // 解密由base64编码的公钥</div><div class="line">        byte[] keyBytes = decryptBASE64(publicKey);</div><div class="line">        // 构造X509EncodedKeySpec对象</div><div class="line">        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes);</div><div class="line">        // KEY_ALGORITHM 指定的加密算法</div><div class="line">        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);</div><div class="line">        // 取公钥匙对象</div><div class="line">        PublicKey pubKey = keyFactory.generatePublic(keySpec);</div><div class="line">        Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);</div><div class="line">        signature.initVerify(pubKey);</div><div class="line">        signature.update(data);</div><div class="line">        // 验证签名是否正常</div><div class="line">        return signature.verify(decryptBASE64(sign));</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public static byte[] decryptByPrivateKey(byte[] data, String key) throws Exception&#123;</div><div class="line">        // 对密钥解密</div><div class="line">        byte[] keyBytes = decryptBASE64(key);</div><div class="line">        // 取得私钥</div><div class="line">        PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes);</div><div class="line">        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);</div><div class="line">        Key privateKey = keyFactory.generatePrivate(pkcs8KeySpec);</div><div class="line">        // 对数据解密</div><div class="line">        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());</div><div class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey);</div><div class="line">        return cipher.doFinal(data);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    /**</div><div class="line">     * 解密&lt;br&gt;</div><div class="line">     * 用私钥解密</div><div class="line">     *</div><div class="line">     * @param data</div><div class="line">     * @param key</div><div class="line">     * @return</div><div class="line">     * @throws Exception</div><div class="line">     */</div><div class="line">    public static byte[] decryptByPrivateKey(String data, String key)</div><div class="line">            throws Exception &#123;</div><div class="line">        return decryptByPrivateKey(decryptBASE64(data),key);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    /**</div><div class="line">     * 解密&lt;br&gt;</div><div class="line">     * 用公钥解密</div><div class="line">     *</div><div class="line">     * @param data</div><div class="line">     * @param key</div><div class="line">     * @return</div><div class="line">     * @throws Exception</div><div class="line">     */</div><div class="line">    public static byte[] decryptByPublicKey(byte[] data, String key)</div><div class="line">            throws Exception &#123;</div><div class="line">        // 对密钥解密</div><div class="line">        byte[] keyBytes = decryptBASE64(key);</div><div class="line">        // 取得公钥</div><div class="line">        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes);</div><div class="line">        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);</div><div class="line">        Key publicKey = keyFactory.generatePublic(x509KeySpec);</div><div class="line">        // 对数据解密</div><div class="line">        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());</div><div class="line">        cipher.init(Cipher.DECRYPT_MODE, publicKey);</div><div class="line">        return cipher.doFinal(data);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    /**</div><div class="line">     * 加密&lt;br&gt;</div><div class="line">     * 用公钥加密</div><div class="line">     *</div><div class="line">     * @param data</div><div class="line">     * @param key</div><div class="line">     * @return</div><div class="line">     * @throws Exception</div><div class="line">     */</div><div class="line">    public static byte[] encryptByPublicKey(String data, String key)</div><div class="line">            throws Exception &#123;</div><div class="line">        // 对公钥解密</div><div class="line">        byte[] keyBytes = decryptBASE64(key);</div><div class="line">        // 取得公钥</div><div class="line">        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes);</div><div class="line">        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);</div><div class="line">        Key publicKey = keyFactory.generatePublic(x509KeySpec);</div><div class="line">        // 对数据加密</div><div class="line">        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());</div><div class="line">        cipher.init(Cipher.ENCRYPT_MODE, publicKey);</div><div class="line">        return cipher.doFinal(data.getBytes());</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    /**</div><div class="line">     * 加密&lt;br&gt;</div><div class="line">     * 用私钥加密</div><div class="line">     *</div><div class="line">     * @param data</div><div class="line">     * @param key</div><div class="line">     * @return</div><div class="line">     * @throws Exception</div><div class="line">     */</div><div class="line">    public static byte[] encryptByPrivateKey(byte[] data, String key)</div><div class="line">            throws Exception &#123;</div><div class="line">        // 对密钥解密</div><div class="line">        byte[] keyBytes = decryptBASE64(key);</div><div class="line">        // 取得私钥</div><div class="line">        PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes);</div><div class="line">        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);</div><div class="line">        Key privateKey = keyFactory.generatePrivate(pkcs8KeySpec);</div><div class="line">        // 对数据加密</div><div class="line">        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());</div><div class="line">        cipher.init(Cipher.ENCRYPT_MODE, privateKey);</div><div class="line">        return cipher.doFinal(data);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    /**</div><div class="line">     * 取得私钥</div><div class="line">     *</div><div class="line">     * @param keyMap</div><div class="line">     * @return</div><div class="line">     * @throws Exception</div><div class="line">     */</div><div class="line">    public static String getPrivateKey(Map&lt;String, Key&gt; keyMap)</div><div class="line">            throws Exception &#123;</div><div class="line">        Key key = (Key) keyMap.get(PRIVATE_KEY);</div><div class="line">        return encryptBASE64(key.getEncoded());</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    /**</div><div class="line">     * 取得公钥</div><div class="line">     *</div><div class="line">     * @param keyMap</div><div class="line">     * @return</div><div class="line">     * @throws Exception</div><div class="line">     */</div><div class="line">    public static String getPublicKey(Map&lt;String, Key&gt; keyMap)</div><div class="line">            throws Exception &#123;</div><div class="line">        Key key = keyMap.get(PUBLIC_KEY);</div><div class="line">        return encryptBASE64(key.getEncoded());</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    /**</div><div class="line">     * 初始化密钥</div><div class="line">     *</div><div class="line">     * @return</div><div class="line">     * @throws Exception</div><div class="line">     */</div><div class="line">    public static Map&lt;String, Key&gt; initKey() throws Exception &#123;</div><div class="line">        KeyPairGenerator keyPairGen = KeyPairGenerator</div><div class="line">                .getInstance(KEY_ALGORITHM);</div><div class="line">        keyPairGen.initialize(1024);</div><div class="line">        KeyPair keyPair = keyPairGen.generateKeyPair();</div><div class="line">        Map&lt;String, Key&gt; keyMap = new HashMap(2);</div><div class="line">        keyMap.put(PUBLIC_KEY, keyPair.getPublic());// 公钥</div><div class="line">        keyMap.put(PRIVATE_KEY, keyPair.getPrivate());// 私钥</div><div class="line">        return keyMap;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="算47-x-30-y-1-的解"><a href="#算47-x-30-y-1-的解" class="headerlink" title="算47  x + 30  y ==1 的解"></a>算47 <em> x + 30 </em> y ==1 的解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class Exercise</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args)</div><div class="line">    &#123;</div><div class="line">        int[] p = new int[2];</div><div class="line">        int a = 47;</div><div class="line">        int b = 30;</div><div class="line">        RSA(a,b,p);</div><div class="line">        System.out.print(&quot;p[0] is: &quot; + p[0] + &quot;;p[1] is：&quot; + p[1]);//p1为私钥</div><div class="line">    &#125;</div><div class="line">    public static  int[] RSA(int a,int b,int[] p)//这里假设a &gt; b</div><div class="line">    &#123;</div><div class="line">        if(a%b == 1)</div><div class="line">        &#123;</div><div class="line">            p[0] = 1;</div><div class="line">            p[1] = -(a - 1) / b;</div><div class="line">            return p;</div><div class="line">        &#125;</div><div class="line">            else</div><div class="line">        &#123;</div><div class="line">                RSA(b,a % b,p);</div><div class="line">                int t = p[0];</div><div class="line">                p[0] = p[1];</div><div class="line">                p[1] = t - (a / b) * p[1]; </div><div class="line">                return p;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>摘自<a href="https://baike.baidu.com/item/RSA%E7%AE%97%E6%B3%95/263310?fr=aladdin&amp;fromid=9645994&amp;fromtitle=RSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95" target="_blank" rel="external">百度百科</a></li>
</ul>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/10/Java/加密解密／编码解码/RAS简单介绍/" data-id="cje2lrz1f0039pxblc5vyhyfc" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/加密解密／编码解码/对称加密算法与非对称加密算法" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/10/Java/加密解密／编码解码/对称加密算法与非对称加密算法/">对称加密算法与非对称加密算法</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/10/Java/加密解密／编码解码/对称加密算法与非对称加密算法/" class="article-date"><time datetime="2017-08-10T02:09:45.000Z" itemprop="datePublished">2017-08-10</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="对称加密算法与非对称加密算法的区别"><a href="#对称加密算法与非对称加密算法的区别" class="headerlink" title="对称加密算法与非对称加密算法的区别"></a>对称加密算法与非对称加密算法的区别</h3><ul>
<li><p>对称加密算法:<br>加密和解密用到的密钥是相同的，这种加密方式加密速度非常快，适合经常发送数据的场合。缺点是密钥的传输比较麻烦</p>
</li>
<li><p>非对称加密算法:<br>加密和解密用的密钥是不同的，这种加密方式是用数学上的难解问题构造的，通常加密解密的速度比较慢，适合偶尔发送数据的场合。优点是密钥传输方便。常见的非对称加密算法为RSA、ECC和EIGamal</p>
</li>
</ul>
<p>实际中，一般是通过RSA加密AES的密钥，传输到接收方，接收方解密得到AES密钥，然后发送方和接收方用AES密钥来通信</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/10/Java/加密解密／编码解码/对称加密算法与非对称加密算法/" data-id="cje2lrz1j003jpxbldqmw7dgw" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-网络/HTTP 消息结构" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/02/网络/HTTP 消息结构/">HTTP 消息结构</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/02/网络/HTTP 消息结构/" class="article-date"><time datetime="2017-08-02T02:09:45.000Z" itemprop="datePublished">2017-08-02</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络/">网络</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Http-Message结构"><a href="#Http-Message结构" class="headerlink" title="Http Message结构"></a>Http Message结构</h3><p>了解Http Message先看下图：<br><img src="http://pic002.cnblogs.com/img/hyddd/200904/2009041900523663.jpg" alt="image">  </p>
<p>Http Message包含3个部分：</p>
<ul>
<li><strong>请求行/状态行</strong></li>
<li><p><strong>消息头（Message Header）</strong></p>
<ul>
<li>常规头</li>
<li>请求头</li>
<li>响应头</li>
<li>实体头</li>
</ul>
</li>
<li><p><strong>消息体（Message Body）</strong>，这个是可选的。</p>
</li>
</ul>
<h4 id="Http-Message分两类："><a href="#Http-Message分两类：" class="headerlink" title="Http Message分两类："></a>Http Message分两类：</h4><h5 id="1-请求消息（Request-Message）"><a href="#1-请求消息（Request-Message）" class="headerlink" title="1.请求消息（Request Message）"></a>1.请求消息（Request Message）</h5><p>Request Message结构如下：<br><img src="http://images.cnblogs.com/cnblogs_com/hyddd/WindowsLiveWriter/Http_F92D/Request_4.jpg" alt="image"> </p>
<ol>
<li><strong>请求行（Request-Line）</strong>: </li>
</ol>
<p><img src="http://pic002.cnblogs.com/img/hyddd/200904/2009041900533376.jpg" alt="image">         </p>
<ul>
<li>Http方法（Http Method）：主要有8类：GET,POST……下面会介绍。</li>
<li>Request-URI：请求操作的资源。</li>
<li>Http-Version：Http的版本，如：Http/1.0，Http/1.1</li>
</ul>
<ol>
<li><strong>消息头</strong>：<br>请求消息（Request Message）不应包含响应头。</li>
</ol>
<h5 id="2-响应消息（Response-Message）"><a href="#2-响应消息（Response-Message）" class="headerlink" title="2.响应消息（Response Message）"></a>2.响应消息（Response Message）</h5><p>Response Message结构如下：<br><img src="http://pic002.cnblogs.com/img/hyddd/200904/2009041900535013.jpg" alt="image">   </p>
<ol>
<li><strong>状态行（Status-Line）结构</strong>：<br><img src="http://pic002.cnblogs.com/img/hyddd/200904/2009041900541065.jpg" alt="image">   </li>
</ol>
<ul>
<li><p>Http-Version：Http的版本，如：Http/1.0，Http/1.1</p>
</li>
<li><p>Status-Code（状态码）：状态码是一个三位数字，我对状态码的理解是：对请求(request)做出响应的类型/结果。</p>
<p>  状态码第一位数字定义了响应类型，这里分为5种：</p>
<p>  -1XX：Informational，请求接收到了，正在进一步的处理中（Request received, continuing process）。</p>
<p>  -2XX：Success，表示用户请求被正确接收（The action was successfully received,understood, and accepted），这里典型的是：200 OK</p>
<p>  -3XX：Redirection，表示请求没有成功，客户必须采取进一步的动作 (Further action must be taken in order to complete the request.)</p>
<p>  -4XX：Client Error，表示客户端提交的请求有错误（The request contains bad syntax or cannot be fulfilled），典型的有：404 Not Found</p>
<p>  -5XX：Server Error，表示服务器不能完成对请求的处理 (The server failed to fulfill an apparently valid request)，典型的是：503 Service Unavailable</p>
</li>
</ul>
<ol>
<li><strong>消息头</strong>：<br>响应消息（Response Message）不应包含请求头。</li>
</ol>
<h4 id="Http消息头包括4类："><a href="#Http消息头包括4类：" class="headerlink" title="Http消息头包括4类："></a>Http消息头包括4类：</h4><p>Http消息头（Message Header），主要是带上一些处理HTTP消息所需的辅助信息。<br>​<br>Http消息头结构如下：<br><img src="http://pic002.cnblogs.com/img/hyddd/200904/2009041901110863.jpg" alt="image">   </p>
<ul>
<li><p><strong>Field-Name</strong>：下面提到的，如：Cache-Control，Date…等，这些就是Field-Name，在RFC文档中Field-Name的数量是有限的，只有43个，而你自己可以增加自定义的Field-Name，但由于浏览器是按照RFC规范实施的（当然它们也有它们自定义的消息头），所以除非是自己实现服务器和客户端，否则，自定义的Field-Name一般没用。</p>
</li>
<li><p><strong>Field-Vlaue</strong>：根据Field-Name的不同，会有不同的Field-Value</p>
</li>
</ul>
<ol>
<li><strong>常规头</strong></li>
</ol>
<p>常规头（generl-header）：request和response都有可能会用到的，但和消息体无关的一些附加信息。</p>
<p>  (1).Cache-Control（14.9）</p>
<p>  (2).Connection（14.10）</p>
<p>  (3).Date（14.18）</p>
<p>  (4).Pragma（14.32）</p>
<p>  (5).Trailer（14.40）</p>
<p>  (6).Transfer-Encoding（14.41）</p>
<p>  (7).Upgrade（14.42）</p>
<p>  (8).Via（14.45）</p>
<p>  (9).Warning（14.46）</p>
<ol>
<li><strong>请求头</strong></li>
</ol>
<p>请求头（request-header）：一些关于客户端/request的附加信息。</p>
<p>  (1).Accept（14.1）</p>
<p>  (2).Accept-Charset（14.2）</p>
<p>  (3).Accept-Encoding（14.3）</p>
<p>  (4).Accept-Language（14.4）</p>
<p>  (5).Authorization（14.8）</p>
<p>  (6).Expect（14.20）</p>
<p>  (7).From（14.22）</p>
<p>  (8).Host（14.23）</p>
<p>  (9).If-Match（14.24）</p>
<p>  (10).If-Modified-Since（14.25）</p>
<p>  (11).If-None-Match（14.26）</p>
<p>  (12).If-Range（14.27）</p>
<p>  (13).If-Unmodified-Since（14.28）</p>
<p>  (14).Max-Forwards（14.31）</p>
<p>  (15).Proxy-Authorization（14.34）</p>
<p>  (16).Range（14.35）</p>
<p>  (17).Referer（14.36）</p>
<p>  (18).TE（14.39）</p>
<p>  (19).User-Agent（14.43）</p>
<ol>
<li><strong>响应头</strong></li>
</ol>
<p>响应头（response header）：一些关于响应（response）的附加信息。</p>
<p>  (1).Accept-Ranges（14.5）</p>
<p>  (2).Age（14.6）</p>
<p>  (3).ETag（14.19）</p>
<p>  (4).Location（14.30）</p>
<p>  (5).Proxy-Authenticate（14.33）</p>
<ol>
<li><strong>实体头</strong></li>
</ol>
<p>实体头（entity-header）：和消息体有关的附加信息。</p>
<p>  (1).Allow（14.7）</p>
<p>  (2).Content-Encoding（14.11）</p>
<p>  (3).Content-Language（14.12）</p>
<p>  (4).Content-Length（14.13）</p>
<p>  (5).Content-Location（14.14）</p>
<p>  (6).Content-MD5（14.15）</p>
<p>  (7).Content-Range（14.16）</p>
<p>  (8).Content-Type（14.17）</p>
<p>  (9).Expires（14.21）</p>
<p>  (11).Last-Modified（14.29）</p>
<p>  (12).extension-header</p>
<p>看到这里你可能会很奇怪，为什么会没有Cookie，Content-Disposition这种常见的信息头？！这里我说一下，Content-Disposition不是HTTP标准的一部分，但它在其他RFC文档中定义了（RFC1806）。而Cookie呢？首先看看Cookie是用来干嘛的：Cookie和Session是为了解决Http协议中无状态的问题，由于Http的设计者们时就没打算让Http有状态这种特性，故Cookie这种东西是肯定不可能是Http标准中的一部分。其实，它们都属于上面所说的：extension-header。其实各种浏览器都有它们自定义的扩展头，特别是IE！</p>
<h4 id="Http-1-1方法："><a href="#Http-1-1方法：" class="headerlink" title="Http/1.1方法："></a>Http/1.1方法：</h4><p>1.<strong>OPTIONS</strong>：简单说它的作用是查询信息，例如：查询服务器的能力(能干些什么)/查询操作该资源需要一些什么……当然，你可以不查询，直接操作资源/向服务器发送请求，如果服务器直接，它会告诉你成功/失败，如果服务器不支持，它也会告诉你不支持，但这样效率比较低，因为你操作了资源/你需要初始化资源，而OPTIONS不会执行这些操作，它仅仅是询问，当你不知道能否对资源执行此操作时，可以使用OPTIONS提高效率。</p>
<p>2.<strong>GET</strong>：请求资源</p>
<p>3.<strong>HEAD</strong>：主要是获取服务器响应的头信息，它的响应消息(response message)没有消息体(message body)，只有消息头(message headers)，作用是获取服务器的一些信息，如：Cache-Control等，以给客户端足够的信息决定接下来该如何去做。</p>
<p>4.<strong>POST</strong>：更新资料</p>
<p>5.<strong>PUT</strong>：如果请求的URI是已经存在的资源，则PUT请求所附的实体应被当作修改服务器中的资源，成功的话返回200或者204。如果请求的URI资源不存在，则URI可以被定义成新的资源，这时，服务器必须通过201（建立）响应通知用户。</p>
<p>POST和PUT不同点在反映在对request-URI的不同意义。使用POST方法时，URI资源会处理POST所提交的数据，这时的URI资源可以看作是接收并处理数据的程序。而使用PUT方法时，请求(request)中的实体数据会被认为是URI资源，而服务器不会试图用其他资源去接收这个请求。</p>
<p>6.<strong>DELETE</strong>：要求服务器释放请求(request)中URI所指向的资源。在服务器上，DELETE方法可能会被强行制止，所以客户端不能担保操作已经实现，即使服务器返回的状态码说明操作已经成功完成了（当然，如果服务器返回了成功，说明服务器已经打算去删除/移动需要被删除的资源了）。</p>
<p>7.<strong>TRACE</strong>：TRACE 方法用于引起远程的，该请求消息的应用层回射。请求的最终接收者应该反射200（OK）响应，并以该消息作为客户端回收消息的实体。最终接收者是原始服务器或第一个收到请求中的Max-Forwards值为0（0）的代理或网关。TRACE请求(注意是请求不是响应)不能包括实体。以上是RFC文档的解释，或许你没看明白上面到底想说什么，但只要你知道它的作用，你大概也能猜到了:&gt;，TRACE作用是：允许客户端看见请求链上的另一端收到了什么，然后使用该数据作为测试或诊断信息。就是说响应请求(response)的实体里包含了服务器/网关接收到的数据，而其中消息头Via的值有特殊作用，将它作为请求链路径。使用Max-Forwards头部域允许客户端限制请求链的长度，这对于测试无限循环转发消息的代理链非常有用。</p>
<p>8.<strong>CONNECT</strong>：规范保留 CONNECT 方法名。该方法用于代理，使之能够动态切换隧道（例如 SSL隧道）。</p>
<p>9.<strong>extension-method</strong></p>
<h3 id="客户端请求消息"><a href="#客户端请求消息" class="headerlink" title="客户端请求消息"></a>客户端请求消息</h3><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。<br><img src="http://www.runoob.com/wp-content/uploads/2013/11/2012072810301161.png" alt="image"></p>
<h3 id="服务器响应消息"><a href="#服务器响应消息" class="headerlink" title="服务器响应消息"></a>服务器响应消息</h3><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。<br><img src="http://www.runoob.com/wp-content/uploads/2013/11/httpmessage.jpg" alt="image">   </p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面实例是一点典型的使用GET来传递数据的实例：<br>客户端请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">GET /hello.txt HTTP/1.1</div><div class="line">User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3</div><div class="line">Host: www.example.com</div><div class="line">Accept-Language: en, mi</div></pre></td></tr></table></figure></p>
<p>服务端响应:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Mon, 27 Jul 2009 12:28:53 GMT</div><div class="line">Server: Apache</div><div class="line">Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT</div><div class="line">ETag: &quot;34aa387-d-1568eb00&quot;</div><div class="line">Accept-Ranges: bytes</div><div class="line">Content-Length: 51</div><div class="line">Vary: Accept-Encoding</div><div class="line">Content-Type: text/plain</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello World! My payload includes a trailing CRLF.</div></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/02/网络/HTTP 消息结构/" data-id="cje2lryz3001ypxblxqhqv8ie" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-网络/状态码" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/02/网络/状态码/">状态码</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/02/网络/状态码/" class="article-date"><time datetime="2017-08-02T02:09:45.000Z" itemprop="datePublished">2017-08-02</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络/">网络</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。<br>HTTP状态码的英文为HTTP Status Code。</p>
<p>下面是常见的HTTP状态码：</p>
<ul>
<li>200 - 请求成功</li>
<li>301 - 资源（网页等）被永久转移到其它URL</li>
<li>404 - 请求的资源（网页等）不存在</li>
<li>500 - 内部服务器错误</li>
</ul>
<h2 id="HTTP状态码分类"><a href="#HTTP状态码分类" class="headerlink" title="HTTP状态码分类"></a>HTTP状态码分类</h2><p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：<br>| 分类   | 分类描述                    |<br>| —- | ———————– |<br>| 1<strong>  | 信息，服务器收到请求，需要请求者继续执行操作  |<br>| 2</strong>  | 成功，操作被成功接收并处理           |<br>| 3<strong>  | 重定向，需要进一步的操作以完成请求       |<br>| 4</strong>  | 客户端错误，请求包含语法错误或无法完成请求   |<br>| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |</p>
<p>HTTP状态码列表:<br>| 状态码  |             状态码英文名称             |                   中文描述                   |<br>| :–: | :—————————–: | :————————————–: |<br>| 100  |            Continue             |               继续。客户端应继续其请求               |<br>| 101  |       Switching Protocols       | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |<br>|      |                                 |                                          |<br>| 200  |               OK                |           请求成功。一般用于GET与POST请求            |<br>| 201  |             Created             |             已创建。成功请求并创建了新的资源             |<br>| 202  |            Accepted             |            已接受。已经接受请求，但未处理完成             |<br>| 203  |  Non-Authoritative Information  |   非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本   |<br>| 204  |           No Content            | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |<br>| 205  |          Reset Content          | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |<br>| 206  |         Partial Content         |           部分内容。服务器成功处理了部分GET请求           |<br>|      |                                 |                                          |<br>| 300  |        Multiple Choices         | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |<br>| 301  |        Moved Permanently        | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |<br>| 302  |              Found              |   临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI   |<br>| 303  |            See Other            |       查看其它地址。与301类似。使用GET和POST请求查看       |<br>| 304  |          Not Modified           | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |<br>| 305  |            Use Proxy            |           使用代理。所请求的资源必须通过代理访问            |<br>| 306  |             Unused              |              已经被废弃的HTTP状态码               |<br>| 307  |       Temporary Redirect        |         临时重定向。与302类似。使用GET请求重定向          |<br>|      |                                 |                                          |<br>| 400  |           Bad Request           |            客户端请求的语法错误，服务器无法理解            |<br>| 401  |          Unauthorized           |               请求要求用户的身份认证                |<br>| 402  |        Payment Required         |                 保留，将来使用                  |<br>| 403  |            Forbidden            |         服务器理解请求客户端的请求，但是拒绝执行此请求          |<br>| 404  |            Not Found            | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面 |<br>| 405  |       Method Not Allowed        |               客户端请求中的方法被禁止               |<br>| 406  |         Not Acceptable          |          服务器无法根据客户端请求的内容特性完成请求           |<br>| 407  |  Proxy Authentication Required  |    请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权     |<br>| 408  |        Request Time-out         |           服务器等待客户端发送的请求时间过长，超时           |<br>| 409  |            Conflict             |   服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突   |<br>| 410  |              Gone               | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |<br>| 411  |         Length Required         |    服务器无法处理客户端发送的不带Content-Length的请求信息    |<br>| 412  |       Precondition Failed       |              客户端请求信息的先决条件错误              |<br>| 413  |    Request Entity Too Large     | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |<br>| 414  |      Request-URI Too Large      |        请求的URI过长（URI通常为网址），服务器无法处理        |<br>| 415  |     Unsupported Media Type      |             服务器无法处理请求附带的媒体格式             |<br>| 416  | Requested range not satisfiable |                客户端请求的范围无效                |<br>| 417  |       Expectation Failed        |           服务器无法满足Expect的请求头信息            |<br>|      |                                 |                                          |<br>| 500  |      Internal Server Error      |              服务器内部错误，无法完成请求              |<br>| 501  |         Not Implemented         |            服务器不支持请求的功能，无法完成请求            |<br>| 502  |           Bad Gateway           |      充当网关或代理的服务器，从远端服务器接收到了一个无效的请求       |<br>| 503  |       Service Unavailable       | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |<br>| 504  |        Gateway Time-out         |        充当网关或代理的服务器，未及时从远端服务器获取请求         |<br>| 505  |   HTTP Version not supported    |        服务器不支持请求的HTTP协议的版本，无法完成处理         |</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/02/网络/状态码/" data-id="cje2lryz9002dpxbl35svellr" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/page/9/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/8/">8</a></li><li><a class="page-number" href="/page/9/">9</a></li><li class="active"><span class="page-number">10</span></li><li><a class="page-number" href="/page/11/">11</a></li><li><a class="page-number" href="/page/12/">12</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/24/">24</a></li><li><a class="page-next" rel="next" href="/page/11/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-module-inset">
  <h4>关于</h4>
  <p>该博客内的文章是博主在日常工作或者学习中总结出来，部分内容来自网络.</p>

</div>


  
  <div class="sidebar-module">
    <h4>分类</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Eclipse/">Eclipse</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Github/">Github</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/">Java</a><span class="sidebar-module-list-count">84</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/Cookie/">Cookie</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/JAXB/">JAXB</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/JavaMail/">JavaMail</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/分布式/">分布式</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/基础/">基础</a><span class="sidebar-module-list-count">21</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/数据类型/">数据类型</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/日记/">日记</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/时间日期/">时间日期</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/线程/">线程</a><span class="sidebar-module-list-count">17</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/网络NIO/">网络NIO</a><span class="sidebar-module-list-count">12</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/队列/">队列</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/集合/">集合</a><span class="sidebar-module-list-count">8</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Linux/">Linux</a><span class="sidebar-module-list-count">17</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Maven/">Maven</a><span class="sidebar-module-list-count">9</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/">Spring</a><span class="sidebar-module-list-count">60</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Application-Event/">Application Event</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/JPA/">JPA</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Security/">Security</a><span class="sidebar-module-list-count">22</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Spring-Boot/">Spring Boot</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Spring-Session/">Spring Session</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Task/">Task</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/spring-MVC/">spring MVC</a><span class="sidebar-module-list-count">17</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/spring-data-redis/">spring data redis</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/基础/">基础</a><span class="sidebar-module-list-count">5</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/前端技术相关/">前端技术相关</a><span class="sidebar-module-list-count">3</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/前端技术相关/forever/">forever</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/前端技术相关/javascript/">javascript</a><span class="sidebar-module-list-count">1</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/数据库相关/">数据库相关</a><span class="sidebar-module-list-count">20</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/数据库相关/mysql/">mysql</a><span class="sidebar-module-list-count">20</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/">服务器相关</a><span class="sidebar-module-list-count">29</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Hessian/">Hessian</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Hudson-Jenkins/">Hudson & Jenkins</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Memcached/">Memcached</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Nginx/">Nginx</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Tomcat/">Tomcat</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/red5/">red5</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/redis/">redis</a><span class="sidebar-module-list-count">13</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/resin/">resin</a><span class="sidebar-module-list-count">3</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/网络/">网络</a><span class="sidebar-module-list-count">9</span></li></ul>
  </div>



  


  

  
  <div class="sidebar-module">
    <h4>归档</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">二月 2018</a><span class="sidebar-module-list-count">45</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">十月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">62</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">125</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/02/">二月 2017</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>最近文章</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/2018/02/25/Java/基础/java8新特性/">java8新特性</a>
        </li>
      
        <li>
          <a href="/2018/02/25/Java/集合/HashSet原理/">HashSet原理</a>
        </li>
      
        <li>
          <a href="/2018/02/25/Java/分布式/分布式锁/">分布式锁</a>
        </li>
      
        <li>
          <a href="/2018/02/25/Java/集合/在List循环中删除元素/">在List循环中删除元素</a>
        </li>
      
        <li>
          <a href="/2018/02/25/Java/集合/Hashtable与ConcurrentHashMap区别/">Hashtable与ConcurrentHashMap区别</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2018 LeoChan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>



<script src="/js/script.js"></script>

</body>
</html>
