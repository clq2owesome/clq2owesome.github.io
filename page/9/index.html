
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LeoChan&#39;s 个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="描述啊">
<meta property="og:type" content="website">
<meta property="og:title" content="LeoChan&#39;s 个人博客">
<meta property="og:url" content="http://yoursite.com/page/9/index.html">
<meta property="og:site_name" content="LeoChan&#39;s 个人博客">
<meta property="og:description" content="描述啊">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeoChan&#39;s 个人博客">
<meta name="twitter:description" content="描述啊">
  
    <link rel="alternative" href="/atom.xml" title="LeoChan&#39;s 个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LeoChan&#39;s 个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术都是通用的，重要的是是否具有自主解决问题的能力！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="yoursite.com">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main">
  
    <article id="post-Spring/SpringMVC/定义@RequestMapping注解的处理方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/19/Spring/SpringMVC/定义@RequestMapping注解的处理方法/" class="article-date">
  <time datetime="2017-07-19T02:09:45.000Z" itemprop="datePublished">2017-07-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/spring-MVC/">spring MVC</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/19/Spring/SpringMVC/定义@RequestMapping注解的处理方法/">定义@RequestMapping注解的处理方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(path=&quot;/owners/&#123;ownerId&#125;&quot;, method=RequestMethod.GET)</div><div class="line">public String findOwner(@PathVariable String ownerId, Model model) &#123;</div><div class="line">    Owner owner = ownerService.findOwner(ownerId);</div><div class="line">    model.addAttribute(&quot;owner&quot;, owner);</div><div class="line">    return &quot;displayOwner&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>URI模板”/owners/{ownerId}”指定了一个变量，名为ownerId。当控制器处理这个请求的时候，ownerId的值就会被URI模板中对应部分的值所填充。比如说，如果请求的URI是/owners/fred，此时变量ownerId的值就是fred.<br>为了处理@PathVariables注解，Spring MVC必须通过变量名来找到URI模板中相对应的变量。你可以在注解中直接声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(path=&quot;/owners/&#123;ownerId&#125;&#125;&quot;, method=RequestMethod.GET)</div><div class="line">public String findOwner(@PathVariable(&quot;ownerId&quot;) String theOwner, Model model) &#123;</div><div class="line">    // 具体的方法代码…</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果URI模板中的变量名与方法的参数名是相同的，则你可以不必再指定一次<br>一个方法可以拥有任意数量的@PathVariable注解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(path=&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;&quot;, method=RequestMethod.GET)</div><div class="line">public String findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) &#123;</div><div class="line">    Owner owner = ownerService.findOwner(ownerId);</div><div class="line">    Pet pet = owner.getPet(petId);</div><div class="line">    model.addAttribute(&quot;pet&quot;, pet);</div><div class="line">    return &quot;displayPet&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当@PathVariable注解被应用于Map<string, string="">类型的参数上时，框架会使用所有URI模板变量来填充这个map。  </string,></p>
<p>URI模板可以从类级别和方法级别的 @RequestMapping 注解获取数据。因此，像这样的findPet()方法可以被类似于/owners/42/pets/21这样的URL路由并调用到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Controller</div><div class="line">@RequestMapping(&quot;/owners/&#123;ownerId&#125;&quot;)</div><div class="line">public class RelativePathUriTemplateController &#123;</div><div class="line"></div><div class="line">    @RequestMapping(&quot;/pets/&#123;petId&#125;&quot;)</div><div class="line">    public void findPet(_@PathVariable_ String ownerId, _@PathVariable_ String petId, Model model) &#123;</div><div class="line">        // 方法实现体这里忽略</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>@PathVariable可以被应用于所有 简单类型 的参数上，比如int、long、Date等类型。Spring会自动地帮你把参数转化成合适的类型，如果转换失败，就抛出一个TypeMismatchException。如果你需要处理其他数据类型的转换，也可以注册自己的类</p>
<h1 id="MatrixVariable"><a href="#MatrixVariable" class="headerlink" title="@MatrixVariable"></a>@MatrixVariable</h1><p>矩阵变量可以在任何路径段落中出现，每对矩阵变量之间使用一个分号“;”隔开。比如这样的URI：”/cars;color=red;year=2012”。多个值可以用逗号隔开”color=red,green,blue”，或者重复变量名多次”color=red;color=green;color=blue”<br>下面是一个例子，展示了我们如何从矩阵变量中获取到变量“q”的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// GET /pets/42;q=11;r=22</div><div class="line"></div><div class="line">@RequestMapping(path = &quot;/pets/&#123;petId&#125;&quot;, method = RequestMethod.GET)</div><div class="line">public void findPet(@PathVariable String petId, @MatrixVariable int q) &#123;</div><div class="line"></div><div class="line">    // petId == 42</div><div class="line">    // q == 11</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于任意路径段落中都可以含有矩阵变量，在某些场景下，你需要用更精确的信息来指定一个矩阵变量的位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// GET /owners/42;q=11/pets/21;q=22</div><div class="line"></div><div class="line">@RequestMapping(path = &quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;&quot;, method = RequestMethod.GET)</div><div class="line">public void findPet(</div><div class="line">    @MatrixVariable(name=&quot;q&quot;, pathVar=&quot;ownerId&quot;) int q1,</div><div class="line">    @MatrixVariable(name=&quot;q&quot;, pathVar=&quot;petId&quot;) int q2) &#123;</div><div class="line"></div><div class="line">    // q1 == 11</div><div class="line">    // q2 == 22</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你也可以声明一个矩阵变量不是必须出现的，并给它赋一个默认值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// GET /pets/42</div><div class="line"></div><div class="line">@RequestMapping(path = &quot;/pets/&#123;petId&#125;&quot;, method = RequestMethod.GET)</div><div class="line">public void findPet(@MatrixVariable(required=false, defaultValue=&quot;1&quot;) int q) &#123;</div><div class="line"></div><div class="line">    // q == 1</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也可以通过一个Map来存储所有的矩阵变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// GET /owners/42;q=11;r=12/pets/21;q=22;s=23</div><div class="line"></div><div class="line">@RequestMapping(path = &quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;&quot;, method = RequestMethod.GET)</div><div class="line">public void findPet(</div><div class="line">    @MatrixVariable Map&lt;String, String&gt; matrixVars,</div><div class="line">    @MatrixVariable(pathVar=&quot;petId&quot;) Map&lt;String, String&gt; petMatrixVars) &#123;</div><div class="line"></div><div class="line">    // matrixVars: [&quot;q&quot; : [11,22], &quot;r&quot; : 12, &quot;s&quot; : 23]</div><div class="line">    // petMatrixVars: [&quot;q&quot; : 11, &quot;s&quot; : 23]</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用MVC的命名空间配置时，你可以把<mvc:annotation-driven>元素下的enable-matrix-variables属性设置为true。该值默认情况下是配置为false的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;</div><div class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">    xsi:schemaLocation=&quot;</div><div class="line">        http://www.springframework.org/schema/beans</div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">        http://www.springframework.org/schema/mvc</div><div class="line">        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;</div><div class="line"></div><div class="line">    &lt;mvc:annotation-driven enable-matrix-variables=&quot;true&quot;/&gt;</div><div class="line"></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></mvc:annotation-driven></p>
<h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><ul>
<li>value：参数名字，即入参的请求参数名字，如username表示请求的参数区中的名字为username的参数的值将传入；</li>
<li>required：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报404错误码；</li>
<li>defaultValue：默认值，表示如果请求中没有同名参数时的默认值<br>。<br>你可以使用@RequestParam注解将请求参数绑定到你控制器的方法参数上。<br>类似于<code>request.getParameter();</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@Controller</div><div class="line">@RequestMapping(&quot;/pets&quot;)</div><div class="line">@SessionAttributes(&quot;pet&quot;)</div><div class="line">public class EditPetForm &#123;</div><div class="line">    // ...</div><div class="line">    @RequestMapping(method = RequestMapping.GET)</div><div class="line">    public String setupForm(@RequestParam(&quot;petId&quot;) int petId, ModelMap model) &#123;</div><div class="line">        Pet pet = this.clinic.loadPet(petId);</div><div class="line">        model.addAttribute(&quot;pet&quot;, pet);</div><div class="line">        return &quot;petForm&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // ,..</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>若参数使用了该注解，则该参数默认是必须提供的，但你也可以把该参数标注为非必须的：只需要将@RequestParam注解的required属性设置为false即可（比如，<code>@RequestParam(path=&quot;id&quot;, required=false)</code>）。    </p>
<p>若所注解的方法参数类型不是String，则类型转换会自动地发生。<br>若@RequestParam注解的参数类型是Map<string, string="">或者MultiValueMap<string, string="">，则该Map中会自动填充所有的请求参数。</string,></string,></p>
<h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p>一直以为在SpringMVC环境中，@RequestBody接收的是一个Json对象，一直在调试代码都没有成功，后来发现，其实 @RequestBody接收的是一个Json对象的字符串，而不是一个Json对象。然而在ajax请求往往传的都是Json对象，后来发现用 JSON.stringify(data)的方式就能将对象变成字符串。同时ajax请求的时候也要指定dataType: “json”,contentType:”application/json” 这样就可以轻易的将一个对象或者List传到Java端，使用@RequestBody即可绑定对象或者List.  </p>
<p>该注解常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等；<br>它是通过使用HandlerAdapter 配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。<br>因为配置有FormHttpMessageConverter，所以也可以用来处理 application/x-www-form-urlencoded的内容，处理完的结果放在一个MultiValueMap<string, string="">里，这种情况在某些特殊需求下使用，详情查看FormHttpMessageConverter api;</string,></p>
<p>@RequestBody注解时： 根据Request对象header部分的Content-Type类型，逐一匹配合适的HttpMessageConverter来读取数据</p>
<p>MappingJacksonHttpMessageConverter 调用了 objectMapper.writeValue(OutputStream stream, Object)方法，使用@ResponseBody注解返回的对象就传入Object参数内。若返回的对象为已经格式化好的json串时，不使用@RequestBody注解，而应该这样处理：</p>
<ol>
<li>response.setContentType(“application/json; charset=UTF-8”);</li>
<li>response.getWriter().print(jsonStr);</li>
<li>直接输出到body区，然后的视图为void。</li>
</ol>
<p>方法参数中的@RequestBody注解暗示了方法参数应该被绑定了HTTP请求体的值。举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(path = &quot;/something&quot;, method = RequestMethod.PUT)</div><div class="line">public void handle(@RequestBody String body, Writer writer) throws IOException &#123;</div><div class="line">    writer.write(body);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>请求体到方法参数的转换是由HttpMessageConverter完成的。HttpMessageConverter负责将HTTP请求信息转换成对象，以及将对象转换回一个HTTP响应体。对于@RequestBody注解，RequestMappingHandlerAdapter提供了以下几种默认的HttpMessageConverter支持：</p>
<ul>
<li>ByteArrayHttpMessageConverter用以转换字节数组</li>
<li>StringHttpMessageConverter用以转换字符串</li>
<li>FormHttpMessageConverter用以将表格数据转换成MultiValueMap<string, string="">或从MultiValueMap<string, string="">中转换出表格数据</string,></string,></li>
<li>SourceHttpMessageConverter用于javax.xml.transform.Source类的互相转换</li>
<li>MappingJacksonHttpMessageConverter负责读取和写入json格式的数据</li>
</ul>
<p>若你更倾向于阅读和编写XML文件，那么你需要配置一个MarshallingHttpMessageConverter并为其提供org.springframework.oxm包下的一个Marshaller和Unmarshaller实现。下面的示例就为你展示如何直接在配置文件中配置它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;</div><div class="line">    &lt;property name=&quot;messageConverters&quot;&gt;</div><div class="line">        &lt;util:list id=&quot;beanList&quot;&gt;</div><div class="line">            &lt;ref bean=&quot;stringHttpMessageConverter&quot;/&gt;</div><div class="line">            &lt;ref bean=&quot;marshallingHttpMessageConverter&quot;/&gt;</div><div class="line">        &lt;/util:list&gt;</div><div class="line">    &lt;/property</div><div class="line">&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;bean id=&quot;stringHttpMessageConverter&quot; class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;/&gt;</div><div class="line"></div><div class="line">&lt;bean id=&quot;marshallingHttpMessageConverter&quot;</div><div class="line">        class=&quot;org.springframework.http.converter.xml.MarshallingHttpMessageConverter&quot;&gt;</div><div class="line">    &lt;property name=&quot;marshaller&quot; ref=&quot;castorMarshaller&quot;/&gt;</div><div class="line">    &lt;property name=&quot;unmarshaller&quot; ref=&quot;castorMarshaller&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;bean id=&quot;castorMarshaller&quot; class=&quot;org.springframework.oxm.castor.CastorMarshaller&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>注解了@RequestBody的方法参数还可以被@Valid注解，这样框架会使用已配置的Validator实例来对该参数进行验证。若你的应用是使用MVC命令空间或MVC Java编程的方式配置的，框架会假设在classpath路径下存在一个符合JSR-303规范的验证器，并自动将其作为默认配置。      </p>
<p>与@ModelAttribute注解的参数一样，Errors也可以被传入为方法参数，用于检查错误。如果没有声明这样一个参数，那么程序会抛出一个MethodArgumentNotValidException异常。该异常默认由DefaultHandlerExceptionResolver处理，处理程序会返回一个400错误给客户端。</p>
<h2 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h2><p>@ResponseBody注解与@RequestBody注解类似。@ResponseBody注解可被应用于方法上，标志该方法的返回值（更正，原文是return type，看起来应该是返回值）应该被直接写回到HTTP响应体中去（而不会被被放置到Model中或被解释为一个视图名）。举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(path = &quot;/something&quot;, method = RequestMethod.PUT)</div><div class="line">@ResponseBody</div><div class="line">public String helloWorld() &#123;</div><div class="line">    return &quot;Hello World&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码结果是文本Hello World将被写入HTTP的响应流中。<br>与@RequestBody注解类似，Spring使用了一个HttpMessageConverter来将返回对象转换到响应体中。</p>
<h2 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h2><p>@CookieValue注解能将一个方法参数与一个HTTP cookie的值进行绑定。<br>看一个这样的场景：以下的这个cookie存储在一个HTTP请求中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84</div></pre></td></tr></table></figure></p>
<p>下面的代码演示了拿到JSESSIONID这个cookie值的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(&quot;/displayHeaderInfo.do&quot;)</div><div class="line">public void displayHeaderInfo(@CookieValue(&quot;JSESSIONID&quot;) String cookie) &#123;</div><div class="line">    //...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>若注解的目标方法参数不是String类型，则类型转换会自动进行。</p>
<h2 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h2><p>@RequestHeader注解能将一个方法参数与一个请求头属性进行绑定。<br>以下是一个请求头的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Host                    localhost:8080</div><div class="line">Accept                  text/html,application/xhtml+xml,application/xml;q=0.9</div><div class="line">Accept-Language         fr,en-gb;q=0.7,en;q=0.3</div><div class="line">Accept-Encoding         gzip,deflate</div><div class="line">Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7</div><div class="line">Keep-Alive              300</div></pre></td></tr></table></figure></p>
<p>以下的代码片段展示了如何取得Accept-Encoding请求头和Keep-Alive请求头的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(&quot;/displayHeaderInfo.do&quot;)</div><div class="line">public void displayHeaderInfo(@RequestHeader(&quot;Accept-Encoding&quot;) String encoding,</div><div class="line">        @RequestHeader(&quot;Keep-Alive&quot;) long keepAlive) &#123;</div><div class="line">    //...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>若注解的目标方法参数不是String类型，则类型转换会自动进行。<br>如果@RequestHeader注解应用在Map<string, string="">、MultiValueMap<string, string="">或HttpHeaders类型的参数上，那么所有的请求头属性值都会被填充到map中。<br>Spring内置支持将一个逗号分隔的字符串（或其他类型转换系统所能识别的类型）转换成一个String类型的列表/集合。举个例子，一个注解了@RequestHeader(“Accept”)的方法参数可以是一个String类型，但也可以是String[]或List<string>类型的。</string></string,></string,></p>
<h2 id="HttpEntity"><a href="#HttpEntity" class="headerlink" title="@HttpEntity"></a>@HttpEntity</h2><p>HttpEntity与@RequestBody和@ResponseBody很相似。除了能获得请求体和响应体中的内容之外，HttpEntity（以及专门负责处理响应的ResponseEntity子类）还可以存取请求头和响应头，像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(&quot;/something&quot;)</div><div class="line">public ResponseEntity&lt;String&gt; handle(HttpEntity&lt;byte[]&gt; requestEntity) throws UnsupportedEncodingException &#123;</div><div class="line">    String requestHeader = requestEntity.getHeaders().getFirst(&quot;MyRequestHeader&quot;);</div><div class="line">    byte[] requestBody = requestEntity.getBody();</div><div class="line"></div><div class="line">    // do something with request header and body</div><div class="line"></div><div class="line">    HttpHeaders responseHeaders = new HttpHeaders();</div><div class="line">    responseHeaders.set(&quot;MyResponseHeader&quot;, &quot;MyValue&quot;);</div><div class="line">    return new ResponseEntity&lt;String&gt;(&quot;Hello World&quot;, responseHeaders, HttpStatus.CREATED);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面这段示例代码先是获取了MyRequestHeader请求头的值，然后读取请求体的主体内容。读完以后往影响头中添加了一个自己的响应头MyResponseHeader，然后向响应流中写了字符串Hello World，最后把响应状态码设置为201（创建成功）。<br>与@RequestBody与@ResponseBody注解一样，Spring使用了HttpMessageConverter来对请求流和响应流进行转换。</p>
<h2 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h2><h3 id="ModelAttribute注解应用在方法上"><a href="#ModelAttribute注解应用在方法上" class="headerlink" title="@ModelAttribute注解应用在方法上"></a>@ModelAttribute注解应用在方法上</h3><p>注解在方法上的@ModelAttribute说明了方法的作用是用于添加一个或多个属性到model上。这样的方法能接受与@RequestMapping注解相同的参数类型，只不过不能直接被映射到具体的请求上。在同一个控制器中，注解了@ModelAttribute的方法实际上会在@RequestMapping方法之前被调用。以下是几个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Add one attribute</span></div><div class="line"><span class="comment">// The return value of the method is added to the model under the name "account"</span></div><div class="line"><span class="comment">// You can customize the name via @ModelAttribute("myAccount")</span></div><div class="line"></div><div class="line"><span class="meta">@ModelAttribute</span></div><div class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">addAccount</span><span class="params">(@RequestParam String number)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> accountManager.findAccount(number);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Add multiple attributes</span></div><div class="line"></div><div class="line"><span class="meta">@ModelAttribute</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populateModel</span><span class="params">(@RequestParam String number, Model model)</span> </span>&#123;</div><div class="line">    model.addAttribute(accountManager.findAccount(number));</div><div class="line">    <span class="comment">// add more ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>@ModelAttribute方法通常被用来填充一些公共需要的属性或数据，比如一个下拉列表所预设的几种状态，或者宠物的几种类型，或者去取得一个HTML表单渲染所需要的命令对象，比如Account等。<br>留意@ModelAttribute方法的两种风格。在第一种写法中，方法通过返回值的方式默认地将添加一个属性；在第二种写法中，方法接收一个Model对象，然后可以向其中添加任意数量的属性。你可以在根据需要，在两种风格中选择合适的一种。<br>一个控制器可以拥有数量不限的@ModelAttribute方法。同个控制器内的所有这些方法，都会在@RequestMapping方法之前被调用.<br>@ModelAttribute方法也可以定义在@ControllerAdvice注解的类中，并且这些@ModelAttribute可以同时对许多控制器生效。<br>@ModelAttribute注解也可以被用在@RequestMapping方法上。这种情况下，@RequestMapping方法的返回值将会被解释为model的一个属性，而非一个视图名。此时视图名将以视图命名约定来方式来决议，与返回值为void的方法所采用的处理方法类似</p>
<h3 id="ModelAttribute注解用在方法参数上"><a href="#ModelAttribute注解用在方法参数上" class="headerlink" title="@ModelAttribute注解用在方法参数上"></a>@ModelAttribute注解用在方法参数上</h3><p>注解在方法参数上的@ModelAttribute说明了该方法参数的值将由model中取得。如果model中找不到，那么该参数会先被实例化，然后被添加到model中。在model中存在以后，请求中所有名称匹配的参数都会填充到该参数中。这在Spring MVC中被称为数据绑定，一个非常有用的特性，节约了你每次都需要手动从表格数据中转换这些字段数据的时间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(path = &quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit&quot;, method = RequestMethod.POST)</div><div class="line">public String processSubmit(@ModelAttribute Pet pet) &#123; &#125;</div></pre></td></tr></table></figure></p>
<p>以上面的代码为例，这个Pet类型的实例可能来自哪里呢？有几种可能:     </p>
<ul>
<li>它可能因为@SessionAttributes注解的使用已经存在于model中</li>
<li>它可能因为在同个控制器中使用了@ModelAttribute方法已经存在于model中</li>
<li>它可能是由URI模板变量和类型转换中取得的（下面会详细讲解）</li>
<li>它可能是调用了自身的默认构造器被实例化出来的  </li>
</ul>
<p>@ModelAttribute方法常用于从数据库中取一个属性值，该值可能通过@SessionAttributes注解在请求中间传递。在一些情况下，使用URI模板变量和类型转换的方式来取得一个属性是更方便的方式。这里有个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(path = &quot;/accounts/&#123;account&#125;&quot;, method = RequestMethod.PUT)</div><div class="line">public String save(@ModelAttribute(&quot;account&quot;) Account account) &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面这个例子中，model属性的名称（”account”）与URI模板变量的名称相匹配。如果你配置了一个可以将String类型的账户值转换成Account类型实例的转换器Converter<string, account="">，那么上面这段代码就可以工作的很好，而不需要再额外写一个@ModelAttribute方法。<br>下一步就是数据的绑定。WebDataBinder类能将请求参数——包括字符串的查询参数和表单字段等——通过名称匹配到model的属性上。成功匹配的字段在需要的时候会进行一次类型转换（从String类型到目标字段的类型），然后被填充到model对应的属性中。数据绑定和数据验证的问题在第8章 验证，数据绑定和类型转换中提到。如何在控制器层来定制数据绑定的过程，在这一节 “定制WebDataBinder的初始化”中提及。<br>进行了数据绑定后，则可能会出现一些错误，比如没有提供必须的字段、类型转换过程的错误等。若想检查这些错误，可以在注解了@ModelAttribute的参数紧跟着声明一个BindingResult参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(path = &quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit&quot;, method = RequestMethod.POST)</div><div class="line">public String processSubmit(@ModelAttribute(&quot;pet&quot;) Pet pet, BindingResult result) &#123;</div><div class="line">    if (result.hasErrors()) &#123;</div><div class="line">        return &quot;petForm&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></string,></p>
<p>拿到BindingResult参数后，你可以检查是否有错误。有时你可以通过Spring的<errors>表单标签来在同一个表单上显示错误信息。<br>BindingResult被用于记录数据绑定过程的错误，因此除了数据绑定外，你还可以把该对象传给自己定制的验证器来调用验证。这使得数据绑定过程和验证过程出现的错误可以被搜集到一处，然后一并返回给用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(path = &quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit&quot;, method = RequestMethod.POST)</div><div class="line">public String processSubmit(@ModelAttribute(&quot;pet&quot;) Pet pet, BindingResult result) &#123;</div><div class="line"></div><div class="line">    new PetValidator().validate(pet, result);</div><div class="line">    if (result.hasErrors()) &#123;</div><div class="line">        return &quot;petForm&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></errors></p>
<p>又或者，你可以通过添加一个JSR-303规范的@Valid注解，这样验证器会自动被调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(path = &quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit&quot;, method = RequestMethod.POST)</div><div class="line">public String processSubmit(@Valid @ModelAttribute(&quot;pet&quot;) Pet pet, BindingResult result) &#123;</div><div class="line"></div><div class="line">    if (result.hasErrors()) &#123;</div><div class="line">        return &quot;petForm&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="SessionAttributes"><a href="#SessionAttributes" class="headerlink" title="@SessionAttributes"></a>@SessionAttributes</h2><p>类型级别的@SessionAttributes注解声明了某个特定处理器所使用的会话属性。通常它会列出该类型希望存储到session或converstaion中的model属性名或model的类型名，一般是用于在请求之间保存一些表单数据的bean。<br>以下的代码段演示了该注解的用法，它指定了模型属性的名称<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Controller</div><div class="line">@RequestMapping(&quot;/editPet.do&quot;)</div><div class="line">@SessionAttributes(&quot;pet&quot;)</div><div class="line">public class EditPetForm &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2017/07/19/Spring/SpringMVC/定义@RequestMapping注解的处理方法/" data-id="cj5knthww00593mblmehehfdd" class="article-share-link" data-share="baidu" data-title="定义@RequestMapping注解的处理方法">分享到</a>
      

      
        <a href="http://yoursite.com/2017/07/19/Spring/SpringMVC/定义@RequestMapping注解的处理方法/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器相关/redis/Redis 持久化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/19/服务器相关/redis/Redis 持久化/" class="article-date">
  <time datetime="2017-07-19T02:09:45.000Z" itemprop="datePublished">2017-07-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/19/服务器相关/redis/Redis 持久化/">Redis 持久化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Redis 提供了不同级别的持久化方式:</p>
<ul>
<li><code>RDB</code>持久化方式能够在指定的时间间隔能对你的数据进行快照存储.</li>
<li><code>AOF</code>持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大.</li>
<li>如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</li>
<li>你也可以同时开启两种持久化方式, 在这种情况下, 当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</li>
</ul>
<p>最重要的事情是了解RDB和AOF持久化方式的不同,让我们以RDB持久化方式开始:</p>
<h2 id="RDB的优点"><a href="#RDB的优点" class="headerlink" title="RDB的优点"></a>RDB的优点</h2><ul>
<li>RDB是一个非常紧凑的文件,它保存了某个时间点得数据集,非常适用于数据集的备份,比如你可以在每个小时报保存一下过去24小时内的数据,同时每天保存过去30天的数据,这样即使出了问题你也可以根据需求恢复到不同版本的数据集.</li>
<li>RDB是一个紧凑的单一文件,很方便传送到另一个远端数据中心或者亚马逊的S3（可能加密），非常适用于灾难恢复.</li>
<li>RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程,接下来的工作全部由子进程来做，父进程不需要再做其他IO操作，所以RDB持久化方式可以最大化redis的性能.</li>
<li>与AOF相比,在恢复大的数据集的时候，RDB方式会更快一些.</li>
</ul>
<h2 id="RDB的缺点"><a href="#RDB的缺点" class="headerlink" title="RDB的缺点"></a>RDB的缺点</h2><ul>
<li>如果你希望在redis意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么RDB不适合你.虽然你可以配置不同的save时间点(例如每隔5分钟并且对数据集有100个写的操作),是Redis要完整的保存整个数据集是一个比较繁重的工作,你通常会每隔5分钟或者更久做一次完整的保存,万一在Redis意外宕机,你可能会丢失几分钟的数据.</li>
<li>RDB 需要经常fork子进程来保存数据集到硬盘上,当数据集比较大的时候,fork的过程是非常耗时的,可能会导致Redis在一些毫秒级内不能响应客户端的请求.如果数据集巨大并且CPU性能不是很好的情况下,这种情况会持续1秒,AOF也需要fork,但是你可以调节重写日志文件的频率来提高数据集的耐久度.</li>
</ul>
<h2 id="AOF-优点"><a href="#AOF-优点" class="headerlink" title="AOF 优点"></a>AOF 优点</h2><ul>
<li>使用AOF 会让你的Redis更加耐久: 你可以使用不同的fsync策略：无fsync,每秒fsync,每次写的时候fsync.使用默认的每秒fsync策略,Redis的性能依然很好(fsync是由后台线程进行处理的,主线程会尽力处理客户端请求),一旦出现故障，你最多丢失1秒的数据.</li>
<li>AOF文件是一个只进行追加的日志文件,所以不需要写入seek,即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令,你也也可使用redis-check-aof工具修复这些问题.</li>
<li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 - - - Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</li>
<li>AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。</li>
</ul>
<h2 id="AOF-缺点"><a href="#AOF-缺点" class="headerlink" title="AOF 缺点"></a>AOF 缺点</h2><ul>
<li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</li>
<li>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。</li>
</ul>
<h2 id="如何选择使用哪种持久化方式？"><a href="#如何选择使用哪种持久化方式？" class="headerlink" title="如何选择使用哪种持久化方式？"></a>如何选择使用哪种持久化方式？</h2><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性，<br>你应该同时使用两种持久化功能。  </p>
<p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。 </p>
<p>有很多用户都只使用 AOF 持久化， 但我们并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快， 除此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug 。</p>
<h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><p>在默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。你可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。你也可以通过调用 SAVE或者 BGSAVE ， 手动让 Redis 进行数据集保存操作。</p>
<p>比如说， 以下设置会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">save 60 1000</div></pre></td></tr></table></figure></p>
<p>这种持久化方式被称为快照 snapshotting.</p>
<h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><p>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作:</p>
<ul>
<li>Redis 调用forks. 同时拥有父进程和子进程。</li>
<li>子进程将数据集写入到一个临时 RDB 文件中。</li>
<li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li>
</ul>
<p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。</p>
<h2 id="只追加操作的文件（Append-only-file，AOF）"><a href="#只追加操作的文件（Append-only-file，AOF）" class="headerlink" title="只追加操作的文件（Append-only file，AOF）"></a>只追加操作的文件（Append-only file，AOF）</h2><p>快照功能并不是非常耐久（dura ble）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。<br>你可以在配置文件中打开AOF方式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">appendonly yes</div></pre></td></tr></table></figure></p>
<p>从现在开始， 每当 Redis 执行一个改变数据集的命令时（比如 SET）， 这个命令就会被追加到 AOF 文件的末尾。这样的话， 当 Redis 重新启时， 程序就可以通过重新执行 AOF 文件中的命令来达到重建数据集的目的。</p>
<h2 id="日志重写"><a href="#日志重写" class="headerlink" title="日志重写"></a>日志重写</h2><p>因为 AOF 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， AOF 文件的体积也会变得越来越大。举个例子， 如果你对一个计数器调用了 100 次 INCR ， 那么仅仅是为了保存这个计数器的当前值， AOF 文件就需要使用 100 条记录（entry）。然而在实际上， 只使用一条 SET 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的。<br>为了处理这种情况， Redis 支持一种有趣的特性： 可以在不打断服务客户端的情况下， 对 AOF 文件进行重建（rebuild）。执行 BGREWRITEAOF 命令， Redis 将生成一个新的 AOF 文件， 这个文件包含重建当前数据集所需的最少命令。Redis 2.2 需要自己手动执行 BGREWRITEAOF 命令； Redis 2.4 则可以自动触发 AOF 重写， 具体信息请查看 2.4 的示例配置文件。</p>
<h2 id="AOF有多耐用"><a href="#AOF有多耐用" class="headerlink" title="AOF有多耐用?"></a>AOF有多耐用?</h2><p>你可以配置 Redis 多久才将数据 fsync 到磁盘一次。有三种方式：</p>
<ul>
<li>每次有新命令追加到 AOF 文件时就执行一次 fsync ：非常慢，也非常安全</li>
<li>每秒 fsync 一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据。</li>
<li>从不 fsync ：将数据交给操作系统来处理。更快，也更不安全的选择。</li>
<li>推荐（并且也是默认）的措施为每秒 fsync 一次， 这种 fsync 策略可以兼顾速度和安全性。</li>
</ul>
<h2 id="如果AOF文件损坏了怎么办？"><a href="#如果AOF文件损坏了怎么办？" class="headerlink" title="如果AOF文件损坏了怎么办？"></a>如果AOF文件损坏了怎么办？</h2><p>服务器可能在程序正在对 AOF 文件进行写入时停机， 如果停机造成了 AOF 文件出错（corrupt）， 那么 Redis 在重启时会拒绝载入这个 AOF 文件， 从而确保数据的一致性不会被破坏。当发生这种情况时， 可以用以下方法来修复出错的 AOF 文件：  </p>
<ul>
<li>为现有的 AOF 文件创建一个备份。</li>
<li>使用 Redis 附带的 redis-check-aof 程序，对原来的 AOF 文件进行修复:<br>$ redis-check-aof –fix</li>
<li>（可选）使用 diff -u 对比修复后的 AOF 文件和原始 AOF 文件的备份，查看两个文件之间的不同之处。</li>
<li>重启 Redis 服务器，等待服务器载入修复后的 AOF 文件，并进行数据恢复。</li>
</ul>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>AOF 重写和 RDB 创建快照一样，都巧妙地利用了写时复制机制:</p>
<ul>
<li>Redis 执行 fork() ，现在同时拥有父进程和子进程。</li>
<li>子进程开始将新 AOF 文件的内容写入到临时文件。</li>
<li>对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾,这样样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。</li>
<li>当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。</li>
<li>搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。</li>
</ul>
<h2 id="怎样从RDB方式切换为AOF方式"><a href="#怎样从RDB方式切换为AOF方式" class="headerlink" title="怎样从RDB方式切换为AOF方式"></a>怎样从RDB方式切换为AOF方式</h2><p>在 Redis 2.2 或以上版本，可以在不重启的情况下，从 RDB 切换到 AOF ：</p>
<ul>
<li>为最新的 dump.rdb 文件创建一个备份。</li>
<li>将备份放到一个安全的地方。</li>
<li>执行以下两条命令:</li>
<li>redis-cli config set appendonly yes</li>
<li>redis-cli config set save “”</li>
<li>确保写命令会被正确地追加到 AOF 文件的末尾。</li>
<li>执行的第一条命令开启了 AOF 功能： Redis 会阻塞直到初始 AOF 文件创建完成为止， 之后 Redis 会继续处理命令请求， 并开始将写入命令追加到 AOF 文件末尾。  </li>
</ul>
<p>执行的第二条命令用于关闭 RDB 功能。 这一步是可选的， 如果你愿意的话， 也可以同时使用 RDB 和 AOF 这两种持久化功能。 </p>
<p>重要:别忘了在 redis.conf 中打开 AOF 功能！ 否则的话， 服务器重启之后， 之前通过 CONFIG SET 设置的配置就会被遗忘， 程序会按原来的配置来启动服务器。    </p>
<h2 id="AOF和RDB之间的相互作用"><a href="#AOF和RDB之间的相互作用" class="headerlink" title="AOF和RDB之间的相互作用"></a>AOF和RDB之间的相互作用</h2><p>在版本号大于等于 2.4 的 Redis 中， BGSAVE 执行的过程中， 不可以执行 BGREWRITEAOF 。 反过来说， 在 BGREWRITEAOF 执行的过程中， 也不可以执行 BGSAVE。这可以防止两个 Redis 后台进程同时对磁盘进行大量的 I/O 操作。  </p>
<p>如果 BGSAVE 正在执行， 并且用户显示地调用 BGREWRITEAOF 命令， 那么服务器将向用户回复一个 OK 状态， 并告知用户， BGREWRITEAOF 已经被预定执行： 一旦 BGSAVE 执行完毕， BGREWRITEAOF 就会正式开始。 当 Redis 启动时， 如果 RDB 持久化和 AOF 持久化都被打开了， 那么程序会优先使用 AOF 文件来恢复数据集， 因为 AOF 文件所保存的数据通常是最完整的。</p>
<h2 id="备份redis数据"><a href="#备份redis数据" class="headerlink" title="备份redis数据"></a>备份redis数据</h2><p>在阅读这个小节前， 请牢记下面这句话: 确保你的数据由完整的备份. 磁盘故障， 节点失效， 诸如此类的问题都可能让你的数据消失不见， 不进行备份是非常危险的。  </p>
<p>Redis 对于数据备份是非常友好的， 因为你可以在服务器运行的时候对 RDB 文件进行复制： RDB 文件一旦被创建， 就不会进行任何修改。 当服务器要创建一个新的 RDB 文件时， 它先将文件的内容保存在一个临时文件里面， 当临时文件写入完毕时， 程序才使用 rename(2) 原子地用临时文件替换原来的 RDB 文件。  </p>
<p>这也就是说， 无论何时， 复制 RDB 文件都是绝对安全的。</p>
<ul>
<li>创建一个定期任务（cron job）， 每小时将一个 RDB 文件备份到一个文件夹， 并且每天将一个 RDB 文件备份到另一个文件夹。</li>
<li>确保快照的备份都带有相应的日期和时间信息， 每次执行定期任务脚本时， 使用 find 命令来删除过期的快照： 比如说， 你可以保留最近 48 小时内的每小时快照， 还可以保留最近一两个月的每日快照。</li>
<li>至少每天一次， 将 RDB 备份到你的数据中心之外， 或者至少是备份到你运行 Redis 服务器的物理机器之外。  </li>
</ul>
<h2 id="容灾备份"><a href="#容灾备份" class="headerlink" title="容灾备份"></a>容灾备份</h2><p>Redis 的容灾备份基本上就是对数据进行备份， 并将这些备份传送到多个不同的外部数据中心。容灾备份可以在 Redis 运行并产生快照的主数据中心发生严重的问题时， 仍然让数据处于安全状态。    </p>
<p>因为很多 Redis 用户都是创业者， 他们没有大把大把的钱可以浪费， 所以下面介绍的都是一些实用又便宜的容灾备份方法：    </p>
<ul>
<li>Amazon S3 ，以及其他类似 S3 的服务，是一个构建灾难备份系统的好地方。 最简单的方法就是将你的每小时或者每日 RDB 备份加密并传送到 S3 。 对数据的加密可以通过 gpg -c 命令来完成（对称加密模式）。 记得把你的密码放到几个不同的、安全的地方去（比如你可以把密码复制给你组织里最重要的人物）。 同时使用多个储存服务来保存数据文件，可以提升数据的安全性。</li>
<li>传送快照可以使用 SCP 来完成（SSH 的组件）。 以下是简单并且安全的传送方法： 买一个离你的数据中心非常远的 VPS ， 装上 SSH ， 创建一个无口令的 SSH 客户端 key ， 并将这个 key 添加到 VPS 的 authorized_keys 文件中， 这样就可以向这个 VPS 传送快照备份文件了。 为了达到最好的数据安全性，至少要从两个不同的提供商那里各购买一个 VPS 来进行数据容灾备份。</li>
<li>需要注意的是， 这类容灾系统如果没有小心地进行处理的话， 是很容易失效的。最低限度下， 你应该在文件传送完毕之后， 检查所传送备份文件的体积和原始快照文件的体积是否相同。 如果你使用的是 VPS ， 那么还可以通过比对文件的 SHA1 校验和来确认文件是否传送完整。  </li>
</ul>
<p>另外， 你还需要一个独立的警报系统， 让它在负责传送备份文件的传送器（transfer）失灵时通知你。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2017/07/19/服务器相关/redis/Redis 持久化/" data-id="cj5knthwx005b3mblzsyxebrs" class="article-share-link" data-share="baidu" data-title="Redis 持久化">分享到</a>
      

      
        <a href="http://yoursite.com/2017/07/19/服务器相关/redis/Redis 持久化/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器相关/redis/事物管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/19/服务器相关/redis/事物管理/" class="article-date">
  <time datetime="2017-07-19T02:09:45.000Z" itemprop="datePublished">2017-07-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/19/服务器相关/redis/事物管理/">事物管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p><code>MULTI</code> 、 <code>EXEC</code> 、 <code>DISCARD</code> 和 <code>WATCH</code> 是 Redis 事务相关的命令。事务可以一次执行多个命令， 并且带有以下两个重要的保证：    </p>
<ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li>
</ul>
<p><code>EXEC</code> 命令负责触发并执行事务中的所有命令：    </p>
<ul>
<li>如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。</li>
<li>另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。  </li>
</ul>
<p>当使用 AOF 方式做持久化的时候， Redis 会使用单个 write(2) 命令将事务写入到磁盘中。<br>然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。    </p>
<p>如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。    </p>
<p>使用redis-check-aof程序可以修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。<br>从 2.2 版本开始，Redis 还可以通过乐观锁（optimistic lock）实现 CAS （check-and-set）操作，具体信息请参考文档的后半部分。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>MULTI 命令用于开启一个事务，它总是返回 OK 。 MULTI 执行之后， 客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行， 而是被放到一个队列中， 当 EXEC命令被调用时， 所有队列中的命令才会被执行。    </p>
<p>另一方面， 通过调用 DISCARD ， 客户端可以清空事务队列， 并放弃执行事务。</p>
<p>以下是一个事务例子， 它原子地增加了 foo 和 bar 两个键的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; MULTI</div><div class="line">OK</div><div class="line">&gt; INCR foo</div><div class="line">QUEUED</div><div class="line">&gt; INCR bar</div><div class="line">QUEUED</div><div class="line">&gt; EXEC</div><div class="line">1) (integer) 1</div><div class="line">2) (integer) 1</div></pre></td></tr></table></figure></p>
<p>EXEC 命令的回复是一个数组， 数组中的每个元素都是执行事务中的命令所产生的回复。 其中， 回复元素的先后顺序和命令发送的先后顺序一致。  </p>
<p>当客户端处于事务状态时， 所有传入的命令都会返回一个内容为 <code>QUEUED</code> 的状态回复（status reply）， 这些被入队的命令将在 EXEC 命令被调用时执行。</p>
<h2 id="事务中的错误"><a href="#事务中的错误" class="headerlink" title="事务中的错误"></a>事务中的错误</h2><p>使用事务时可能会遇上以下两种错误：</p>
<ul>
<li>事务在执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 maxmemory 设置了最大内存限制的话）。</li>
<li>命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。  </li>
</ul>
<p>对于发生在 EXEC 执行之前的错误，客户端以前的做法是检查命令入队所得的返回值：如果命令入队时返回 QUEUED ，那么入队成功；否则，就是入队失败。如果有命令在入队时失败，那么大部分客户端都会停止并取消这个事务。    </p>
<p>不过，从 Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。<br>​<br>在 Redis 2.6.5 以前， Redis 只执行事务中那些入队成功的命令，而忽略那些入队失败的命令。 而新的处理方式则使得在流水线（pipeline）中包含事务变得简单，因为发送事务和读取事务的回复都只需要和服务器进行一次通讯。    </p>
<p>至于那些在 EXEC 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。    </p>
<p>从协议的角度来看这个问题，会更容易理解一些。 以下例子中， LPOP 命令的执行将出错， 尽管调用它的语法是正确的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Trying 127.0.0.1...</div><div class="line">Connected to localhost.</div><div class="line">Escape character is &apos;^]&apos;.</div><div class="line">MULTI</div><div class="line">+OK</div><div class="line">SET a 3</div><div class="line">abc</div><div class="line">+QUEUED</div><div class="line">LPOP a</div><div class="line">+QUEUED</div><div class="line">EXEC</div><div class="line">*2</div><div class="line">+OK</div><div class="line">-ERR Operation against a key holding the wrong kind of value</div></pre></td></tr></table></figure></p>
<p>EXEC 返回两条bulk-string-reply： 第一条是 OK ，而第二条是 -ERR 。 至于怎样用合适的方法来表示事务中的错误， 则是由客户端自己决定的。     </p>
<p>==最重要的是记住这样一条， 即使事务中有某条/某些命令执行失败了， 事务队列中的其他命令仍然会继续执行 —— Redis不会停止执行事务中的命令。==  </p>
<p>以下例子展示的是另一种情况， 当命令在入队时产生错误， 错误会立即被返回给客户端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MULTI</div><div class="line">+OK</div><div class="line">INCR a b c</div><div class="line">-ERR wrong number of arguments for &apos;incr&apos; command</div></pre></td></tr></table></figure></p>
<p>因为调用 INCR 命令的参数格式不正确， 所以这个 INCR 命令入队失败。</p>
<h2 id="为什么-Redis-不支持回滚（roll-back）"><a href="#为什么-Redis-不支持回滚（roll-back）" class="headerlink" title="为什么 Redis 不支持回滚（roll back）"></a>为什么 Redis 不支持回滚（roll back）</h2><p>如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。    </p>
<p>以下是这种做法的优点：</p>
<ul>
<li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li>
<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li>
</ul>
<p>有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 INCR 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 INCR ， 回滚是没有办法处理这些情况的。</p>
<h2 id="放弃事务"><a href="#放弃事务" class="headerlink" title="放弃事务"></a>放弃事务</h2><p>当执行 DISCARD 命令时， 事务会被放弃， 事务队列会被清空， 并且客户端会从事务状态中退出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; SET foo 1</div><div class="line">OK</div><div class="line">&gt; MULTI</div><div class="line">OK</div><div class="line">&gt; INCR foo</div><div class="line">QUEUED</div><div class="line">&gt; DISCARD</div><div class="line">OK</div><div class="line">&gt; GET foo</div><div class="line">&quot;1&quot;</div></pre></td></tr></table></figure></p>
<h2 id="使用-check-and-set-操作实现乐观锁"><a href="#使用-check-and-set-操作实现乐观锁" class="headerlink" title="使用 check-and-set 操作实现乐观锁"></a>使用 check-and-set 操作实现乐观锁</h2><p>WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。</p>
<p>被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回nil-reply来表示事务已经失败。  </p>
<p>举个例子， 假设我们需要原子性地为某个值进行增 1 操作（假设 INCR 不存在）。<br>首先我们可能会这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val = GET mykey</div><div class="line">val = val + 1</div><div class="line">SET mykey $val</div></pre></td></tr></table></figure></p>
<p>上面的这个实现在只有一个客户端的时候可以执行得很好。 但是， 当多个客户端同时对同一个键进行这样的操作时， 就会产生竞争条件。举个例子， 如果客户端 A 和 B 都读取了键原来的值， 比如 10 ， 那么两个客户端都会将键的值设为 11 ， 但正确的结果应该是 12 才对。  </p>
<p>有了 WATCH ， 我们就可以轻松地解决这类问题了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">WATCH mykey</div><div class="line">val = GET mykey</div><div class="line">val = val + 1</div><div class="line">MULTI</div><div class="line">SET mykey $val</div><div class="line">EXEC</div></pre></td></tr></table></figure></p>
<p>使用上面的代码， 如果在 WATCH 执行之后， EXEC 执行之前， 有其他客户端修改了 mykey 的值， 那么当前客户端的事务就会失败。 程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞为止。  </p>
<p>这种形式的锁被称作乐观锁， 它是一种非常强大的锁机制。 并且因为大多数情况下， 不同的客户端会访问不同的键， 碰撞的情况一般都很少， 所以通常并不需要进行重试。</p>
<h2 id="了解-WATCH"><a href="#了解-WATCH" class="headerlink" title="了解 WATCH"></a>了解 WATCH</h2><p>WATCH 使得 EXEC 命令需要有条件地执行： 事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。 <a href="http://code.google.com/p/redis/issues/detail?id=270" target="_blank" rel="external">了解更多-&gt;</a></p>
<p>WATCH 命令可以被调用多次。 对键的监视从 WATCH 执行之后开始生效， 直到调用 EXEC 为止。<br>用户还可以在单个 WATCH 命令中监视任意多个键， 就像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">redis&gt; WATCH key1 key2 key3</div><div class="line">OK</div></pre></td></tr></table></figure></p>
<p>当 EXEC 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消。<br>另外， 当客户端断开连接时， 该客户端对键的监视也会被取消。<br>使用无参数的 UNWATCH 命令可以手动取消对所有键的监视。 对于一些需要改动多个键的事务， 有时候程序需要同时对多个键进行加锁， 然后检查这些键的当前值是否符合程序的要求。 当值达不到要求时， 就可以使用 UNWATCH 命令来取消目前对键的监视， 中途放弃这个事务， 并等待事务的下次尝试。</p>
<h2 id="使用-WATCH-实现-ZPOP"><a href="#使用-WATCH-实现-ZPOP" class="headerlink" title="使用 WATCH 实现 ZPOP"></a>使用 WATCH 实现 ZPOP</h2><p>WATCH 可以用于创建 Redis 没有内置的原子操作。举个例子， 以下代码实现了原创的 ZPOP 命令， 它可以原子地弹出有序集合中分值（score）最小的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">WATCH zset</div><div class="line">element = ZRANGE zset 0 0</div><div class="line">MULTI</div><div class="line">ZREM zset element</div><div class="line">EXEC</div></pre></td></tr></table></figure>
<p>程序只要重复执行这段代码， 直到 EXEC 的返回值不是nil-reply回复即可。    </p>
<h2 id="Redis-脚本和事务"><a href="#Redis-脚本和事务" class="headerlink" title="Redis 脚本和事务"></a>Redis 脚本和事务</h2><p>从定义上来说， Redis 中的脚本本身就是一种事务， 所以任何在事务里可以完成的事， 在脚本里面也能完成。 并且一般来说， 使用脚本要来得更简单，并且速度更快。    </p>
<p>因为脚本功能是 Redis 2.6 才引入的， 而事务功能则更早之前就存在了， 所以 Redis 才会同时存在两种处理事务的方法。<br>不过我们并不打算在短时间内就移除事务功能， 因为事务提供了一种即使不使用脚本， 也可以避免竞争条件的方法， 而且事务本身的实现并不复杂。    </p>
<p>不过在不远的将来， 可能所有用户都会只使用脚本来实现事务也说不定。 如果真的发生这种情况的话， 那么我们将废弃并最终移除事务功能。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2017/07/19/服务器相关/redis/事物管理/" data-id="cj5knthwy005d3mbl0wtpfv0i" class="article-share-link" data-share="baidu" data-title="事物管理">分享到</a>
      

      
        <a href="http://yoursite.com/2017/07/19/服务器相关/redis/事物管理/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器相关/redis/set get getset append命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/19/服务器相关/redis/set get getset append命令/" class="article-date">
  <time datetime="2017-07-19T02:09:45.000Z" itemprop="datePublished">2017-07-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/19/服务器相关/redis/set get getset append命令/">set get getset append命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SET-key-value-EX-seconds-PX-milliseconds-NX-XX"><a href="#SET-key-value-EX-seconds-PX-milliseconds-NX-XX" class="headerlink" title="SET key value [EX seconds] [PX milliseconds] [NX|XX]"></a>SET key value [EX seconds] [PX milliseconds] [NX|XX]</h1><p>将键key设定为指定的“字符串”值。<br>如果key    已经保存了一个值，那么这个操作会直接覆盖原来的值，并且忽略原始类型。<br>当set命令执行成功之后，之前设置的过期时间都将失效</p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><ul>
<li>EX seconds – 设置键key的过期时间，单位时秒</li>
<li>PX milliseconds – 设置键key的过期时间，单位时毫秒</li>
<li>NX – 只有键key不存在的时候才会设置key的值</li>
<li>XX – 只有键key存在的时候才会设置key的值</li>
</ul>
<p><strong>注意</strong>: 由于SET命令加上选项已经可以完全取代SETNX, SETEX, PSETEX的功能，所以在将来的版本中，redis可能会不推荐使用并且最终抛弃这几个命令。</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>simple-string-reply:如果SET命令正常执行那么回返回OK，否则如果加了NX 或者 XX选项，但是没有设置条件。那么会返回nil。</p>
<h1 id="GET-key"><a href="#GET-key" class="headerlink" title="GET key"></a>GET key</h1><blockquote>
<p>起始版本：1.0.0<br>  时间复杂度：O(1)</p>
</blockquote>
<p>返回key的value。如果key不存在，返回特殊值nil。如果key的value不是string，就返回错误，因为GET只处理string类型的values。</p>
<h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>simple-string-reply:key对应的value，或者nil（key不存在时）</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">redis&gt; GET nonexisting</div><div class="line">(nil)</div><div class="line">redis&gt; SET mykey &quot;Hello&quot;</div><div class="line">OK</div><div class="line">redis&gt; GET mykey</div><div class="line">&quot;Hello&quot;</div><div class="line">redis&gt;</div></pre></td></tr></table></figure>
<h1 id="GETSET-key-value"><a href="#GETSET-key-value" class="headerlink" title="GETSET key value"></a>GETSET key value</h1><blockquote>
<p>起始版本：1.0.0<br>时间复杂度：O(1)</p>
</blockquote>
<p>自动将key对应到value并且返回原来key对应的value。如果key存在但是对应的value不是字符串，就返回错误。 </p>
<p>设计模式:<br>GETSET可以和INCR一起使用实现支持重置的计数功能。举个例子：每当有事件发生的时候，一段程序都会调用INCR给key mycounter加1，但是有时我们需要获取计数器的值，并且自动将其重置为0。这可以通过GETSET mycounter “0”来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">INCR mycounter</div><div class="line">GETSET mycounter &quot;0&quot;</div><div class="line">GET mycounter</div></pre></td></tr></table></figure></p>
<h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><p>bulk-string-reply: 返回之前的旧值，如果之前Key不存在将返回nil。</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">redis&gt; INCR mycounter</div><div class="line">(integer) 1</div><div class="line">redis&gt; GETSET mycounter &quot;0&quot;</div><div class="line">&quot;1&quot;</div><div class="line">redis&gt; GET mycounter</div><div class="line">&quot;0&quot;</div></pre></td></tr></table></figure>
<h1 id="APPEND-key-value"><a href="#APPEND-key-value" class="headerlink" title="APPEND key value"></a>APPEND key value</h1><blockquote>
<p>起始版本：2.0.0<br>时间复杂度：O(1)。均摊时间复杂度是O(1)， 因为redis用的动态字符串的库在每次分配空间的时候会增加一倍的可用空闲空间，所以在添加的value较小而且已经存在的 value是任意大小的情况下，均摊时间复杂度是O(1) 。</p>
</blockquote>
<p>如果 key 已经存在，并且值为字符串，那么这个命令会把 value 追加到原来值（value）的结尾。 如果 key 不存在，那么它将首先创建一个空字符串的key，再执行追加操作，这种情况 APPEND 将类似于 SET 操作。</p>
<h3 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h3><p>Integer reply：返回append后字符串值（value）的长度。</p>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">redis&gt; EXISTS mykey</div><div class="line">(integer) 0</div><div class="line">redis&gt; APPEND mykey &quot;Hello&quot;</div><div class="line">(integer) 5</div><div class="line">redis&gt; APPEND mykey &quot; World&quot;</div><div class="line">(integer) 11</div><div class="line">redis&gt; GET mykey</div><div class="line">&quot;Hello World&quot;</div><div class="line">redis&gt;</div></pre></td></tr></table></figure>
<h3 id="模式：节拍序列-Time-series"><a href="#模式：节拍序列-Time-series" class="headerlink" title="模式：节拍序列(Time series)"></a>模式：节拍序列(Time series)</h3><p>APPEND 命令可以用来连接一系列固定长度的样例,与使用列表相比这样更加紧凑. 通常会用来记录节拍序列. 每收到一个新的节拍样例就可以这样记录:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">APPEND timeseries &quot;fixed-size sample&quot;</div></pre></td></tr></table></figure></p>
<p>在节拍序列里, 可以很容易地访问序列中的每个元素:</p>
<ul>
<li><code>STRLEN</code> 可以用来计算样例个数.</li>
<li><code>GETRANGE</code> 允许随机访问序列中的各个元素. 如果序列中有明确的节拍信息, 在Redis 2.6中就可以使用GETRANGE配合Lua脚本来实现一个二分查找算法.</li>
<li><code>SETRANGE</code> 可以用来覆写已有的节拍序列.</li>
</ul>
<p>该模式的局限在于只能做追加操作. Redis目前缺少剪裁字符串的命令, 所以无法方便地把序列剪裁成指定的尺寸. 但是, 节拍序列在空间占用上效率极好.</p>
<p>小贴士: 在键值中组合Unix时间戳, 可以在构建一系列相关键值时缩短键值长度,更优雅地分配Redis实例.</p>
<p>使用定长字符串进行温度采样的例子(在实际使用时,采用二进制格式会更好).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">redis&gt; APPEND ts &quot;0043&quot;</div><div class="line">(integer) 4</div><div class="line">redis&gt; APPEND ts &quot;0035&quot;</div><div class="line">(integer) 8</div><div class="line">redis&gt; GETRANGE ts 0 3</div><div class="line">&quot;0043&quot;</div><div class="line">redis&gt; GETRANGE ts 4 7</div><div class="line">&quot;0035&quot;</div><div class="line">redis&gt;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2017/07/19/服务器相关/redis/set get getset append命令/" data-id="cj5knthwz005g3mblv3wq10ik" class="article-share-link" data-share="baidu" data-title="set get getset append命令">分享到</a>
      

      
        <a href="http://yoursite.com/2017/07/19/服务器相关/redis/set get getset append命令/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器相关/redis/安装(Mac版)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/19/服务器相关/redis/安装(Mac版)/" class="article-date">
  <time datetime="2017-07-19T02:09:45.000Z" itemprop="datePublished">2017-07-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/19/服务器相关/redis/安装(Mac版)/">安装(Mac版)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brew search redis</div><div class="line">brew install redis</div></pre></td></tr></table></figure>
<p>安装后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">To have launchd start redis at login:</div><div class="line">  ln -sfv /usr/local/opt/redis/*.plist ~/Library/LaunchAgents</div><div class="line">Then to load redis now:</div><div class="line">  launchctl load ~/Library/LaunchAgents/homebrew.mxcl.redis.plist</div><div class="line">Or, if you don&apos;t want/need launchctl, you can just run:</div><div class="line">  redis-server /usr/local/etc/redis.conf</div><div class="line">==&gt; Summary</div><div class="line">🍺  /usr/local/Cellar/redis/3.0.7: 9 files, 876.3K</div></pre></td></tr></table></figure></p>
<p>Redis相关可执行文件的主要作用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">（1）redis-server  -------Redis服务器</div><div class="line">（2）redis-cli         -------Redis命令行客户端</div><div class="line">（3）redis-benchmark ---------Redis性能测试工具</div><div class="line">（4）redis-check-aof ----------AOF文件修复工具</div><div class="line">（5）redis-check-dump --------RDB文件检查工具</div></pre></td></tr></table></figure></p>
<p>开机自动启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.redis.plist</div></pre></td></tr></table></figure></p>
<p>取消开机自动启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.redis.plist</div></pre></td></tr></table></figure></p>
<p>启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">进入/usr/local/Cellar/redis/3.0.7/bin</div><div class="line">指定conf启动：</div><div class="line">./redis-server /usr/local/etc/redis.conf</div></pre></td></tr></table></figure></p>
<p>访问服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">进入/usr/local/Cellar/redis/3.0.7/bin</div><div class="line">./redis-cli -h 127.0.0.1 -p 6379</div><div class="line"></div><div class="line">输入：</div><div class="line">ping 返回PONG即为连接服务器成功</div><div class="line"></div><div class="line">设置值:</div><div class="line">set aa aa</div><div class="line">获取值：</div><div class="line">get aa</div><div class="line">退出：</div><div class="line">exit</div></pre></td></tr></table></figure></p>
<p>停止服务：<br>考虑到redis正在将内存中的数据拷贝到硬盘，所以强行终止进程可能导致数据丢失，所以争取的方式之一是通过客户端发送 shutdown命令，服务器在收到shutdown命令后，先断开所有客户端的连接，再根据配置持久化数据，再关闭Redis服务<br>redis可以妥善处理sigterm信号，多以Kill Redis的进程也可以关闭redis，效果金额发送 shutdown命令有同样的效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">进入/usr/local/Cellar/redis/3.0.7/bin</div><div class="line">./redis-cli -p 6379 shutdown</div></pre></td></tr></table></figure></p>
<p>配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">#修改为守护模式</div><div class="line">daemonize yes</div><div class="line">#设置进程锁文件</div><div class="line">pidfile /usr/local/redis/redis.pid</div><div class="line">#端口</div><div class="line">port 6379</div><div class="line">#客户端超时时间</div><div class="line">timeout 300</div><div class="line">#日志级别</div><div class="line">loglevel debug</div><div class="line">#日志文件位置</div><div class="line">logfile /usr/local/redis/log-redis.log</div><div class="line">#设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id</div><div class="line">databases 8</div><div class="line">##指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</div><div class="line">#save &lt;seconds&gt; &lt;changes&gt;</div><div class="line">#Redis默认配置文件中提供了三个条件：</div><div class="line">save 900 1</div><div class="line">save 300 10</div><div class="line">save 60 10000</div><div class="line">#指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，</div><div class="line">#可以关闭该#选项，但会导致数据库文件变的巨大</div><div class="line">rdbcompression yes</div><div class="line">#指定本地数据库文件名</div><div class="line">dbfilename dump.rdb</div><div class="line">#指定本地数据库路径</div><div class="line">dir /usr/local/redis/db/</div><div class="line">#指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能</div><div class="line">#会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有</div><div class="line">#的数据会在一段时间内只存在于内存中</div><div class="line">appendonly no</div><div class="line">#指定更新日志条件，共有3个可选值：</div><div class="line">#no：表示等操作系统进行数据缓存同步到磁盘（快）</div><div class="line">#always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）</div><div class="line">#everysec：表示每秒同步一次（折衷，默认值）</div><div class="line">appendfsync everysec</div><div class="line">&lt;/changes&gt;&lt;/seconds&gt;&lt;/dbid&gt;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2017/07/19/服务器相关/redis/安装(Mac版)/" data-id="cj5knthwz005i3mblsfd2g8nz" class="article-share-link" data-share="baidu" data-title="安装(Mac版)">分享到</a>
      

      
        <a href="http://yoursite.com/2017/07/19/服务器相关/redis/安装(Mac版)/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器相关/redis/常用原子方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/19/服务器相关/redis/常用原子方法/" class="article-date">
  <time datetime="2017-07-19T02:09:45.000Z" itemprop="datePublished">2017-07-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/19/服务器相关/redis/常用原子方法/">常用原子方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SETEX-key-seconds-value"><a href="#SETEX-key-seconds-value" class="headerlink" title="SETEX key seconds value"></a>SETEX key seconds value</h1><blockquote>
<p>起始版本：2.0.0<br>  时间复杂度：O(1)</p>
</blockquote>
<p>设置key对应字符串value，并且设置key在给定的seconds时间之后超时过期。这个命令等效于执行下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SET mykey value</div><div class="line">EXPIRE mykey seconds</div></pre></td></tr></table></figure></p>
<p>==SETEX是原子的==，也可以通过把上面两个命令放到MULTI/EXEC块中执行的方式重现。相比连续执行上面两个命令，它更快，因为当Redis当做缓存使用时，这个操作更加常用。</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">simple-string-reply</div></pre></td></tr></table></figure>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">redis&gt; SETEX mykey 10 “Hello” </div><div class="line">OK</div><div class="line">redis&gt; TTL mykey </div><div class="line">(integer) 10</div><div class="line">redis&gt; GET mykey </div><div class="line">“Hello”</div></pre></td></tr></table></figure>
<h1 id="PSETEX-key-milliseconds-value"><a href="#PSETEX-key-milliseconds-value" class="headerlink" title="PSETEX key milliseconds value"></a>PSETEX key milliseconds value</h1><blockquote>
<p>起始版本：2.6.0<br>时间复杂度：O(1)</p>
</blockquote>
<p>PSETEX和SETEX一样，唯一的区别是到期时间以毫秒为单位,而不是秒。</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">redis&gt; PSETEX mykey 1000 &quot;Hello&quot;</div><div class="line">OK</div><div class="line">redis&gt; PTTL mykey</div><div class="line">(integer) 999</div><div class="line">redis&gt; GET mykey</div><div class="line">&quot;Hello&quot;</div><div class="line">redis&gt;</div></pre></td></tr></table></figure>
<h1 id="MSET"><a href="#MSET" class="headerlink" title="MSET"></a>MSET</h1><blockquote>
<p>起始版本：1.0.1<br>时间复杂度：O(N) where N is the number of keys to set.</p>
</blockquote>
<p>对应给定的keys到他们相应的values上。MSET会用新的value替换已经存在的value，就像普通的SET命令一样。如果你不想覆盖已经存在的values，请参看命令MSETNX。<br>==MSET是原子的==，所以所有给定的keys是一次性set的。客户端不可能看到这种一部分keys被更新而另外的没有改变的情况。</p>
<h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>simple-string-reply：总是OK，因为MSET不会失败。</p>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">redis&gt; MSET key1 &quot;Hello&quot; key2 &quot;World&quot;</div><div class="line">OK</div><div class="line">redis&gt; GET key1</div><div class="line">&quot;Hello&quot;</div><div class="line">redis&gt; GET key2</div><div class="line">&quot;World&quot;</div></pre></td></tr></table></figure>
<h1 id="MGET-key-key-…"><a href="#MGET-key-key-…" class="headerlink" title="MGET key [key …]"></a>MGET key [key …]</h1><blockquote>
<p>起始版本：1.0.0<br>时间复杂度：O(N) where N is the number of keys to retrieve.</p>
</blockquote>
<p>返回所有指定的key的value。对于每个不对应string或者不存在的key，都返回特殊值nil。正因为此，这个操作从来不会失败。</p>
<h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><p>array-reply: 指定的key对应的values的list</p>
<h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子:"></a>例子:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">redis&gt; SET key1 &quot;Hello&quot;</div><div class="line">OK</div><div class="line">redis&gt; SET key2 &quot;World&quot;</div><div class="line">OK</div><div class="line">redis&gt; MGET key1 key2 nonexisting</div><div class="line">1) &quot;Hello&quot;</div><div class="line">2) &quot;World&quot;</div><div class="line">3) (nil)</div></pre></td></tr></table></figure>
<h1 id="MSETNX-key-value-key-value-…"><a href="#MSETNX-key-value-key-value-…" class="headerlink" title="MSETNX key value [key value …]"></a>MSETNX key value [key value …]</h1><blockquote>
<p>起始版本：1.0.1<br>时间复杂度：O(N) where N is the number of keys to set.</p>
</blockquote>
<p>对应给定的keys到他们相应的values上。只要有一个key已经存在，MSETNX一个操作都不会执行。由于这种特性，MSETNX可以实现要么所有的操作都成功，要么一个都不执行，这样可以用来设置不同的key，来表示一个唯一的对象的不同字段。<br>==MSETNX是原子的==，所以所有给定的keys是一次性set的。客户端不可能看到这种一部分keys被更新而另外的没有改变的情况。</p>
<h3 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h3><p>integer-reply，只有以下两种值：</p>
<ul>
<li><code>1</code> 如果所有的key被set</li>
<li><code>0</code> 如果没有key被set(至少其中有一个key是存在的)</li>
</ul>
<h3 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">redis&gt; MSETNX key1 &quot;Hello&quot; key2 &quot;there&quot;</div><div class="line">(integer) 1</div><div class="line">redis&gt; MSETNX key2 &quot;there&quot; key3 &quot;world&quot;</div><div class="line">(integer) 0</div><div class="line">redis&gt; MGET key1 key2 key3</div><div class="line">1) &quot;Hello&quot;</div><div class="line">2) &quot;there&quot;</div><div class="line">3) (nil)</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2017/07/19/服务器相关/redis/常用原子方法/" data-id="cj5knthx0005l3mbl3zos4q0m" class="article-share-link" data-share="baidu" data-title="常用原子方法">分享到</a>
      

      
        <a href="http://yoursite.com/2017/07/19/服务器相关/redis/常用原子方法/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器相关/redis/常用非原子方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/19/服务器相关/redis/常用非原子方法/" class="article-date">
  <time datetime="2017-07-19T02:09:45.000Z" itemprop="datePublished">2017-07-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/19/服务器相关/redis/常用非原子方法/">常用非原子方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SETNX-key-value"><a href="#SETNX-key-value" class="headerlink" title="SETNX key value"></a>SETNX key value</h1><blockquote>
<p>起始版本：1.0.0<br>  时间复杂度：O(1)</p>
</blockquote>
<p>将key设置值为value，如果key不存在，这种情况下等同SET命令。 当key存在时，什么也不做。SETNX是”SET if Not eXists”的简写</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Integer reply, 特定值:</div><div class="line">1 如果key被设置了</div><div class="line">0 如果key没有被设置</div></pre></td></tr></table></figure>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">redis&gt; SETNX mykey &quot;Hello&quot;</div><div class="line">(integer) 1</div><div class="line">redis&gt; SETNX mykey &quot;World&quot;</div><div class="line">(integer) 0</div><div class="line">redis&gt; GET mykey</div><div class="line">&quot;Hello&quot;</div><div class="line">redis&gt;</div></pre></td></tr></table></figure>
<h1 id="STRLEN-key"><a href="#STRLEN-key" class="headerlink" title="STRLEN key"></a>STRLEN key</h1><blockquote>
<p>起始版本：2.2.0<br>  时间复杂度：O(1)</p>
</blockquote>
<p>返回key的string类型value的长度。如果key对应的非string类型，就返回错误。</p>
<h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>integer-reply：key对应的字符串value的长度，或者0（key不存在）</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">redis&gt; SET mykey &quot;Hello world&quot;</div><div class="line">OK</div><div class="line">redis&gt; STRLEN mykey</div><div class="line">(integer) 11</div><div class="line">redis&gt; STRLEN nonexisting</div><div class="line">(integer) 0</div><div class="line">redis&gt;</div></pre></td></tr></table></figure>
<h1 id="SETRANGE-key-offset-value"><a href="#SETRANGE-key-offset-value" class="headerlink" title="SETRANGE key offset value"></a>SETRANGE key offset value</h1><blockquote>
<p>起始版本：2.2.0<br>时间复杂度：O(1), not counting the time taken to copy the new string in place. Usually, this string is very small so the amortized complexity is O(1). Otherwise, complexity is O(M) with M being the length of the value argument.</p>
</blockquote>
<p>这个命令的作用是覆盖key对应的string的一部分，从指定的offset处开始，覆盖value的长度。如果offset比当前key对应string还要长，那这个string后面就补0以达到offset。不存在的keys被认为是空字符串，所以这个命令可以确保key有一个足够大的字符串，能在offset处设置value。<br>注意，offset最大可以是229-1(536870911),因为redis字符串限制在512M大小。如果你需要超过这个大小，你可以用多个keys。</p>
<h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><p>integer-reply：该命令修改后的字符串长度</p>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>基本使用方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">redis&gt; SET key1 &quot;Hello World&quot;</div><div class="line">OK</div><div class="line">redis&gt; SETRANGE key1 6 &quot;Redis&quot;</div><div class="line">(integer) 11</div><div class="line">redis&gt; GET key1</div><div class="line">&quot;Hello Redis&quot;</div><div class="line">redis&gt;</div></pre></td></tr></table></figure></p>
<p>补0的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">redis&gt; SETRANGE key2 6 &quot;Redis&quot;</div><div class="line">(integer) 11</div><div class="line">redis&gt; GET key2</div><div class="line">&quot;\x00\x00\x00\x00\x00\x00Redis&quot;</div><div class="line">redis&gt;</div></pre></td></tr></table></figure></p>
<h1 id="GETRANGE-key-start-end"><a href="#GETRANGE-key-start-end" class="headerlink" title="GETRANGE key start end"></a>GETRANGE key start end</h1><blockquote>
<p>起始版本：2.4.0<br>时间复杂度：O(N) N是字符串长度，复杂度由最终返回长度决定，但由于通过一个字符串创建子字符串是很容易的，它可以被认为是O(1)。</p>
</blockquote>
<p>==警告==：这个命令是被改成GETRANGE的，在小于2.0的Redis版本中叫SUBSTR。 返回key对应的字符串value的子串，这个子串是由start和end位移决定的（两者都在string内）。可以用负的位移来表示从string尾部开始数的下标。所以-1就是最后一个字符，-2就是倒数第二个，以此类推。  </p>
<p>这个函数处理超出范围的请求时，都把结果限制在string内。</p>
<h3 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h3><p>bulk-reply</p>
<h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">redis&gt; SET mykey &quot;This is a string&quot;</div><div class="line">OK</div><div class="line">redis&gt; GETRANGE mykey 0 3</div><div class="line">&quot;This&quot;</div><div class="line">redis&gt; GETRANGE mykey -3 -1</div><div class="line">&quot;ing&quot;</div><div class="line">redis&gt; GETRANGE mykey 0 -1</div><div class="line">&quot;This is a string&quot;</div><div class="line">redis&gt; GETRANGE mykey 10 100</div><div class="line">&quot;string&quot;</div><div class="line">redis&gt;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2017/07/19/服务器相关/redis/常用非原子方法/" data-id="cj5knthx1005m3mbl4uydn485" class="article-share-link" data-share="baidu" data-title="常用非原子方法">分享到</a>
      

      
        <a href="http://yoursite.com/2017/07/19/服务器相关/redis/常用非原子方法/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器相关/redis/文档（持续更新中）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/19/服务器相关/redis/文档（持续更新中）/" class="article-date">
  <time datetime="2017-07-19T02:09:45.000Z" itemprop="datePublished">2017-07-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/19/服务器相关/redis/文档（持续更新中）/">文档（持续更新中）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="中文官方文档"><a href="#中文官方文档" class="headerlink" title="中文官方文档"></a>中文官方文档</h2><p><a href="http://www.redis.cn/" target="_blank" rel="external">http://www.redis.cn/</a></p>
<h2 id="命令大全"><a href="#命令大全" class="headerlink" title="命令大全"></a>命令大全</h2><p><a href="http://www.redis.cn/commands.html" target="_blank" rel="external">http://www.redis.cn/commands.html</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2017/07/19/服务器相关/redis/文档（持续更新中）/" data-id="cj5knthx2005o3mbl8h3agbge" class="article-share-link" data-share="baidu" data-title="文档（持续更新中）">分享到</a>
      

      
        <a href="http://yoursite.com/2017/07/19/服务器相关/redis/文档（持续更新中）/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器相关/redis/系统命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/19/服务器相关/redis/系统命令/" class="article-date">
  <time datetime="2017-07-19T02:09:45.000Z" itemprop="datePublished">2017-07-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/19/服务器相关/redis/系统命令/">系统命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MONITOR"><a href="#MONITOR" class="headerlink" title="MONITOR"></a>MONITOR</h1><p>MONITOR 是一个调试命令，返回服务器处理的每一个命令，它能帮助我们了解在数据库上发生了什么操作，可以通过redis-cli和telnet命令使用.</p>
<p>停止：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ctrl+c</div></pre></td></tr></table></figure></p>
<p>==注意：MONITOR会引起性能消耗==</p>
<h1 id="QUIT"><a href="#QUIT" class="headerlink" title="QUIT"></a>QUIT</h1><p>客户端请求与服务器关闭连接。连接将会尽可能快的将未完成的客户端请求完成处理。    </p>
<h1 id="SELECT-index"><a href="#SELECT-index" class="headerlink" title="SELECT index"></a>SELECT index</h1><p>选择一个数据库，下标值从0开始，一个新连接默认连接的数据库是DB0。</p>
<h1 id="ECHO-message"><a href="#ECHO-message" class="headerlink" title="ECHO message"></a>ECHO message</h1><p>输出信息</p>
<h1 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h1><p>如果后面没有参数时返回PONG，否则会返回后面带的参数。<br>这个命令经常用来测试一个连接是否还是可用的，或者用来测试一个连接的延时。<br>如果客户端处于频道订阅模式下，它将是一个multi-bulk返回，第一次时返回”pong”，之后返回空（empty bulk），除非命令后面更随了参数。</p>
<h1 id="DBSIZE"><a href="#DBSIZE" class="headerlink" title="DBSIZE"></a>DBSIZE</h1><p>返回当前数据里面keys的数量。</p>
<h1 id="FLUSHALL"><a href="#FLUSHALL" class="headerlink" title="FLUSHALL"></a>FLUSHALL</h1><p>删除所有数据库里面的所有数据，注意不是当前数据库，而是所有数据库。<br>这个命令永远不会出现失败。<br>这个操作的时间复杂度是O(N),N是数据库的数量。</p>
<h1 id="FLUSHDB"><a href="#FLUSHDB" class="headerlink" title="FLUSHDB"></a>FLUSHDB</h1><p>删除当前数据库里面的所有数据。<br>这个命令永远不会出现失败。<br>这个操作的时间复杂度是O(N),N是当前数据库的keys数量。</p>
<h1 id="SAVE"><a href="#SAVE" class="headerlink" title="SAVE"></a>SAVE</h1><p>SAVE 命令执行一个同步操作，以RDB文件的方式保存所有数据的快照 很少在生产环境直接使用SAVE 命令，因为它会阻塞所有的客户端的请求，可以使用BGSAVE 命令代替. 如果在BGSAVE命令的保存数据的子进程发生错误的时,用 SAVE命令保存最新的数据是最后的手段,详细的说明请参考持久化文档</p>
<h3 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h3><p>simple-string-reply: 命令成功返回OK.</p>
<h1 id="BGSAVE"><a href="#BGSAVE" class="headerlink" title="BGSAVE"></a>BGSAVE</h1><p>后台保存DB。会立即返回 OK 状态码。 Redis forks, 父进程继续提供服务以供客户端调用，子进程将DB数据保存到磁盘然后退出。如果操作成功，可以通过客户端命令LASTSAVE来检查操作结果。</p>
<h1 id="INFO-section"><a href="#INFO-section" class="headerlink" title="INFO [section]"></a>INFO [section]</h1><p>INFO命令以一种易于理解和阅读的格式，返回关于Redis服务器的各种信息和统计数值。<br>通过给定可选的参数 section ，可以让命令只返回某一部分的信息:</p>
<ul>
<li>server: Redis服务器的一般信息</li>
<li>clients: 客户端的连接部分</li>
<li>memory: 内存消耗相关信息</li>
<li>persistence: RDB和AOF相关信息</li>
<li>stats: 一般统计</li>
<li>replication: 主/从复制信息</li>
<li>cpu: 统计CPU的消耗</li>
<li>commandstats: Redis命令统计</li>
<li>cluster: Redis集群信息</li>
<li>keyspace: 数据库的相关统计<br>它也可以采取以下值:</li>
<li>all: 返回所有信息</li>
<li>default: 值返回默认设置的信息<br>如果没有使用任何参数时，默认为default。</li>
</ul>
<h1 id="CLIENT-LIST"><a href="#CLIENT-LIST" class="headerlink" title="CLIENT LIST"></a>CLIENT LIST</h1><p>Redis CLIENT LIST命令用于返回所有连接到服务器的客户端信息和统计数据。</p>
<h4 id="返回-1"><a href="#返回-1" class="headerlink" title="返回"></a>返回</h4><p>bulk-string-reply: 一个独特的字符串，格式如下：</p>
<ul>
<li>每个已连接客户端对应一行（以 LF 分割）</li>
<li>每行字符串由一系列 属性=值（property=value） 形式的域组成，每个域之间以空格分开。  </li>
</ul>
<p>下面是各字段的含义：</p>
<ul>
<li>id: 唯一的64位的客户端ID(Redis 2.8.12加入)。</li>
<li>addr: 客户端的地址和端口</li>
<li>fd: 套接字所使用的文件描述符</li>
<li>age: 以秒计算的已连接时长</li>
<li>idle: 以秒计算的空闲时长</li>
<li>flags: 客户端 flag</li>
<li>db: 该客户端正在使用的数据库 ID</li>
<li>sub: 已订阅频道的数量</li>
<li>psub: 已订阅模式的数量</li>
<li>multi: 在事务中被执行的命令数量</li>
<li>qbuf: 查询缓冲区的长度（字节为单位， 0 表示没有分配查询缓冲区）</li>
<li>qbuf-free: 查询缓冲区剩余空间的长度（字节为单位， 0 表示没有剩余空间）</li>
<li>obl: 输出缓冲区的长度（字节为单位， 0 表示没有分配输出缓冲区）</li>
<li>oll: 输出列表包含的对象数量（当输出缓冲区没有剩余空间时，命令回复会以字符串对象的形式被入队到这个队列里）</li>
<li>omem: 输出缓冲区和输出列表占用的内存总量</li>
<li>events: 文件描述符事件</li>
<li>cmd: 最近一次执行的命令</li>
</ul>
<p>客户端 flag 可以由以下部分组成：</p>
<ul>
<li>O: 客户端是 MONITOR 模式下的附属节点（slave）</li>
<li>S: 客户端是一般模式下（normal）的附属节点</li>
<li>M: 客户端是主节点（master）</li>
<li>x: 客户端正在执行事务</li>
<li>b: 客户端正在等待阻塞事件</li>
<li>i: 客户端正在等待 VM I/O 操作（已废弃）</li>
<li>d: 一个受监视（watched）的键已被修改， EXEC 命令将失败</li>
<li>c: 在将回复完整地写出之后，关闭链接</li>
<li>u: 客户端未被阻塞（unblocked）</li>
<li>U: 通过Unix套接字连接的客户端</li>
<li>r: 客户端是只读模式的集群节点</li>
<li>A: 尽可能快地关闭连接</li>
<li>N: 未设置任何 flag</li>
</ul>
<p>文件描述符事件可以是：</p>
<ul>
<li>r: 客户端套接字（在事件 loop 中）是可读的（readable）</li>
<li>w: 客户端套接字（在事件 loop 中）是可写的（writeable）</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2017/07/19/服务器相关/redis/系统命令/" data-id="cj5knthx3005p3mbl6q8dgovc" class="article-share-link" data-share="baidu" data-title="系统命令">分享到</a>
      

      
        <a href="http://yoursite.com/2017/07/19/服务器相关/redis/系统命令/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器相关/resin/热部署配置" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/19/服务器相关/resin/热部署配置/" class="article-date">
  <time datetime="2017-07-19T02:09:45.000Z" itemprop="datePublished">2017-07-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/resin/">resin</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/19/服务器相关/resin/热部署配置/">热部署配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;host id=&quot;&quot; root-directory=&quot;.&quot;&gt;</div><div class="line">     &lt;host-alias&gt;test.com&lt;/host-alias&gt;</div><div class="line">     &lt;web-app id=&quot;/&quot; root-directory=&quot;D:\test_space\maven-demo\target\maven-demo&quot;&gt;</div><div class="line">         &lt;class-loader&gt;</div><div class="line">             &lt;compiling-loader path=&quot;D:\test_space\maven-demo\target\classes&quot; /&gt;</div><div class="line">             &lt;library-loader path=&quot;WEB-INF/lib&quot; /&gt;</div><div class="line">         &lt;/class-loader&gt;</div><div class="line">     &lt;/web-app&gt;</div><div class="line">&lt;/host&gt;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2017/07/19/服务器相关/resin/热部署配置/" data-id="cj5knthx4005r3mbld2eqb5gq" class="article-share-link" data-share="baidu" data-title="热部署配置">分享到</a>
      

      
        <a href="http://yoursite.com/2017/07/19/服务器相关/resin/热部署配置/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/8/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/10/">下一页 &raquo;</a>
  </nav>
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Eclipse/">Eclipse</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Github/">Github</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">27</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Cookie/">Cookie</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JavaMail/">JavaMail</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/安全相关/">安全相关</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/数据类型/">数据类型</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/日记/">日记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/线程/">线程</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/集合/">集合</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">32</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Application-Event/">Application Event</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/JPA/">JPA</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Security/">Security</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Task/">Task</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-MVC/">spring MVC</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-data-redis/">spring data redis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/基础/">基础</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/">服务器相关</a><span class="category-list-count">16</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hessian/">Hessian</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hudson-Jenkins/">Hudson & Jenkins</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Tomcat/">Tomcat</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/red5/">red5</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/redis/">redis</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/resin/">resin</a><span class="category-list-count">2</span></li></ul></li></ul>
    </div>
  </div>

  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">93</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/07/19/Spring/Spring Data Redis/配置/">配置</a>
          </li>
        
          <li>
            <a href="/2017/07/19/Spring/JPA/GeneratedValue主键生成策略/">GeneratedValue主键生成策略</a>
          </li>
        
          <li>
            <a href="/2017/07/19/Linux/nginx安装/">安装nginx</a>
          </li>
        
          <li>
            <a href="/2017/07/19/Linux/activemq安装和配置/">activemq安装和配置</a>
          </li>
        
          <li>
            <a href="/2017/07/19/Linux/redis安装和配置/">redis安装和配置</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="https://clq2owesome.github.io/" target="_blank">作者主页</a>
          </li>
        
          <li>
            <a href="https://githubcandybabe.github.io/" target="_blank">御用前端</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 leo chen<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"reqianduan"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/script.js"></script>

</div>
</body>
</html>
