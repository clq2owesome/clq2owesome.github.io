<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LeoChan&#39;s 个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="描述啊">
<meta property="og:type" content="website">
<meta property="og:title" content="LeoChan&#39;s 个人博客">
<meta property="og:url" content="https://clq2owesome.github.io/page/9/index.html">
<meta property="og:site_name" content="LeoChan&#39;s 个人博客">
<meta property="og:description" content="描述啊">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeoChan&#39;s 个人博客">
<meta name="twitter:description" content="描述啊">
  
    <link rel="alternate" href="/atom.xml" title="LeoChan&#39;s 个人博客" type="application/atom+xml">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  

</head>

<body>
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">LeoChan&#39;s 个人博客</h1>
  
    <p class="lead blog-description">技术都是通用的，重要的是是否具有自主解决问题的能力！</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-前端技术相关/javascript/js中去掉空格的方法" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/13/前端技术相关/javascript/js中去掉空格的方法/">js中去掉空格的方法</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/13/前端技术相关/javascript/js中去掉空格的方法/" class="article-date"><time datetime="2017-08-13T02:09:45.000Z" itemprop="datePublished">2017-08-13</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端技术相关/">前端技术相关</a> / <a class="article-category-link" href="/categories/前端技术相关/javascript/">javascript</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/13/前端技术相关/javascript/js中去掉空格的方法/" data-id="cje2lrz7000cepxblrwlg0dfr" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/基础/生成随机数" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/12/Java/基础/生成随机数/">生成随机数</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/12/Java/基础/生成随机数/" class="article-date"><time datetime="2017-08-12T02:09:45.000Z" itemprop="datePublished">2017-08-12</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>使用java.util.Random包</p>
<h3 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int randNumber = rand.nextInt(MAX - MIN + 1) + MIN; // randNumber 将被赋值为一个 [MIN,MAX] 范围内的随机数</div></pre></td></tr></table></figure>
<p>例如：生成[1000, 9999]的随机数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Random rand = new Random();</div><div class="line">int random =  rand.nextInt(9999-1000+1) + 1000;</div></pre></td></tr></table></figure></p>
<p>说明：如果没有提供种子，java会默认处理,详情请查阅api</p>
<p>如果指定不变的种子，则每次返回的随机数都是一样的，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Random rand = new Random(100);</div><div class="line">int random =  rand.nextInt(9999-1000+1) + 1000;</div><div class="line">每次返回的random都一样</div></pre></td></tr></table></figure></p>
<h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">import java.util.Random;</div><div class="line">import org.apache.commons.lang3.RandomStringUtils;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 生成随机字符串，随机数工具类</div><div class="line"> * @author  chenliqiang, 2017年4月19日 下午9:47:25 &lt;br/&gt;   </div><div class="line"> * @version  1.0</div><div class="line"> * @see 	 </div><div class="line"> */</div><div class="line">public class RandomUtil extends RandomStringUtils &#123;</div><div class="line">	</div><div class="line">	public static final String stringBase = &quot;abcdefghijklmnopqrstuvwxyz0123456789&quot;;</div><div class="line">	public static final String numberBase = &quot;0123456789&quot;;</div><div class="line">	</div><div class="line">	/**</div><div class="line">	 *  获取特定位数的随机字符串</div><div class="line">	 * @param length  随机串长度</div><div class="line">	 * @param toUpperCase 是否转成大写</div><div class="line">	 * @return</div><div class="line">	 * @author chenliqiang， 2017年4月19日 下午9:48:54 &lt;br/&gt;</div><div class="line">	 */</div><div class="line">	public static String getRandomString(int length, boolean toUpperCase) &#123; //length表示生成字符串的长度  </div><div class="line">	    Random random = new Random();     </div><div class="line">	    StringBuffer sb = new StringBuffer();     </div><div class="line">	    for (int i = 0; i &lt; length; i++) &#123;     </div><div class="line">	        int number = random.nextInt(stringBase.length());     </div><div class="line">	        sb.append(stringBase.charAt(number));     </div><div class="line">	    &#125;</div><div class="line">	    if(toUpperCase) &#123;</div><div class="line">	    	return sb.toString().toUpperCase();  </div><div class="line">	    &#125;</div><div class="line">	    return  sb.toString();</div><div class="line">	 &#125;</div><div class="line">	</div><div class="line">	/**</div><div class="line">	 * 获取特定位数的随机数</div><div class="line">	 * @param length  随机数长度</div><div class="line">	 * @return</div><div class="line">	 * @author chenliqiang， 2017年4月19日 下午9:53:29 &lt;br/&gt;</div><div class="line">	 */</div><div class="line">	public static String getRandomNumber(int length) &#123; </div><div class="line">	    Random random = new Random();     </div><div class="line">	    StringBuffer sb = new StringBuffer();     </div><div class="line">	    for (int i = 0; i &lt; length; i++) &#123;     </div><div class="line">	        int number = random.nextInt(numberBase.length());     </div><div class="line">	        sb.append(numberBase.charAt(number));     </div><div class="line">	    &#125;</div><div class="line">	    return  sb.toString();</div><div class="line">	 &#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		System.out.println(randomAlphanumeric(50));</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/12/Java/基础/生成随机数/" data-id="cje2lrz20004gpxblh59cuwg3" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/基础/静态代码块和静态方法" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/12/Java/基础/静态代码块和静态方法/">静态代码块和静态方法</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/12/Java/基础/静态代码块和静态方法/" class="article-date"><time datetime="2017-08-12T02:09:45.000Z" itemprop="datePublished">2017-08-12</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>如果有些代码必须在项目启动的时候就执行,就需要使用静态代码块,这种代码是主动执行的;需要在项目启动的时候就初始化但是不执行,在不创建对象的情况下,可以供其他程序调用,而在调用的时候才执行，这需要使用静态方法,这种代码是被动执行的. 静态方法在类加载的时候 就已经加载 可以用类名直接调用。</p>
<h4 id="静态代码块和静态方法的区别"><a href="#静态代码块和静态方法的区别" class="headerlink" title="静态代码块和静态方法的区别"></a>静态代码块和静态方法的区别</h4><ol>
<li>静态代码块是自动执行的</li>
<li>静态方法是被调用的时候才执行的</li>
</ol>
<h4 id="在使用静态方法的时候需要注意一下几个方面"><a href="#在使用静态方法的时候需要注意一下几个方面" class="headerlink" title="在使用静态方法的时候需要注意一下几个方面"></a>在使用静态方法的时候需要注意一下几个方面</h4><ol>
<li>在静态方法里只能直接调用同类中其他的静态成员（包括变量和方法），而不能直接访问类中的非静态成员。这是因为，对于非静态的方法和变量，需要先创建类的实例对象后才可使用，而静态方法在使用前不用创建任何对象。（备注：静态变量是属于整个类的变量而不是属于某个对象的）</li>
<li>静态方法不能以任何方式引用this和super关键字，因为静态方法在使用前不用创建任何实例对象，当静态方法调用时，this所引用的对象根本没有产生</li>
</ol>
<h4 id="静态变量：一直存于内存中，所以一般要少使用静态变量"><a href="#静态变量：一直存于内存中，所以一般要少使用静态变量" class="headerlink" title="静态变量：一直存于内存中，所以一般要少使用静态变量"></a>静态变量：一直存于内存中，所以一般要少使用静态变量</h4><p>建议使用场景：</p>
<ol>
<li>变量所包含的对象体积较大，占用内存较多。</li>
<li>变量所包含的对象生命周期较长。</li>
<li>变量所包含的对象数据稳定。</li>
<li>该类的对象实例有对该变量所包含的对象的共享需求。</li>
</ol>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/12/Java/基础/静态代码块和静态方法/" data-id="cje2lrz24004tpxbl4h51dhtb" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/基础/JVM的堆和栈" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/12/Java/基础/JVM的堆和栈/">JVM的堆和栈</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/12/Java/基础/JVM的堆和栈/" class="article-date"><time datetime="2017-08-12T02:09:45.000Z" itemprop="datePublished">2017-08-12</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是java程序运行的关键，在java中，每一个线程都会有一个与之对应的线程栈。它是由许多栈帧（stack frame）或者说帧（frame）组成的，一个栈帧包含一个java方法调用的状态。当线程调用一个java方法时，虚拟机压入一个新的栈帧到该线程的java栈中，当该方法返回时，这个栈帧被从java栈中弹出并抛弃。总结起来就是，<strong>栈负责java程序运行过程中的进程和程序处理逻辑的控制</strong>。  </p>
<p>栈帧由三部分组成：局部变量区，操作数栈和帧数据区。</p>
<ol>
<li>局部变量区，顾名思义，存储对应方法的参数和局部变量。</li>
<li>操作数栈，相当于寄存器，存储虚拟机的程序指令。</li>
<li>帧数据区，除了局部变量区和操作数栈中的数据外，java栈帧还需要一些数据来支持常量池解析，正常方法返回以及异常派发机制，这些信息都保存在帧数据区中。    </li>
</ol>
<p>由于栈的结构和功能设计导致它不适合动态增长，因此在java的虚拟机规范中，<strong>栈只能存储基本类型的数据和对堆中对象的引用</strong>。<strong>java栈上的数据都是此线程私有的，任何线程都不能访问另外一个线程的栈数据</strong>。  </p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是java程序运行时创建的实例和数组的存储空间。每一个java虚拟机实例只会存在一个堆空间，因此，<strong>所有线程都将共享这个堆</strong>。    </p>
<p> 由堆的作用可以很容易的知道，它是一个随时都会有大量新数据产生，大量老数据过期的地方，因此对数据的管理和垃圾回收机制是影响堆性能很重要的指标。java虚拟机并没有强制规定怎么去实现一个堆，它只要求虚拟机必须以某种方式来管理自己的堆空间。因此，堆的构成和处理机制不能一概而论，不同的jvm可能会有各自独特的实现。  </p>
<p>堆一般由两部分构成：年轻代，年老代。</p>
<ol>
<li>年轻代：作用是作为程序中所有刚生成的对象的存储空间，设计这一空间的目的是尽可能快的回收掉那些生命周期不长的对象，提高堆空间的利用率。年轻代的内部还有更细划分，涉及到垃圾回收机制的介绍，在后续笔记中会说明。</li>
<li>年老代：用于存放那些生命周期较长，经历了数次垃圾回收后仍然健在的对象。存放于年老代的数据基本上都经过年轻代的过滤，比较稳定。</li>
</ol>
<h3 id="堆和栈的联系和区别"><a href="#堆和栈的联系和区别" class="headerlink" title="堆和栈的联系和区别"></a>堆和栈的联系和区别</h3><p>堆和栈是程序运行的关键，很有必要把他们的关系说清楚。<br><img src="http://note.youdao.com/yws/public/resource/5ae3ccd96f4823c07e89aa21f066d959/xmlnote/A54E95E4BFD74BCBA2EB0A5FA12C5BD1/7827" alt="image"><br><strong>栈是运行时的单位，而堆是存储的单位</strong>。    </p>
<p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据；堆解决的是数据存储的问题，即数据怎么放、放在哪儿。    </p>
<p>在Java中一个线程就会相应有一个线程栈与之对应，这点很容易理解，因为不同的线程执行逻辑有所不同，因此需要一个独立的线程栈。而堆则是所有线程共享的。栈因为是运行单位，因此里面存储的信息都是跟当前线程（或程序）相关信息的。包括局部变量、程序运行状态、方法返回值等等；而堆只负责存储对象信息。    </p>
<h4 id="为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？"><a href="#为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？" class="headerlink" title="为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？"></a>为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？</h4><ol>
<li>从软件设计的角度看，<strong>栈代表了处理逻辑</strong>，而<strong>堆代表了数据</strong>。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。</li>
<li>堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。</li>
<li>栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。</li>
<li><strong>面向对象就是堆和栈的完美结合</strong>。其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。不得不承认，面向对象的设计，确实很美。</li>
</ol>
<h4 id="在Java中，Main函数就是栈的起始点，也是程序的起始点。"><a href="#在Java中，Main函数就是栈的起始点，也是程序的起始点。" class="headerlink" title="在Java中，Main函数就是栈的起始点，也是程序的起始点。"></a>在Java中，Main函数就是栈的起始点，也是程序的起始点。</h4><p> 程序要运行总是有一个起点的。同C语言一样，java中的Main就是那个起点。无论什么java程序，找到main就找到了程序执行的入口：     </p>
<h5 id="堆中存什么？栈中存什么？"><a href="#堆中存什么？栈中存什么？" class="headerlink" title="堆中存什么？栈中存什么？"></a>堆中存什么？栈中存什么？</h5><p> <strong>堆中存的是对象</strong>。<strong>栈中存的是基本数据类型和堆中对象的引用</strong>。一个对象的大小是不可估计的，或者说是可以动态变化的，但是在栈中，一个对象只对应了一个4btye的引用（堆栈分离的好处）  </p>
<p> 为什么不把基本类型放堆中呢？因为其占用的空间一般是1~8个字节——需要空间比较少，而且因为是基本类型，所以不会出现动态增长的情况——长度固定，因此栈中存储就够了，如果把他存在堆中是没有什么意义的（还会浪费空间，后面说明）。可以这么说，基本类型和对象的引用都是存放在栈中，而且都是几个字节的一个数，因此在程序运行时，他们的处理方式是统一的。但是基本类型、对象引用和对象本身就有所区别了，因为一个是栈中的数据一个是堆中的数据。最常见的一个问题就是，Java中参数传递时的问题。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/12/Java/基础/JVM的堆和栈/" data-id="cje2lrz1l003opxblfft66kxu" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/基础/单例模式" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/12/Java/基础/单例模式/">单例模式</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/12/Java/基础/单例模式/" class="article-date"><time datetime="2017-08-12T02:09:45.000Z" itemprop="datePublished">2017-08-12</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="第一种（懒汉，线程不安全）："><a href="#第一种（懒汉，线程不安全）：" class="headerlink" title="第一种（懒汉，线程不安全）："></a>第一种（懒汉，线程不安全）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123; </div><div class="line">	private static Singleton instance; </div><div class="line">	private Singleton ()&#123;&#125; </div><div class="line">	    </div><div class="line">	public static Singleton getInstance() &#123; </div><div class="line">		if (instance == null) &#123; </div><div class="line">			instance = new Singleton(); </div><div class="line">		&#125; </div><div class="line">		return instance; </div><div class="line">	&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种写法lazy loading很明显，但是致命的是在多线程不能正常工作。</p>
<h3 id="第二种（懒汉，线程安全）："><a href="#第二种（懒汉，线程安全）：" class="headerlink" title="第二种（懒汉，线程安全）："></a>第二种（懒汉，线程安全）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123; </div><div class="line">    private static Singleton instance; </div><div class="line">    private Singleton ()&#123;&#125; </div><div class="line">    public static synchronized Singleton getInstance() &#123;    </div><div class="line">        if (instance == null) &#123; </div><div class="line">            instance = new Singleton(); </div><div class="line">        &#125; </div><div class="line">        return instance; </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种写法能够在多线程中很好的工作，而且看起来它也具备很好的lazy loading，但是，遗憾的是，效率很低，99%情况下不需要同步。</p>
<h3 id="第三种（饿汉）："><a href="#第三种（饿汉）：" class="headerlink" title="第三种（饿汉）："></a>第三种（饿汉）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123; </div><div class="line">    private static Singleton instance = new Singleton(); </div><div class="line">    private Singleton ()&#123;&#125; </div><div class="line">    public static Singleton getInstance() &#123; </div><div class="line">        return instance; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用getInstance方法，但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到lazy loading的效果。</p>
<h3 id="第四种（饿汉，变种）："><a href="#第四种（饿汉，变种）：" class="headerlink" title="第四种（饿汉，变种）："></a>第四种（饿汉，变种）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123; </div><div class="line">    private Singleton instance = null; </div><div class="line">    static &#123; </div><div class="line">        instance = new Singleton(); </div><div class="line">    &#125; </div><div class="line">    private Singleton ()&#123;&#125; </div><div class="line">    public static Singleton getInstance() &#123; </div><div class="line">        return this.instance; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>表面上看起来差别挺大，其实跟第三种方式差不多，都是在类初始化即实例化instance。</p>
<h3 id="第五种（静态内部类）："><a href="#第五种（静态内部类）：" class="headerlink" title="第五种（静态内部类）："></a>第五种（静态内部类）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123; </div><div class="line">    private static class SingletonHolder &#123; </div><div class="line">        private static final Singleton INSTANCE = new Singleton(); </div><div class="line">    &#125; </div><div class="line">    private Singleton ()&#123;&#125; </div><div class="line">    public static final Singleton getInstance() &#123; </div><div class="line">        return SingletonHolder.INSTANCE; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式同样利用了classloder的机制来保证初始化instance时只有一个线程，它跟第三种和第四种方式不同的是（很细微的差别）：第三种和第四种方式是只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading效果），而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。想象一下，如果实例化instance很消耗资源，我想让他延迟加载，另外一方面，我不希望在Singleton类加载时就实例化，因为我不能确保Singleton类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化instance显然是不合适的。这个时候，这种方式相比第三和第四种方式就显得很合理。</p>
<h3 id="第六种（枚举）："><a href="#第六种（枚举）：" class="headerlink" title="第六种（枚举）："></a>第六种（枚举）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class EnumSingleton&#123;</div><div class="line">    private EnumSingleton()&#123;&#125;</div><div class="line">    public static EnumSingleton getInstance()&#123;</div><div class="line">        return Singleton.INSTANCE.getInstance();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private static enum Singleton &#123;</div><div class="line">        INSTANCE;</div><div class="line">        </div><div class="line">        private EnumSingleton singleton;</div><div class="line">        //JVM会保证此方法绝对只调用一次</div><div class="line">        private Singleton()&#123;</div><div class="line">            singleton = new EnumSingleton();</div><div class="line">        &#125;</div><div class="line">        public EnumSingleton getInstance()&#123;</div><div class="line">            return singleton;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>目前最为安全的实现单例的方法是通过内部静态enum的方法来实现，因为JVM会保证enum不能被反射并且构造器方法只执行一次。<br>这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏，在实际工作中，我也很少看见有人这么写过。</p>
<h3 id="第七种（双重校验锁）："><a href="#第七种（双重校验锁）：" class="headerlink" title="第七种（双重校验锁）："></a>第七种（双重校验锁）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123; </div><div class="line">    private volatile static Singleton singleton; </div><div class="line">    private Singleton ()&#123;&#125; </div><div class="line">    public static Singleton getSingleton() &#123; </div><div class="line">        if (singleton == null) &#123; </div><div class="line">            synchronized (Singleton.class) &#123; </div><div class="line">                if (singleton == null) &#123; </div><div class="line">                    singleton = new Singleton(); </div><div class="line">                &#125;  </div><div class="line">            &#125; </div><div class="line">        &#125; </div><div class="line">        return singleton; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>单例的共同单：传统的两私有一公开（私有构造方法、私有静态实例(懒实例化/直接实例化)、公开的静态获取方法）涉及线程安全问题（即使有多重检查锁也可以通过反射破坏单例）</li>
<li>private Singleton (){}：私有化构造函数，防止外部创建实例</li>
<li>在运用单例模式时，要考虑所在的运行环境，在多线程的环境下，要考虑多线程安全的问题，一般来说，加锁会导致效率变低</li>
<li>要根据调用情况合理选择饿汉还是懒汉的加载方式</li>
</ol>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/12/Java/基础/单例模式/" data-id="cje2lrz1y004cpxblinluvgii" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/基础/JVM体系结构" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/12/Java/基础/JVM体系结构/">JVM体系结构</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/12/Java/基础/JVM体系结构/" class="article-date"><time datetime="2017-08-12T02:09:45.000Z" itemprop="datePublished">2017-08-12</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>jvm的全称是Java Virtual Machine，即java虚拟机</strong>，它是构建于操作系统内存中一个虚拟软件，用于支持java程序的运行，是java之所以能够跨平台的关键。对java开发者来说，jvm既重要，又不重要。说它重要是因为我们的每一个程序，每一行代码，都必须通过它才能运行。说他不重要则是因为就算对它一无所知，实际上也不影响绝大部分java开发者日常工作。</p>
<p>当一个java程序被运行时，一个java虚拟机实例也就随之被创建。如果启动多个java程序，对应的，就会有多个虚拟机实例存在于内存中。一言以蔽之，jvm先java程序而生，后Java程序而亡。</p>
<p>那么一个jvm有哪些组成部分呢？如下图所示：<br><img src="http://note.youdao.com/yws/public/resource/1ba13d8b1eecc2e67ee0bff89b1d2735/xmlnote/D0F22E55CAC34EAEB73DCD810FAF8527/7828" alt="image"><br>上图就是jvm的构成图，也就是jvm的基本体系结构，可以看到，jvm大体上可以分为四大部分：   </p>
<ol>
<li><p>class loader，也就是类加载器。它的作用是查找符合java class格式的类文件（也就是图中的class files），并将之加载进Runtime Data Area。值得一提的是，只要文件符合.class文件的格式要求，就会被它加载，至于是否能够顺利运行，就不是它的职责了。</p>
</li>
<li><p>Runtime Data Area，顾名思义，运行时数据区。java程序运行时数据管理，对象的生成与消亡，内存的分配与回收都发生在这个区域。也是程序员主要关注的区域，一般意义上的jvm优化指的就是针对这个区域的优化，它由以下几个部分构成：</p>
</li>
</ol>
<ul>
<li>stack，也就是java栈。栈是java程序运行的关键，<strong>java中的每一个线程都会有一个与之相对应的线程栈</strong>。里面存储的信息都是跟当前线程相关的信息，包括局部变量，程序运行状态，方法返回值等。每一次方法的调用都将作为一个整体帧被压入栈中，遵循”先入后出”原则。<strong>不同的栈无法访问彼此的数据，栈中只能存储基本类型和堆中对象的引用</strong>。</li>
<li>heap，堆内存。<strong>堆负责java对象信息的存储，堆中的内容可以被多个栈共享，堆的存在，使得java多个线程之间可以共享数据</strong>。每一个java虚拟机都只有一个堆内存，它主要由两个部分构成：年轻代、老年代，对堆内存的分配与垃圾的回收机制是jvm优化的一个极端重要的课题，这部分留待在后续的学习笔记中介绍。  </li>
<li>method area，方法区（永久代）。<strong>该区域被所有线程所共享，主要用于存储java类信息，常量，静态变量等</strong>。</li>
<li>PC Register，程序计数器。<strong>每一个java线程都有一个自己的pc register</strong>，它的内容总是指向下一条被执行指令的地址，不做深究。</li>
<li>native method stack，本地方法栈。其作用类似于java栈，不同之处是它负责存储本地方法的调用信息，也就是当java程序调用native方法时(简单地讲，<strong>一个Native Method就是一个Java调用非java代码的接口</strong>)，其相关的运行信息将被压入本地方法栈，而不是Java栈。</li>
</ul>
<ol>
<li><p>Execution Engine，执行引擎，也叫解释器。负责解释命令，执行字节码或本地方法。太偏向于底层，不做深究。</p>
</li>
<li><p>Native Interface，本地接口。它赋予了java调用由其它语言编写而成的接口的能力，通过执行引擎加载执行，现在的用处较少，有兴趣的同学可自行学习。</p>
</li>
</ol>
<p>下面重点讲解一下运行数据区</p>
<h2 id="运行数据区"><a href="#运行数据区" class="headerlink" title="运行数据区"></a>运行数据区</h2><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（第2版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示：<br><img src="http://pic002.cnblogs.com/images/2012/416402/2012101820014328.jpg" alt="image">    </p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），<strong>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</strong>。        </p>
<p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：<strong>每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程</strong>。<br>经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”在后面会专门讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变量表部分。  </p>
<p>局部变量表存放了<strong>编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型）</strong>，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。    </p>
<p>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。    </p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。   </p>
<p>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>对于大多数应用来说，<strong>Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建</strong>。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存</strong>。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。    </p>
<p>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以<strong>Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等</strong>。如果从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java堆中的上述各个区域的分配和回收等细节将会是下一章的主题。      </p>
<p>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p><strong>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域</strong>，它<strong>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。  </p>
<p>对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。即使是HotSpot虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory来实现方法区的规划了。    </p>
<p><strong>Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集</strong>。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。在Sun公司的BUG列表中，曾出现过的若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。 根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p><strong>运行时常量池（Runtime Constant Pool）是方法区的一部分</strong>。Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），<strong>用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中</strong>。  </p>
<p>Java虚拟机对Class文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。    </p>
<p><strong>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中</strong>，这种特性被开发人员利用得比较多的便是String类的intern()方法。 既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p>
<h2 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h2><p>介绍完Java虚拟机的运行时数据区之后，我们就可以来探讨一个问题：在Java语言中，对象访问是如何进行的？对象访问在Java语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及Java栈、Java堆、方法区这三个最重要内存区域之间的关联关系，如下面的这句代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object obj = new Object();</div></pre></td></tr></table></figure></p>
<p>假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java栈的本地变量表中，作为一个reference类型数据出现。而“new Object()”这部分的语义将会反映到Java堆中，形成一块存储了Object类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。    </p>
<p>由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，<strong>主流的访问方式有两种：使用句柄和直接指针</strong>。    </p>
<p>如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如下图所示：<br><img src="http://pic002.cnblogs.com/images/2012/416402/2012101820441174.jpg" alt="image">       </p>
<p>如果使用的是直接指针访问方式，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址，如下图所示：<br><img src="http://pic002.cnblogs.com/images/2012/416402/2012101820481861.jpg" alt="image">   </p>
<p>这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/12/Java/基础/JVM体系结构/" data-id="cje2lrz1k003lpxbll6cpbgf3" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/基础/java 垃圾回收机制" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/12/Java/基础/java 垃圾回收机制/">java 垃圾回收机制</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/12/Java/基础/java 垃圾回收机制/" class="article-date"><time datetime="2017-08-12T02:09:45.000Z" itemprop="datePublished">2017-08-12</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JVM体系结构简介"><a href="#JVM体系结构简介" class="headerlink" title="JVM体系结构简介"></a>JVM体系结构简介</h2><h4 id="JVM-Specification中的JVM整体架构"><a href="#JVM-Specification中的JVM整体架构" class="headerlink" title="JVM Specification中的JVM整体架构"></a>JVM Specification中的JVM整体架构</h4><p><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/7F3773507E124A918989B46388D81BAE/7802" alt="image"><br>主要包括两个子系统和两个组件，<strong>Class Loader(类装载)子系统</strong>，<strong>Execution Engine(执行引擎)子系统</strong>，<strong>Runtime Data Area(运行时数据区)组件</strong>，<strong>Native Interface(本地接口)组件</strong>。 </p>
<ul>
<li>Class loader 子系统的作用 ：根 据给定的全限定名类名(如 java.lang.Object)来装载class文件的内容到 Runtime data area 中的method area(方法区域)。Java 程序员可以extends java.lang.ClassLoader 类来写自己的Class loader。</li>
<li>Execution engine 子系统的作用 ：执 行 classes中的指令。任何 JVM specification实现(JDK)的核心是Execution engine， 换句话说：Sun 的JDK 和IBM的JDK好坏主要取决于他们各自实现的Execution  engine的好坏。每个运行中的线程都有一个 Execution engine的实例。 </li>
<li>Native interface 组件 ：与native libraries 交互，是其它编程语言交互的接口。 </li>
<li>Runtime data area 组件：这个组件就是 JVM中的内存。</li>
</ul>
<p>Runtime data area 的整体架构图：<br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/6AA4AD5DE0324A3C8BEE06B56345725F/7804" alt="image"><br><strong>Runtime data area 主要包括五个部分：Heap (堆), Method Area(方法区域), Java Stack(java 的栈), Program Counter(程序计数器), Native method stack(本地方法栈)。Heap 和Method Area 是被所有线程的共享使用的；而Java stack, Program counter 和 Native method stack 是以线程为粒度的，每个线程独自拥有。</strong>   </p>
<ul>
<li><p><strong>Heap（堆内存）</strong><br>Java程序在运行时创建的所有类实例或数组都放在同一个堆中。而一个Java虚拟实例中只存在一个堆空间，因此所有线程都将共享这个堆。每一个 java程序独占一个JVM实例，因而每个 java程序都有它自己的堆空间，它们不会彼此干扰。但是同一java程序的多个线程都共享着同一个堆空间，就得考虑多线程访问对象（堆数据）的同步问 题。（这里可能出现的异常 java.lang.OutOfMemoryError: Java heap space）  </p>
</li>
<li><p><strong>Method area（方法区）</strong><br>在Java 虚拟机中，被装载的 class的信息存储在 Method area的内存中。当虚拟机装载某个类型时，它使用类装载器定位相应的 class文件，然后读入这个class文件内容并把它传输到虚拟机中。紧接着虚拟机提取其中的类型信息，并将这些信息存储到方法区。该类型中的类（静 态）变量同样也存储在方法区中。与Heap 一样，method area 是多线程共享的，因此要考虑多线程访问的同步问题。比如，假设同时两个线程都企图访问一个名为 Lava的类，而这个类还没有内装载入虚拟机，那么，这时应该只有一个线程去装载它，而另一个线程则只能等待。 （这里可能出现的异常 java.lang.OutOfMemoryError: PermGen full）  </p>
</li>
<li><p><strong>Java stack（java 栈）</strong><br>Java stack 以帧为单位保存线程的运行状态。虚拟机只会直接对 Java stack执行两种操作：以帧为单位的压栈或出栈。每当线程调用一个方法的时候，就对当前状态作为一个帧保存到 java stack 中(压栈)；当一个方法调用返回时，从java stack 弹出一个帧(出栈)。栈的大小是有一定的限制，这个可能出现StackOverFlow 问题，例如递归的层数太深。  </p>
</li>
<li><p><strong>Program counter（程序计数器）</strong><br>每个运行中的Java程序，每一个线程都有它自己的PC寄存器，也是该线程启动时创建的。PC寄存器的内容总是指向下一条将被执行指令的地址，这里的地址可以是一个本地指针，也可以是在方法区中相对应于该方法起始指令的偏移量。  </p>
</li>
<li><p><strong>Native method stack（本地方法栈）</strong><br>对于一个运行中的Java程序而言，它还能会用到一些跟本地方法相关的数据区。当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限 制的世界。本地方法可以通过本地方法接口来访问虚拟机的运行时数据区，不止如此，它还可以做任何它想做的事情。比如，可以调用寄存器，或在操作系统中分配 内存等。总之，本地方法具有和JVM 相同的能力和权限。  (这里出现 JVM无法控制的内存溢出问题 native heap OutOfMemory ) 。  </p>
</li>
</ul>
<h4 id="Sun-JVM-中对-JVM-Specification-的实现（内存部分）"><a href="#Sun-JVM-中对-JVM-Specification-的实现（内存部分）" class="headerlink" title="Sun JVM 中对 JVM Specification 的实现（内存部分）"></a>Sun JVM 中对 JVM Specification 的实现（内存部分）</h4><p>JVM Specification只是抽象的说明了 JVM 实例按照子系统、内存区、数据类型以及指令这几个术语来描述的，  但是规范并非是要强制规定 Java 虚拟机实现内部的体系结构，更多的是为了严格地定义这些实现的外部特征。  Sun JVM 实现中：Runtime data area(JVM  内存)  五个部分中的 Java Stack , Program Counter, Native method stack 三部分和规范中的描述基本一致；但对 Heap  和  Method Area 进行了自己独特的实现。这个实现和 Sun JVM  的Garbage collector（垃圾回收）机制有关。     </p>
<h5 id="垃圾分代回收算法（Generational-Collecting）"><a href="#垃圾分代回收算法（Generational-Collecting）" class="headerlink" title="垃圾分代回收算法（Generational Collecting）"></a>垃圾分代回收算法（Generational Collecting）</h5><p>基于对对象生命周期分析后得出的垃圾回收算法。把对象分为年青代、年老代、持久代，对不同生命周期的对象使用不同的算法（上述方式中的一个）进行回收。现在的垃圾回收器（从J2SE1.2开始）都是使用此算法的。<br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/51FF00BC6F604060B8EE5826F063E7FF/7803" alt="image">    </p>
<p>如上图所示，为Java 堆中的各代分布。   </p>
<ol>
<li>Young（年轻代）JVM specification 中的  Heap的一部分。年轻代分三个区。一个Eden区，两个 Survivor区。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到 Survivor区（两个中的一个），当这个 Survivor区满时，此区的存活对象将被复制到另外一个 Survivor区，当这个 Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到年老区(Tenured)。需要注 意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来的对象，和从前一个 Survivor复制过来的对象，而复制到年老区的只有从第一个 Survivor 区过来的对象。而且，Survivor 区总有一个是空的。  </li>
<li>Tenured（年老代）JVM specification中的  Heap的一部分。年老代存放从年轻代存活的对象。一般来说年老代存放的都是生命期较长的对象。</li>
<li>Perm（持久代）  JVM specification 中的  Method area 用于存放静态文件，如 Java 类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些 class，例如 Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=进行设置。</li>
</ol>
<h2 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h2><p>JVM的内存分代管理结构：<br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/605518F2B1504903B1A126803190723C/7805" alt="image"><br>下面是一些需要关注的常用的JVM内存配置参数，我们来看看它们是如何影响上图中的比例的。        </p>
<h3 id="Heap-Size"><a href="#Heap-Size" class="headerlink" title="Heap Size"></a>Heap Size</h3><p><strong>-Xmx —最大Heap Size</strong>，即上图的Total size（包括Eden+form+to，Tenured，不包含Perm，见上图），限制了年轻代和年老代的可分配最大值；<br><strong>-Xms —初始化分配的Heap Size</strong><br>生产环境中ms一般设置成跟mx相等，因为若ms不等于mx那么在某些场景下JVM可能需要对Heap Size进行频繁的扩展和收缩，增加处理时间；</p>
<h3 id="New-Young-Generation-Size"><a href="#New-Young-Generation-Size" class="headerlink" title="New/Young Generation Size"></a>New/Young Generation Size</h3><p><strong>-Xmn —最大年轻代大小</strong>，即上图中的Eden+S0+S1+Virtual<br><strong>-XX:NewSize —初始化年轻代大小</strong>，即上图中的Eden+S0+S1，在只设置了-Xmn不设置-XX:NewSize的情况下，NewSize等于mn。<br>生产环境中一般只需设置-Xmn或者设置mn和NewSize相等，理由和HeapSize的设置一样，避免容量震荡消耗资源；</p>
<h3 id="Old-Generation-Size-（Tenured）"><a href="#Old-Generation-Size-（Tenured）" class="headerlink" title="Old Generation Size （Tenured）"></a>Old Generation Size （Tenured）</h3><p>-XX:NewRatio — Old Size/New Size，通过年老代和年轻代的比例和Heap Size就可以算出年老代的大小。<strong>一般默认为8</strong>，若Heap Size为1024m，则 NewSize=HeapSize/(NewRatio+1)=114m，OldSize=HeapSize-NewSize=910m；<br>注意：-Xmn的优先级比-XX:NewRatio高，若-Xmn已指定，则OldSize=HeapSize-NewSize，无需再按比例计算。生产环境中一般只需指定-Xmn就足够了。</p>
<h3 id="Eden和S0、S1"><a href="#Eden和S0、S1" class="headerlink" title="Eden和S0、S1"></a>Eden和S0、S1</h3><p>-XX:SurvivorRatio — Eden/S0，即 Eden区和S0的比例，<strong>默认为8</strong>，若NewSize为114m，则S0=NewSize/(SurvivorRatio+2)=11.4m;<br>S0==S1，S0、S1的职能是一模一样的，又叫做From space和To space，在每一次minor gc后角色会交换。<br>注意：-XX类型的选项在不同的JDK版本或实现中定义可能有所区别，在近日的实践中发现，在Linux jdk_1_5_0_10_x86版本中，SurvivorRatio=(YoungSize/S0)，而Linux jdk_1_5_0_20_x64版本中，SurvivorRatio=(Eden/S0)，所以，我们在实际的工程实践中还是应该用jmap -heap输出的jvm内存结构信息为准，不要想当然。</p>
<h3 id="Permanent-Generation-Size"><a href="#Permanent-Generation-Size" class="headerlink" title="Permanent Generation Size"></a>Permanent Generation Size</h3><p><strong>-XX:MaxPermSize</strong> —最大持久代大小，默认为64m；<br><strong>-XX:PermSize</strong> —初始化持久代大小，默认为16m；<br>生产环境中一般设置MaxPermSize和PermSize相等，理由和HeapSize的设置一样，避免容量震荡消耗资源；<br>当应用引用的类比较多或者应用了一些动态类生产技术时应该加大该区的值，一般256m对服务器程序都很足够了。  </p>
<h3 id="Thread-Stack-Size"><a href="#Thread-Stack-Size" class="headerlink" title="Thread Stack Size"></a>Thread Stack Size</h3><p><strong>-Xss</strong> —线程堆栈大小，一般用于存放方法入口参数和返回值，以及原子类型的本地变量（即方法内部变量）；<br>一般可设置为128k.</p>
<h3 id="Direct-Memory-Size"><a href="#Direct-Memory-Size" class="headerlink" title="Direct Memory Size"></a>Direct Memory Size</h3><p>-XX:MaxDirectMemorySize —direct byte buffer用到的本地内存，默认跟mx相等，所以生产环境中一般不设置mx大于物理内存的一半。</p>
<h2 id="GC过程"><a href="#GC过程" class="headerlink" title="GC过程"></a>GC过程</h2><p>在讲述GC过程前我先解释一下JVM的两个控制参数：</p>
<ul>
<li><strong>-XX:TargetSurvivorRatio</strong> — Survivor Space最大使用率，若存放对象的总大小超过该值，将引起对象向Old区迁移；</li>
<li><strong>-XX:MaxTenuringThreshold</strong> — Young区对象的最大任期阀值，即可经历minor gc的次数，超过该次数的对象直接迁移到Old区；</li>
</ul>
<h3 id="Heap在初始状态"><a href="#Heap在初始状态" class="headerlink" title="Heap在初始状态"></a>Heap在初始状态</h3><p><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/D697D9F32C4B49B695E55BA6C17F05BA/7806" alt="image">    </p>
<h3 id="在Eden存放新对象"><a href="#在Eden存放新对象" class="headerlink" title="在Eden存放新对象"></a>在Eden存放新对象</h3><p><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/661FF2FC15A54B968D78771794964F82/7807" alt="image">    </p>
<h3 id="Eden空间不足分配新对象，进行第一次minor-gc"><a href="#Eden空间不足分配新对象，进行第一次minor-gc" class="headerlink" title="Eden空间不足分配新对象，进行第一次minor gc"></a>Eden空间不足分配新对象，进行第一次minor gc</h3><p><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/3055967862EE440593549C52A86D1BFA/7808" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/DCC7EA8095674A87A8B731179AD2C055/7810" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/360E2E4E55074C43A2CEC0BF1E984735/7809" alt="image">    </p>
<h3 id="Eden区再次被写满，进行第二次minor-gc"><a href="#Eden区再次被写满，进行第二次minor-gc" class="headerlink" title="Eden区再次被写满，进行第二次minor gc"></a>Eden区再次被写满，进行第二次minor gc</h3><p><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/D82167248EE1422F9E2E168A2E0BED2C/7811" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/02BD5695A74249788A952C94A2BB6C5B/7813" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/ECFFAB95FB884318BFBC4810FA24C7DE/7812" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/43B37C943BB94ACD98390B311FB7EEE0/7814" alt="image">   </p>
<h3 id="Eden再次被写满，进行第3次minor-gc"><a href="#Eden再次被写满，进行第3次minor-gc" class="headerlink" title="Eden再次被写满，进行第3次minor gc"></a>Eden再次被写满，进行第3次minor gc</h3><p>第3次gc，发生了对象从from space提升到old区的迁移，然后也发生了from space到to space的copy<br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/9C0C8EDA8702471AA5FDA2B245A38442/7816" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/074D37A977464B0A9666B29BEF481E9D/7815" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/4E881AF6D6A94548A6E537AF0C0DEC7F/7817" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/A30D42C7170E468E8C789FAA797ED51F/7819" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/B37B2D99E29543F98F46BFCA716CB9D8/7818" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/61FA00EA2A28452A98CB66A1348D1771/7820" alt="image">   </p>
<p>以下是Survivor space空间不足但对象的minor gc次数未到达MaxTenuringThreshold时的gc情况：<br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/C0BD54B605034553BE7F6CA3877DCD6D/7821" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/E3EBAC9AB610412AA408431B7A448D20/7822" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/4A2675338FF843A295210D7DC59557B3/7823" alt="image">   </p>
<h2 id="GC实战"><a href="#GC实战" class="headerlink" title="GC实战"></a>GC实战</h2><p>在进行GC Tuning时有两个很强大的利器：   </p>
<ul>
<li>jstat：用于查看某java进程的gc情况；</li>
<li>jmap：查看java进程堆栈分配和使用情况，以及dump出当前堆栈内容（可以用Eclipse MAT进行进一步分析） </li>
</ul>
<p>以上两个利器都是jdk自带，且无需java进程添加任何额外的debug信息输出参数的，直接就可以对任意java进程进行跟踪了。</p>
<h3 id="常见配置举例"><a href="#常见配置举例" class="headerlink" title="常见配置举例"></a>常见配置举例</h3><h4 id="堆大小设置"><a href="#堆大小设置" class="headerlink" title="堆大小设置"></a>堆大小设置</h4><p>JVM 中最大堆大小有三方面限制：相关操作系统的数据模型（32-bt还是64-bit）限制；系统的可用虚拟内存限制；系统的可用物理内存限制。32位系统 下，一般限制在1.5G~2G；64为操作系统对内存无限制。</p>
<p>典型设置：</p>
<ul>
<li><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k  </p>
<p>  <strong>-Xmx3550m</strong>：设置JVM最大可用内存为3550M。<br>  <strong>-Xms3550m</strong>：设置JVM初始内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。<br>  <strong>-Xmn2g</strong>：设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。<br>  <strong>-Xss128k</strong>： 设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内 存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p>
</li>
</ul>
<ul>
<li><p>java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4           -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0</p>
<p>  <strong>-XX:NewRatio=4</strong>:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5<br>  <strong>-XX:SurvivorRatio=4</strong>：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6<br>  <strong>-XX:MaxPermSize=16m</strong>:设置持久代大小为16m。<br>  <strong>-XX:MaxTenuringThreshold=0</strong>：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</p>
</li>
</ul>
<h4 id="回收器选择"><a href="#回收器选择" class="headerlink" title="回收器选择"></a>回收器选择</h4><p>JVM给了三种选择：<strong>串行收集器</strong>、<strong>并行收集器</strong>、<strong>并发收集器</strong>，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。默认情况下，JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行判断。  </p>
<ol>
<li><p>吞吐量优先的并行收集器<br>并行收集器主要以到达一定的吞吐量为目标，适用于科学技术和后台处理等。</p>
<p> 典型配置：</p>
<ul>
<li><p><strong>java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20</strong>  </p>
<p>  <strong>-XX:+UseParallelGC</strong>：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。<br>  <strong>-XX:ParallelGCThreads=20</strong>：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。  </p>
</li>
<li><p><strong>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 -XX:+UseParallelOldGC</strong> </p>
<p>  <strong>-XX:+UseParallelOldGC</strong>：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。    </p>
</li>
<li><p><strong>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis=100</strong></p>
<p>  <strong>-XX:MaxGCPauseMillis=100</strong>:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。</p>
<ul>
<li><p><strong>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis=100 -XX:+UseAdaptiveSizePolicy</strong></p>
<p><strong>-XX:+UseAdaptiveSizePolicy</strong>：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>响应时间优先的并发收集器<br>并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域等。</p>
</li>
</ol>
<p>典型配置：</p>
<ul>
<li><p><strong>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC</strong></p>
<p>  <strong>-XX:+UseConcMarkSweepGC</strong>：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。<br>  <strong>-XX:+UseParNewGC</strong>:设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。</p>
</li>
<li><p><strong>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection</strong></p>
<p>  <strong>-XX:CMSFullGCsBeforeCompaction</strong>：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。<br>  <strong>-XX:+UseCMSCompactAtFullCollection</strong>：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</p>
</li>
</ul>
<h3 id="常见配置汇总"><a href="#常见配置汇总" class="headerlink" title="常见配置汇总"></a>常见配置汇总</h3><ul>
<li>堆设置<ul>
<li>-Xms:初始堆大小</li>
<li>-Xmx:最大堆大小</li>
<li>-XX:NewSize=n:设置年轻代大小</li>
<li>-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4</li>
<li>-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5</li>
<li>-XX:MaxPermSize=n:设置持久代大小</li>
</ul>
</li>
</ul>
<ul>
<li>收集器设置<ul>
<li>-XX:+UseSerialGC:设置串行收集器</li>
<li>-XX:+UseParallelGC:设置并行收集器</li>
<li>-XX:+UseParalledlOldGC:设置并行年老代收集器</li>
<li>-XX:+UseConcMarkSweepGC:设置并发收集器</li>
</ul>
</li>
</ul>
<ul>
<li><p>垃圾回收统计信息</p>
<ul>
<li>-XX:+PrintGC</li>
<li>-XX:+Printetails</li>
<li>-XX:+PrintGCTimeStamps</li>
<li>-Xloggc:filename</li>
</ul>
</li>
<li><p>并行收集器设置</p>
<ul>
<li>-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。</li>
<li>-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间</li>
<li>-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)<br>并发收集器设置</li>
<li>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。</li>
<li>-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</li>
</ul>
</li>
</ul>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/12/Java/基础/java 垃圾回收机制/" data-id="cje2lrz1n003tpxblt1ct3ntq" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-服务器相关/Memcached/Memcached线程模型" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/12/服务器相关/Memcached/Memcached线程模型/">Memcached线程模型</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/12/服务器相关/Memcached/Memcached线程模型/" class="article-date"><time datetime="2017-08-12T02:09:45.000Z" itemprop="datePublished">2017-08-12</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a> / <a class="article-category-link" href="/categories/服务器相关/Memcached/">Memcached</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="模型分析"><a href="#模型分析" class="headerlink" title="模型分析"></a>模型分析</h3><p>memcached到底是如何处理我们的网络连接的？<br><strong>非阻塞的IO复用模型</strong></p>
<p>memcached通过epoll（使用libevent，下面具体再讲）实现异步的服务器，但仍然使用多线程，主要有两种线程，分别是“主线程”和“worker线程”，一个主线程，多个worker线程。  </p>
<p><strong>主线程负责监听网络连接，并且accept连接。当监听到连接时，accept后，连接成功，把相应的client fd丢给其中一个worker线程。<br>worker线程接收主线程丢过来的client fd，加入到自己的epoll监听队列，负责处理该连接的读写事件。</strong></p>
<p>所以说，主线程和worker线程都各自有自己的监听队列，主线程监听的仅是listen fd，而worker线程监听的则是主线程accept成功后丢过来的client fd。</p>
<p>memcached使用libevent实现事件监听。在这简单介绍一下libevent的使用，一般有以下几步：    </p>
<ol>
<li>event_base = event_init(); 初始化事件基地。</li>
<li>event_set(event, fd, event_flags, event_handler, args); 创建事件event，fd为要监听的fd，event_flags为监听的事件类型，event_handler为事件发生后的处理函数，args为调用 处理函数时传递的参数。</li>
<li>event_base_set(event_base, event); 为创建的事件event指定事件基地。</li>
<li>event_add(event, timeval); 把事件加入到事件基地进行监听</li>
<li>event_base_loop(event_base, flag); 进入事件循环，即epoll_wait<br>memcached主线程和worker线程各有自己的监听队列，故有主线程和每个worker线程都有一个独立的event_base，事件基地。</li>
</ol>
<p>了解libevent的简单使用后，我们回到memcache线程模型上，先看看下面的图片了解它线程模型的构建逻辑：<br><img src="http://note.youdao.com/yws/public/resource/8129468ec7b125aad250ebe1448c3cae/xmlnote/7662618307C94D5093771F6409CC5700/7893" alt="image">    </p>
<ol>
<li>主线程首先为自己分配一个event_base，用于监听连接，即listen fd。</li>
<li>主线程创建n个worker线程，同时每个worker线程也分配了独立的event_base。</li>
<li>每个worker线程通过管道方式与其它线程（主要是主线程）进行通信，调用pipe函数，产生两个fd，一个是管道写入fd，一个是管道读取fd。 worker线程把管道读取fd加到自己的event_base，监听管道读取fd的可读事件，即当主线程往某个线程的管道写入fd写数据时，触发事件。</li>
<li>主线程监听到有一个连接到达时，accept连接，产生一个client fd，然后选择一个worker线程，把这个client fd包装成一个CQ_ITEM对象（这个对象实质是起主线程与worker线程之间通信媒介的作用，主线程把client fd丢给worker线程往往不止“client fd”这一个参数，还有别的参数，所以这个CQ_ITEM相当于一个“参数对象”，把参数都包装在里面），然后压到worker线程的CQ_ITEM队列 里面去（每个worker线程有一个CQ_ITEM队列），<br>同时主线程往选中的worker线程的管道写入fd中写入一个字符“c”（触发worker线程）。</li>
<li>主线程往选中的worker线程的管道写入fd中写入一个字符“c”，则worker线程监听到自己的管道读取fd可读，触发事件处理，而此是的事件处理 是：从自己的CQ_ITEM队列中取出CQ_ITEM对象（相当于收信，看看主线程给了自己什么东西），从4）可知，CQ_ITEM对象中包含 client fd，worker线程把此client fd加入到自己的event_base，从此负责该连接的读写工作。</li>
</ol>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/12/服务器相关/Memcached/Memcached线程模型/" data-id="cje2lrz8000e6pxblr9mczru3" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/基础/==与equals的区别" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/12/Java/基础/==与equals的区别/">==与equals的区别</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/12/Java/基础/==与equals的区别/" class="article-date"><time datetime="2017-08-12T02:09:45.000Z" itemprop="datePublished">2017-08-12</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><strong>==:对于基本类型来说，比较的是两个对象的值是否想等；对于引用类型来说，比较的是两个引用对象是否指向同一个对象（即两个对象的引用地址是否想等）<br>equals:该方法不能作用于基本类型的对象，比较的是两个引用对象的地址是否想等<br>注意：由于String，Integer，Byte等类重写了equals方法，所以相当于比较两个对象的值是否想等</strong></p>
<hr>
<p>在Java中游8种基本数据类型：</p>
<p>　　浮点型：float(4 byte), double(8 byte)</p>
<p>　　整型：byte(1 byte), short(2 byte), int(4 byte) , long(8 byte)</p>
<p>　　字符型: char(2 byte)</p>
<p>　　布尔型: boolean(JVM规范没有明确规定其所占的空间大小，仅规定其只能够取字面值”true”和”false”)</p>
<p>　　对于这8种基本数据类型的变量，变量直接存储的是“值”，因此在用关系操作符==来进行比较时，比较的就是 “值” 本身。要注意浮点型和整型都是有符号类型的，而char是无符号类型的（char类型取值范围为0~2^16-1).
　　</p>
<ol>
<li><strong>String类型的比较</strong><br>String类型比较不同对象内容是否相同，应该用equals，因为==用于比较引用类型和比较基本数据类型时具有不同的功能。</li>
</ol>
<p>分析如下：</p>
<p>例子一：对象不同，内容相同，”==”返回false，equals返回true<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"java"</span>);</div><div class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"java"</span>);</div><div class="line"></div><div class="line">System.out.println(s1==s2);            <span class="comment">//false</span></div><div class="line">System.out.println(s1.equals(s2));    <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>例子二：同一对象，”==”和equals结果相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String s1 = new String(&quot;java&quot;);</div><div class="line">String s2 = s1;</div><div class="line"></div><div class="line">System.out.println(s1==s2);            //true</div><div class="line">System.out.println(s1.equals(s2));    //true</div></pre></td></tr></table></figure></p>
<p>例子三：String作为一个“基本类型”来使用</p>
<p>如果值不相同，对象就不相同，所以”==” 和equals结果一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String s1 = &quot;java&quot;;</div><div class="line">String s2 = &quot;java&quot;;</div><div class="line"></div><div class="line">System.out.println(s1==s2);            //true</div><div class="line">System.out.println(s1.equals(s2));    //true</div></pre></td></tr></table></figure></p>
<p>如果String缓冲池内不存在与其指定值相同的String对象，那么此时虚拟机将为此创建新的String对象，并存放在String缓冲池内。</p>
<p>如果String缓冲池内存在与其指定值相同的String对象，那么此时虚拟机将不为此创建新的String对象，而直接返回已存在的String对象的引用。</p>
<p>　　</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/12/Java/基础/==与equals的区别/" data-id="cje2lrz1h003gpxbl5mxv7jwr" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-服务器相关/Memcached/memcached命令" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/12/服务器相关/Memcached/memcached命令/">memcached命令</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/12/服务器相关/Memcached/memcached命令/" class="article-date"><time datetime="2017-08-12T02:09:45.000Z" itemprop="datePublished">2017-08-12</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a> / <a class="article-category-link" href="/categories/服务器相关/Memcached/">Memcached</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="启动Memcached"><a href="#启动Memcached" class="headerlink" title="启动Memcached"></a>启动Memcached</h4><p>一般情况下，简单地可以使用类似如下形式，启动Memcached服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/bin/memcached -d -m 64 -I 20m -u root -l 192.168.4.86 -p 11211 -c 1024 -P /usr/local/memcached/memcached.pid</div></pre></td></tr></table></figure></p>
<p>上述命令行中，基于上面各个选项，以及其他一些选项的含义，说明如下表所示：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>指定memcached进程作为一个守护进程启动</td>
</tr>
<tr>
<td>-m <num></num></td>
<td>指定分配给memcached使用的内存，单位是MB</td>
</tr>
<tr>
<td>-u <username></username></td>
<td>运行memcached的用户</td>
</tr>
<tr>
<td>-l <ip_addr></ip_addr></td>
<td>监听的服务器IP地址，如果有多个地址的话，使用逗号分隔，格式可以为“IP地址:端口号”，例如：-l 指定192.168.0.184:19830,192.168.0.195:13542；端口号也可以通过-p选项指定</td>
</tr>
<tr>
<td>-p <num></num></td>
<td>Memcached监听的端口，要保证该端口号未被占用</td>
</tr>
<tr>
<td>-c <num></num></td>
<td>设置最大运行的并发连接数，默认是1024</td>
</tr>
<tr>
<td>-R <num></num></td>
<td>为避免客户端饿死（starvation），对连续达到的客户端请求数设置一个限额，如果超过该设置，会选择另一个连接来处理请求，默认为20</td>
</tr>
<tr>
<td>-k</td>
<td>设置锁定所有分页的内存，对于大缓存应用场景，谨慎使用该选项</td>
</tr>
<tr>
<td>-P</td>
<td>保存memcached进程的pid文件</td>
</tr>
<tr>
<td>-s <file></file></td>
<td>指定Memcached用于监听的UNIX socket文件</td>
</tr>
<tr>
<td>-a <perms></perms></td>
<td>设置-s选项指定的UNIX socket文件的权限</td>
</tr>
<tr>
<td>-U <num></num></td>
<td>指定监听UDP的端口，默认11211，0表示关闭</td>
</tr>
<tr>
<td>-M</td>
<td>当内存使用超出配置值时，禁止自动清除缓存中的数据项，此时Memcached不可以，直到内存被释放</td>
</tr>
<tr>
<td>-r</td>
<td>设置产生core文件大小</td>
</tr>
<tr>
<td>-f <factor></factor></td>
<td>用于计算缓存数据项的内存块大小的乘数因子，默认是1.25</td>
</tr>
<tr>
<td>-n</td>
<td>为缓存数据项的key、value、flag设置最小分配字节数，默认是48</td>
</tr>
<tr>
<td>-C</td>
<td>禁用CAS</td>
</tr>
<tr>
<td>-h</td>
<td>显示Memcached版本和摘要信息</td>
</tr>
<tr>
<td>-v</td>
<td>输出警告和错误信息</td>
</tr>
<tr>
<td>-vv</td>
<td>打印信息比-v更详细：不仅输出警告和错误信息，也输出客户端请求和响应信息</td>
</tr>
<tr>
<td>-i</td>
<td>打印libevent和Memcached的licenses信息</td>
</tr>
<tr>
<td>-t <threads></threads></td>
<td>指定用来处理请求的线程数，默认为4</td>
</tr>
<tr>
<td>-D <char></char></td>
<td>用于统计报告中Key前缀和ID之间的分隔符，默认是冒号“:”</td>
</tr>
<tr>
<td>-L</td>
<td>尝试使用大内存分页（pages）</td>
</tr>
<tr>
<td>-B <proto></proto></td>
<td>指定使用的协议，默认行为是自动协商（autonegotiate），可能使用的选项有auto、ascii、binary。</td>
</tr>
<tr>
<td>-I <size></size></td>
<td>覆盖默认的STAB页大小，默认是1M</td>
</tr>
<tr>
<td>-F</td>
<td>禁用flush_all命令</td>
</tr>
<tr>
<td>-o <options></options></td>
<td>指定逗号分隔的选项，一般用于用于扩展或实验性质的选项</td>
</tr>
</tbody>
</table>
<h3 id="停止Memcached"><a href="#停止Memcached" class="headerlink" title="停止Memcached"></a>停止Memcached</h3><p>可以通过Linux的如下命令查询到Memcached的进程号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -ef | grep memcached</div></pre></td></tr></table></figure></p>
<p>然后杀掉Memcached服务进程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kill -9 &lt;PID&gt;</div></pre></td></tr></table></figure></p>
<p>-9表示强制杀掉进程。</p>
<h4 id="Telnet客户端"><a href="#Telnet客户端" class="headerlink" title="Telnet客户端"></a>Telnet客户端</h4><p>Telnet客户端可以通过命令行的方式来监控查看Memcached服务器存储数据的情况。例如，Memcached的服务地址为192.168.4.86:11211，可以telnet到该服务端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">telnet 192.168.4.86 11211</div></pre></td></tr></table></figure></p>
<p>如果连接成功，可以使用如下一些命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stats命令</div></pre></td></tr></table></figure></p>
<p>该命令用于显示服务器信息、统计数据等，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">STAT pid 22362   //memcache服务器的进程ID</div><div class="line">STAT uptime 1469315  //服务器已经运行的秒数</div><div class="line">STAT time 1339671194   //服务器当前的unix时间戳</div><div class="line">STAT version 1.4.9   //memcache版本</div><div class="line">STAT libevent 1.4.9-stable  //libevent版本</div><div class="line">STAT pointer_size 64   //当前操作系统的指针大小（32位系统一般是32bit,64就是64位操作系统）</div><div class="line">STAT rusage_user 3695.485200     //进程的累计用户时间</div><div class="line">STAT rusage_system 14751.273465  //进程的累计系统时间</div><div class="line">STAT curr_connections 69     //服务器当前存储的items数量</div><div class="line">STAT total_connections 855430    //从服务器启动以后存储的items总数量</div><div class="line">STAT connection_structures 74    //服务器分配的连接构造数</div><div class="line">STAT reserved_fds 20</div><div class="line">STAT cmd_get 328806688   //get命令（获取）总请求次数</div><div class="line">STAT cmd_set 75441133    //set命令（保存）总请求次数</div><div class="line">STAT cmd_flush 34    //flush命令请求次数</div><div class="line">STAT cmd_touch 0     //touch命令请求次数</div><div class="line">STAT get_hits 253547177  //总命中次数</div><div class="line">STAT get_misses 75259511     //总未命中次数</div><div class="line">STAT delete_misses 4     //delete命令未命中次数</div><div class="line">STAT delete_hits 565730  //delete命令命中次数</div><div class="line">STAT incr_misses 0 //incr命令未命中次数</div><div class="line">STAT incr_hits 0 //incr命令命中次数</div><div class="line">STAT decr_misses 0  //decr命令未命中次数</div><div class="line">STAT decr_hits 0  //decr命令命中次数</div><div class="line">STAT cas_misses 0  //cas命令未命中次数</div><div class="line">STAT cas_hits 0  //cas命令命中次数</div><div class="line">STAT cas_badval 0    //使用擦拭次数</div><div class="line">STAT touch_hits 0    //touch命令未命中次数</div><div class="line">STAT touch_misses 0  //touch命令命中次数</div><div class="line">STAT auth_cmds 0     //认证命令处理的次数</div><div class="line">STAT auth_errors 0   //认证失败数目</div><div class="line">STAT bytes_read 545701515844     //总读取字节数（请求字节数）</div><div class="line">STAT bytes_written 1649639749866     //总发送字节数（结果字节数）</div><div class="line">STAT limit_maxbytes 2147483648   //分配给memcache的内存大小（字节）</div><div class="line">STAT accepting_conns 1   //服务器是否达到过最大连接（0/1）</div><div class="line">STAT listen_disabled_num 0   //失效的监听数</div><div class="line">STAT threads 4   //当前线程数</div><div class="line">STAT conn_yields 14  //连接操作主动放弃数目</div><div class="line">STAT hash_power_level 16   </div><div class="line">STAT hash_bytes 524288</div><div class="line">STAT hash_is_expanding 0</div><div class="line">STAT expired_unfetched 30705763</div><div class="line">STAT evicted_unfetched 0</div><div class="line">STAT bytes 61380700  //当前存储占用的字节数</div><div class="line">STAT curr_items 28786    //当前存储的数据总数</div><div class="line">STAT total_items 75441133    //启动以来存储的数据总数</div><div class="line">STAT evictions 0     //为获取空闲内存而删除的items数（分配给memcache的空间用满后需要删除旧的items来得到空间分配给新的items)</div><div class="line">STAT reclaimed 39957976  //已过期的数据条目来存储新数据的数目</div><div class="line">END</div></pre></td></tr></table></figure></p>
<p>stats命令有几个二级子项，说明如下表所示：   </p>
<table>
<thead>
<tr>
<th>命令</th>
<th>含义说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>stats slabs</td>
<td>显示各个slab的信息，包括chunk的大小、数目、使用情况等</td>
</tr>
<tr>
<td>stats items</td>
<td>显示各个slab中item的数目和最老item的年龄（最后一次访问距离现在的秒数）</td>
</tr>
<tr>
<td>stats detail [on\</td>
<td>off\</td>
<td>dump]</td>
<td>设置或者显示详细操作记录；<br>参数为on，打开详细操作记录；<br>参数为off，关闭详细操作记录；<br>参数为dump，显示详细操作记录（每一个键值get、set、hit、del的次数）</td>
</tr>
<tr>
<td>stats malloc</td>
<td>打印内存分配信息</td>
</tr>
<tr>
<td>stats sizes</td>
<td>打印缓存使用信息</td>
</tr>
<tr>
<td>stats reset</td>
<td>重置统计信息</td>
</tr>
</tbody>
</table>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>用法格式</th>
<th>含义说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>get</td>
<td>get <key></key></td>
<td>用于获取缓存的数据，键为key。</td>
</tr>
<tr>
<td>gets</td>
<td>gets <key></key></td>
<td>用于获取缓存的数据，键为一组key。</td>
</tr>
<tr>
<td>set</td>
<td>set <key> <flags> <exptime> <bytes> [noreply] <value></value></bytes></exptime></flags></key></td>
<td>向缓存中存储数据，不管key对应的值存在与否，都设置key对应的值</td>
</tr>
<tr>
<td>touch</td>
<td>touch <key> <exptime> [noreply]</exptime></key></td>
<td>更新缓存中key对应的值的过期时间。</td>
</tr>
<tr>
<td>delete</td>
<td>delete <key> [<time>] [noreply]</time></key></td>
<td>给定键key，删除缓存中key对应的数据。</td>
</tr>
<tr>
<td>add</td>
<td>add <key> <flags> <exptime> <bytes> [noreply] <value></value></bytes></exptime></flags></key></td>
<td>向缓存中存储数据，只有key对应的值不存在时，才会设置key对应的值。</td>
</tr>
<tr>
<td>replace</td>
<td>replace <key> <flags> <exptime> <bytes> [noreply] <value></value></bytes></exptime></flags></key></td>
<td>覆盖一个已经存在Key及其对应的Value，替换一定要保证替换后的值的长度原始长度相同，否则replace失败。</td>
</tr>
<tr>
<td>append</td>
<td>append <key> <flags> <exptime> <bytes> [noreply] <value></value></bytes></exptime></flags></key></td>
<td>在一个已经存在的数据值（value）上追加，是在数据值的后面追加。</td>
</tr>
<tr>
<td>prepend</td>
<td>prepend <key> <flags> <exptime> <bytes> [noreply] <value></value></bytes></exptime></flags></key></td>
<td>在一个已经存在的数据值（value）上追加，是在数据值的前面追加。</td>
</tr>
<tr>
<td>incr</td>
<td>incr <key> <value> [noreply]</value></key></td>
<td>计数命令，可以在原来已经存在的数字上进行累加求和，计算并存储新的数值。</td>
</tr>
<tr>
<td>decr</td>
<td>decr <key> <value> [noreply]</value></key></td>
<td>计数命令，可以在原来已经存在的数字上进行减法计算，计算并存储新的数值。</td>
</tr>
<tr>
<td>flush_all</td>
<td>flush_all [<time>] [noreply]</time></td>
<td>使缓存中的数据项失效，可选参数是在多少秒后失效。</td>
</tr>
<tr>
<td>version</td>
<td>version</td>
<td>返回Memcached服务器的版本信息。</td>
</tr>
<tr>
<td>quit</td>
<td>quit</td>
<td>退出telnet终端。</td>
</tr>
</tbody>
</table>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/12/服务器相关/Memcached/memcached命令/" data-id="cje2lrz8100e8pxblttnjxvjv" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/page/8/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/7/">7</a></li><li><a class="page-number" href="/page/8/">8</a></li><li class="active"><span class="page-number">9</span></li><li><a class="page-number" href="/page/10/">10</a></li><li><a class="page-number" href="/page/11/">11</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/24/">24</a></li><li><a class="page-next" rel="next" href="/page/10/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-module-inset">
  <h4>关于</h4>
  <p>该博客内的文章是博主在日常工作或者学习中总结出来，部分内容来自网络.</p>

</div>


  
  <div class="sidebar-module">
    <h4>分类</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Eclipse/">Eclipse</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Github/">Github</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/">Java</a><span class="sidebar-module-list-count">84</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/Cookie/">Cookie</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/JAXB/">JAXB</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/JavaMail/">JavaMail</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/分布式/">分布式</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/基础/">基础</a><span class="sidebar-module-list-count">21</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/数据类型/">数据类型</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/日记/">日记</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/时间日期/">时间日期</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/线程/">线程</a><span class="sidebar-module-list-count">17</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/网络NIO/">网络NIO</a><span class="sidebar-module-list-count">12</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/队列/">队列</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/集合/">集合</a><span class="sidebar-module-list-count">8</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Linux/">Linux</a><span class="sidebar-module-list-count">17</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Maven/">Maven</a><span class="sidebar-module-list-count">9</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/">Spring</a><span class="sidebar-module-list-count">60</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Application-Event/">Application Event</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/JPA/">JPA</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Security/">Security</a><span class="sidebar-module-list-count">22</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Spring-Boot/">Spring Boot</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Spring-Session/">Spring Session</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Task/">Task</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/spring-MVC/">spring MVC</a><span class="sidebar-module-list-count">17</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/spring-data-redis/">spring data redis</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/基础/">基础</a><span class="sidebar-module-list-count">5</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/前端技术相关/">前端技术相关</a><span class="sidebar-module-list-count">3</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/前端技术相关/forever/">forever</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/前端技术相关/javascript/">javascript</a><span class="sidebar-module-list-count">1</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/数据库相关/">数据库相关</a><span class="sidebar-module-list-count">20</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/数据库相关/mysql/">mysql</a><span class="sidebar-module-list-count">20</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/">服务器相关</a><span class="sidebar-module-list-count">29</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Hessian/">Hessian</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Hudson-Jenkins/">Hudson & Jenkins</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Memcached/">Memcached</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Nginx/">Nginx</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Tomcat/">Tomcat</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/red5/">red5</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/redis/">redis</a><span class="sidebar-module-list-count">13</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/resin/">resin</a><span class="sidebar-module-list-count">3</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/网络/">网络</a><span class="sidebar-module-list-count">9</span></li></ul>
  </div>



  


  

  
  <div class="sidebar-module">
    <h4>归档</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">二月 2018</a><span class="sidebar-module-list-count">45</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">十月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">62</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">125</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/02/">二月 2017</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>最近文章</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/2018/02/25/Java/基础/java8新特性/">java8新特性</a>
        </li>
      
        <li>
          <a href="/2018/02/25/Java/集合/HashSet原理/">HashSet原理</a>
        </li>
      
        <li>
          <a href="/2018/02/25/Java/分布式/分布式锁/">分布式锁</a>
        </li>
      
        <li>
          <a href="/2018/02/25/Java/集合/在List循环中删除元素/">在List循环中删除元素</a>
        </li>
      
        <li>
          <a href="/2018/02/25/Java/集合/Hashtable与ConcurrentHashMap区别/">Hashtable与ConcurrentHashMap区别</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2018 LeoChan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>



<script src="/js/script.js"></script>

</body>
</html>
