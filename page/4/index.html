<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LeoChan&#39;s 个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="描述啊">
<meta property="og:type" content="website">
<meta property="og:title" content="LeoChan&#39;s 个人博客">
<meta property="og:url" content="https://clq2owesome.github.io/page/4/index.html">
<meta property="og:site_name" content="LeoChan&#39;s 个人博客">
<meta property="og:description" content="描述啊">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeoChan&#39;s 个人博客">
<meta name="twitter:description" content="描述啊">
  
    <link rel="alternate" href="/atom.xml" title="LeoChan&#39;s 个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LeoChan&#39;s 个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术都是通用的，重要的是是否具有自主解决问题的能力！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://clq2owesome.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Spring/Spring Boot/多环境配置" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Spring/Spring Boot/多环境配置/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/Spring-Boot/">Spring Boot</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Spring/Spring Boot/多环境配置/">多环境配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="配置文件加载顺序"><a href="#配置文件加载顺序" class="headerlink" title="配置文件加载顺序"></a>配置文件加载顺序</h2><ol>
<li>在命令行中传入的参数</li>
<li>SPRING_APPLICATION_JSON中的属性。SPRING_APPLICATION_JSON是以JSON格式配置在系统环境变量中的内容</li>
<li>java:comp/env中的JNDI属性</li>
<li>java的系统属性，可以通过System.getproperties()获得的内容</li>
<li>操作系统的环境变量</li>
<li>通过random.*配置的随机属性</li>
<li>位于当前应用jar包之外，针对不同{profile}环境的配置文件内容，例如application-{profile}.properties或是YAML定义的配置文件</li>
<li>位于当前应用jar包之内，针对不同{profile}环境的配置文件内容，例如application-{profile}.properties或是YAML定义的配置文件</li>
<li>位于当前应用jar包之外的application.properties和YAML配置内容</li>
<li>位于当前应用jar包之内的application.properties和YAML配置内容</li>
<li>在@Configuration注解修改的类中，通过@PropertySource注解定义的属性</li>
<li>应用默认属性，使用SpringApplication.setDefaultProperties定义的内容</li>
</ol>
<p>优先级按上面的顺序由高到低，数字越小优先级越高</p>
<p>可以看到，其中第7项和第9项都是从应用jar包之外读取配置文件，所以，实现外部化配置的原理就是从此切入，为其指定外部配置文件的记载位置来取代jar包之内的配置内容。通过这样的实现，我们的工程在配置中就变的非常干净，只需在本地放置开发需要的配置即可，而不用关心其他环境的配置，由其对应环境的负责人去维护即可</p>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>使用命令<code>java -jar</code>来启动应用时，还可以在命令行中指定应用的参数，比如<code>java -jar xxx.jar --server.port=8888</code>，直接以命令行的方式来设置<code>server.port</code>属性，并将启动应用的端口设为8888</p>
<p>在命令行方式启动Spring Boot应用时，连续的两个减号–就是对application.properties中的属性值进行赋值的标识。所以，<code>java -jar xxx.jar --server.port=8888</code>命令，等价于在application.properties中添加属性server.port=8888</p>
<h2 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h2><p><strong>Spring Boot的默认配置文件位置为：src/main/resources/application.properties 或者 application.yml；Spring Boot默认会加载放置在src/main/resources目录或者类路径的/config下</strong></p>
<p>在Spring Boot中，多环境配置的文件名需要满足application-{profile}.properties的格式，其中{profile}对应你的环境标识，如下所示：</p>
<ul>
<li><strong>application-dev.properties</strong>（开发环境）</li>
<li><strong>application-test.properties</strong>（测试环境）</li>
<li><strong>application-prod.properties</strong>（生产环境）</li>
</ul>
<p>至于具体哪个配置文件会被加载，需要在application.properties文件中通过<strong>spring.profiles.active</strong>属性来设置，其值对应配置文件中的{profile}值。如spring.profiles.active=test就会加载application-test.properties配置文件内容</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>application.properties<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root=http://localhost</div><div class="line"></div><div class="line">#spring.profiles.active</div><div class="line">spring.profiles.active=dev</div></pre></td></tr></table></figure></p>
<ol>
<li>Controller<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Autowired  </div><div class="line">private Environment env;  </div><div class="line">           </div><div class="line">@RequestMapping(&quot;/testProfile&quot;)  </div><div class="line">public String testProfile()&#123;  </div><div class="line">    return env.getProperty(&quot;profile&quot;);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>测试：</p>
<ul>
<li>上述代码执行后的结果是：dev_envrimont</li>
<li>如果application.properties的配置改为：spring.profiles.active=prod，则结果是：prod_envrimont</li>
<li>如果application.properties的配置改为：spring.profiles.active=prod，而application.properties中也配置了profile=xxx（不管该配置配置在spring.profiles.active=prod的上方还是下方），这个时候结果是：prod_envrimont</li>
<li>如果application.properties的配置改为：spring.profiles.active=prod，而application.properties中也配置了profile=xxx（不管该配置配置在spring.profiles.active=prod的上方还是下方），但是application-prod.properties删掉了profile = prod_envrimont，这个时候结果是：xxx</li>
</ul>
<p>结论：</p>
<ul>
<li>各个环境公共的配置写在application.properties中</li>
<li>各个模块独有的配置配置在自己的application-{xxx}.properties文件中</li>
<li>程序读取的时候优先读取application.properties中选中的profile的配置，若读不到才会从application.properties去读</li>
</ul>
<h2 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h2><p>缺陷：无法通过@PropertySource注解来加载配置</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>spring boot中，可以通过在application.yml配置文件中，配置多个不同的profile，实现在不同的环境（比如开发、测试和生产环境）使用不同的配置变量。</p>
<p>具体配置如下（application.yml中的内容）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">server:  </div><div class="line">  port: 8082  </div><div class="line">  </div><div class="line"># 默认的profile为dev，其他环境通过指定启动参数使用不同的profile，比如：  </div><div class="line">#   测试环境：java -jar my-spring-boot.jar --spring.profiles.active=test  </div><div class="line">#   生产环境：java -jar my-spring-boot.jar --spring.profiles.active=prod  </div><div class="line">spring:  </div><div class="line">  profiles:  </div><div class="line">    active: dev  </div><div class="line">  </div><div class="line">---  </div><div class="line"># 开发环境配置  </div><div class="line">spring:  </div><div class="line">  profiles: dev  </div><div class="line">mysql:  </div><div class="line">  ipPort: localhost:3306  </div><div class="line">    </div><div class="line">---  </div><div class="line"># 测试环境配置  </div><div class="line">spring:  </div><div class="line">  profiles: test  </div><div class="line">mysql:  </div><div class="line">  ipPort: 192.168.0.12:8066  </div><div class="line">    </div><div class="line">---  </div><div class="line"># 生产环境配置  </div><div class="line">spring:  </div><div class="line">  profiles: prod  </div><div class="line">mysql:  </div><div class="line">  ipPort: 192.168.0.13:8066</div></pre></td></tr></table></figure></p>
<h2 id="启动Spring-Boot的方式"><a href="#启动Spring-Boot的方式" class="headerlink" title="启动Spring Boot的方式"></a>启动Spring Boot的方式</h2><ol>
<li>作为一个Java应用程序，可以直接通过运行拥有main函数的类来启动</li>
<li><p>通过maven执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn spring-boot:run命令</div></pre></td></tr></table></figure>
</li>
<li><p>在服务其上部署运行时，通常先使用<code>mvn install</code>将应用打包成jar包，再通过<code>java -jar xxx.jar</code>来启动应用</p>
</li>
</ol>
<p>通过指定启动参数使用不同的profile，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#   测试环境：Java -jar my-spring-boot.jar --spring.profiles.active=test</div><div class="line">#   生产环境：java -jar my-spring-boot.jar --spring.profiles.active=prod</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Spring/Spring Boot/多环境配置/" data-id="cjegeio7k00a6pfblrihgzi6u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux/jenkins安装和启动" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Linux/jenkins安装和启动/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Linux/jenkins安装和启动/">jenkins安装和启动</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>多种安装方式，参考<a href="https://www.ilanni.com/?p=12545" target="_blank" rel="external">https://www.ilanni.com/?p=12545</a> 或者 参考官网</p>
<p><a href="http://blog.csdn.net/wh211212/article/details/53644980" target="_blank" rel="external">http://blog.csdn.net/wh211212/article/details/53644980</a></p>
<h3 id="运行和停止Jenkins"><a href="#运行和停止Jenkins" class="headerlink" title="运行和停止Jenkins"></a>运行和停止Jenkins</h3><p>普通启动，关闭进程后jenkins关闭<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 启动Jenkins</div><div class="line">java -jar /usr/share/jenkins/jenkins.war     </div><div class="line"></div><div class="line"># 停止Jenkins</div><div class="line">按Ctrl+C 组合键</div></pre></td></tr></table></figure></p>
<p>后台启动，指定端口，指定log文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">参数：</div><div class="line">--httpPort：指定端口</div><div class="line">--daemon：后台启动</div><div class="line">--logfile：指定jenkins启动日志路径</div><div class="line"></div><div class="line">例一：</div><div class="line">java -jar /usr/share/jenkins/jenkins.war --httpPort=8081 --daemon</div><div class="line"></div><div class="line"></div><div class="line">例二：</div><div class="line">mkdir /var/log/jenkins</div><div class="line">java -jar /usr/local/src/jenkins.war --logfile=/var/log/jenkins/jenkins.log</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Linux/jenkins安装和启动/" data-id="cjegeio0z000fpfble8okhmjc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux/shell script" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Linux/shell script/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Linux/shell script/">shell script</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="编写shell-script的需要注意以下事项："><a href="#编写shell-script的需要注意以下事项：" class="headerlink" title="编写shell script的需要注意以下事项："></a>编写shell script的需要注意以下事项：</h3><ol>
<li>命令的执行是从上而下，从左而右地分析与执行</li>
<li>命令，参数间的多个空白都会被忽略掉</li>
<li>空白行也将被忽略掉，并且[tab]按键所得的空白同样视为空格键</li>
<li>如果读取到一个Enter符号（CR），就尝试开始执行该行（或该串）命令</li>
<li>至于如果一行的内容太多，则可以使用“\Enter”来扩展至下一行</li>
<li>“#”可以作为批注。任何加在#后面的数据将全部被视为批注文字而被忽略</li>
</ol>
<h3 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h3><ol>
<li><p><strong>直接命令执行</strong>：shell.sh文件必须具备可读与可执行（rx）的权限，然后：</p>
<ol>
<li>绝对路径：使用<code>/home/dmtsai/shell.sh</code>来执行命令</li>
<li>相对命令：假设工作目录在/home/dmtsai/,则使用<code>./shell.sh</code>来执行</li>
<li>变量“PATH”功能：将shell.sh放在PATH指定的目录内，例如：~/bin/</li>
</ol>
</li>
<li><p><strong>以bash进程来执行</strong>：通过<code>bash shell.sh</code> 或 <code>sh shell.sh</code>来执行</p>
</li>
</ol>
<h3 id="脚本规范"><a href="#脚本规范" class="headerlink" title="脚本规范"></a>脚本规范</h3><ol>
<li><p>第一行<code>#!/bin/bash</code>声明这个script使用的shell名称</p>
<p> 因为我们使用的是bash，所以必须要以<code>#!/bin/bash</code>来声明这个内的语法使用bash的语法。那么当这个程序被执行时，它就能够加载bash的相关环境配置文件（一般来说就是non-login shell的~/.bashrc），并且执行bash来执行bash使我们下面的命令能够执行。这很重要的（在很多情况中，如果没有设置好这一行，那么该程序很可能会无法执行，因为系统可能无法判断该程序需要使用什么shell来执行）</p>
</li>
<li><p>程序内容的说明</p>
<p> 整个script当中，除了第一行的<code>#!</code>是用来声明shell的之外，其他的#都是“批注”用途。一般来说，建议你一定要养成说明该script的内容和功能，版本信息，作者与联系方式，建立日期，历史记录等习惯，这将有助于将来程序的改写与调试</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"># 功能：</div><div class="line">#   这里是功能描述</div><div class="line"># 历史：</div><div class="line">#   时间 作者 版本号</div></pre></td></tr></table></figure>
</li>
<li><p>主要环境变量的声明</p>
<p> 建议务必要将一些重要的环境变量设置好，PATH与LANG（如果有使用到输出相关的信息时）是当中最重要的！如此一来，则可让我们这个程序在进行时可以直接执行一些外部命令，而不必写绝对路径</p>
</li>
<li><p>主要程序部分</p>
<p> 就将主要的程序写好即可</p>
</li>
<li><p>告知执行结果</p>
<p> 可以利用exit这个命令来让程序中断，并且回传一个数值给系统。例如使用exit 0，这代表离开script并且回传一个0给系统。进一步，可以利用exit n（n为数字）的功能，自定义错误信息，让程序变得更加聪明</p>
</li>
</ol>
<p>注意：<strong>使用上述的方式执行script时，该script都会使用一个新的bash环境来执行脚本内的命令</strong>.</p>
<p>也就是说，<strong>使用这种执行方式时，其实script是在子进程的bash内执行的。当子进程完成后，子进程内的各项变量或操作将会结束而不会传回到父进程中</strong></p>
<p>如下图：<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/WechatIMG2436.jpeg" alt="image"><br>​    </p>
<h5 id="使用source来执行脚本：在父进程中执行"><a href="#使用source来执行脚本：在父进程中执行" class="headerlink" title="使用source来执行脚本：在父进程中执行"></a>使用source来执行脚本：在父进程中执行</h5><p><img src="https://raw.githubusercontent.com/clq2owesome/image/master/WechatIMG2438.jpeg" alt="image"></p>
<h3 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var=$((运算内容))</div></pre></td></tr></table></figure>
<h3 id="自定义变量转成环境变量（export）"><a href="#自定义变量转成环境变量（export）" class="headerlink" title="自定义变量转成环境变量（export）"></a>自定义变量转成环境变量（export）</h3><p><strong>子进程仅会继承父进程的环境变量，子进程不会继承父进程的自定义变量</strong>，所以你原本bash中的自定义变量在进入了子进程后就会消失不见，一直到你离开子进程并回到原本的父进程后，这个变量才会又出现</p>
<p>换个角度来说，如果我能将自定义变量变成环境变量的话，那不就可以让该变量值继续存在于子进程了？如果想要让该变量内容继续在子进程中使用，那么就请执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export 变量名称</div></pre></td></tr></table></figure></p>
<p>为什么环境变量的数据可以被子进程所引用呢？这是因为内存配置的关系。理论上是这样的：</p>
<ul>
<li>当启动一个shell，操作系统会分配一记忆块给shell使用，此内存内的变量可让子进程取用</li>
<li>若在父进程利用export功能，可以让自定义变量的内容写到上述的记忆块当中（环境变量）</li>
<li>当加载另一个shell时（即启动子进程，而离开原本的父进程了），子shell可以将父shell的环境变量所在的记忆块导入自己的环境变量块当中</li>
</ul>
<h3 id="关于本shell的PID"><a href="#关于本shell的PID" class="headerlink" title="$(关于本shell的PID)"></a>$(关于本shell的PID)</h3><p>“$”本身也是个变量，这个代表的是目前这个shell的线程代号，即是所谓的PID（Process ID）</p>
<h3 id="（关于上个执行命令的回传码）"><a href="#（关于上个执行命令的回传码）" class="headerlink" title="?（关于上个执行命令的回传码）"></a>?（关于上个执行命令的回传码）</h3><p>问号也是一个特殊的变量，在bash里面这个变量很重要。<strong>这个变量是上一个执行的命令所回传的值</strong>。当我们执行某些命令时，这些命令都会回传一个执行后的代码。一般来说，<strong>如果成功执行该命令，则会回传一个0值，如果执行过程中发生错误，就会回传“错误代码”才对。一般就是以非0的数值来替代</strong></p>
<h3 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h3><h6 id="关于某个文件名的“文件类型”判断"><a href="#关于某个文件名的“文件类型”判断" class="headerlink" title="关于某个文件名的“文件类型”判断"></a>关于某个文件名的“文件类型”判断</h6><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-e</td>
<td>该文件名是否存在（常用）</td>
</tr>
<tr>
<td>-f</td>
<td>该文件名是否存在且为文件（file）（常用）</td>
</tr>
<tr>
<td>-d</td>
<td>是否存在且为目录（常用）</td>
</tr>
<tr>
<td>-b</td>
<td>是否存在且为一个block device设备</td>
</tr>
<tr>
<td>-c</td>
<td>是否存在且为一个character device设备</td>
</tr>
<tr>
<td>-S</td>
<td>是否存在且为一个Socket文件</td>
</tr>
<tr>
<td>-p</td>
<td>是否存在且为一个FIFO（pipe）文件</td>
</tr>
<tr>
<td>-L</td>
<td>是否存在且为一个连接文件</td>
</tr>
</tbody>
</table>
<h6 id="关于文件的权限检测"><a href="#关于文件的权限检测" class="headerlink" title="关于文件的权限检测"></a>关于文件的权限检测</h6><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-r</td>
<td>检测该文件是否存在且具有“可读”的权限</td>
</tr>
<tr>
<td>-w</td>
<td>检测该文件是否存在且具有“可写”的权限</td>
</tr>
<tr>
<td>-x</td>
<td>检测该文件是否存在且具有“可执行”的权限</td>
</tr>
<tr>
<td>-u</td>
<td>检测该文件是否存在且具有“SUID”的属性</td>
</tr>
<tr>
<td>-g</td>
<td>检测该文件是否存在且具有“SGID”的属性</td>
</tr>
<tr>
<td>-k</td>
<td>检测该文件是否存在且具有“Sticky bit”的属性</td>
</tr>
<tr>
<td>-s</td>
<td>检测该文件是否存在且为“非空白文件”</td>
</tr>
</tbody>
</table>
<h6 id="关于文件的权限检测-1"><a href="#关于文件的权限检测-1" class="headerlink" title="关于文件的权限检测"></a>关于文件的权限检测</h6><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-nt</td>
<td>判断file1是否比file2新</td>
</tr>
<tr>
<td>-ot</td>
<td>判断file1是否比file2旧</td>
</tr>
<tr>
<td>-ef</td>
<td>判断file1与file2是否为同一文件，可用在判断hard link的判定上。主要意义在于判定两个文件是否均指向同一个node</td>
</tr>
</tbody>
</table>
<h6 id="关于两个整数之间的判定"><a href="#关于两个整数之间的判定" class="headerlink" title="关于两个整数之间的判定"></a>关于两个整数之间的判定</h6><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-eq</td>
<td>两数值相等</td>
</tr>
<tr>
<td>-ne</td>
<td>两数值不等</td>
</tr>
<tr>
<td>-gt</td>
<td>n1大于n2</td>
</tr>
<tr>
<td>-lt</td>
<td>n1小于n2</td>
</tr>
<tr>
<td>-ge</td>
<td>n1大于等于n2</td>
</tr>
<tr>
<td>-le</td>
<td>n1小于等于n2</td>
</tr>
</tbody>
</table>
<h6 id="判定字符串的数据"><a href="#判定字符串的数据" class="headerlink" title="判定字符串的数据"></a>判定字符串的数据</h6><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Test -Z string</td>
<td>判定字符串是否为0，若string为空字符串，则为true</td>
</tr>
<tr>
<td>Test -n string</td>
<td>判定字符串是否为非0，若string为空字符串，则为false<br>注：-n也可以省略</td>
</tr>
<tr>
<td>test str1 = str2</td>
<td>判定str1是否等于str2，若相等，则回传true</td>
</tr>
<tr>
<td>test str1 != str2</td>
<td>判定str1是否不等于str2，若相等，则返回false</td>
</tr>
</tbody>
</table>
<h6 id="多重条件判定"><a href="#多重条件判定" class="headerlink" title="多重条件判定"></a>多重条件判定</h6><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>两个条件同时成立！例如test -r file -a -x file，则file同时具有r与x的权限时，才返回true</td>
</tr>
<tr>
<td>-o</td>
<td>任何一个条件成立！例如test -r file -o -x file，则file具有r或x权限时，就会返回true</td>
</tr>
<tr>
<td>!</td>
<td>反向状态！例如 test ! -x file，当file不具有x时，就会回传true</td>
</tr>
</tbody>
</table>
<h3 id="利用判断符号"><a href="#利用判断符号" class="headerlink" title="利用判断符号[]"></a>利用判断符号[]</h3><p>中括号的用法与test几乎一模一样，只是中括号比较常用在条件判断式 if…then…fi 的情况</p>
<p>例如：如果想要知道$HOME这个变量是否为空的，可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># [ -z &quot;$HOME&quot; ];echo $?</div><div class="line">1</div></pre></td></tr></table></figure></p>
<p>必须要注意：</p>
<ol>
<li>在中括号[]内的每个组件的两端都需要有空格符来分隔</li>
<li>中中括号内的变量，最好都以双引号括起来</li>
<li>在中括号内的常量，最好都以单或双引号括起来</li>
</ol>
<h3 id="shell-script-的默认变量"><a href="#shell-script-的默认变量" class="headerlink" title="shell script 的默认变量"></a>shell script 的默认变量</h3><p>script针对参数已经有设置好一些变量名称了，对应如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/path/to/scriptname opt1 opt2 opt3 opt4</div><div class="line">     $0              $1   $2   $3   $4</div></pre></td></tr></table></figure></p>
<p>除了这些数字的变量之外，我们还有一些较为特殊的变量可以在script内使用来调用这些参数</p>
<ul>
<li>$#:代表后接的参数的个数</li>
<li>$@:代表“$1”，“$2”，“$3”，“$4”之意，每个变量是独立的（用双引号括起来）</li>
<li>$*:代表“”$1c$2c$3c$4””，其中c为分隔字符，默认为空格键，所以本例中代表“”$1 $2 $3 $4””之意</li>
</ul>
<h3 id="判断式"><a href="#判断式" class="headerlink" title="判断式"></a>判断式</h3><h6 id="单层，简单条件判断式"><a href="#单层，简单条件判断式" class="headerlink" title="单层，简单条件判断式"></a>单层，简单条件判断式</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if [条件];then</div><div class="line">    当条件成立时，可以进行的命令工作内容</div><div class="line">fi &lt;---结束之意</div></pre></td></tr></table></figure>
<h6 id="多重，复杂条件判断式"><a href="#多重，复杂条件判断式" class="headerlink" title="多重，复杂条件判断式"></a>多重，复杂条件判断式</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">if [条件]; then</div><div class="line">    当条件成立时，可以进行的命令工作内容</div><div class="line">elif [条件]; then</div><div class="line">    当条件成立时，可以进行的命令工作内容</div><div class="line">fi &lt;---结束之意</div><div class="line"></div><div class="line">或者</div><div class="line"></div><div class="line">if [条件]; then</div><div class="line">    当条件成立时，可以进行的命令工作内容</div><div class="line">elif [条件]; then</div><div class="line">    当条件成立时，可以进行的命令工作内容</div><div class="line">else </div><div class="line">    当条件成立时，可以进行的命令工作内容</div><div class="line">fi &lt;---结束之意</div><div class="line"></div><div class="line">例如：</div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">if [ &quot;$1&quot; == &quot;hello&quot; ]; then</div><div class="line">	echo &quot;Hello, how are you?&quot;</div><div class="line">elif [ &quot;$1&quot; == &quot;&quot; ]; then</div><div class="line">	echo &quot;you must input params, ex&gt; &#123;$0 someword&#125;&quot;</div><div class="line">else </div><div class="line">	echo &quot;the only params is &apos;hello&apos;, ex&gt; &#123;$0 hello&#125;&quot;</div><div class="line">fi</div></pre></td></tr></table></figure>
<h3 id="netstat-简单使用"><a href="#netstat-简单使用" class="headerlink" title="netstat 简单使用"></a>netstat 简单使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">~# netstat -tuln</div><div class="line">Active Internet connections (only servers)</div><div class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </div><div class="line">tcp        0      0 127.0.0.1:8005          0.0.0.0:*               LISTEN     </div><div class="line">tcp        0      0 0.0.0.0:8009            0.0.0.0:*               LISTEN     </div><div class="line">tcp        0      0 127.0.0.1:6379          0.0.0.0:*               LISTEN     </div><div class="line">tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN     </div><div class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN     </div><div class="line">tcp        0      0 0.0.0.0:8081            0.0.0.0:*               LISTEN     </div><div class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     </div><div class="line">tcp6       0      0 :::3306                 :::*                    LISTEN     </div><div class="line">tcp6       0      0 :::3000                 :::*                    LISTEN     </div><div class="line">tcp6       0      0 :::88                   :::*                    LISTEN     </div><div class="line">udp        0      0 0.0.0.0:33848           0.0.0.0:*                          </div><div class="line">udp        0      0 0.0.0.0:5353            0.0.0.0:*                          </div><div class="line">udp        0      0 172.18.79.196:123       0.0.0.0:*                          </div><div class="line">udp        0      0 127.0.0.1:123           0.0.0.0:*                          </div><div class="line">udp        0      0 0.0.0.0:123             0.0.0.0:*                          </div><div class="line">udp6       0      0 :::123                  :::*</div></pre></td></tr></table></figure>
<p>上面的重点是Local Address（本地主机的IP与端口对应）那个字段，它代表的是本机所启动的网络服务。IP的部分说明的是该服务位于哪个接口上，若为127.0.0.1则是针对本机开放，若是0.0.0.0 或 ::: 则代表对整个Internet开发。每个端口都有其特定的网络服务，几个常见与相关网络服务的关系是：</p>
<ul>
<li>80:www</li>
<li>22:ssh</li>
<li>21:ftp</li>
<li>25:mail</li>
<li>111:RPC（远程过程调用）</li>
<li>631:CUPS（打印服务功能）</li>
</ul>
<h3 id="利用case…esac判断"><a href="#利用case…esac判断" class="headerlink" title="利用case…esac判断"></a>利用case…esac判断</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">case $变量名称 in </div><div class="line">    &quot;第一个变量内容&quot;) &lt;==每个变量内容建议用双引号括起来，关键字则为小括号</div><div class="line">    程序段</div><div class="line">    ;;</div><div class="line">    </div><div class="line">    &quot;第二个变量内容&quot;)</div><div class="line">    程序段</div><div class="line">    ;;</div><div class="line">    </div><div class="line">    *) &lt;==最后一个变量内容都会用*来代表所有其他值，不包含第一个变量内容与第二个变量内容的其他程序执行段</div><div class="line">    ;;</div><div class="line">esac  &lt;== case反过来写，表示结尾</div><div class="line"></div><div class="line">例如：</div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">case $1 in </div><div class="line">	&quot;hello&quot;)</div><div class="line">		echo &quot;你好&quot;</div><div class="line">		;;</div><div class="line">	</div><div class="line">	&quot;&quot;)</div><div class="line">		echo &quot;请输入参数：ex&gt; &#123;$0 someword&#125;&quot;</div><div class="line">		;;</div><div class="line">	</div><div class="line">	*)</div><div class="line">		echo &quot;usage $0 &#123;hello&#125;&quot;</div><div class="line">		;;</div><div class="line">esac</div></pre></td></tr></table></figure>
<p>每一个变量内容的程序段最后都需要两个分号（;;）来代表该程序段落的结束，这很重要</p>
<p>使用“case $变量 in”这个语法中，当中的那个“$变量”大致有两种取得的方式：</p>
<ul>
<li>直接执行式：例如上面提到的，利用“script.sh variable”的方式来直接给予$1这个变量的内容，这也是在/etc/init.d目录下大多数程序的设计方式</li>
<li>交互式：通过read这个命令来让用户输入变量的内容</li>
</ul>
<h6 id="交互式"><a href="#交互式" class="headerlink" title="交互式"></a>交互式</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">echo &quot;this program will print your selection&quot;</div><div class="line"># 交互式</div><div class="line">read -p &quot;input your choice:&quot; choice</div><div class="line">case $choice in</div><div class="line">	&quot;one&quot;)</div><div class="line">		echo &quot;your choice is one&quot;</div><div class="line">		;;</div><div class="line">	</div><div class="line">	&quot;two&quot;)</div><div class="line">		echo &quot;your choice is two&quot;</div><div class="line">		;;</div><div class="line">		</div><div class="line">	&quot;three&quot;)</div><div class="line">	echo &quot;your choice is three&quot;</div><div class="line">	;;</div><div class="line">	</div><div class="line">	*)</div><div class="line">		echo &quot;usage $0 &#123;one|two|three&#125;&quot;</div><div class="line">		;;</div><div class="line">esac</div></pre></td></tr></table></figure>
<h6 id="直接执行式"><a href="#直接执行式" class="headerlink" title="直接执行式"></a>直接执行式</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">echo &quot;this program will print your selection&quot;</div><div class="line"></div><div class="line">case $1 in </div><div class="line">	&quot;one&quot;)</div><div class="line">		echo &quot;your choice is one&quot;</div><div class="line">		;;</div><div class="line">	</div><div class="line">	&quot;two&quot;)</div><div class="line">		echo &quot;your choice is two&quot;</div><div class="line">		;;</div><div class="line">		</div><div class="line">	&quot;three&quot;)</div><div class="line">	echo &quot;your choice is three&quot;</div><div class="line">	;;</div><div class="line">	</div><div class="line">	*)</div><div class="line">		echo &quot;usage $0 &#123;one|two|three&#125;&quot;</div><div class="line">		;;</div><div class="line">esac</div></pre></td></tr></table></figure>
<h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function fname() &#123;</div><div class="line">    程序段</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为shell script 的执行方式是由上而下，由左而右，因此在shell script当中的function的设置一定要在程序最前面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">echo &quot;this program will print your selection&quot;</div><div class="line">function printit() &#123;</div><div class="line">	echo -n &quot;your choice is &quot;  # 加上-n可以不断行继续在同一行显示</div><div class="line">&#125;</div><div class="line"># 直接执行式</div><div class="line">case $1 in </div><div class="line">	&quot;one&quot;)</div><div class="line">		printit; echo $1 | tr &apos;a-z&apos; &apos;A-Z&apos; # 将参数大小写转换</div><div class="line">		;;</div><div class="line">	</div><div class="line">	&quot;two&quot;)</div><div class="line">		printit; echo $1 | tr &apos;a-z&apos; &apos;A-Z&apos;</div><div class="line">		;;</div><div class="line">		</div><div class="line">	&quot;three&quot;)</div><div class="line">		printit; echo $1 | tr &apos;a-z&apos; &apos;A-Z&apos;</div><div class="line">		;;</div><div class="line">	</div><div class="line">	*)</div><div class="line">		echo &quot;usage $0 &#123;one|two|three&#125;&quot;</div><div class="line">		;;</div><div class="line">esac</div></pre></td></tr></table></figure></p>
<p>function 也是拥有内置变量的，它的内置变量与shell script很类似，函数名称代表$0,而后续的变量也是以$1,$2…来替代的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">echo &quot;this program will print your selection&quot;</div><div class="line">function printit() &#123;</div><div class="line">	echo -n &quot;your choice is $1 &quot;  # 加上-n可以不断行继续在同一行显示</div><div class="line">&#125;</div><div class="line"># 直接执行式</div><div class="line">case $1 in </div><div class="line">	&quot;one&quot;)</div><div class="line">		printit 1; echo $1 | tr &apos;a-z&apos; &apos;A-Z&apos; # 将参数大小写转换</div><div class="line">		;;</div><div class="line">	</div><div class="line">	&quot;two&quot;)</div><div class="line">		printit 2; echo $1 | tr &apos;a-z&apos; &apos;A-Z&apos;</div><div class="line">		;;</div><div class="line">		</div><div class="line">	&quot;three&quot;)</div><div class="line">		printit 3; echo $1 | tr &apos;a-z&apos; &apos;A-Z&apos;</div><div class="line">		;;</div><div class="line">	</div><div class="line">	*)</div><div class="line">		echo &quot;usage $0 &#123;one|two|three&#125;&quot;</div><div class="line">		;;</div><div class="line">esac</div></pre></td></tr></table></figure></p>
<h3 id="循环（loop）"><a href="#循环（loop）" class="headerlink" title="循环（loop）"></a>循环（loop）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># 当condition成立时开始循环</div><div class="line">while [condition]</div><div class="line">do  &lt;== do是循环的开始</div><div class="line">    程序段</div><div class="line">done  &lt;== done 是循环的结束</div><div class="line"></div><div class="line"></div><div class="line"># 当condition 成立时结束循环</div><div class="line">until [condition]</div><div class="line">do  </div><div class="line">    程序段</div><div class="line">done</div></pre></td></tr></table></figure>
<h3 id="for…do…done（固定循环）"><a href="#for…do…done（固定循环）" class="headerlink" title="for…do…done（固定循环）"></a>for…do…done（固定循环）</h3><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for var in con1 con2 con3 ...</div><div class="line">do </div><div class="line">    程序段</div><div class="line">done</div></pre></td></tr></table></figure></p>
<p>以上来的语法来说，这个$var 的变量内容在循环工作时：</p>
<ol>
<li>第一次循环时，$var的内容为con1</li>
<li>第二次循环时，$var的内容为con2</li>
<li>第三次循环时，$var的内容为con3</li>
</ol>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for animal in dog cat elepant</div><div class="line">do </div><div class="line">	echo &quot;there are $&#123;animal&#125;s...&quot;</div><div class="line">done</div></pre></td></tr></table></figure></p>
<h3 id="for…do…done数值处理"><a href="#for…do…done数值处理" class="headerlink" title="for…do…done数值处理"></a>for…do…done数值处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(( 初始值; 限制值; 执行步长))</div><div class="line">do</div><div class="line">    程序段</div><div class="line">done</div></pre></td></tr></table></figure>
<p>这种语法适合于数值方式的运算当中，在for后面的括号内的三串内容意义为：</p>
<ol>
<li>初始值：某个变量在循环当中的初始值，直接以类似i=1设置好</li>
<li>限制值：当变量的值在这个限制值的范围内，就继续进行循环，例如i&lt;=100</li>
<li>执行步长：每做一次循环时变量的变化值，例如i=i+1</li>
</ol>
<h3 id="shell-script的追踪与调试"><a href="#shell-script的追踪与调试" class="headerlink" title="shell script的追踪与调试"></a>shell script的追踪与调试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sh [-nvx] scripts.sh</div><div class="line">参数：</div><div class="line">-n：不要执行script，仅查询语法的问题</div><div class="line">-v：在执行script前，先将script的内容输出到屏幕上</div><div class="line">-x：将使用到的script内容显示到屏幕上，这是很有用的参数</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Linux/shell script/" data-id="cjegeio13000npfbl49b9li0r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux/shell 变量" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Linux/shell 变量/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Linux/shell 变量/">shell 变量</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是变量"><a href="#什么是变量" class="headerlink" title="什么是变量"></a>什么是变量</h3><p>变量就是以一组文件或符号等，来替代一些设置或者是一串保留的数据</p>
<p>可以使用<code>echo</code>这个命令来显示变量，但是变量在被显示时，前面必须要加上字符<code>$</code>或者以<code>${变量}</code>的方式来显示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">echo $PATH</div><div class="line">echo $&#123;PATH&#125;</div></pre></td></tr></table></figure></p>
<h3 id="变量的设置规则"><a href="#变量的设置规则" class="headerlink" title="变量的设置规则"></a>变量的设置规则</h3><p>在bash当中，当一个变量名称尚未被设置时，默认的内容是“空”的，另外变量在设置时，还是需要符合某些规定的，否则会设置失败</p>
<ol>
<li><p>变量与变量内容以一个等号“=”来连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myname=VBird</div></pre></td></tr></table></figure>
</li>
<li><p>等号两边不能直接接空格符，如下显示是错误的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myname= VBird</div><div class="line">myname=VBird Tsai</div></pre></td></tr></table></figure>
</li>
<li><p>变量的名称只能是英文字母与数字，但是开头字符不能是数字，如下为错误的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2myname=VBird</div></pre></td></tr></table></figure>
</li>
<li><p>变量的内容若有空格符号可使用双引号””或者单引号’’将变量内容结合起来，但是</p>
<ul>
<li><p>双引号内的特殊字符如$等，可以保持原本的特性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var=&quot;lang is $LANG&quot;</div><div class="line">echo $var 输出为:lang is zh_CN.UTF-8</div></pre></td></tr></table></figure>
</li>
<li><p>单引号内的特殊字符则仅为一般字符（纯文本）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var=&apos;lang is $LANG&apos;</div><div class="line">echo $var 输出为:lang is $LANG</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>可用转义字符“\”将特殊符号（如[Enter],$,空格符,! 等）变为一般字符</p>
</li>
<li><p>在一串命令中，还需要通过其他的命令提供信息，可以使用反单引号“`命令`”或“$(命令)”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">test=$(echo $PATH)</div><div class="line">echo $test 输出PATH的内容</div></pre></td></tr></table></figure>
</li>
<li><p>若该变量为了增加变量内容时，则可使用“$变量名称”或“${变量}”累加内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PATH=&quot;$PATH&quot;:/home/bin</div></pre></td></tr></table></figure>
</li>
<li><p>若该变量需要在其他子进程执行，则需要以<code>export</code>来使变量变成环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PATH</div></pre></td></tr></table></figure>
</li>
<li><p>通常大写字符为系统默认变量，自行设置变量可以使用小写字符，方便判断</p>
</li>
<li>取消变量的方法为使用“unset变量名称”<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unset myname</div></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：在一串命令中，在反单引号（`）之内的命令将会被先执行，而其执行出来的结果将作为外部的输入信息</p>
<h3 id="环境变量的功能"><a href="#环境变量的功能" class="headerlink" title="环境变量的功能"></a>环境变量的功能</h3><h4 id="用env查看环境变量与常见环境变量说明"><a href="#用env查看环境变量与常见环境变量说明" class="headerlink" title="用env查看环境变量与常见环境变量说明"></a>用env查看环境变量与常见环境变量说明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">env</div><div class="line">-------------------------------</div><div class="line">TERM_PROGRAM=Apple_Terminal</div><div class="line">SHELL=/bin/bash</div><div class="line">TERM=xterm-256color</div><div class="line">CATALINA_HOME=/Users/chenliqiang/software/apache-tomcat-test</div><div class="line">TMPDIR=/var/folders/mx/gn0s9skj0jzgxdzn68wtj8_h0000gn/T/</div><div class="line">Apple_PubSub_Socket_Render=/private/tmp/com.apple.launchd.ElGvcw57Yf/Render</div><div class="line">TERM_PROGRAM_VERSION=400</div><div class="line">TERM_SESSION_ID=60C62703-2490-444F-86A8-3C0827EC0DF0</div><div class="line">USER=chenliqiang</div><div class="line">SSH_AUTH_SOCK=/private/tmp/com.apple.launchd.jD69alTKH6/Listeners</div><div class="line">MAVEN_HOME=/usr/local/Cellar/maven/3.5.2</div><div class="line">PATH=/Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Home/bin:/usr/local/Cellar/maven/3.5.2/bin:/Users/chenliqiang/software/apache-tomcat-test/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</div><div class="line">PWD=/Users/chenliqiang</div><div class="line">JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Home</div><div class="line">LANG=zh_CN.UTF-8</div><div class="line">XPC_FLAGS=0x0</div><div class="line">XPC_SERVICE_NAME=0</div><div class="line">SHLVL=1</div><div class="line">HOME=/Users/chenliqiang</div><div class="line">LOGNAME=chenliqiang</div><div class="line">CLASSPATH=.:/Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Home/lib/tools.jar:/Users/chenliqiang/software/apache-tomcat-test/lib</div><div class="line">_=/usr/bin/env</div></pre></td></tr></table></figure>
<h4 id="查看所有变量（含环境变量和自定义变量）（set）"><a href="#查看所有变量（含环境变量和自定义变量）（set）" class="headerlink" title="查看所有变量（含环境变量和自定义变量）（set）"></a>查看所有变量（含环境变量和自定义变量）（set）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set</div></pre></td></tr></table></figure>
<h3 id="变量键盘的读取，数组与声明（read，array，declare）"><a href="#变量键盘的读取，数组与声明（read，array，declare）" class="headerlink" title="变量键盘的读取，数组与声明（read，array，declare）"></a>变量键盘的读取，数组与声明（read，array，declare）</h3><h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><p>要读取来自键盘输入的变量，就需要用read命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">read [-pt] variable</div><div class="line">参数：</div><div class="line">-p：后面可以接提示符</div><div class="line">-t：后面可以接等待的“秒数”，这个比较有趣，不会一直等待用户</div><div class="line"></div><div class="line">chenliqiangdeMacBook-Pro:~ chenliqiang$ read -p &quot;Please keyin your name:&quot; -t 30 atest</div><div class="line">Please keyin your name:test</div><div class="line">chenliqiangdeMacBook-Pro:~ chenliqiang$ echo $atest</div><div class="line">test</div></pre></td></tr></table></figure></p>
<h4 id="声明变量类型（declare）"><a href="#声明变量类型（declare）" class="headerlink" title="声明变量类型（declare）"></a>声明变量类型（declare）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">declare [-aixr] variable</div><div class="line">参数：</div><div class="line">-a：将后面名为variable的变量定义成为数组类型</div><div class="line">-i：将后面名为variable的变量定义成为整数数字类型</div><div class="line">-x：用法与export一样，就是将variable变成环境变量，把-改为+可以将variable变为非环境变量</div><div class="line">-r：将变量设置为readonly类型，该变量不可被更改内容，也不能重设</div></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>变量类型默认为“字符串”，所以若不指定变量类型，则1+2为一个“字符串”而不是“计算式”</li>
<li>bash环境中的数值运算，默认最多仅能达到整数类型，所以1/3的结果是0</li>
</ul>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组的设置方式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var[index]=content</div></pre></td></tr></table></figure></p>
<p>一般来说，建议直接以<code>${数组}</code>的方式来读取，会比较正确无误</p>
<h3 id="变量的测试与内容替换"><a href="#变量的测试与内容替换" class="headerlink" title="变量的测试与内容替换"></a>变量的测试与内容替换</h3><table>
<thead>
<tr>
<th>变量设置方式</th>
<th>str没有设置</th>
<th>str为空字符串</th>
<th>str已设置为非空字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>var=${str-expr}</td>
<td>var=expr</td>
<td>var=</td>
<td>var=$str</td>
</tr>
<tr>
<td>var=${str:-expr}</td>
<td>var=expr</td>
<td>var=expr</td>
<td>var=$str</td>
</tr>
<tr>
<td>var=${str+expr}</td>
<td>var=</td>
<td>var=expr</td>
<td>var=expr</td>
</tr>
<tr>
<td>var=${str:+expr}</td>
<td>var=</td>
<td>var=</td>
<td>var=expr</td>
</tr>
<tr>
<td>var=${str=expr}</td>
<td>str=expr<br>var=expr</td>
<td>str不变<br>var=</td>
<td>str不变<br>var=$str</td>
</tr>
<tr>
<td>var=${str:=expr}</td>
<td>str=expr<br>var=expr</td>
<td>str=expr<br>var=expr</td>
<td>str不变<br>var=$str</td>
</tr>
<tr>
<td>var=${str?expr}</td>
<td>expr输出至stderr</td>
<td>var=</td>
<td>var=str</td>
</tr>
<tr>
<td>var=${str:?expr}</td>
<td>expr输出至stderr</td>
<td>expr输出至stderr</td>
<td>var=str</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">例一：测试一下是否存在username这个变量，若不存在则给予username内容为root</div><div class="line">username=$&#123;username-root&#125;</div><div class="line">echo $username 输出：root</div><div class="line">username=&quot;vbird tsai&quot;</div><div class="line">username=$&#123;username-root&#125;</div><div class="line">echo $username 输出：vbird tsai</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Linux/shell 变量/" data-id="cjegeio14000ppfbl45ynm4lf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-GitHub/git命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/GitHub/git命令/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Github/">Github</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/GitHub/git命令/">git命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：</p>
<ol>
<li><p><code>/etc/gitconfig</code> 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 –system 选项的 git config 时，它会从此文件读写配置变量。</p>
</li>
<li><p><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：只针对当前用户。 可以传递 –global 选项让 Git 读写此文件。</p>
</li>
<li><p>当前使用仓库的 Git 目录中的 config 文件（就是 <code>.git/config</code>）：针对该仓库。</p>
</li>
</ol>
<p>每一个级别覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。</p>
<h4 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h4><p>当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;John Doe&quot;</div><div class="line">$ git config --global user.email johndoe@example.com</div></pre></td></tr></table></figure></p>
<p>再次强调，如果使用了 –global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 –global 选项的命令来配置。</p>
<h4 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h4><p>如果想要检查你的配置，可以使用 <code>git config --list</code> 命令来列出所有 Git 当时能找到的配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ git config --list</div><div class="line">credential.helper=osxkeychain</div><div class="line">user.name=陈礼强</div><div class="line">user.email=chenliqiang@000861.com</div><div class="line">difftool.sourcetree.cmd=opendiff &quot;$LOCAL&quot; &quot;$REMOTE&quot;</div><div class="line">difftool.sourcetree.path=</div><div class="line">mergetool.sourcetree.cmd=/Applications/SourceTree.app/Contents/Resources/opendiff-w.sh &quot;$LOCAL&quot; &quot;$REMOTE&quot; -ancestor &quot;$BASE&quot; -merge &quot;$MERGED&quot;</div><div class="line">mergetool.sourcetree.trustexitcode=true</div><div class="line">core.excludesfile=/Users/chenliqiang/.gitignore_global</div><div class="line">core.quotepath=false</div><div class="line">commit.template=/Users/chenliqiang/.stCommitMsg</div></pre></td></tr></table></figure></p>
<p>你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：/etc/gitconfig 与 ~/.gitconfig）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。</p>
<p>你可以通过输入 git config <key>： 来检查 Git 的某一项配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config user.name</div><div class="line">clq</div></pre></td></tr></table></figure></key></p>
<h3 id="git基础"><a href="#git基础" class="headerlink" title="git基础"></a>git基础</h3><h4 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h4><p>有两种取得 Git 项目仓库的方法。   </p>
<ul>
<li>在现有项目或目录下导入所有文件到 Git 中； </li>
<li>从一个服务器克隆一个现有的 Git 仓库。</li>
</ul>
<h5 id="在现有目录中初始化仓库"><a href="#在现有目录中初始化仓库" class="headerlink" title="在现有目录中初始化仓库"></a>在现有目录中初始化仓库</h5><p>如果你打算使用 Git 来对现有的项目进行管理，你只需要进入该项目目录并输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git init</div></pre></td></tr></table></figure></p>
<p>该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。</p>
<h5 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h5><p>Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。 当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。 事实上，如果你的服务器的磁盘坏掉了，你通常可以使用任何一个克隆下来的用户端来重建服务器上的仓库</p>
<p>克隆仓库的命令格式是 <code>git clone [url]</code>。 比如，要克隆 Git 的可链接库 libgit2，可以用下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/libgit2/libgit2</div></pre></td></tr></table></figure></p>
<p>这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹，从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 libgit2 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。 如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/libgit2/libgit2 mylibgit</div></pre></td></tr></table></figure></p>
<p>这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为 mylibgit。</p>
<h4 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h4><p>请记住，你工作目录下的每一个文件都不外乎这两种状态：<strong>已跟踪或未跟踪</strong>。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。 工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。</p>
<p>编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。所以使用 Git 时文件的生命周期如下：<br><img src="https://git-scm.com/book/en/v2/images/lifecycle.png" alt="image"></p>
<h5 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h5><p>要查看哪些文件处于什么状态，可以用 git status 命令。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">nothing to commit, working directory clean</div></pre></td></tr></table></figure></p>
<p>这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。 此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。 最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。 现在，分支名是 “master”,这是默认的分支名。</p>
<p>现在，让我们在项目下创建一个新的 text.txt 文件。 如果之前并不存在这个文件，使用 git status 命令，你将看到一个新的未跟踪文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">echo &apos;test&apos; &gt; text.txt</div><div class="line">chenliqiangdeMacBook-Pro:jenkinsTest chenliqiang$ git status</div><div class="line">On branch master</div><div class="line">Your branch is up to date with &apos;origin/master&apos;.</div><div class="line"></div><div class="line">Untracked files:</div><div class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</div><div class="line"></div><div class="line">	text.txt</div><div class="line"></div><div class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</div></pre></td></tr></table></figure></p>
<p>在状态报告中可以看到新建的 README 文件出现在 Untracked files 下面。 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”， 这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。 不过现在的例子中，我们确实想要跟踪管理 test.txt 这个文件。</p>
<h6 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h6><p>git status命令的输出十分详细，但其用语有些繁琐。 如果你使用 ·git status -s· 命令或 ·git status –short· 命令，你将得到一种更为紧凑的格式输出。 运行 git status -s ，状态报告输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git status -s</div><div class="line"> M README.md //未暂存的已修改的文件</div><div class="line">M  pom.xml //已暂存的已修改的文件</div><div class="line">A  text.txt //已暂存的新文件</div><div class="line">?? aa.txt  //表示未暂存新加的文件</div></pre></td></tr></table></figure></p>
<h5 id="暂存文件"><a href="#暂存文件" class="headerlink" title="暂存文件"></a>暂存文件</h5><p>git add 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。</p>
<p>将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适</p>
<p>使用命令 git add 开始暂存一个文件。 所以，要暂存 text.txt 文件，运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git add text.txt</div></pre></td></tr></table></figure></p>
<p>此时再运行 git status 命令，会看到 README 文件已被跟踪，并处于暂存状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Your branch is up to date with &apos;origin/master&apos;.</div><div class="line"></div><div class="line">Changes to be committed:</div><div class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</div><div class="line"></div><div class="line">	new file:   text.txt</div></pre></td></tr></table></figure></p>
<p>只要在 <code>Changes to be committed</code> 这行下面的，就说明是已暂存状态。 如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。 你可能会想起之前我们使用 git init 后就运行了 git add (files) 命令，开始跟踪当前目录下的文件。</p>
<h5 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h5><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。 来看一个实际的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cat .gitignore</div><div class="line">*.[oa]</div><div class="line">*~</div></pre></td></tr></table></figure></p>
<p>第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。</p>
<h5 id="查看已暂存和未暂存的修改-diff"><a href="#查看已暂存和未暂存的修改-diff" class="headerlink" title="查看已暂存和未暂存的修改(diff)"></a>查看已暂存和未暂存的修改(diff)</h5><p><code>git diff</code> 看暂存前后的变化<br><code>git diff --cached</code> 查看已经暂存起来的变化：（–staged 和 –cached 是同义词）</p>
<h5 id="提交更新-git-commit"><a href="#提交更新-git-commit" class="headerlink" title="提交更新(git commit)"></a>提交更新(git commit)</h5><p>一般会在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$git commit -m &quot;这是本次提交说明&quot;</div><div class="line"></div><div class="line">[master d78b417] 这是本次提交说明</div><div class="line"> 2 files changed, 2 insertions(+), 1 deletion(-)</div><div class="line"> create mode 100644 text.txt</div></pre></td></tr></table></figure></p>
<p>可以看到，提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整 SHA-1 校验和是什么（463dc4f），以及在本次提交中，有多少文件修订过，多少行添加和删改过。</p>
<p>请记住，提交时记录的是放在暂存区域的快照。 任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p>
<h6 id="跳过使用暂存区域-git-commit-a"><a href="#跳过使用暂存区域-git-commit-a" class="headerlink" title="跳过使用暂存区域(git commit -a)"></a>跳过使用暂存区域(git commit -a)</h6><p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，<strong>Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git commit -m &quot;提交为暂存的文件&quot; -a</div><div class="line">[master 3e3a5fe] 提交为暂存的文件</div><div class="line"> 1 file changed, 1 insertion(+)</div></pre></td></tr></table></figure></p>
<h5 id="移除文件-rm"><a href="#移除文件-rm" class="headerlink" title="移除文件(rm)"></a>移除文件(rm)</h5><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是<strong>从暂存区域移除</strong>），然后提交。 可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git rm aa.txt</div></pre></td></tr></table></figure></p>
<p>下一次提交时，该文件就不再纳入版本管理了。 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。</p>
<p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 <code>--cached</code> 选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git rm --cached aa.txt</div></pre></td></tr></table></figure></p>
<h5 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h5><p>不像其它的 VCS 系统，Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。<br>既然如此，当你看到 Git 的 mv 命令时一定会困惑不已。 要在 Git 中对文件改名，可以这么做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># aa.txt文件必须先要加入暂存中</div><div class="line">$ git mv aa.txt abc.txt</div></pre></td></tr></table></figure></p>
<p>其实，运行 git mv 就相当于运行了下面三条命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ mv README.md README</div><div class="line">$ git rm README.md</div><div class="line">$ git add README</div></pre></td></tr></table></figure></p>
<h4 id="撤消操作"><a href="#撤消操作" class="headerlink" title="撤消操作"></a>撤消操作</h4><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 –amend 选项的提交命令尝试重新提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git commit --amend</div></pre></td></tr></table></figure></p>
<p>这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。</p>
<h4 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git reset HEAD abcd.txt</div></pre></td></tr></table></figure>
<h4 id="撤消对文件的修改"><a href="#撤消对文件的修改" class="headerlink" title="撤消对文件的修改"></a>撤消对文件的修改</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -- abcd.txt</div></pre></td></tr></table></figure>
<h4 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h4><p>如果想查看你已经配置的远程仓库服务器，可以运行 <code>git remote</code> 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin - 这是 Git 给你克隆的仓库服务器的默认名字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git remote</div><div class="line">origin</div></pre></td></tr></table></figure></p>
<p>你也可以指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git remote -v</div><div class="line">origin	git@120.77.81.95:root/JenkinsTest.git (fetch)</div><div class="line">origin	git@120.77.81.95:root/JenkinsTest.git (push)</div></pre></td></tr></table></figure></p>
<h4 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h4><p>运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote add gittest git@120.77.81.95:root/gittest.git</div></pre></td></tr></table></figure></p>
<p>现在你可以在命令行中使用字符串 pb 来代替整个 URL。</p>
<h4 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h4><p>从远程仓库中获得数据，可以执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git fetch [remote-name]</div></pre></td></tr></table></figure></p>
<p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p>
<p>如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 <strong>必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作</strong>。</p>
<p>如果你有一个分支设置为跟踪一个远程分支，可以使用 git pull 命令来自动的抓取然后合并远程分支到当前分支。 这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支。 运行 <code>git pull</code> 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p>
<h4 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h4><p>当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：<code>git push [remote-name] [branch-name]</code>。 当你想要将 master 分支推送到 origin 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push origin master</div></pre></td></tr></table></figure></p>
<p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。</p>
<h4 id="查看远程仓库-1"><a href="#查看远程仓库-1" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h4><p>如果想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show [remote-name]</code> 命令。 如果想以一个特定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote show origin</div></pre></td></tr></table></figure></p>
<p>它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 master 分支，并且如果运行 git pull，就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。 它也会列出拉取到的所有远程引用。</p>
<h4 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h4><p>如果想要重命名引用的名字可以运行 git remote rename 去修改一个远程仓库的简写名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote rename gittest git1test</div></pre></td></tr></table></figure></p>
<p>如果因为一些原因想要移除一个远程仓库,可以使用 git remote rm ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git remote rm git1test</div><div class="line">$ git remote -v</div><div class="line">origin	git@120.77.81.95:root/JenkinsTest.git (fetch)</div><div class="line">origin	git@120.77.81.95:root/JenkinsTest.git (push)</div></pre></td></tr></table></figure></p>
<h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><h5 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h5><p>在 Git 中列出已有的标签是非常简单直观的。 只需要输入 git tag：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag</div></pre></td></tr></table></figure></p>
<p>你也可以使用特定的模式查找标签。 例如，Git 自身的源代码仓库包含标签的数量超过 500 个。 如果只对 1.8.5 系列感兴趣，可以运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git tag -l &apos;v1.8.5*&apos;</div><div class="line">v1.8.5</div><div class="line">v1.8.5-rc0</div></pre></td></tr></table></figure></p>
<h5 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h5><p>Git 使用两种主要类型的标签：<strong>轻量标签（lightweight）与附注标签（annotated）</strong>。</p>
<p>一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。</p>
<p>然而，附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。</p>
<h6 id="附注标签"><a href="#附注标签" class="headerlink" title="附注标签"></a>附注标签</h6><p>在 Git 中创建一个附注标签是很简单的。 最简单的方式是当你在运行 tag 命令时指定 -a 选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag -a v1.0 -m &quot;测试标签&quot;</div></pre></td></tr></table></figure></p>
<p>-m 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入信息。</p>
<p>通过使用 git show 命令可以看到标签信息与对应的提交信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git show v1.0</div></pre></td></tr></table></figure></p>
<h6 id="轻量标签"><a href="#轻量标签" class="headerlink" title="轻量标签"></a>轻量标签</h6><p>另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中 - 没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag v1.0</div></pre></td></tr></table></figure></p>
<h6 id="后期打标签"><a href="#后期打标签" class="headerlink" title="后期打标签"></a>后期打标签</h6><p>你也可以对过去的提交打标签。<br>现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag -a v1.2 9fceb02</div></pre></td></tr></table></figure></p>
<h6 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h6><p>默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样 - 你可以运行 <code>git push origin [tagname]</code>。</p>
<p>如果想要一次性推送很多标签，也可以使用带有 <code>--tags</code> 选项的 git push 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p>
<h6 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h6><p>在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。 如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用 git checkout -b [branchname] [tagname] 在特定的标签上创建一个新分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b version2 v2.0.0</div><div class="line">Switched to a new branch &apos;version2&apos;</div></pre></td></tr></table></figure></p>
<h3 id="Git-分支"><a href="#Git-分支" class="headerlink" title="Git 分支"></a>Git 分支</h3><h4 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h4><p>Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 git branch 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git branch testing</div></pre></td></tr></table></figure></p>
<p>这会在当前所在的提交对象上创建一个指针。<br><img src="https://git-scm.com/book/en/v2/images/two-branches.png" alt="image"></p>
<p>那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 HEAD 的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 <code>HEAD</code> 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。 在本例中，你仍然在 master 分支上。 因为 git branch 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。<br><img src="https://git-scm.com/book/en/v2/images/head-to-master.png" alt="image">  </p>
<p>想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 -b 参数的 git checkout 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b iss53</div><div class="line">Switched to a new branch &quot;iss53&quot;</div></pre></td></tr></table></figure></p>
<p>它是下面两条命令的简写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch iss53</div><div class="line">$ git checkout iss53</div></pre></td></tr></table></figure></p>
<h4 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h4><p>要切换到一个已存在的分支，你需要使用 git checkout 命令。 我们现在切换到新创建的 testing 分支去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout testing</div></pre></td></tr></table></figure></p>
<p>这样 HEAD 就指向 testing 分支了。<br><img src="https://git-scm.com/book/en/v2/images/head-to-testing.png" alt="image"> </p>
<h4 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h4><p>出到你想合并入的分支，然后运行 git merge 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">Switched to branch &apos;master&apos;</div><div class="line">$ git merge iss53</div></pre></td></tr></table></figure></p>
<h4 id="分支删除"><a href="#分支删除" class="headerlink" title="分支删除"></a>分支删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git branch -d iss53</div></pre></td></tr></table></figure>
<h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p>git branch 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git branch</div><div class="line">* master</div><div class="line">  testing</div></pre></td></tr></table></figure></p>
<p>注意 master 分支前的 * 字符：它代表现在检出的那一个分支（也就是说，当前 HEAD 指针所指向的分支）。 这意味着如果在这时候提交，master 分支将会随着新的工作向前移动。 如果需要查看每一个分支的最后一次提交，可以运行 git branch -v 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git branch -v</div><div class="line">* master  32262c1 [ahead 1] 123</div><div class="line">  testing 32262c1 123</div></pre></td></tr></table></figure></p>
<p>–merged 与 –no-merged 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 git branch –merged：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git branch --merged</div><div class="line">* master</div><div class="line">  testing</div></pre></td></tr></table></figure></p>
<h4 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h4><h5 id="显式地获得远程引用的完整列表"><a href="#显式地获得远程引用的完整列表" class="headerlink" title="显式地获得远程引用的完整列表"></a>显式地获得远程引用的完整列表</h5><p><code>git ls-remote (remote)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git ls-remote origin</div><div class="line">877993c88d9772791f18d6b5a913f57b6282f0e5	HEAD</div><div class="line">877993c88d9772791f18d6b5a913f57b6282f0e5	refs/heads/master</div><div class="line">8b41f3c4ccc0c8f3eb5a0a5ba6c84c849c752a37	refs/tags/v1.0</div><div class="line">877993c88d9772791f18d6b5a913f57b6282f0e5	refs/tags/v1.0^&#123;&#125;</div></pre></td></tr></table></figure></p>
<h5 id="获得远程分支的更多信息"><a href="#获得远程分支的更多信息" class="headerlink" title="获得远程分支的更多信息"></a>获得远程分支的更多信息</h5><p><code>git remote show (remote)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ git remote show origin</div><div class="line">* remote origin</div><div class="line">  Fetch URL: git@120.77.81.95:root/JenkinsTest.git</div><div class="line">  Push  URL: git@120.77.81.95:root/JenkinsTest.git</div><div class="line">  HEAD branch: master</div><div class="line">  Remote branch:</div><div class="line">    master tracked</div><div class="line">  Local branch configured for &apos;git pull&apos;:</div><div class="line">    master merges with remote master</div><div class="line">  Local ref configured for &apos;git push&apos;:</div><div class="line">    master pushes to master (fast-forwardable)</div></pre></td></tr></table></figure></p>
<h5 id="推送远程分支"><a href="#推送远程分支" class="headerlink" title="推送远程分支"></a>推送远程分支</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push (remote) (branch)</div></pre></td></tr></table></figure>
<p>如果并不想让远程仓库上的分支叫做 serverfix，可以运行 git push origin serverfix:awesomebranch 来将本地的 serverfix 分支推送到远程仓库上的 awesomebranch 分支。</p>
<h5 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h5><p>从一个远程跟踪分支检出一个本地分支会自动创建一个叫做 “跟踪分支”（有时候也叫做 “上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p>
<p>当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。 然而，如果你愿意的话可以设置其他的跟踪分支 - 其他远程仓库上的跟踪分支，或者不跟踪 master 分支。 最简单的就是之前看到的例子，运行 git checkout -b [branch] [remotename]/[branch]。 这是一个十分常用的操作所以 Git 提供了 –track 快捷方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git checkout --track origin/serverfix</div><div class="line">Branch serverfix set up to track remote branch serverfix from origin.</div><div class="line">Switched to a new branch &apos;serverfix&apos;</div></pre></td></tr></table></figure></p>
<p>如果想要将本地分支与远程分支设置为不同名字，你可以轻松地增加一个不同名字的本地分支的上一个命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b sf origin/serverfix</div><div class="line">Branch sf set up to track remote branch serverfix from origin.</div><div class="line">Switched to a new branch &apos;sf&apos;</div></pre></td></tr></table></figure></p>
<p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用 -u 或 –set-upstream-to 选项运行 git branch 来显式地设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch -u origin/serverfix</div><div class="line">Branch serverfix set up to track remote branch serverfix from origin.</div></pre></td></tr></table></figure></p>
<h5 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h5><p>当 git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 clone 或 checkout 命令为你创建的，git pull 都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。</p>
<p>由于 git pull 的魔法经常令人困惑所以通常单独显式地使用 fetch 与 merge 命令会更好一些。</p>
<h5 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h5><p>假设你已经通过远程分支做完所有的工作了 - 也就是说你和你的协作者已经完成了一个特性并且将其合并到了远程仓库的 master 分支（或任何其他稳定代码分支）。 可以运行带有 –delete 选项的 git push 命令来删除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git push origin --delete serverfix</div><div class="line">To https://github.com/schacon/simplegit</div><div class="line"> - [deleted]         serverfix</div></pre></td></tr></table></figure></p>
<p>基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/GitHub/git命令/" data-id="cjegeio0m0001pfblra8nx5ap" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux/别名，历史命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Linux/别名，历史命令/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Linux/别名，历史命令/">别名，历史命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="设置和取消别名（alias，unalias）"><a href="#设置和取消别名（alias，unalias）" class="headerlink" title="设置和取消别名（alias，unalias）"></a>设置和取消别名（alias，unalias）</h3><p>alias的定义规则和变量定义规则几乎相同，所以你只要在alias后面加上你的（”别名”=’命令参数…’）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alias lm=&apos;ls -l | more&apos;</div></pre></td></tr></table></figure></p>
<p>取消别名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unalias lm</div></pre></td></tr></table></figure></p>
<h3 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">history [n]</div><div class="line">history [-c]</div><div class="line">history [-raw] histfiles</div><div class="line">参数：</div><div class="line">n：数字，是要列出最近的n条命令行</div><div class="line">-c：将目前的shell中的所有history内容全部消除</div><div class="line">-a：将目前新增的history命令新增入histfiles中，若没有加histfiles，则默认写入~/.bash_history</div><div class="line">-r：将histfiles的内容读到目前这个shell的history记忆中</div><div class="line">-w：将目前的history记忆内容写入histfiles中</div><div class="line"></div><div class="line"></div><div class="line">!number</div><div class="line">!command</div><div class="line">!!</div><div class="line">参数：</div><div class="line">number：执行第几条命令</div><div class="line">command：由最近的命令向前搜寻命令串开头为command的那个命令，并执行</div><div class="line">!!：就是执行上一条命令（相当于按↑按键后，按[Enter]）</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Linux/别名，历史命令/" data-id="cjegeio18000xpfbldg8omlmg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux/文件和目录管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Linux/文件和目录管理/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Linux/文件和目录管理/">文件和目录管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="显示目前所在的目录（pwd）"><a href="#显示目前所在的目录（pwd）" class="headerlink" title="显示目前所在的目录（pwd）"></a>显示目前所在的目录（pwd）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pwd [-P]</div><div class="line">参数：</div><div class="line">-P：显示出当前的路径，而非使用连接路径</div></pre></td></tr></table></figure>
<h3 id="新建目录（mkdir）"><a href="#新建目录（mkdir）" class="headerlink" title="新建目录（mkdir）"></a>新建目录（mkdir）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir [-mp] 目录名称</div><div class="line">参数：</div><div class="line">-m：配置目录的权限，直接设置，不需要看默认权限（umask）</div><div class="line">-p：帮助你直接将所需的目录（包含上层目录）递归创建起来</div></pre></td></tr></table></figure>
<h3 id="删除空的目录（rmdir）"><a href="#删除空的目录（rmdir）" class="headerlink" title="删除空的目录（rmdir）"></a>删除空的目录（rmdir）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rmdir [-p] 目录名称</div><div class="line">参数：</div><div class="line">-p：连同上层“空的”目录也一起删除</div></pre></td></tr></table></figure>
<h3 id="查看文件与目录（ls）"><a href="#查看文件与目录（ls）" class="headerlink" title="查看文件与目录（ls）"></a>查看文件与目录（ls）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ls [-aAdfFhilnrRSt] 目录名称</div><div class="line">参数：</div><div class="line">-a：全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用）</div><div class="line">-d：仅列出目录本身，而不是列出目录内的文件数据（常用）</div><div class="line">-l：列出长数据串，包含文件的属性与权限等数据（常用）</div></pre></td></tr></table></figure>
<h3 id="复制文件或目录（cp）"><a href="#复制文件或目录（cp）" class="headerlink" title="复制文件或目录（cp）"></a>复制文件或目录（cp）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">cp [-adfilprsu] 源文件（source） 目标文件（destination）</div><div class="line">cp [options] source1 source2 source3 ... directory</div><div class="line">参数：</div><div class="line">-a：相当于-pdr的意思（常用）</div><div class="line">-i：若目标文件已经存在时，在覆盖时会先询问操作的进行（常用）</div><div class="line">-r：递归持续复制，用于目录的复制行为（常用）</div><div class="line">-d：若源文件为连接文件的属性，则复制连接文件属性而非文件本身</div><div class="line">-p：连同文件的属性一起复制过期，而非使用默认属性（备份常用）</div></pre></td></tr></table></figure>
<p>在默认的条件中，cp的源文件与目的文件的权限是不同的，目的文件的所有者通常会是命令操作者本身</p>
<p>由于具有这个特性，因为当我们在进行备份的时候，某些需要特别注意的特殊权限文件，例如密码文件（/etc/shadow）以及一些配置文件，就不能直接以cp来复制，而必须要加上-a或者是-p等可以完整复制文件权限的参数才行。另外，如果你想要复制文件给其他的用户，也必须要注意到文件的权限（包含读，写，执行以及文件所有者等），否则，其他人还是无法针对你给予的文件进行修订的操作</p>
<h3 id="移除文件或目录（rm）"><a href="#移除文件或目录（rm）" class="headerlink" title="移除文件或目录（rm）"></a>移除文件或目录（rm）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">rm [-fir] 文件或目录</div><div class="line">参数：</div><div class="line">-f：就是force意思，忽略不存在的文件，不会出现警告信息</div><div class="line">-i：互动模式，在删除前会询问用户是否操作</div><div class="line">-r：递归删除，最常用在目录的删除了，这是个非常危险的参数！！！！</div></pre></td></tr></table></figure>
<h3 id="移动文件与目录，或更名（mv）"><a href="#移动文件与目录，或更名（mv）" class="headerlink" title="移动文件与目录，或更名（mv）"></a>移动文件与目录，或更名（mv）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mv [-fiu] source destination</div><div class="line">mv [options] source1 source2 source3 ... directory</div><div class="line">参数：</div><div class="line">-f：就是force强制的意思，如果目标文件以及存在，不会询问直接覆盖</div><div class="line">-i：若目标文件已经存在时，就会询问是否覆盖</div><div class="line">-u：若目标文件已经存在，且source比较新，才会更新</div></pre></td></tr></table></figure>
<h3 id="取得路径的文件名与目录名称（basename，dirname）"><a href="#取得路径的文件名与目录名称（basename，dirname）" class="headerlink" title="取得路径的文件名与目录名称（basename，dirname）"></a>取得路径的文件名与目录名称（basename，dirname）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">basename /etc/sysconfig/network</div><div class="line">network #取得最后的文件名</div><div class="line"></div><div class="line">dirname /etc/sysconfig/network</div><div class="line">/etc/sysconfig #取得目录名</div></pre></td></tr></table></figure>
<h3 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="文件内容查阅"></a>文件内容查阅</h3><ul>
<li>cat：由第一行开始显示文件内容</li>
<li>tac：从最后一行开始显示，可以看出tac是cat的倒写形式</li>
<li>nl：显示的时候，顺便输出行号</li>
<li>more：一页一页地显示文件内容</li>
<li>less：与more类似，但是比more更好的是，它可以往前翻页</li>
<li>head：只看头几行</li>
<li>tail：只看结尾几行</li>
<li>od：以二进制的方式读取文件内容</li>
</ul>
<h5 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cat [-AbEnTv]</div><div class="line">参数：</div><div class="line">-n：打印出行号，连同空白行也会有行号</div></pre></td></tr></table></figure>
<h5 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">nl [-bnw] 文件</div><div class="line">参数：</div><div class="line">-b：指定行号指定的方式，主要有两种：</div><div class="line">    -b a：表示不论是否为空行，也同样列出行号（类似 cat -n）</div><div class="line">    -b t：如果有空行，空的那一行不要列出行号（默认值）</div><div class="line">-n：列出行号的表示方法，主要有三种：</div><div class="line">    -n ln：行号在屏幕的最左方显示</div><div class="line">    -n rn：行号在自己字段的最右方显示，且不加0</div><div class="line">    -n rz：行号在自己字段的最右方显示，且加0</div><div class="line">-w：行号字段占用的位数</div></pre></td></tr></table></figure>
<h5 id="more"><a href="#more" class="headerlink" title="more"></a>more</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">空格键：向下翻一页</div><div class="line">Enter：向下滚一行</div><div class="line">/字符串</div><div class="line">:f：立刻显示出文件名以及目前显示的行数</div><div class="line">q：立刻离开more，不再显示该文件内容</div><div class="line">b：往回翻页，不过这操作只对文件有用，对管道无用</div></pre></td></tr></table></figure>
<h5 id="less"><a href="#less" class="headerlink" title="less"></a>less</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">空格键：向下翻一页</div><div class="line">[PageDown]：向下翻动一页</div><div class="line">[PageUp]：向上翻动一页</div><div class="line">/字符串：向下查询“字符串”的功能</div><div class="line">?字符串：向上查询“字符串”的功能</div><div class="line">n：重复前一个查询（与/或?有关）</div><div class="line">N：反向重复前一个查询（与/或?有关）</div><div class="line">q：离开</div></pre></td></tr></table></figure>
<h5 id="head"><a href="#head" class="headerlink" title="head"></a>head</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">head [-n number] 文件</div><div class="line">参数：</div><div class="line">-n：后面接数字，代表显示几行的意思（默认显示10行）</div></pre></td></tr></table></figure>
<h5 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tail [-n number] 文件</div><div class="line">参数：</div><div class="line">-n：后面接数字，代表显示几行的意思</div><div class="line">-f：表示持续输出文件内容，要等到按下[ctrl]+c才会结束tail的输出</div></pre></td></tr></table></figure>
<h3 id="修改文件时间或创建新文件（touch）"><a href="#修改文件时间或创建新文件（touch）" class="headerlink" title="修改文件时间或创建新文件（touch）"></a>修改文件时间或创建新文件（touch）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">touch [-acdmt] 文件</div><div class="line">参数：</div><div class="line">-a：仅修改访问时间</div><div class="line">-c：仅修改文件的时间，若该文件不存在则不创建新文件</div><div class="line">-d：后面可以接欲修改的日期而不用目前的日期，也可以使用 --date=&quot;日期或时间&quot;</div><div class="line">-m：仅修改mtime</div><div class="line">-t：后面可以接欲修改的时间而不用目前的时间，格式为[YYMMDDhhmm]</div></pre></td></tr></table></figure>
<h3 id="文件默认权限（umask）"><a href="#文件默认权限（umask）" class="headerlink" title="文件默认权限（umask）"></a>文件默认权限（umask）</h3><p>umask就是指定“<strong>目前用户在新建文件或目录时候的权限默认值</strong>”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">umask</div><div class="line">0022</div><div class="line"></div><div class="line">umask -S</div><div class="line">u=rwx,g=rx,o=rx</div></pre></td></tr></table></figure></p>
<p>查看的方式有两种，一种可以直接输入umask，就可以看到数字形态的权限设置分数，一种则是加入-S这个参数，就会以符号类型的方式来显示出权限</p>
<p>在默认权限的属性上，目录与文件是不一样的，默认的情况如下：</p>
<ul>
<li>若用户创建“文件”则默认没有可执行（x）权限，即只有r，w这两个选项，也就是最大为666，默认权限为：<code>-rw-rw-rw-</code></li>
<li>若用户新建“目录”，则由于x与是否可以进入此目录有关，因此默认所有权限均开放，即为777，默认权限为：<code>drwxrwxrwx</code></li>
</ul>
<p>要注意的是，umask的分数是指“<strong>该默认值需要减掉的权限</strong>”。因为r，w，x分别是4，2，1，也就是说当要拿掉能写的权限，就是输入2，而如果要拿掉能读的权限，也就是4，那么要拿掉读与写的权限，也就是6，而要拿掉执行与写入的权限，也就是3，要拿掉读与执行的权限，也就是5</p>
<p>所以在设置了umask的时候，默认新建文件和目录的权限为：</p>
<ul>
<li>新建文件时：（-rw-rw-rw-）-（—–w–w-）==&gt;-rw-r–r–(644)</li>
<li>新建目录时：（drwxrwxrwx）-（d—-w–w-）==&gt;drwxr-xr-x(755)</li>
</ul>
<h3 id="命令与文件的查询"><a href="#命令与文件的查询" class="headerlink" title="命令与文件的查询"></a>命令与文件的查询</h3><h4 id="脚本文件名的查询（which）"><a href="#脚本文件名的查询（which）" class="headerlink" title="脚本文件名的查询（which）"></a>脚本文件名的查询（which）</h4><p>which是根据用户所设置的PATH变量内的目录去查找可执行文件的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">which [-a] command</div><div class="line">参数：</div><div class="line">-a：将所有有PATH目录中可以找到的命令均列出，而不只第一个被找到的命令名称</div></pre></td></tr></table></figure></p>
<h4 id="文件名的查询（whereis，locate）"><a href="#文件名的查询（whereis，locate）" class="headerlink" title="文件名的查询（whereis，locate）"></a>文件名的查询（whereis，locate）</h4><p>whereis与locate是利用数据库来查找数据，所以速度相当快速，而且并没有实际查询硬盘，比较节省时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">whereis [-bmsu] 文件或目录名</div><div class="line">参数：</div><div class="line">-b：只找二进制格式的文件</div><div class="line">-m：只找在说明文件mamual路径下的文件</div><div class="line">-s：只找source源文件</div><div class="line">-u：查找不在上述三个选项当中的其他特殊文件</div></pre></td></tr></table></figure></p>
<p>locate的使用更简单，直接在后面输入“文件的部分名称”后就能够得到结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">locate [-ir] keyword</div><div class="line">参数：</div><div class="line">-i：忽略大小写的差异</div><div class="line">-r：后面可接正则表达式的显示方式</div></pre></td></tr></table></figure></p>
<p>locate是依据/var/lib/mlocate内的数据库记载，查出用户输入的关键字文件名</p>
<p>可以输入<code>updatedb</code>来手动更新数据库，updatedb命令回去读取<code>/etc/updatedb.conf</code>这个配置文件的设置，然后再去硬盘里面进行查找文件名的操作，最后就更新整个数据库文件（/var/lib/mlocate）</p>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">find [PATH] [option] [action]</div><div class="line">参数：</div><div class="line">1.与时间有关的参数：共有-atime，-ctime，-mtime，下面以-mtime说明</div><div class="line">-mtime n：n为数字，意义为在n天之前的“一天之内”被更改过的文件</div><div class="line">-mtime +n：列出在n天之前（不含n天本身）被更改过的文件名</div><div class="line">-mtime -n：列出n天之内（含n本身）被更改过的文件名</div><div class="line">-newer file：file为一个存在的文件，列出比file还要新的文件名</div><div class="line"></div><div class="line">2.用户或用户组名有关的参数：</div><div class="line">-uid n：n为数字，这个数字是用户的账号ID，即UID，这个UID是记录在/etc/passwd里面与账号名称对应的数字</div><div class="line">-gid n：n为数字，这个数字是用户组名的ID，即GID，这个GID记录在/etc/group中</div><div class="line">-user name：name为用户账号名称</div><div class="line">-group name：name为用户组名称</div><div class="line">-nouser：寻找文件的所有者不在/etc/passwd的人</div><div class="line">-nogroup：选找文件的所有用户组不存在于/etc/group中的文件</div><div class="line">当你自行安装软件时，很可能该软件的属性当中并没有文件所有者，这是可能的，在这个时候，就可以使用-nouser和-nogroup查找</div><div class="line"></div><div class="line">3.与文件权限及名称有关的参数：</div><div class="line">-name filename：查找文件名为filename的文件</div><div class="line">-size [+-]SIZE:查找比SIZE还要大（+）或小（-）的文件，这个SIZE的规格有：</div><div class="line">    c：代表byte k：代表1024bytes 。所以，要找比50KB还要大的文件，就是“-size +50k”</div><div class="line">-type TYPE：查找文件的类型为TYPE的，类型主要有：一般正规文件（f），设备文件（b，c），目录（d），连接文件（l），socket（s）及FIFO（p）等属性</div><div class="line">-perm mode：查找文件权限“刚好等于”mode的文件，这个mode类似chmod的属性值，举例来说，-rwsr-xr-x的属性为4755</div><div class="line">-perm -mode：查找文件权限“必须要全部包括mode的权限”的文件，举例来说，我们要查找-rwxr--r--，即0744的文件，使用-perm -0744，当一个文件的权限为-rwsr-xr-x，即4755时，也会被列出，因为-rwsr-xr-x的属性已经包括了-rwxr--r--的属性了</div><div class="line">-perm +mode：查找文件权限“包含任一mode的权限”的文件，举例来说，我们查找-rwxr-xr-x，即-perm +755时，但一个文件属性为-rw-------也会被列出来，因为它有-rw...的属性存在</div><div class="line"></div><div class="line">4.其他可进行的操作：</div><div class="line">-exec command：command为其他命令，-exec后面可再接其他的命令来处理查找到的结果</div><div class="line">-print：将结果打印到屏幕上，这个操作是默认操作</div><div class="line"></div><div class="line">例子：find / -perm +7000 -exec ls -l &#123;&#125; \;</div><div class="line">&#123;&#125;代表的是“由find找到的内容”，find的结果会被放置在&#123;&#125;位置中</div><div class="line">-exec 一直到“\;”是关键字，代表find额外命令的开始（-exec）到结束（\;）,在这个中间的就是find命令内的额外命令，在本例中就是“ls -l &#123;&#125;”</div><div class="line">因为“;”在bash环境下是有特殊意义的，因此利用反斜杠来转义</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Linux/文件和目录管理/" data-id="cjegeio1a000zpfbl2dgzwcts" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux/权限相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Linux/权限相关/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Linux/权限相关/">权限相关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="列出所有的文件详细的权限与属性"><a href="#列出所有的文件详细的权限与属性" class="headerlink" title="列出所有的文件详细的权限与属性"></a>列出所有的文件详细的权限与属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ls -al</div><div class="line">drwxr-xr-x+  42 chenliqiang  staff   1344 12  2 14:20 .</div><div class="line">drwxr-xr-x    6 root         admin    192 11 15 11:23 ..</div><div class="line">-r--------    1 chenliqiang  staff      9 11 15 15:44 .CFUserTextEncoding</div><div class="line">-rw-r--r--@   1 chenliqiang  staff  18436 12  2 15:05 .DS_Store</div><div class="line">drwxr-xr-x   11 chenliqiang  staff    352  4 24  2017 .MarkEditorData</div><div class="line">drwx------    2 chenliqiang  staff     64 12  2 15:08 .Trash</div><div class="line">-rw-------    1 chenliqiang  staff  18925 12  2 14:31 .bash_history</div><div class="line">-rw-r--r--@   1 chenliqiang  staff    354 11 30 17:27 .bash_profile</div><div class="line">drwx------  459 chenliqiang  staff  14688 12  2 14:31 .bash_sessions</div><div class="line">drwx------    6 chenliqiang  staff    192 11 28 17:46 .config</div><div class="line">[权限]      [连接]   [所有者] [用户组] [容量：B] [修改时间]   [文件名]</div></pre></td></tr></table></figure>
<h4 id="第一列代表这个文件的类型与权限"><a href="#第一列代表这个文件的类型与权限" class="headerlink" title="第一列代表这个文件的类型与权限"></a>第一列代表这个文件的类型与权限</h4><h5 id="第一个字符代表这个文件是“目录，文件或链接文件等”"><a href="#第一个字符代表这个文件是“目录，文件或链接文件等”" class="headerlink" title="第一个字符代表这个文件是“目录，文件或链接文件等”"></a>第一个字符代表这个文件是“目录，文件或链接文件等”</h5><ul>
<li>d：目录</li>
<li>-：文件</li>
<li>l：连接文件</li>
<li>b：设备文件里面的可供存储的接口设备</li>
<li>c：设备文件里面的串行端口设备</li>
</ul>
<h5 id="接下来的字符中，以3个为一组，且均为“rwx”的3个参数的组合。其中-r-代表可读（read），-w-代表可写（write），-x-代表可执行（execute）"><a href="#接下来的字符中，以3个为一组，且均为“rwx”的3个参数的组合。其中-r-代表可读（read），-w-代表可写（write），-x-代表可执行（execute）" class="headerlink" title="接下来的字符中，以3个为一组，且均为“rwx”的3个参数的组合。其中[r]代表可读（read）， [w]代表可写（write），[x]代表可执行（execute）"></a>接下来的字符中，以3个为一组，且均为“rwx”的3个参数的组合。其中[r]代表可读（read）， [w]代表可写（write），[x]代表可执行（execute）</h5><p>注意：这3个权限的位置不会改变，如果没有权限，就会出现减号[-]而已</p>
<ul>
<li>第一组为“文件所有者的权限”</li>
<li>第二组为“同用户组的权限”</li>
<li>第三组为“其他非本用户组的权限”</li>
</ul>
<h3 id="查看文件或者目录的权限"><a href="#查看文件或者目录的权限" class="headerlink" title="查看文件或者目录的权限"></a>查看文件或者目录的权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">ls -l webapps</div><div class="line">total 0</div><div class="line">drwxr-xr-x  17 chenliqiang  staff   544  9 29 20:27 ROOT</div><div class="line">drwxr-xr-x  54 chenliqiang  staff  1728  9 29 20:27 docs</div><div class="line">drwxr-xr-x   8 chenliqiang  staff   256  9 29 20:27 examples</div><div class="line">drwxr-xr-x   7 chenliqiang  staff   224  9 29 20:27 host-manager</div><div class="line">drwxr-xr-x   8 chenliqiang  staff   256  9 29 20:27 manager</div><div class="line"></div><div class="line">//包括隐藏文件</div><div class="line">ls -al webapps</div><div class="line">total 16</div><div class="line">drwxr-xr-x   8 chenliqiang  staff   256 12  1 15:35 .</div><div class="line">drwxrwxr-x  14 chenliqiang  staff   448 11 30 15:52 ..</div><div class="line">-rw-r--r--@  1 chenliqiang  staff  6148 12  2 15:49 .DS_Store</div><div class="line">drwxr-xr-x  17 chenliqiang  staff   544  9 29 20:27 ROOT</div><div class="line">drwxr-xr-x  54 chenliqiang  staff  1728  9 29 20:27 docs</div><div class="line">drwxr-xr-x   8 chenliqiang  staff   256  9 29 20:27 examples</div><div class="line">drwxr-xr-x   7 chenliqiang  staff   224  9 29 20:27 host-manager</div><div class="line">drwxr-xr-x   8 chenliqiang  staff   256  9 29 20:27 manager</div></pre></td></tr></table></figure>
<h3 id="改变文件属性与权限"><a href="#改变文件属性与权限" class="headerlink" title="改变文件属性与权限"></a>改变文件属性与权限</h3><ul>
<li><code>chgrp</code>：改变文件所属用户组</li>
<li><code>chown</code>：改变文件所属者</li>
<li><code>chmod</code>：改变文件的权限</li>
</ul>
<h4 id="改变所属用户组：chgrp"><a href="#改变所属用户组：chgrp" class="headerlink" title="改变所属用户组：chgrp"></a>改变所属用户组：chgrp</h4><p>注意：要被改变的组名必须要在<code>/etc/group</code>文件内存在才行，否则就会显示错误</p>
<p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">chgrp [-R] 用户组名 目录名/文件名</div><div class="line">选项与参数：</div><div class="line">—R:进行递归（recursive）的持续更改，也即连同子目录下的所有文件，目录</div></pre></td></tr></table></figure></p>
<h4 id="改变文件所有者：chown"><a href="#改变文件所有者：chown" class="headerlink" title="改变文件所有者：chown"></a>改变文件所有者：chown</h4><p>注意：用户必须已经存在与系统中的账号，也就是在<code>/etc/passwd</code>这个文件中有记录的用户名称才能改变</p>
<p>chown还可以直接修改用户组的名称</p>
<p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">chown [-R] 用户名 目录名/文件名</div><div class="line">chown [-R] 用户名:组名 目录名/文件名</div><div class="line">chown [-R] 用户名.组名 目录名/文件名(不建议这样的写法，因为账号中可能会有小数点，如：vbird.tsai)</div><div class="line">选项与参数：</div><div class="line">—R:进行递归（recursive）的持续更改，也即连同子目录下的所有文件，目录</div></pre></td></tr></table></figure></p>
<h4 id="改变权限：chmod"><a href="#改变权限：chmod" class="headerlink" title="改变权限：chmod"></a>改变权限：chmod</h4><p>权限的设置方法有两种，可以使用数字或者是符号来进行权限的更改</p>
<h6 id="1-数字类型改变文件权限"><a href="#1-数字类型改变文件权限" class="headerlink" title="1.数字类型改变文件权限"></a>1.数字类型改变文件权限</h6><p>Linux文件的基本权限就有9个，分别是owner，group，others三种身份各有自己的read，write，execute权限</p>
<p>我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p>
<ul>
<li>r：4</li>
<li>w：2</li>
<li>x：1</li>
</ul>
<p>每种身份（owner，group，others）各自三个权限（r，w，x）分数是需要累加的，例如当权限为[-rwxrwx—],分数则是：</p>
<ul>
<li>owner=rwx=4+2+1=7</li>
<li>group=rwx=4+2+1=7</li>
<li>others=—=0+0+0=0</li>
</ul>
<p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">chmod [-R] rwx 目录名/文件名</div><div class="line">选项与参数：</div><div class="line">—R:进行递归（recursive）的持续更改，也即连同子目录下的所有文件，目录</div></pre></td></tr></table></figure></p>
<h6 id="2-符号类型改变文件权限"><a href="#2-符号类型改变文件权限" class="headerlink" title="2.符号类型改变文件权限"></a>2.符号类型改变文件权限</h6><p>user，group，others3种身份可以通过u，g，o来代表，此外，a代表all，也即全部的身份</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>身份简写</th>
<th>权限操作</th>
<th>权限</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>chmod</td>
<td><code>u:用户身份</code><br> <code>g:组身份</code><br> <code>o:其他身份</code><br> <code>a:所有身份</code><br></td>
<td>+（加入）<br> -（除去）<br>=（设置）</td>
<td>r <br>w <br>x</td>
<td>文件或者目录</td>
</tr>
</tbody>
</table>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1.设置一个文件的权限为“-rwxr-xr-x”</div><div class="line">chmod u=rwx,go=rx .bashrc  注意：那个u=rwx,go=rx是连在一起的，中间没有任何空格</div><div class="line"></div><div class="line">2.如果只想要增加.bashrc这个文件的每个人均可写入的权限，那么可以使用</div><div class="line">chmod a+w .bashrc</div><div class="line"></div><div class="line">3.去掉全部人的可执行权限</div><div class="line">chmod a-x .bashrc</div></pre></td></tr></table></figure></p>
<p>在+与-的状态下，只要是没有指定到的选项，则该权限“不会被变动”，例如上面的例子中，由于仅以-去掉x，则其他两个权限保持当时的值不变</p>
<p>如果让一个程序可以拥有执行的权限，但你又不知道该文件原本的权限，此时利用<code>chmod a+x filename</code>就可以让该程序拥有执行的权限了</p>
<h3 id="目录与文件的权限意义"><a href="#目录与文件的权限意义" class="headerlink" title="目录与文件的权限意义"></a>目录与文件的权限意义</h3><h4 id="权限对文件的重要性"><a href="#权限对文件的重要性" class="headerlink" title="权限对文件的重要性"></a>权限对文件的重要性</h4><ul>
<li>r：可读取此文件的实际内容，如读取文本文件的文字内容等</li>
<li>w：可以编辑，新增，或者是修改该文件的内容（但不含删除该文件）</li>
<li>x：该文件具有可以被系统执行的权限</li>
</ul>
<p>对于文件的r，w，x来说，主要都是针对“文件的内容”而言，与文件名的存在与否没有关系的，因为文件记录的是实际的数据</p>
<h4 id="权限对目录的重要性"><a href="#权限对目录的重要性" class="headerlink" title="权限对目录的重要性"></a>权限对目录的重要性</h4><p>文件是存放实际数据的所在，目录主要的内容是记录文件名列表，文件名与目录有强烈的关联</p>
<ul>
<li>r：表示具有读取目录结构列表的权限，所以当你具有读取一个目录的权限时，表示你可以查询该目录下的文件名数据</li>
<li>w：表示你具有更改该目录结构列表的权限，也就是下面这些权限<ul>
<li>新建心的文件与目录</li>
<li>删除已经存在的文件与目录</li>
<li>将已存在的文件或者目录进行重命名</li>
<li>转移该目录内的文件，目录位置</li>
</ul>
</li>
<li>x：<strong>目录的x代表的是用户能否进入该目录成为工作目录</strong>的用途。所谓的工作目录（work directory）就是你目前所在的目录。工作目录对于命令的执行是非常重要的，如果你在某目录下不具有x的权限，那么你就无法切换到该目录下，也就无法执行该目录下的任何命令，即使你具有该目录的r权限</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Linux/权限相关/" data-id="cjegeio1b0012pfblunu4vvzu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux/设置主机SSH连接不需要密码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Linux/设置主机SSH连接不需要密码/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Linux/设置主机SSH连接不需要密码/">设置主机SSH连接不需要密码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="单一连接"><a href="#单一连接" class="headerlink" title="单一连接"></a>单一连接</h2><ol>
<li><p>在本机生成私匙和公匙</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa</div></pre></td></tr></table></figure>
</li>
<li><p>把公匙放到需要连接的服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">scp ~/.ssh/id_rsa.pub 连接的账户@服务器ip:.ssh/id_rsa.pub</div><div class="line"></div><div class="line">如：</div><div class="line">scp ~/.ssh/id_rsa.pub root@120.77.81.95:.ssh/id_rsa.pub</div></pre></td></tr></table></figure>
</li>
<li><p>生成authorized_keys文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">检查是否存在该文件：</div><div class="line">cat /root/.ssh/authorized_keys</div><div class="line">不存在则生成</div><div class="line">touch /root/.ssh/authorized_keys</div></pre></td></tr></table></figure>
</li>
<li><p>将id_rsa.pub的内容追加到authorized_keys 中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /root/.ssh/id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys</div></pre></td></tr></table></figure>
</li>
<li><p>测试<br>回到主机,ssh连接服务器，不需要密码则成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh root@120.77.81.95</div></pre></td></tr></table></figure>
</li>
</ol>
<p>如出现Agent admitted failure to sign using the key错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-add   ~/.ssh/id_rsa</div></pre></td></tr></table></figure></p>
<h3 id="控制n个机器如上所述自动登录"><a href="#控制n个机器如上所述自动登录" class="headerlink" title="控制n个机器如上所述自动登录"></a>控制n个机器如上所述自动登录</h3><p>需要n对钥匙(密钥和公钥), ssh-keygen 命令可以随意更改钥匙对的名字, 比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># ssh-keygen -t rsa</div><div class="line">Generating public/private rsa key pair.</div><div class="line">Enter file in which to save the key (/root/.ssh/id_rsa): /root/.ssh/id_rsa_192.168.60.110</div></pre></td></tr></table></figure></p>
<p>这样私钥和公钥的名字分别就是: id_rsa_192.168.60.110和 id_rsa_192.168.60.110.pub;然后将 id_rsa_192.168.60.110.pub 文件的内容, 追加到sever的 ~/.ssh/authorized_keys文件中,最后, 在本地用ssh命令的 -i 参数指定本地密钥, 并登录:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># ssh -i /root/.ssh/id_rsa_192.168.60.110 someone@192.168.60.110</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Linux/设置主机SSH连接不需要密码/" data-id="cjegeio1c0014pfbl2zvd1w2o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器相关/redis/Redis集群" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/服务器相关/redis/Redis集群/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/服务器相关/redis/Redis集群/">Redis集群</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Redis集群介绍"><a href="#Redis集群介绍" class="headerlink" title="Redis集群介绍"></a>Redis集群介绍</h3><p>Redis 集群是一个提供在<strong>多个Redis间节点间共享数据</strong>的程序集。 </p>
<p>Redis集群并不支持处理多个keys的命令,因为这需要在不同的节点间移动数据,从而达不到像Redis那样的性能,在高负载的情况下可能会导致不可预料的错误.  </p>
<p>Redis 集群通过分区来提供<strong>一定程度的可用性</strong>,在实际环境中当某个节点宕机或者不可达的情况下继续处理命令. Redis 集群的优势:</p>
<ul>
<li>自动分割数据到不同的节点上。</li>
<li>整个集群的部分节点失败或者不可达的情况下能够继续处理命令。</li>
</ul>
<h3 id="Redis-集群的数据分片"><a href="#Redis-集群的数据分片" class="headerlink" title="Redis 集群的数据分片"></a>Redis 集群的数据分片</h3><p>Redis 集群没有使用一致性hash, 而是引入了 <strong>哈希槽</strong>的概念.</p>
<p>Redis 集群有<strong>16384</strong>个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽,举个例子,比如当前集群有3个节点,那么:</p>
<ul>
<li>节点 A 包含 0 到 5500号哈希槽.</li>
<li>节点 B 包含5501 到 11000 号哈希槽.</li>
<li>节点 C 包含11001 到 16384号哈希槽.</li>
</ul>
<p>这种结构很容易添加或者删除节点. 比如如果我想新添加个节点D, 我需要从节点 A, B, C中得部分槽到D上. 如果我像移除节点A,需要将A中得槽移到B和C节点上,然后将没有任何槽的A节点从集群中移除即可. 由于从一个节点将哈希槽移动到另一个节点并不会停止服务,所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态.</p>
<h3 id="Redis-集群的主从复制模型"><a href="#Redis-集群的主从复制模型" class="headerlink" title="Redis 集群的主从复制模型"></a>Redis 集群的主从复制模型</h3><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品.</p>
<p>在我们例子中具有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用.</p>
<p>然而如果在集群创建的时候（或者过一段时间）我们为每个节点添加一个从节点A1，B1，C1,那么整个集群便有三个master节点和三个slave节点组成，这样在节点B失败后，集群便会选举B1为新的主节点继续服务，整个集群便不会因为槽找不到而不可用了</p>
<p>不过当B和B1 都失败后，集群是不可用的.</p>
<h3 id="Redis-一致性保证"><a href="#Redis-一致性保证" class="headerlink" title="Redis 一致性保证"></a>Redis 一致性保证</h3><p>Redis 并不能保证数据的<strong>强一致性</strong>. 这意味这在实际中集群在特定的条件下可能会丢失写操作.</p>
<p>第一个原因是因为集群是用了异步复制. 写操作过程:</p>
<ol>
<li>客户端向主节点B写入一条命令.</li>
<li>主节点B向客户端回复命令状态.</li>
<li>主节点将写操作复制给他得从节点 B1, B2 和 B3.</li>
</ol>
<p>主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。 注意：Redis 集群可能会在将来提供同步写的方法。 Redis 集群另外一种可能会丢失命令的情况是集群出现了网络分区， 并且一个客户端与至少包括一个主节点在内的少数实例被孤立。</p>
<p>举个例子 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点， 其中 A 、B 、C 为主节点， A1 、B1 、C1 为A，B，C的从节点， 还有一个客户端 Z1 假设集群中发生网络分区，那么集群可能会分为两方，大部分的一方包含节点 A 、C 、A1 、B1 和 C1 ，小部分的一方则包含节点 B 和客户端 Z1 .</p>
<p>Z1仍然能够向主节点B中写入, 如果网络分区发生时间较短,那么集群将会继续正常运作,如果分区的时间足够让大部分的一方将B1选举为新的master，那么Z1写入B中得数据便丢失了.</p>
<p>注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项</p>
<h3 id="搭建并使用Redis集群"><a href="#搭建并使用Redis集群" class="headerlink" title="搭建并使用Redis集群"></a>搭建并使用Redis集群</h3><p>搭建集群的第一件事情我们需要一些运行在 集群模式的Redis实例. 这意味这集群并不是由一些普通的Redis实例组成的，集群模式需要通过配置启用，开启集群模式后的Redis实例便可以使用集群特有的命令和特性了.<br>下面是一个最少选项的集群的配置文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">port 7000</div><div class="line">cluster-enabled yes</div><div class="line">cluster-config-file nodes.conf</div><div class="line">cluster-node-timeout 5000</div><div class="line">appendonly yes</div></pre></td></tr></table></figure></p>
<p>文件中的 cluster-enabled 选项用于开实例的集群模式， 而 cluster-conf-file 选项则设定了保存节点配置文件的路径， 默认值为 nodes.conf.节点配置文件无须人为修改， 它由 Redis 集群在启动时创建， 并在有需要时自动进行更新。 </p>
<p>要让集群正常运作至少需要三个主节点，不过在刚开始试用集群功能时， 强烈建议使用六个节点： 其中三个为主节点， 而其余三个则是各个主节点的从节点。</p>
<p>首先， 让我们进入一个新目录， 并创建六个以端口号为名字的子目录， 稍后我们在将每个目录中运行一个 Redis 实例：  命令如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir cluster-test</div><div class="line">cd cluster-test</div><div class="line">mkdir 7000 7001 7002 7003 7004 7005</div></pre></td></tr></table></figure></p>
<p>在文件夹 7000 至 7005 中， 各创建一个 redis.conf 文件， 文件的内容可以使用上面的示例配置文件， 但记得将配置中的端口号从 7000 改为与文件夹名字相同的号码,并且nodes.conf的文件名也要相应调整，如nodes-7000.conf。</p>
<p>启动6个集群示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/Cellar/redis/3.2.8/bin</div><div class="line">1./usr/local/Cellar/redis/3.2.8/cluster-test/7000/redis.conf</div><div class="line">2./usr/local/Cellar/redis/3.2.8/cluster-test/70010/redis.conf</div><div class="line">3./usr/local/Cellar/redis/3.2.8/cluster-test/7002/redis.conf</div><div class="line">4./usr/local/Cellar/redis/3.2.8/cluster-test/7003/redis.conf</div><div class="line">5./usr/local/Cellar/redis/3.2.8/cluster-test/7004/redis.conf</div><div class="line">6./usr/local/Cellar/redis/3.2.8/cluster-test/7005/redis.conf</div></pre></td></tr></table></figure></p>
<p>实例打印的日志显示， 因为 nodes.conf 文件不存在， 所以每个节点都为它自身指定了一个新的 ID ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[82462] 26 Nov 11:56:55.329 * No cluster configuration found, I&apos;m 97a3a64667477371c4479320d683e4c8db5858b1</div></pre></td></tr></table></figure></p>
<p>实例会一直使用同一个 ID ， 从而在集群中保持一个独一无二（unique）的名字。</p>
<h3 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h3><p>现在我们已经有了六个正在运行中的 Redis 实例， 接下来我们需要使用这些实例来创建集群， 并为每个节点编写配置文件。<br>通过使用 Redis 集群命令行工具 redis-trib ， 编写节点配置文件的工作可以非常容易地完成： redis-trib 位于 Redis 源码的 src 文件夹中， 它是一个 Ruby 程序， 这个程序通过向实例发送特殊命令来完成创建新集群， 检查集群， 或者对集群进行重新分片（reshared）等工作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 \</div><div class="line">127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</div></pre></td></tr></table></figure></p>
<p>这个命令在这里用于创建一个新的集群, 选项–replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。<br>之后跟着的其他参数则是这个集群实例的地址列表,3个master3个slave redis-trib 会打印出一份预想中的配置给你看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</div><div class="line">&gt;&gt;&gt; Creating cluster</div><div class="line">&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...</div><div class="line">Using 3 masters:</div><div class="line">127.0.0.1:7000</div><div class="line">127.0.0.1:7001</div><div class="line">127.0.0.1:7002</div><div class="line">Adding replica 127.0.0.1:7003 to 127.0.0.1:7000</div><div class="line">Adding replica 127.0.0.1:7004 to 127.0.0.1:7001</div><div class="line">Adding replica 127.0.0.1:7005 to 127.0.0.1:7002</div><div class="line">M: 83976d23ea61befbacc383aa03bd2da9f08fa7fa 127.0.0.1:7000</div><div class="line">   slots:0-5460 (5461 slots) master</div><div class="line">M: c2f4de6b29648599ade1d596b96838cdf559f397 127.0.0.1:7001</div><div class="line">   slots:5461-10922 (5462 slots) master</div><div class="line">M: 3e9798d73cc0685745c18cb15cf68c75c746e0a5 127.0.0.1:7002</div><div class="line">   slots:10923-16383 (5461 slots) master</div><div class="line">S: dfcad7da198267663734490dc876a7c072d186f1 127.0.0.1:7003</div><div class="line">   replicates 83976d23ea61befbacc383aa03bd2da9f08fa7fa</div><div class="line">S: d415630bb73d2df4ddbe8032ac3034756dff838c 127.0.0.1:7004</div><div class="line">   replicates c2f4de6b29648599ade1d596b96838cdf559f397</div><div class="line">S: ccda46a376b2a473ac596c80050b464ca9ba30d4 127.0.0.1:7005</div><div class="line">   replicates 3e9798d73cc0685745c18cb15cf68c75c746e0a5</div><div class="line">Can I set the above configuration? (type &apos;yes&apos; to accept):</div></pre></td></tr></table></figure></p>
<p>如果你觉得没问题的话， 就可以输入 yes ， redis-trib 就会将这份配置应用到集群当中,让各个节点开始互相通讯,最后可以得到如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">Can I set the above configuration? (type &apos;yes&apos; to accept): yes</div><div class="line">&gt;&gt;&gt; Nodes configuration updated</div><div class="line">&gt;&gt;&gt; Assign a different config epoch to each node</div><div class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</div><div class="line">Waiting for the cluster to join...</div><div class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)</div><div class="line">M: 83976d23ea61befbacc383aa03bd2da9f08fa7fa 127.0.0.1:7000</div><div class="line">   slots:0-5460 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: d415630bb73d2df4ddbe8032ac3034756dff838c 127.0.0.1:7004</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates c2f4de6b29648599ade1d596b96838cdf559f397</div><div class="line">M: c2f4de6b29648599ade1d596b96838cdf559f397 127.0.0.1:7001</div><div class="line">   slots:5461-10922 (5462 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: ccda46a376b2a473ac596c80050b464ca9ba30d4 127.0.0.1:7005</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates 3e9798d73cc0685745c18cb15cf68c75c746e0a5</div><div class="line">M: 3e9798d73cc0685745c18cb15cf68c75c746e0a5 127.0.0.1:7002</div><div class="line">   slots:10923-16383 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: dfcad7da198267663734490dc876a7c072d186f1 127.0.0.1:7003</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates 83976d23ea61befbacc383aa03bd2da9f08fa7fa</div><div class="line">[OK] All nodes agree about slots configuration.</div><div class="line">&gt;&gt;&gt; Check for open slots...</div><div class="line">&gt;&gt;&gt; Check slots coverage...</div><div class="line">[OK] All 16384 slots covered.</div></pre></td></tr></table></figure></p>
<p>这表示集群中的 16384 个槽都有至少一个主节点在处理， 集群运作正常。</p>
<p><strong>注意</strong>：如果脚本报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">custom_require.rb:36:in `require&apos;: cannot load such file -- redis (LoadError)</div><div class="line">from /usr/lib/ruby/1.9.1/rubygems/custom_require.rb:36:in `require&apos;</div><div class="line">from ./redis-trib.rb:25:in `&lt;main&gt;&apos;</div></pre></td></tr></table></figure></p>
<p>那么说明Ruby的redis接口没有安装，可以通过<code>sudo gem install redis</code>进行安装。</p>
<h3 id="Creating-a-Redis-Cluster-using-the-create-cluster-script"><a href="#Creating-a-Redis-Cluster-using-the-create-cluster-script" class="headerlink" title="Creating a Redis Cluster using the create-cluster script"></a>Creating a Redis Cluster using the create-cluster script</h3><p>If you don’t want to create a Redis Cluster by configuring and executing individual instances manually as explained above, there is a much simpler system (but you’ll not learn the same amount of operational details).</p>
<p>Just check utils/create-cluster directory in the Redis distribution. There is a script called create-cluster inside (same name as the directory it is contained into), it’s a simple bash script. In order to start a 6 nodes cluster with 3 masters and 3 slaves just type the following commands:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1. create-cluster start</div><div class="line">2. create-cluster create</div></pre></td></tr></table></figure></p>
<p>Reply to yes in step 2 when the redis-trib utility wants you to accept the cluster layout.<br>You can now interact with the cluster, the first node will start at port 30001 by default. When you are done, stop the cluster with:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">create-cluster stop</div></pre></td></tr></table></figure></p>
<p>Please read the README inside this directory for more information on how to run the script.</p>
<h3 id="使用集群"><a href="#使用集群" class="headerlink" title="使用集群"></a>使用集群</h3><p>Redis 集群现阶段的一个问题是客户端实现很少。<br>以下是一些我知道的实现：</p>
<ul>
<li><a href="https://github.com/antirez/redis-rb-cluster" target="_blank" rel="external">redis-rb-cluster</a> 是我（@antirez）编写的 Ruby 实现， 用于作为其他实现的参考。 该实现是对 redis-rb 的一个简单包装， 高效地实现了与集群进行通讯所需的最少语义（semantic）.</li>
<li><a href="https://github.com/Grokzen/redis-py-cluster" target="_blank" rel="external">redis-py-cluster</a> 看上去是 redis-rb-cluster 的一个 Python 版本， 这个项目有一段时间没有更新了（最后一次提交是在六个月之前）， 不过可以将这个项目用作学习集群的起点。</li>
<li>流行的 <a href="https://github.com/nrk/predis" target="_blank" rel="external">Predis</a> 曾经对早期的 Redis 集群有过一定的支持， 但我不确定它对集群的支持是否完整， 也不清楚它是否和最新版本的 Redis 集群兼容 （因为新版的 Redis 集群将槽的数量从 4k 改为 16k 了）.</li>
<li>使用最多的时java客户端, <a href="https://github.com/xetorthio/jedis" target="_blank" rel="external">Jedis</a> 最近添加了对集群的支持, 详细请查看项目README中Jedis Cluster部分.</li>
<li><a href="https://github.com/StackExchange/StackExchange.Redis" target="_blank" rel="external">StackExchange.Redis</a> 提供对 C# 的支持(并且包括大部分 .NET 下面的语言，比如： VB, F#等等)</li>
<li><a href="https://github.com/thunks/thunk-redis" target="_blank" rel="external">thunk-redis</a> 提供对 Node.js 和 io.js的支持。</li>
<li>Redis unstable 分支中的 redis-cli 程序实现了非常基本的集群支持， 可以使用命令 redis-cli -c 来启动。</li>
</ul>
<p>测试 Redis 集群比较简单的办法就是使用 redis-rb-cluster 或者 redis-cli ， 接下来我们将使用 redis-cli 为例来进行演示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -c -p 7000</div><div class="line">redis 127.0.0.1:7000&gt; set foo bar</div><div class="line">-&gt; Redirected to slot [12182] located at 127.0.0.1:7002</div><div class="line">OK</div><div class="line">redis 127.0.0.1:7002&gt; set hello world</div><div class="line">-&gt; Redirected to slot [866] located at 127.0.0.1:7000</div><div class="line">OK</div><div class="line">redis 127.0.0.1:7000&gt; get foo</div><div class="line">-&gt; Redirected to slot [12182] located at 127.0.0.1:7002</div><div class="line">&quot;bar&quot;</div><div class="line">redis 127.0.0.1:7000&gt; get hello</div><div class="line">-&gt; Redirected to slot [866] located at 127.0.0.1:7000</div><div class="line">&quot;world&quot;</div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>: 如果你是使用脚本创建的集群节点，那么默认端口可能是从30001开始。</p>
<p>redis-cli 对集群的支持是非常基本的， 所以它总是依靠 Redis 集群节点来将它转向（redirect）至正确的节点。一个真正的（serious）集群客户端应该做得比这更好： 它应该用缓存记录起哈希槽与节点地址之间的映射（map）， 从而直接将命令发送到正确的节点上面。这种映射只会在集群的配置出现某些修改时变化， 比如说， 在一次故障转移（failover）之后， 或者系统管理员通过添加节点或移除节点来修改了集群的布局（layout）之后， 诸如此类。</p>
<h3 id="使用redis-rb-cluster写一个例子"><a href="#使用redis-rb-cluster写一个例子" class="headerlink" title="使用redis-rb-cluster写一个例子"></a>使用redis-rb-cluster写一个例子</h3><p>在展示如何使用集群进行故障转移、重新分片等操作之前， 我们需要创建一个示例应用， 了解一些与 Redis 集群客户端进行交互的基本方法。  </p>
<p>在运行示例应用的过程中， 我们会尝试让节点进入失效状态， 又或者开始一次重新分片， 以此来观察 Redis 集群在真实世界运行时的表现， 并且为了让这个示例尽可能地有用， 我们会让这个应用向集群进行写操作。<br>本节将通过两个示例应用来展示 redis-rb-cluster 的基本用法， 以下是本节的第一个示例应用， 它是一个名为 example.rb 的文件， 包含在redis-rb-cluster 项目里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"> 1  require &apos;./cluster&apos;</div><div class="line"> 2</div><div class="line"> 3  startup_nodes = [</div><div class="line"> 4      &#123;:host =&gt; &quot;127.0.0.1&quot;, :port =&gt; 7000&#125;,</div><div class="line"> 5      &#123;:host =&gt; &quot;127.0.0.1&quot;, :port =&gt; 7001&#125;</div><div class="line"> 6  ]</div><div class="line"> 7  rc = RedisCluster.new(startup_nodes,32,:timeout =&gt; 0.1)</div><div class="line"> 8</div><div class="line"> 9  last = false</div><div class="line">10</div><div class="line">11  while not last</div><div class="line">12      begin</div><div class="line">13          last = rc.get(&quot;__last__&quot;)</div><div class="line">14          last = 0 if !last</div><div class="line">15      rescue =&gt; e</div><div class="line">16          puts &quot;error #&#123;e.to_s&#125;&quot;</div><div class="line">17          sleep 1</div><div class="line">18      end</div><div class="line">19  end</div><div class="line">20</div><div class="line">21  ((last.to_i+1)..1000000000).each&#123;|x|</div><div class="line">22      begin</div><div class="line">23          rc.set(&quot;foo#&#123;x&#125;&quot;,x)</div><div class="line">24          puts rc.get(&quot;foo#&#123;x&#125;&quot;)</div><div class="line">25          rc.set(&quot;__last__&quot;,x)</div><div class="line">26      rescue =&gt; e</div><div class="line">27          puts &quot;error #&#123;e.to_s&#125;&quot;</div><div class="line">28      end</div><div class="line">29      sleep 0.1</div><div class="line">30  &#125;</div></pre></td></tr></table></figure></p>
<p>这个应用所做的工作非常简单： 它不断地以 foo<number> 为键， number 为值， 使用 SET 命令向数据库设置键值对:</number></p>
<ul>
<li>SET foo0 0</li>
<li>SET foo1 1</li>
<li>SET foo2 2</li>
<li>And so forth…</li>
</ul>
<p>代码中的每个集群操作都使用一个 begin 和 rescue 代码块（block）包裹着， 因为我们希望在代码出错时， 将错误打印到终端上面， 而不希望应用因为异常（exception）而退出。</p>
<p>代码的第七行是代码中第一个有趣的地方， 它创建了一个 Redis 集群对象， 其中创建对象所使用的参数及其意义如下：第一个参数是记录了启动节点的 startup_nodes 列表， 列表中包含了两个集群节点的地址。第二个参数指定了对于集群中的各个不同的节点， Redis 集群对象可以获得的最大连接数 ，第三个参数 timeout 指定了一个命令在执行多久之后， 才会被看作是执行失败。</p>
<p>启动列表中并不需要包含所有集群节点的地址， 但这些地址中至少要有一个是有效的： 一旦 redis-rb-cluster 成功连接上集群中的某个节点时， 集群节点列表就会被自动更新， 任何真正的的集群客户端都应该这样做。</p>
<p>现在， 程序创建的 Redis 集群对象实例被保存到 rc 变量里面， 我们可以将这个对象当作普通 Redis 对象实例来使用。<br>在十一至十九行， 我们先尝试阅读计数器中的值， 如果计数器不存在的话， 我们才将计数器初始化为 0 ： 通过将计数值保存到 Redis 的计数器里面， 我们可以在示例重启之后， 仍然继续之前的执行过程， 而不必每次重启之后都从 foo0 开始重新设置键值对。为了让程序在集群下线的情况下， 仍然不断地尝试读取计数器的值， 我们将读取操作包含在了一个 while 循环里面， 一般的应用程序并不需要如此小心。</p>
<p>二十一至三十行是程序的主循环， 这个循环负责设置键值对， 并在设置出错时打印错误信息。程序在主循环的末尾添加了一个 sleep 调用， 让写操作的执行速度变慢， 帮助执行示例的人更容易看清程序的输出。执行 example.rb 程序将产生以下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ruby ./example.rb</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">^C (I stopped the program here)</div></pre></td></tr></table></figure></p>
<p>这个程序并不是十分有趣， 稍后我们就会看到一个更有趣的集群应用示例， 不过在此之前， 让我们先使用这个示例来演示集群的重新分片操作。</p>
<h3 id="集群重新分片"><a href="#集群重新分片" class="headerlink" title="集群重新分片"></a>集群重新分片</h3><p>现在， 让我们来试试对集群进行重新分片操作。在执行重新分片的过程中， 请让你的 example.rb 程序处于运行状态， 这样你就会看到， 重新分片并不会对正在运行的集群程序产生任何影响， 你也可以考虑将 example.rb 中的 sleep 调用删掉， 从而让重新分片操作在近乎真实的写负载下执行 重新分片操作基本上就是将某些节点上的哈希槽移动到另外一些节点上面， 和创建集群一样， 重新分片也可以使用 redis-trib 程序来执行 执行以下命令可以开始一次重新分片操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb reshard 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<p>你只需要指定集群中其中一个节点的地址， redis-trib 就会自动找到集群中的其他节点。<br>目前 redis-trib 只能在管理员的协助下完成重新分片的工作， 要让 redis-trib 自动将哈希槽从一个节点移动到另一个节点， 目前来说还做不到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">你想移动多少个槽( 从1 到 16384)?</div></pre></td></tr></table></figure></p>
<p>我们尝试从将100个槽重新分片， 如果 example.rb 程序一直运行着的话， 现在 1000 个槽里面应该有不少键了。<br>除了移动的哈希槽数量之外， redis-trib 还需要知道重新分片的目标， 也即是， 负责接收这 1000 个哈希槽的节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -p 7000 cluster nodes | grep myself</div><div class="line">97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5460</div></pre></td></tr></table></figure></p>
<p>我的目标节点是 97a3a64667477371c4479320d683e4c8db5858b1.<br>现在需要指定从哪些节点来移动keys到目标节点 我输入的是all ，这样就会从其他每个master上取一些哈希槽。<br>最后确认后你将会看到每个redis-trib移动的槽的信息，每个key的移动的信息也会打印出来        在重新分片的过程中，你的例子程序是不会受到影响的,你可以停止或者重新启动多次。<br>在重新分片结束后你可以通过如下命令检查集群状态:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb check 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<h3 id="一个更有趣的程序"><a href="#一个更有趣的程序" class="headerlink" title="一个更有趣的程序"></a>一个更有趣的程序</h3><p>我们在前面使用的示例程序 example.rb 并不是十分有趣， 因为它只是不断地对集群进行写入， 但并不检查写入结果是否正确。 比如说， 集群可能会错误地将 example.rb 发送的所有 SET 命令都改成了 SET foo 42 ， 但因为 example.rb 并不检查写入后的值， 所以它不会意识到集群实际上写入的值是错误的 因为这个原因， redis-rb-cluster 项目包含了一个名为 consistency-test.rb 的示例应用， 这个应用比起 example.rb 有趣得多： 它创建了多个计数器（默认为 1000 个）， 并通过发送 INCR 命令来增加这些计数器的值。</p>
<p>在增加计数器值的同时， consistency-test.rb 还执行以下操作： 每次使用 INCR 命令更新一个计数器时， 应用会记录下计数器执行 INCR 命令之后应该有的值。 举个例子， 如果计数器的起始值为 0 ， 而这次是程序第 50 次向它发送 INCR 命令， 那么计数器的值应该是 50 。</p>
<p>在每次发送 INCR 命令之前， 程序会随机从集群中读取一个计数器的值， 并将它与自己记录的值进行对比， 看两个值是否相同。</p>
<p>换句话说， 这个程序是一个一致性检查器（consistency checker）： 如果集群在执行 INCR 命令的过程中， 丢失了某条 INCR 命令， 又或者多执行了某条客户端没有确认到的 INCR 命令， 那么检查器将察觉到这一点 —— 在前一种情况中， consistency-test.rb 记录的计数器值将比集群记录的计数器值要大； 而在后一种情况中， consistency-test.rb 记录的计数器值将比集群记录的计数器值要小。</p>
<p>运行 consistency-test 程序将产生类似以下的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ ruby consistency-test.rb</div><div class="line">925 R (0 err) | 925 W (0 err) |</div><div class="line">5030 R (0 err) | 5030 W (0 err) |</div><div class="line">9261 R (0 err) | 9261 W (0 err) |</div><div class="line">13517 R (0 err) | 13517 W (0 err) |</div><div class="line">17780 R (0 err) | 17780 W (0 err) |</div><div class="line">22025 R (0 err) | 22025 W (0 err) |</div><div class="line">25818 R (0 err) | 25818 W (0 err) |</div></pre></td></tr></table></figure></p>
<p>结果展示了执行的读和 写,和错误(由于系统不可用而没有接受的查询发生的错误）的数量.<br>如果程序察觉了不一致的情况出现， 它将在输出行的末尾显式不一致的详细情况。比如说， 如果我们在 consistency-test.rb 运行的过程中， 手动修改某个计数器的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ redis 127.0.0.1:7000&gt; set key_217 0</div><div class="line">OK</div><div class="line"></div><div class="line">(in the other tab I see...)</div><div class="line"></div><div class="line">94774 R (0 err) | 94774 W (0 err) |</div><div class="line">98821 R (0 err) | 98821 W (0 err) |</div><div class="line">102886 R (0 err) | 102886 W (0 err) | 114 lost |</div><div class="line">107046 R (0 err) | 107046 W (0 err) | 114 lost |</div></pre></td></tr></table></figure></p>
<p>在我们修改计数器值的时候， 计数器的正确值是 114 （执行了 114 次 INCR 命令）， 因为我们将计数器的值设成了 0 ， 所以 consistency-test.rb 会向我们报告说丢失了 114 个 INCR 命令。<br>这个程序作为测试程序很有意思，所以我们用这个程序来测试故障恢复.</p>
<h3 id="测试故障转移"><a href="#测试故障转移" class="headerlink" title="测试故障转移"></a>测试故障转移</h3><p>在执行本节操作的过程中， 请一直运行 consistency-test 程序。 要触发一次故障转移， 最简单的办法就是令集群中的某个主节点进入下线状态。首先用以下命令列出集群中的所有主节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -p 7000 cluster nodes | grep master</div><div class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385482984082 0 connected 5960-10921</div><div class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 master - 0 1385482983582 0 connected 11423-16383</div><div class="line">97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422</div></pre></td></tr></table></figure></p>
<p>通过命令输出得知端口号为 7000 、 7001 和 7002 的节点都是主节点， 然后我们可以通过向端口号为7002 的主节点发送 <strong>DEBUG SEGFAULT</strong> 命令， 让这个主节点崩溃：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -p 7002 debug segfault</div><div class="line">Error: Server closed the connection</div></pre></td></tr></table></figure></p>
<p>现在，切换到运行着 consistency-test 的标签页， 可以看到， consistency-test 在 7002 下线之后的一段时间里将产生大量的错误警告信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">18849 R (0 err) | 18849 W (0 err) |</div><div class="line">23151 R (0 err) | 23151 W (0 err) |</div><div class="line">27302 R (0 err) | 27302 W (0 err) |</div><div class="line"></div><div class="line">... many error warnings here ...</div><div class="line"></div><div class="line">29659 R (578 err) | 29660 W (577 err) |</div><div class="line">33749 R (578 err) | 33750 W (577 err) |</div><div class="line">37918 R (578 err) | 37919 W (577 err) |</div><div class="line">42077 R (578 err) | 42078 W (577 err) |</div></pre></td></tr></table></figure></p>
<p>从 consistency-test 的这段输出可以看到， 集群在执行故障转移期间， 总共丢失了 578 个读命令和 577 个写命令， 但是并没有产生任何数据不一致。这听上去可能有点奇怪， 因为在教程的开头我们提到过， Redis 使用的是异步复制， 在执行故障转移期间， 集群可能会丢失写命令。但是在实际上， 丢失命令的情况并不常见， 因为 Redis 几乎是同时执行将命令回复发送给客户端， 以及将命令复制给从节点这两个操作， 所以实际上造成命令丢失的时间窗口是非常小的。不过， 尽管出现的几率不高， 但丢失命令的情况还是有可能会出现的， 所以我们对 Redis 集群不能提供强一致性的这一描述仍然是正确的。现在， 让我们使用 cluster nodes 命令,查看集群在执行故障转移操作之后， 主从节点的布局情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -p 7000 cluster nodes</div><div class="line">3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385503418521 0 connected</div><div class="line">a211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385503419023 0 connected</div><div class="line">97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422</div><div class="line">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385503419023 3 connected 11423-16383</div><div class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385503417005 0 connected 5960-10921</div><div class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385503418016 3 connected</div></pre></td></tr></table></figure></p>
<p>现在masters运行在 7000, 7001 和 7005端口上. 原来的master 7002现在变成了一个7005的一个从节点.<br>CLUSTER NODES 命令的输出看起来有点复杂,其实他非常的简单，含义如下:</p>
<ul>
<li>节点ID</li>
<li>IP:端口</li>
<li>标志: master, slave, myself, fail, …</li>
<li>如果是个从节点, 这里是它的主节点的NODE ID</li>
<li>集群最近一次向节点发送 PING 命令之后， 过去了多长时间还没接到回复。.</li>
<li>节点最近一次返回 PONG 回复的时间。</li>
<li>节点的配置纪元（configuration epoch）：详细信息请参考 Redis 集群规范 。</li>
<li>本节点的网络连接情况：例如 connected 。</li>
<li>节点目前包含的槽：例如 127.0.0.1:7001 目前包含号码为 5960 至 10921 的哈希槽。</li>
</ul>
<h3 id="手动故障转移"><a href="#手动故障转移" class="headerlink" title="手动故障转移"></a>手动故障转移</h3><p>有的时候在主节点没有任何问题的情况下强制手动故障转移也是很有必要的，比如想要升级主节点的Redis进程，我们可以通过故障转移将其转为slave再进行升级操作来避免对集群的可用性造成很大的影响。</p>
<p>Redis集群使用 <code>CLUSTER FAILOVER</code>命令来进行故障转移，不过要被转移的主节点的从节点上执行该命令 手动故障转移比主节点失败自动故障转移更加安全，因为手动故障转移时客户端的切换是在确保新的主节点完全复制了失败的旧的主节点数据的前提下下发生的，所以避免了数据的丢失。<br>执行手动故障转移时从节点日志如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># Manual failover user request accepted.</div><div class="line"># Received replication offset for paused master manual failover: 347540</div><div class="line"># All master replication stream processed, manual failover can start.</div><div class="line"># Start of election delayed for 0 milliseconds (rank #0, offset 347540).</div><div class="line"># Starting a failover election for epoch 7545.</div><div class="line"># Failover election won: I&apos;m the new master.</div></pre></td></tr></table></figure></p>
<p>其基本过程如下：客户端不再链接我们淘汰的主节点，同时主节点向从节点发送复制偏移量,从节点得到复制偏移量后故障转移开始,接着通知主节点进行配置切换,当客户端在旧的master上解锁后重新连接到新的主节点上。</p>
<h3 id="添加一个新节点"><a href="#添加一个新节点" class="headerlink" title="添加一个新节点"></a>添加一个新节点</h3><p>添加新的节点的基本过程就是添加一个空的节点然后移动一些数据给它，有两种情况，添加一个主节点和添加一个从节点（添加从节点时需要将这个新的节点设置为集群中某个节点的复制）<br>针对这两种情况，本节都会介绍，先从添加主节点开始.</p>
<p>两种情况第一步都是要添加 一个空的节点.<br>启动新的7006节点,使用的配置文件和以前的一样,只要把端口号改一下即可，过程如下:   </p>
<ul>
<li>在终端打开一个新的标签页.</li>
<li>进入cluster-test 目录.</li>
<li>创建并进入 7006文件夹.</li>
<li>和其他节点一样，创建redis.conf文件,需要将端口号改成7006.</li>
<li>最后启动节点 ../redis-server ./redis.conf</li>
<li>如果正常的话，节点会正确的启动.</li>
</ul>
<p>接下来使用redis-trib 来添加这个节点到现有的集群中去.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb add-node 127.0.0.1:7006 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<p>可以看到.使用<strong>addnode</strong>命令来添加节点，第一个参数是新节点的地址，第二个参数是任意一个已经存在的节点的IP和端口. 我们可以看到新的节点已经添加到集群中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:7006&gt; cluster nodes</div><div class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385543178575 0 connected 5960-10921</div><div class="line">3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385543179583 0 connected</div><div class="line">f093c80dde814da99c5cf72a7dd01590792b783b :0 myself,master - 0 0 0 connected</div><div class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543178072 3 connected</div><div class="line">a211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385543178575 0 connected</div><div class="line">97a3a64667477371c4479320d683e4c8db5858b1 127.0.0.1:7000 master - 0 1385543179080 0 connected 0-5959 10922-11422</div><div class="line">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385543177568 3 connected 11423-16383</div></pre></td></tr></table></figure></p>
<p>新节点现在已经连接上了集群， 成为集群的一份子， 并且可以对客户端的命令请求进行转向了， 但是和其他主节点相比， 新节点还有两点区别： </p>
<ul>
<li>新节点没有包含任何数据， 因为它没有包含任何哈希槽.</li>
<li>尽管新节点没有包含任何哈希槽， 但它仍然是一个主节点， 所以在集群需要将某个从节点升级为新的主节点时， 这个新节点不会被选中。</li>
</ul>
<p>接下来， 只要使用 redis-trib 程序， 将集群中的某些哈希桶移动到新节点里面， 新节点就会成为真正的主节点了。</p>
<h3 id="添加一个从节点"><a href="#添加一个从节点" class="headerlink" title="添加一个从节点"></a>添加一个从节点</h3><p>有两种方法添加从节点，可以像添加主节点一样使用redis-trib 命令，也可以像下面的例子一样使用 –slave选项:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb add-node --slave 127.0.0.1:7006 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<p>此处的命令和添加一个主节点命令类似，此处并没有指定添加的这个从节点的主节点，这种情况下系统会在其他的复制集中的主节点中随机选取一个作为这个从节点的主节点。<br>你可以通过下面的命令指定主节点:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb add-node --slave --master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7006 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<p>也可以使用CLUSTER REPLICATE 命令添加.这个命令也可以改变一个从节点的主节点。<br>例如，要给主节点 127.0.0.1:7005添加一个从节点，该节点哈希槽的范围1423-16383, 节点 ID 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e,我们需要链接新的节点（已经是空的主节点）并执行命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:7006&gt; cluster replicate 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</div></pre></td></tr></table></figure></p>
<p>我们新的从节点有了一些哈希槽，其他的节点也知道（过几秒后会更新他们自己的配置），可以使用如下命令确认:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -p 7000 cluster nodes | grep slave | grep 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</div><div class="line">f093c80dde814da99c5cf72a7dd01590792b783b 127.0.0.1:7006 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617702 3 connected</div><div class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617198 3 connected</div></pre></td></tr></table></figure></p>
<p>节点 3c3a0c… 有两个从节点， 7002 (已经存在的) 和 7006 (新添加的).</p>
<h3 id="移除一个节点"><a href="#移除一个节点" class="headerlink" title="移除一个节点"></a>移除一个节点</h3><p>只要使用 del-node 命令即可:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb del-node 127.0.0.1:7000 `&lt;node-id&gt;`</div></pre></td></tr></table></figure></p>
<p>第一个参数是任意一个节点的地址,第二个节点是你想要移除的节点地址。<br>使用同样的方法移除主节点,不过在移除主节点前，<strong>需要确保这个主节点是空的</strong>. 如果不是空的,需要将这个节点的数据重新分片到其他主节点上.</p>
<p>替代移除主节点的方法是手动执行故障恢复，被移除的主节点会作为一个从节点存在，不过这种情况下不会减少集群节点的数量，也需要重新分片数据.</p>
<h3 id="从节点的迁移"><a href="#从节点的迁移" class="headerlink" title="从节点的迁移"></a>从节点的迁移</h3><p>在Redis集群中会存在改变一个从节点的主节点的情况，需要执行如下命令 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CLUSTER REPLICATE &lt;master-node-id&gt;</div></pre></td></tr></table></figure></p>
<p>在特定的场景下，不需要系统管理员的协助下，自动将一个从节点从当前的主节点切换到另一个主节 的自动重新配置的过程叫做复制迁移（从节点迁移），从节点的迁移能够提高整个Redis集群的可用性.</p>
<p>你可以阅读（Redis集群规范）<a href="http://www.redis.cn/topics/cluster-spec.html" target="_blank" rel="external">/topics/cluster-spec</a>了解细节.</p>
<p>简短的概况一下从节点迁移</p>
<ul>
<li>集群会在有从节点数量最多的主节点上进行从节点的迁移.</li>
<li>要在一个主节点上添加多个从节点.</li>
<li>参数来控制从节点迁移 replica-migration-barrier:你可以仔细阅读redis.conf 。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/服务器相关/redis/Redis集群/" data-id="cjegeioa400expfblgvncnig4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/5/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Eclipse/">Eclipse</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Github/">Github</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Cookie/">Cookie</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JAXB/">JAXB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JavaMail/">JavaMail</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/基础/">基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/数据类型/">数据类型</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/日记/">日记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/时间日期/">时间日期</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/线程/">线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/网络NIO/">网络NIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/队列/">队列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/集合/">集合</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Application-Event/">Application Event</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/JPA/">JPA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Security/">Security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Spring-Boot/">Spring Boot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Spring-Session/">Spring Session</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Task/">Task</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-MVC/">spring MVC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-data-redis/">spring data redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/基础/">基础</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/">前端技术相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/forever/">forever</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/javascript/">javascript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库相关/">数据库相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据库相关/mysql/">mysql</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/">服务器相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hessian/">Hessian</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hudson-Jenkins/">Hudson & Jenkins</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Memcached/">Memcached</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Nginx/">Nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Tomcat/">Tomcat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/red5/">red5</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/resin/">resin</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/02/25/Java/集合/Hashtable与ConcurrentHashMap区别/">Hashtable与ConcurrentHashMap区别</a>
          </li>
        
          <li>
            <a href="/2018/02/25/Java/集合/HashSet原理/">HashSet原理</a>
          </li>
        
          <li>
            <a href="/2018/02/25/Java/分布式/分布式事务/">分布式事务</a>
          </li>
        
          <li>
            <a href="/2018/02/25/Java/集合/在List循环中删除元素/">在List循环中删除元素</a>
          </li>
        
          <li>
            <a href="/2018/02/25/Java/基础/java8新特性/">java8新特性</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 LeoChan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>