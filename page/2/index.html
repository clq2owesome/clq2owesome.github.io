<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LeoChan&#39;s 个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="描述啊">
<meta property="og:type" content="website">
<meta property="og:title" content="LeoChan&#39;s 个人博客">
<meta property="og:url" content="https://clq2owesome.github.io/page/2/index.html">
<meta property="og:site_name" content="LeoChan&#39;s 个人博客">
<meta property="og:description" content="描述啊">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeoChan&#39;s 个人博客">
<meta name="twitter:description" content="描述啊">
  
    <link rel="alternate" href="/atom.xml" title="LeoChan&#39;s 个人博客" type="application/atom+xml">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  

</head>

<body>
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">LeoChan&#39;s 个人博客</h1>
  
    <p class="lead blog-description">技术都是通用的，重要的是是否具有自主解决问题的能力！</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-Spring/Security/配置十七：基于方法的权限控制" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Spring/Security/配置十七：基于方法的权限控制/">配置十七：基于方法的权限控制</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/15/Spring/Security/配置十七：基于方法的权限控制/" class="article-date"><time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a> / <a class="article-category-link" href="/categories/Spring/Security/">Security</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;之前介绍的都是基于URL的权限控制，Spring Security同样支持对于方法的权限控制。可以通过intercept-methods对某个bean下面的方法进行权限控制，也可以通过pointcut对整个Service层的方法进行统一的权限控制，还可以通过注解定义对单独的某一个方法进行权限控制。</p>
<p>一. <strong>intercept-methods定义方法权限控制</strong><br>&emsp;&emsp;intercept-methods是需要定义在bean元素下的，通过它可以定义对当前的bean的某些方法进行权限控制，具体方法是使用其下的子元素protect进行定义的。protect元素需要指定两个属性，access和method，method表示需要拦截的方法名称，可以使用通配符，access表示执行对应的方法需要拥有的权限，多个权限之间可以使用逗号分隔。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.xxx.service.impl.UserServiceImpl"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-methods</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">security:protect</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span> <span class="attr">method</span>=<span class="string">"find*"</span>/&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">security:protect</span> <span class="attr">access</span>=<span class="string">"ROLE_ADMIN"</span> <span class="attr">method</span>=<span class="string">"add*"</span>/&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">security:protect</span> <span class="attr">access</span>=<span class="string">"ROLE_ADMIN"</span> <span class="attr">method</span>=<span class="string">"update*"</span>/&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">security:protect</span> <span class="attr">access</span>=<span class="string">"ROLE_ADMIN"</span> <span class="attr">method</span>=<span class="string">"delete*"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">security:intercept-methods</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在上面的配置中表示在执行UserServiceImpl的方法名以find开始的方法时需要当前用户拥有ROLE_USER的权限，在执行方法名以add、update或delete开始的方法时需要拥有ROLE_ADMIN的权限。当访问被拒绝时还是交由ExceptionTranslationFilter处理，这也就意味着如果用户未登录则会引导用户进行登录，否则默认将返回403错误码到客户端。  </p>
<p>二. <strong>使用pointcut定义方法权限控制</strong><br>&emsp;&emsp;基于pointcut的方法权限控制是通过global-method-security下的protect-pointcut来定义的。可以在global-method-security元素下定义多个protect-pointcut以对不同的pointcut使用不同的权限控制。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:global-method-security</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:protect-pointcut</span> <span class="attr">access</span>=<span class="string">"ROLE_READ"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.elim.*..*Service.find*(..))"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:protect-pointcut</span> <span class="attr">access</span>=<span class="string">"ROLE_WRITE"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.elim.*..*Service.*(..))"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:global-method-security</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上面的定义表示我们在执行com.elim包或其子包下任意以Service结尾的类，其方法名以find开始的所有方法时都需要用户拥有ROLE_READ的权限，对于com.elim包或其子包下任意以Service结尾的类的其它方法在执行时都需要ROLE_WRITE的权限。需要注意的是对应的类需要是定义在ApplicationContext中的bean才行。此外同对于URL的权限控制一样，当定义多个protect-pointcut时更具有特性的应当先定义，因为在pointcut匹配的时候是按照声明顺序进行匹配的，一旦匹配上了后续的将不再进行匹配了。</p>
<p>三. <strong>使用注解定义方法权限控制</strong><br>&emsp;&emsp;基于注解的方法权限控制也是需要通过global-method-security元素定义来进行启用的。Spring Security在方法的权限控制上支持三种类型的注解，JSR-250注解、@Secured注解和支持表达式的注解。这三种注解默认都是没有启用的，需要单独通过global-method-security元素的对应属性进行启用。</p>
<p>四. <strong>JSR-250注解</strong><br>&emsp;&emsp;要使用JSR-250注解，首先我们需要通过设置global-method-security元素的jsr250-annotation=”enabled”来启用基于JSR-250注解的支持，默认为disabled。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:global-method-security</span> <span class="attr">jsr250-annotations</span>=<span class="string">"enabled"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;此外，还需要确保添加了jsr250-api到我们的类路径下。之后就可以在我们的Service方法上使用JSR-250注解进行权限控制了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="meta">@RolesAllowed</span>(<span class="string">"ROLE_ADMIN"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"addUser................"</span> + user);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"updateUser.............."</span> + user);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="meta">@RolesAllowed</span>(&#123;<span class="string">"ROLE_USER"</span>, <span class="string">"ROLE_ADMIN"</span>&#125;)</div><div class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"find user by id............."</span> + id);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"delete user by id................"</span>);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="meta">@RolesAllowed</span>(<span class="string">"ROLE_USER"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"find all user..............."</span>);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上面的代码表示执行UserServiceImpl里面所有的方法都需要角色ROLE_ADMIN，其中findAll()方法的执行需要ROLE_USER角色，而find()方法的执行对于ROLE_USER或者ROLE_ADMIN角色都可以。<br>&emsp;&emsp;顺便介绍一下JSR-250中对权限支持的注解。  </p>
<ol>
<li><strong>RolesAllowed</strong>表示访问对应方法时所应该具有的角色。其可以标注在类上，也可以标注在方法上，当标注在类上时表示其中所有方法的执行都需要对应的角色，当标注在方法上表示执行该方法时所需要的角色，当方法和类上都使用了@RolesAllowed进行标注，则方法上的@RolesAllowed将覆盖类上的@RolesAllowed，即方法上的@RolesAllowed将对当前方法起作用。@RolesAllowed的值是由角色名称组成的数组。</li>
<li><strong>PermitAll</strong>表示允许所有的角色进行访问，也就是说不进行权限控制。@PermitAll可以标注在方法上也可以标注在类上，当标注在方法上时则只对对应方法不进行权限控制，而标注在类上时表示对类里面所有的方法都不进行权限控制    （1）当@PermitAll标注在类上，而@RolesAllowed标注在方法上时则按照@RolesAllowed将覆盖@PermitAll，即需要@RolesAllowed对应的角色才能访问。  （2）当@RolesAllowed标注在类上，而@PermitAll标注在方法上时则对应的方法也是不进行权限控制的。  （3）当在方法上同时使用了@PermitAll和@RolesAllowed时先定义的将发生作用，而都定义在类上时则是反过来的，即后定义的将发生作用（这个没多大的实际意义，实际应用中不会有这样的定义）。</li>
<li><strong>DenyAll</strong>是和PermitAll相反的，表示无论什么角色都不能访问。@DenyAll只能定义在方法上。你可能会有疑问使用@DenyAll标注的方法无论拥有什么权限都不能访问，那还定义它干啥呢？使用@DenyAll定义的方法只是在我们的权限控制中不能访问，脱离了权限控制还是可以访问的。</li>
</ol>
<p>五. <strong>@Secured注解</strong><br>&emsp;&emsp;@Secured是由Spring Security定义的用来支持方法权限控制的注解。它的使用也是需要启用对应的支持才会生效的。通过设置global-method-security元素的secured-annotations=”enabled”可以启用Spring Security对使用@Secured注解标注的方法进行权限控制的支持，其值默认为disabled。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:global-method-security</span> <span class="attr">secured-annotations</span>=<span class="string">"enabled"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</div><div class="line"> </div><div class="line">   <span class="meta">@Secured</span>(<span class="string">"ROLE_ADMIN"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"addUser................"</span> + user);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="meta">@Secured</span>(<span class="string">"ROLE_USER"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"find all user..............."</span>);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上面的代码中我们使用@Secured定义了只有拥有ROLE_ADMIN角色的用户才能调用方法addUser()，只有拥有ROLE_USER角色的用户才能调用方法findAll()。</p>
<p>六. <strong>支持表达式的注解</strong><br>&emsp;&emsp;Spring Security中定义了四个支持使用表达式的注解，分别是@PreAuthorize、@PostAuthorize、@PreFilter和@PostFilter。其中前两者可以用来在方法调用前或者调用后进行权限检查，后两者可以用来对集合类型的参数或者返回值进行过滤。要使它们的定义能够对我们的方法的调用产生影响我们需要设置global-method-security元素的pre-post-annotations=”enabled”，默认为disabled。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:global-method-security</span> <span class="attr">pre-post-annotations</span>=<span class="string">"disabled"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>6.1 使用@PreAuthorize和@PostAuthorize进行访问控制<br>@PreAuthorize可以用来控制一个方法是否能够被调用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</div><div class="line"> </div><div class="line">   <span class="meta">@PreAuthorize</span>(<span class="string">"hasRole('ROLE_ADMIN')"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"addUser................"</span> + user);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="meta">@PreAuthorize</span>(<span class="string">"hasRole('ROLE_USER') or hasRole('ROLE_ADMIN')"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"find user by id............."</span> + id);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在上面的代码中我们定义了只有拥有角色ROLE_ADMIN的用户才能访问adduser()方法，而访问find()方法需要有ROLE_USER角色或ROLE_ADMIN角色。使用表达式时我们还可以在表达式中使用方法参数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</div><div class="line"> </div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 限制只能查询Id小于10的用户</div><div class="line">    */</div><div class="line">   <span class="meta">@PreAuthorize</span>(<span class="string">"#id&lt;10"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"find user by id........."</span> + id);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line">  </div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 限制只能查询自己的信息</div><div class="line">    */</div><div class="line">   <span class="meta">@PreAuthorize</span>(<span class="string">"principal.username.equals(#username)"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(String username)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"find user by username......"</span> + username);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 限制只能新增用户名称为abc的用户</div><div class="line">    */</div><div class="line">   <span class="meta">@PreAuthorize</span>(<span class="string">"#user.name.equals('abc')"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"addUser............"</span> + user);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在上面代码中我们定义了调用find(int id)方法时，只允许参数id小于10的调用；调用find(String username)时只允许username为当前用户的用户名；定义了调用add()方法时只有当参数user的name为abc时才可以调用。<br>&emsp;&emsp;有时候可能你会想在方法调用完之后进行权限检查，这种情况比较少，但是如果你有的话，Spring Security也为我们提供了支持，通过@PostAuthorize可以达到这一效果。使用@PostAuthorize时我们可以使用内置的表达式returnObject表示方法的返回值。我们来看下面这一段示例代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PostAuthorize</span>(<span class="string">"returnObject.id%2==0"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">  User user = <span class="keyword">new</span> User();</div><div class="line">  user.setId(id);</div><div class="line">  <span class="keyword">return</span> user;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上面这一段代码表示将在方法find()调用完成后进行权限检查，如果返回值的id是偶数则表示校验通过，否则表示校验失败，将抛出AccessDeniedException。       需要注意的是@PostAuthorize是在方法调用完成后进行权限检查，它不能控制方法是否能被调用，只能在方法调用完成后检查权限决定是否要抛出AccessDeniedException。<br>使用@PreFilter和@PostFilter进行过滤<br>6.2 使用@PreFilter和@PostFilter可以对集合类型的参数或返回值进行过滤。<br>使用@PreFilter和@PostFilter时，Spring Security将移除使对应表达式的结果为false的元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PostFilter</span>(<span class="string">"filterObject.id%2==0"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</div><div class="line">  List&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;User&gt;();</div><div class="line">  User user;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</div><div class="line">     user = <span class="keyword">new</span> User();</div><div class="line">     user.setId(i);</div><div class="line">     userList.add(user);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> userList;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上述代码表示将对返回结果中id不为偶数的user进行移除。filterObject是使用@PreFilter和@PostFilter时的一个内置表达式，表示集合中的当前对象。当@PreFilter标注的方法拥有多个集合类型的参数时，需要通过@PreFilter的filterTarget属性指定当前@PreFilter是针对哪个参数进行过滤的。如下面代码就通过filterTarget指定了当前@PreFilter是用来过滤参数ids的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PreFilter</span>(filterTarget=<span class="string">"ids"</span>, value=<span class="string">"filterObject%2==0"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(List&lt;Integer&gt; ids, List&lt;String&gt; usernames)</span> </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>七. <strong>方法权限控制的拦截器</strong><br>&emsp;&emsp;关于方法权限控制，Spring Security提供了两类AbstractSecurityInterceptor，基于AOP Alliance的MethodSecurityInterceptor，和基于Aspectj继承自MethodSecurityInterceptor的AspectJMethodSecurityInterceptor。<br>7.1 <strong>MethodSecurityInterceptor</strong><br>&emsp;&emsp;当我们在使用基于NameSpace进行方法保护的配置时，Spring Security默认配置的就是MethodSecurityInterceptor。根据配置的不同，一个拦截器可能只是针对于一个bean，也可能是针对于多个bean的。MethodSecurityInterceptor使用一个MethodSecurityMetadataSource的实例来获取特定方法调用配置的ConfigAttribute。当我们在ApplicationContext配置文件中使用intercept-methods元素或protect-point元素定义需要保护的方法调用时，Spring Security内部默认会使用一个MapBasedMethodSecurityMetadataSource来保存在这些元素上定义的配置信息，保存的key是对应的方法名（可以是含有通配符的）。类似的使用JSR-250注解时将使用Jsr250MethodSecurityMetadataSource解析配置属性；使用@Secured注解时将使用SecuredAnnotationSecurityMetadataSource解析配置属性；使用pre-post-annotations时将使用PrePostAnnotationSecurityMetadataSource解析配置属性。<br>&emsp;&emsp;MethodSecurityInterceptor是实现了MethodInterceptor接口的，所以我们在使用Spring Aop时，可以自己配置一个MethodSecurityInterceptor的bean。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 自定义MethodSecurityInterceptor --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"methodSecurityInterceptor"</span></span></div><div class="line"><span class="attr">class</span>=<span class="string">"org.springframework.security.access.intercept.aopalliance.MethodSecurityInterceptor"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationManager"</span> <span class="attr">ref</span>=<span class="string">"authenticationManager"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accessDecisionManager"</span> <span class="attr">ref</span>=<span class="string">"accessDecisionManager"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"afterInvocationManager"</span> <span class="attr">ref</span>=<span class="string">"afterInvocationManager"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"securityMetadataSource"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">security:method-security-metadata-source</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 指定需要受保护的方法和需要的权限 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:protect</span> <span class="attr">method</span>=<span class="string">"com.xxx.service.UserService.find*"</span></span></div><div class="line">            <span class="attr">access</span>=<span class="string">"ROLE_USER"</span> /&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">security:protect</span> <span class="attr">method</span>=<span class="string">"com.xxx.service.UserService.delete*"</span></span></div><div class="line">            <span class="attr">access</span>=<span class="string">"ROLE_ADMIN"</span> /&gt;</div><div class="line">     <span class="tag">&lt;/<span class="name">security:method-security-metadata-source</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;定义了MethodSecurityInterceptor以后，我们需要类似AOP配置那样，配置哪些该MethodInterceptor需要拦截哪些方法的执行。这种可选配置是很多种的，因为我们这里只是拦截UserService中的具体方法，所以就采用基于bean name的自动代理。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 基于bean的拦截 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>methodSecurityInterceptor<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanNames"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>userService<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>按照上面的配置，我们在访问UserService的find方法时就需要ROLE_USER的权限，而访问delete方法时则需要ROLE_ADMIN权限。</p>
<p>7.2 <strong>AspectJMethodSecurityInterceptor</strong><br>&emsp;&emsp;AspectJMethodSecurityInterceptor是继承自MethodSecurityInterceptor的，不同的是AspectJMethodSecurityInterceptor是用来支持AspectJ的JointPoint的，但在底层还是会把它封装成一个MethodInvocation进行调用。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Spring/Security/配置十七：基于方法的权限控制/" data-id="cj6vztsdo007woabl5erfsq9p" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Spring/Security/配置十五：权限鉴定结构" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Spring/Security/配置十五：权限鉴定结构/">配置十五：权限鉴定结构</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/15/Spring/Security/配置十五：权限鉴定结构/" class="article-date"><time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a> / <a class="article-category-link" href="/categories/Spring/Security/">Security</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>一. <strong>权限</strong><br>&emsp;&emsp;所有的Authentication实现类都保存了一个GrantedAuthority列表，其表示用户所具有的权限。GrantedAuthority是通过AuthenticationManager设置到Authentication对象中的，然后AccessDecisionManager将从Authentication中获取用户所具有的GrantedAuthority来鉴定用户是否具有访问对应资源的权限。<br>&emsp;&emsp;GrantedAuthority是一个接口，其中只定义了一个getAuthority()方法，其返回值为String类型。该方法允许AccessDecisionManager获取一个能够精确代表该权限的字符串。通过返回一个字符串，一个GrantedAuthority能够很轻易的被大部分AccessDecisionManager读取。如果一个GrantedAuthority不能够精确的使用一个String来表示，那么其对应的getAuthority()方法调用应当返回一个null，这表示AccessDecisionManager必须对该GrantedAuthority的实现有特定的支持，从而可以获取该GrantedAuthority所代表的权限信息。<br>&emsp;&emsp;Spring Security内置了一个GrantedAuthority的实现，SimpleGrantedAuthority。它直接接收一个表示权限信息的字符串，然后getAuthority()方法直接返回该字符串。Spring Security内置的所有AuthenticationProvider都是使用它来封装Authentication对象的。</p>
<p>二. <strong>调用前的处理</strong><br>&emsp;&emsp; Spring Security是通过拦截器来控制受保护对象的访问的，如方法调用和Web请求。在正式访问受保护对象之前，Spring Security将使用AccessDecisionManager来鉴定当前用户是否有访问对应受保护对象的权限。</p>
<p>2.1 AccessDecisionManager<br>&emsp;&emsp;AccessDecisionManager是由AbstractSecurityInterceptor调用的，它负责鉴定用户是否有访问对应资源（方法或URL）的权限。AccessDecisionManager是一个接口，其中只定义了三个方法，其定义如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccessDecisionManager</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 通过传递的参数来决定用户是否有访问对应受保护对象的权限</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> authentication 当前正在请求受包含对象的Authentication</div><div class="line">     * <span class="doctag">@param</span> object 受保护对象，其可以是一个MethodInvocation、JoinPoint或FilterInvocation。</div><div class="line">     * <span class="doctag">@param</span> configAttributes 与正在请求的受保护对象相关联的配置属性</div><div class="line">     *</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decide</span><span class="params">(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes)</span></span></div><div class="line">        <span class="keyword">throws</span> AccessDeniedException, InsufficientAuthenticationException;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 表示当前AccessDecisionManager是否支持对应的ConfigAttribute</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(ConfigAttribute attribute)</span></span>;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 表示当前AccessDecisionManager是否支持对应的受保护对象类型</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;decide()方法用于决定authentication是否符合受保护对象要求的configAttributes。supports(ConfigAttribute attribute)方法是用来判断AccessDecisionManager是否能够处理对应的ConfigAttribute的。supports(Class&lt;?&gt; clazz)方法用于判断配置的AccessDecisionManager是否支持对应的受保护对象类型。</p>
<p>2.2 基于投票的AccessDecisionManager实现<br>&emsp;&emsp;Spring Security已经内置了几个基于投票的AccessDecisionManager，当然如果需要你也可以实现自己的AccessDecisionManager。以下是Spring Security官方文档提供的一个图，其展示了与基于投票的AccessDecisionManager实现相关的类。<br><img src="http://dl2.iteye.com/upload/attachment/0112/0957/b7963b90-3877-3885-84f9-6d0054cb5eec.png" alt="image"><br>&emsp;&emsp;使用这种方式，一系列的AccessDecisionVoter将会被AccessDecisionManager用来对Authentication是否有权访问受保护对象进行投票，然后再根据投票结果来决定是否要抛出AccessDeniedException。AccessDecisionVoter是一个接口，其中定义有三个方法，具体结构如下所示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccessDecisionVoter</span>&lt;<span class="title">S</span>&gt; </span>&#123;</div><div class="line"> </div><div class="line">    intACCESS_GRANTED = <span class="number">1</span>;</div><div class="line">    intACCESS_ABSTAIN = <span class="number">0</span>;</div><div class="line">    intACCESS_DENIED = -<span class="number">1</span>;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(ConfigAttribute attribute)</span></span>;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">vote</span><span class="params">(Authentication authentication, S object, Collection&lt;ConfigAttribute&gt; attributes)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;vote()方法的返回结果会是AccessDecisionVoter中定义的三个常量之一。ACCESS_GRANTED表示同意，ACCESS_DENIED表示返回，ACCESS_ABSTAIN表示弃权。如果一个AccessDecisionVoter不能判定当前Authentication是否拥有访问对应受保护对象的权限，则其vote()方法的返回值应当为弃权ACCESS_ABSTAIN。<br>&emsp;&emsp;Spring Security内置了三个基于投票的AccessDecisionManager实现类，它们分别是AffirmativeBased、ConsensusBased和UnanimousBased。 </p>
<ol>
<li><p>AffirmativeBased的逻辑是这样的：<br>（1）只要有AccessDecisionVoter的投票为ACCESS_GRANTED则同意用户进行访问；<br>（2）如果全部弃权也表示通过；<br>（3）如果没有一个人投赞成票，但是有人投反对票，则将抛出AccessDeniedException。</p>
</li>
<li><p>ConsensusBased的逻辑是这样的：<br>（1）如果赞成票多于反对票则表示通过。<br>（2）反过来，如果反对票多于赞成票则将抛出AccessDeniedException。<br>（3）如果赞成票与反对票相同且不等于0，并且属性allowIfEqualGrantedDeniedDecisions的值为true，则表示通过，否则将抛出异常AccessDeniedException。参数allowIfEqualGrantedDeniedDecisions的值默认为true。<br>（4）如果所有的AccessDecisionVoter都弃权了，则将视参数allowIfAllAbstainDecisions的值而定，如果该值为true则表示通过，否则将抛出异常AccessDeniedException。参数allowIfAllAbstainDecisions的值默认为false。  </p>
</li>
<li>UnanimousBased的逻辑与另外两种实现有点不一样，另外两种会一次性把受保护对象的配置属性全部传递给AccessDecisionVoter进行投票，而UnanimousBased会一次只传递一个ConfigAttribute给AccessDecisionVoter进行投票。这也就意味着如果我们的AccessDecisionVoter的逻辑是只要传递进来的ConfigAttribute中有一个能够匹配则投赞成票，但是放到UnanimousBased中其投票结果就不一定是赞成了。<br>UnanimousBased的逻辑具体来说是这样的：<br>（1）如果受保护对象配置的某一个ConfigAttribute被任意的AccessDecisionVoter反对了，则将抛出AccessDeniedException。<br>（2）如果没有反对票，但是有赞成票，则表示通过。<br>（3）如果全部弃权了，则将视参数allowIfAllAbstainDecisions的值而定，true则通过，false则抛出AccessDeniedException。  </li>
</ol>
<p>2.3 RoleVoter<br>&emsp;&emsp;RoleVoter是Spring Security内置的一个AccessDecisionVoter，其会将ConfigAttribute简单的看作是一个角色名称，在投票的时如果拥有该角色即投赞成票。如果ConfigAttribute是以“ROLE<em>”开头的，则将使用RoleVoter进行投票。当用户拥有的权限中有一个或多个能匹配受保护对象配置的以“ROLE</em>”开头的ConfigAttribute时其将投赞成票；如果用户拥有的权限中没有一个能匹配受保护对象配置的以“ROLE<em>”开头的ConfigAttribute，则RoleVoter将投反对票；如果受保护对象配置的ConfigAttribute中没有以“ROLE</em>”开头的，则RoleVoter将弃权。</p>
<p>2.4 AuthenticatedVoter<br>&emsp;&emsp;AuthenticatedVoter也是Spring Security内置的一个AccessDecisionVoter实现。其主要用来区分匿名用户、通过Remember-Me认证的用户和完全认证的用户。完全认证的用户是指由系统提供的登录入口进行成功登录认证的用户。<br>&emsp;&emsp;AuthenticatedVoter可以处理的ConfigAttribute有IS_AUTHENTICATED_FULLY、IS_AUTHENTICATED_REMEMBERED和IS_AUTHENTICATED_ANONYMOUSLY。如果ConfigAttribute不在这三者范围之内，则AuthenticatedVoter将弃权。否则将视ConfigAttribute而定，如果ConfigAttribute为IS_AUTHENTICATED_ANONYMOUSLY，则不管用户是匿名的还是已经认证的都将投赞成票；如果是IS_AUTHENTICATED_REMEMBERED则仅当用户是由Remember-Me自动登录，或者是通过登录入口进行登录认证时才会投赞成票，否则将投反对票；而当ConfigAttribute为IS_AUTHENTICATED_FULLY时仅当用户是通过登录入口进行登录的才会投赞成票，否则将投反对票。<br>&emsp;&emsp;AuthenticatedVoter是通过AuthenticationTrustResolver的isAnonymous()方法和isRememberMe()方法来判断SecurityContextHolder持有的Authentication是否为AnonymousAuthenticationToken或RememberMeAuthenticationToken的，即是否为IS_AUTHENTICATED_ANONYMOUSLY和IS_AUTHENTICATED_REMEMBERED。</p>
<p>2.5 自定义Voter<br>当然，用户也可以通过实现AccessDecisionVoter来实现自己的投票逻辑。</p>
<p>三. <strong>调用后的处理</strong><br>&emsp;&emsp;AccessDecisionManager是用来在访问受保护的对象之前判断用户是否拥有访问该对象的权限。有的时候我们可能会希望在请求执行完成后对返回值做一些修改，当然，你可以简单的通过AOP来实现这一功能。Spring Security为我们提供了一个AfterInvocationManager接口，它允许我们在受保护对象访问完成后对返回值进行修改或者进行权限鉴定，看是否需要抛出AccessDeniedException，其将由AbstractSecurityInterceptor的子类进行调用。AfterInvocationManager接口的定义如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AfterInvocationManager</span> </span>&#123;</div><div class="line">  </div><div class="line">    <span class="function">Object <span class="title">decide</span><span class="params">(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; attributes,</span></span></div><div class="line">        Object returnedObject) <span class="keyword">throws</span> AccessDeniedException;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(ConfigAttribute attribute)</span></span>;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以下是Spring Security官方文档提供的一个AfterInvocationManager构造实现的图<br><img src="http://dl2.iteye.com/upload/attachment/0112/0959/e6e5dbeb-68f1-3e21-8cb9-66774e701ded.png" alt="image"></p>
<p>&emsp;&emsp;类似于AuthenticationManager，AfterInvocationManager拥有一个默认的实现类AfterInvocationProviderManager，其中拥有一个由AfterInvocationProvider组成的集合，AfterInvocationProvider与AfterInvocationManager具有相同的方法定义，在调用AfterInvocationProviderManager中的方法时实际上就是依次调用其中包含的AfterInvocationProvider对应的方法。<br>&emsp;&emsp;需要注意的是AfterInvocationManager需要在受保护对象成功被访问后才能执行。</p>
<p>四. <strong>角色的继承</strong><br>&emsp;&emsp;对于角色继承这种需求也是经常有的，比如要求ROLE_ADMIN将拥有所有的ROLE_USER所具有的权限。当然我们可以给拥有ROLE_ADMIN角色的用户同时授予ROLE_USER角色来达到这一效果或者修改需要ROLE_USER进行访问的资源使用ROLE_ADMIN也可以访问。Spring Security为我们提供了一种更为简便的办法，那就是角色的继承，它允许我们的ROLE_ADMIN直接继承ROLE_USER，这样所有ROLE_USER可以访问的资源ROLE_ADMIN也可以访问。定义角色的继承我们需要在ApplicationContext中定义一个RoleHierarchy，然后再把它赋予给一个RoleHierarchyVoter，之后再把该RoleHierarchyVoter加入到我们基于Voter的AccessDecisionManager中，并指定当前使用的AccessDecisionManager为我们自己定义的那个。以下是一个定义角色继承的完整示例。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">   <span class="attr">xmlns:security</span>=<span class="string">"http://www.springframework.org/schema/security"</span></div><div class="line">   <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">          http://www.springframework.org/schema/beans/spring-beans-3.1.xsd</div><div class="line">          http://www.springframework.org/schema/security</div><div class="line">          http://www.springframework.org/schema/security/spring-security-3.1.xsd"&gt;</div><div class="line"> </div><div class="line">   <span class="comment">&lt;!-- 通过access-decision-manager-ref指定将要使用的AccessDecisionManager --&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">security:http</span> <span class="attr">access-decision-manager-ref</span>=<span class="string">"accessDecisionManager"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:form-login</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/admin.jsp"</span> <span class="attr">access</span>=<span class="string">"ROLE_ADMIN"</span> /&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span> /&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div><div class="line"> </div><div class="line">   <span class="tag">&lt;<span class="name">security:authentication-manager</span> <span class="attr">alias</span>=<span class="string">"authenticationManager"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:authentication-provider</span></span></div><div class="line">         <span class="attr">user-service-ref</span>=<span class="string">"userDetailsService"</span>/&gt;</div><div class="line">   <span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line"> </div><div class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDetailsService"</span></span></div><div class="line">      <span class="attr">class</span>=<span class="string">"org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl"</span>&gt;</div><div class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">   <span class="comment">&lt;!-- 自己定义AccessDecisionManager对应的bean --&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accessDecisionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.access.vote.AffirmativeBased"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"decisionVoters"</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"roleVoter"</span>/&gt;</span></div><div class="line">         <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"> </div><div class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"roleVoter"</span></span></div><div class="line">      <span class="attr">class</span>=<span class="string">"org.springframework.security.access.vote.RoleHierarchyVoter"</span>&gt;</div><div class="line">      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"roleHierarchy"</span> /&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"roleHierarchy"</span></span></div><div class="line">      <span class="attr">class</span>=<span class="string">"org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl"</span>&gt;</div><div class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hierarchy"</span>&gt;</span><span class="comment">&lt;!-- 角色继承关系 --&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span></div><div class="line">            ROLE_ADMIN &gt; ROLE_USER</div><div class="line">         <span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"> </div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>在上述配置中我们就定义好了ROLE_ADMIN是继承自ROLE_USER的，这样ROLE_ADMIN将能够访问所有ROLE_USER可以访问的资源。通过RoleHierarchyImpl的hierarchy属性我们可以定义多个角色之间的继承关系，如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"roleHierarchy"</span></span></div><div class="line">      <span class="attr">class</span>=<span class="string">"org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hierarchy"</span>&gt;</span><span class="comment">&lt;!-- 角色继承关系 --&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span></div><div class="line">        ROLE_ADMIN &gt; ROLE_USER</div><div class="line">        ROLE_A &gt; ROLE_B</div><div class="line">        ROLE_B &gt; ROLE_C</div><div class="line">        ROLE_C &gt; ROLE_D</div><div class="line">     <span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>在上述配置我们同时定义了ROLE_ADMIN继承了ROLE_USER，ROLE_A继承了ROLE_B，ROLE_B又继承了ROLE_C，ROLE_C又继承了ROLE_D，这样ROLE_A将能访问ROLE_B、ROLE_C和ROLE_D所能访问的所有资源。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Spring/Security/配置十五：权限鉴定结构/" data-id="cj6vztsdn007uoabl7zmwpiz1" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Spring/Security/配置六：AuthenticationProvider" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Spring/Security/配置六：AuthenticationProvider/">配置六：AuthenticationProvider</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/15/Spring/Security/配置六：AuthenticationProvider/" class="article-date"><time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a> / <a class="article-category-link" href="/categories/Spring/Security/">Security</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;认证是由AuthenticationManager来管理的，但是真正进行认证的是AuthenticationManager中定义的AuthenticationProvider。AuthenticationManager中可以定义有多个AuthenticationProvider。当我们使用authentication-provider元素来定义一个AuthenticationProvider时，如果没有指定对应关联的AuthenticationProvider对象，Spring Security默认会使用DaoAuthenticationProvider。DaoAuthenticationProvider在进行认证的时候需要一个UserDetailsService来获取用户的信息UserDetails，其中包括用户名、密码和所拥有的权限等。所以如果我们需要改变认证的方式，我们可以实现自己的AuthenticationProvider；如果需要改变认证的用户信息来源，我们可以实现UserDetailsService。</p>
<p>&emsp;&emsp;实现了自己的AuthenticationProvider之后，我们可以在配置文件中这样配置来使用我们自己的AuthenticationProvider。其中myAuthenticationProvider就是我们自己的AuthenticationProvider实现类对应的bean。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:authentication-provider</span> <span class="attr">ref</span>=<span class="string">"myAuthenticationProvider"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></div></pre></td></tr></table></figure>
<p>&emsp;&emsp;实现了自己的UserDetailsService之后，我们可以在配置文件中这样配置来使用我们自己的UserDetailsService。其中的myUserDetailsService就是我们自己的UserDetailsService实现类对应的bean。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:authentication-provider</span> <span class="attr">user-service-ref</span>=<span class="string">"myUserDetailsService"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></div></pre></td></tr></table></figure>
<p>一. <strong>用户信息从数据库获取</strong><br>&emsp;&emsp;通常我们的用户信息都不会向第一节示例中那样简单的写在配置文件中，而是从其它存储位置获取，比如数据库。根据之前的介绍我们知道用户信息是通过UserDetailsService获取的，要从数据库获取用户信息，我们就需要实现自己的UserDetailsService。幸运的是像这种常用的方式Spring Security已经为我们做了实现了。</p>
<p>二. <strong>使用jdbc-user-service获取</strong><br>&emsp;&emsp;在Spring Security的命名空间中在authentication-provider下定义了一个jdbc-user-service元素，通过该元素我们可以定义一个从数据库获取UserDetails的UserDetailsService。jdbc-user-service需要接收一个数据源的引用。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:authentication-provider</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">security:jdbc-user-service</span> <span class="attr">data-source-ref</span>=<span class="string">"dataSource"</span>/&gt;</span>      </div><div class="line">      <span class="tag">&lt;/<span class="name">security:authentication-provider</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上述配置中dataSource是对应数据源配置的bean引用。使用此种方式需要我们的数据库拥有如下表和表结构。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function">create table <span class="title">users</span><span class="params">(</span></span></div><div class="line">      username varchar_ignorecase(<span class="number">50</span>) not <span class="keyword">null</span> primary key,</div><div class="line">      password <span class="title">varchar_ignorecase</span><span class="params">(<span class="number">50</span>)</span> not <span class="keyword">null</span>,</div><div class="line">      enabled <span class="keyword">boolean</span> not <span class="keyword">null</span>);</div><div class="line"> </div><div class="line"><span class="function">create table <span class="title">authorities</span> <span class="params">(</span></span></div><div class="line">      username varchar_ignorecase(<span class="number">50</span>) not <span class="keyword">null</span>,</div><div class="line">      authority <span class="title">varchar_ignorecase</span><span class="params">(<span class="number">50</span>)</span> not <span class="keyword">null</span>,</div><div class="line">      constraint fk_authorities_users foreign <span class="title">key</span><span class="params">(username)</span> references <span class="title">users</span><span class="params">(username)</span>);</div><div class="line">      <span class="function">create unique index ix_auth_username on <span class="title">authorities</span> <span class="params">(username,authority)</span></span>;</div><div class="line">     </div><div class="line"><span class="function">create table <span class="title">groups</span> <span class="params">(</span></span></div><div class="line">      id bigint generated by <span class="keyword">default</span> as identity(start with <span class="number">0</span>) primary key,</div><div class="line">      group_name <span class="title">varchar_ignorecase</span><span class="params">(<span class="number">50</span>)</span> notnull);</div><div class="line"> </div><div class="line"><span class="function">create table <span class="title">group_authorities</span> <span class="params">(</span></span></div><div class="line">      group_id bigint notnull,</div><div class="line">      authority varchar(<span class="number">50</span>) notnull,</div><div class="line">      constraint fk_group_authorities_group foreign <span class="title">key</span><span class="params">(group_id)</span> references <span class="title">groups</span><span class="params">(id)</span>);</div><div class="line"> </div><div class="line"><span class="function">create table <span class="title">group_members</span> <span class="params">(</span></span></div><div class="line">      id bigint generated by <span class="keyword">default</span> as identity(start with <span class="number">0</span>) primary key,</div><div class="line">      username <span class="title">varchar</span><span class="params">(<span class="number">50</span>)</span> notnull,</div><div class="line">      group_id bigint notnull,</div><div class="line">      constraint fk_group_members_group foreign <span class="title">key</span><span class="params">(group_id)</span> references <span class="title">groups</span><span class="params">(id)</span>);</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这是因为默认情况下jdbc-user-service将使用SQL语句“select username, password, enabled from users where username = ?”来获取用户信息；使用SQL语句“select username, authority from authorities where username = ?”来获取用户对应的权限；使用SQL语句“select g.id, g.group_name, ga.authority from groups g, group_members gm, group_authorities ga where gm.username = ? and g.id = ga.group_id and g.id = gm.group_id”来获取用户所属组的权限。需要注意的是jdbc-user-service定义是不支持用户组权限的，所以使用jdbc-user-service时用户组相关表也是可以不定义的。如果需要使用用户组权限请使用JdbcDaoImpl，这个在后文后讲到。<br>&emsp;&emsp;当然这只是默认配置及默认的表结构。如果我们的表名或者表结构跟Spring Security默认的不一样，我们可以通过以下几个属性来定义我们自己查询用户信息、用户权限和用户组权限的SQL。</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>users-by-username-query</td>
<td>指定查询用户信息的SQL</td>
</tr>
<tr>
<td>authorities-by-username-query</td>
<td>指定查询用户权限的SQL</td>
</tr>
<tr>
<td>group-authorities-by-username-query</td>
<td>指定查询用户组权限的SQL</td>
</tr>
</tbody>
</table>
<p>&emsp;&emsp;假设我们的用户表是t_user，而不是默认的users，则我们可以通过属性users-by-username-query来指定查询用户信息的时候是从用户表t_user查询。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:authentication-provider</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">security:jdbc-user-service</span></span></div><div class="line">            <span class="attr">data-source-ref</span>=<span class="string">"dataSource"</span></div><div class="line">            <span class="attr">users-by-username-query</span>=<span class="string">"select username, password, enabled from t_user where username = ?"</span> /&gt;</div><div class="line">        <span class="tag">&lt;/<span class="name">security:authentication-provider</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>role-prefix属性</strong><br>&emsp;&emsp;jdbc-user-service还有一个属性role-prefix可以用来指定角色的前缀。这是什么意思呢？这表示我们从库里面查询出来的权限需要加上什么样的前缀。举个例子，假设我们库里面存放的权限都是“USER”，而我们指定了某个URL的访问权限access=”ROLE<em>USER”，显然这是不匹配的，Spring Security不会给我们放行，通过指定jdbc-user-service的role-prefix=”ROLE</em>”之后就会满足了。当role-prefix的值为“none”时表示没有前缀，当然默认也是没有的。</p>
<p>三. <strong>直接使用JdbcDaoImpl</strong><br>&emsp;&emsp;JdbcDaoImpl是UserDetailsService的一个实现。其用法和jdbc-user-service类似，只是我们需要把它定义为一个bean，然后通过authentication-provider的user-service-ref进行引用。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:authentication-provider</span> <span class="attr">user-service-ref</span>=<span class="string">"userDetailsService"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDetailsService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;如你所见，JdbcDaoImpl同样需要一个dataSource的引用。如果就是上面这样配置的话我们数据库表结构也需要是标准的表结构。当然，如果我们的表结构和标准的不一样，可以通过usersByUsernameQuery、authoritiesByUsernameQuery和groupAuthoritiesByUsernameQuery属性来指定对应的查询SQL。</p>
<p>四. <strong>用户权限和用户组权限</strong><br>&emsp;&emsp;JdbcDaoImpl使用enableAuthorities和enableGroups两个属性来控制权限的启用。默认启用的是enableAuthorities，即用户权限，而enableGroups默认是不启用的。如果需要启用用户组权限，需要指定enableGroups属性值为true。当然这两种权限是可以同时启用的。需要注意的是使用jdbc-user-service定义的UserDetailsService是不支持用户组权限的，如果需要支持用户组权限的话需要我们使用JdbcDaoImpl。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:authentication-provider</span> <span class="attr">user-service-ref</span>=<span class="string">"userDetailsService"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDetailsService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableGroups"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>五. <strong>PasswordEncoder</strong><br>5.1 <strong>使用内置的PasswordEncoder</strong><br>&emsp;&emsp;通常我们保存的密码都不会像之前介绍的那样，保存的明文，而是加密之后的结果。为此，我们的AuthenticationProvider在做认证时也需要将传递的明文密码使用对应的算法加密后再与保存好的密码做比较。Spring Security对这方面也有支持。通过在authentication-provider下定义一个password-encoder我们可以定义当前AuthenticationProvider需要在进行认证时需要使用的password-encoder。password-encoder是一个PasswordEncoder的实例，我们可以直接使用它，如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:authentication-provider</span> <span class="attr">user-service-ref</span>=<span class="string">"userDetailsService"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">security:password-encoder</span> <span class="attr">hash</span>=<span class="string">"md5"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">security:authentication-provider</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;其属性hash表示我们将用来进行加密的哈希算法，系统已经为我们实现的有plaintext、sha、sha-256、md4、md5、{sha}和{ssha}。它们对应的PasswordEncoder实现类如下：</p>
<table>
<thead>
<tr>
<th>加密算法</th>
<th>PasswordEncoder实现类</th>
</tr>
</thead>
<tbody>
<tr>
<td>plaintext</td>
<td>PlaintextPasswordEncoder</td>
</tr>
<tr>
<td>sha</td>
<td>ShaPasswordEncoder</td>
</tr>
<tr>
<td>sha-256</td>
<td>ShaPasswordEncoder，使用时new ShaPasswordEncoder(256)</td>
</tr>
<tr>
<td>md4</td>
<td>Md4PasswordEncoder</td>
</tr>
<tr>
<td>md5</td>
<td>Md5PasswordEncoder</td>
</tr>
<tr>
<td>{sha}</td>
<td>LdapShaPasswordEncoder</td>
</tr>
<tr>
<td>{ssha}</td>
<td>LdapShaPasswordEncoder</td>
</tr>
</tbody>
</table>
<p><strong>使用BASE64编码加密后的密码</strong><br>&emsp;&emsp;此外，使用password-encoder时我们还可以指定一个属性base64，表示是否需要对加密后的密码使用BASE64进行编码，默认是false。如果需要则设为true。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:password-encoder</span> <span class="attr">hash</span>=<span class="string">"md5"</span> <span class="attr">base64</span>=<span class="string">"true"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>加密时使用salt</strong><br>&emsp;&emsp;加密时使用salt也是很常见的需求，Spring Security内置的password-encoder也对它有支持。通过password-encoder元素下的子元素salt-source，我们可以指定当前PasswordEncoder需要使用的salt。这个salt可以是一个常量，也可以是当前UserDetails的某一个属性，还可以通过实现SaltSource接口实现自己的获取salt的逻辑，SaltSource中只定义了如下一个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public Object getSalt(UserDetails user);</div></pre></td></tr></table></figure></p>
<p>下面来看几个使用salt-source的示例。<br>（1）下面的配置将使用常量“abc”作为salt。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:authentication-provider</span> <span class="attr">user-service-ref</span>=<span class="string">"userDetailsService"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">security:password-encoder</span> <span class="attr">hash</span>=<span class="string">"md5"</span> <span class="attr">base64</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:salt-source</span> <span class="attr">system-wide</span>=<span class="string">"abc"</span>/&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">security:password-encoder</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">security:authentication-provider</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>（2）下面的配置将使用UserDetails的username作为salt。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;security:authentication-manager&gt;</div><div class="line">  &lt;security:authentication-provider user-service-ref=&quot;userDetailsService&quot;&gt;</div><div class="line">     &lt;security:password-encoder hash=&quot;md5&quot; base64=&quot;true&quot;&gt;</div><div class="line">        &lt;security:salt-source user-property=&quot;username&quot;/&gt;</div><div class="line">     &lt;/security:password-encoder&gt;</div><div class="line">  &lt;/security:authentication-provider&gt;</div><div class="line">&lt;/security:authentication-manager&gt;</div></pre></td></tr></table></figure></p>
<p>（3）下面的配置将使用自己实现的SaltSource获取salt。其中mySaltSource就是SaltSource实现类对应的bean的引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;security:authentication-manager&gt;</div><div class="line">  &lt;security:authentication-provider user-service-ref=&quot;userDetailsService&quot;&gt;</div><div class="line">     &lt;security:password-encoder hash=&quot;md5&quot; base64=&quot;true&quot;&gt;</div><div class="line">        &lt;security:salt-source ref=&quot;mySaltSource&quot;/&gt;</div><div class="line">     &lt;/security:password-encoder&gt;</div><div class="line">  &lt;/security:authentication-provider&gt;</div><div class="line">&lt;/security:authentication-manager&gt;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;需要注意的是AuthenticationProvider进行认证时所使用的PasswordEncoder，包括它们的算法和规则都应当与我们保存用户密码时是一致的。也就是说如果AuthenticationProvider使用Md5PasswordEncoder进行认证，我们在保存用户密码时也需要使用Md5PasswordEncoder；如果AuthenticationProvider在认证时使用了username作为salt，那么我们在保存用户密码时也需要使用username作为salt。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Md5PasswordEncoder encoder = <span class="keyword">new</span> Md5PasswordEncoder();</div><div class="line">encoder.setEncodeHashAsBase64(<span class="keyword">true</span>);</div><div class="line">System.out.println(encoder.encodePassword(<span class="string">"user"</span>, <span class="string">"user"</span>));</div></pre></td></tr></table></figure></p>
<p>5.2 <strong>使用自定义的PasswordEncoder</strong><br>&emsp;&emsp;除了通过password-encoder使用Spring Security已经为我们实现了的PasswordEncoder之外，我们也可以实现自己的PasswordEncoder，然后通过password-encoder的ref属性关联到我们自己实现的PasswordEncoder对应的bean对象。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:authentication-provider</span> <span class="attr">user-service-ref</span>=<span class="string">"userDetailsService"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">security:password-encoder</span> <span class="attr">ref</span>=<span class="string">"passwordEncoder"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">security:authentication-provider</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"passwordEncoder"</span> <span class="attr">class</span>=<span class="string">"com.xxx.MyPasswordEncoder"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在Spring Security内部定义有两种类型的PasswordEncoder，分别是org.springframework.security.authentication.encoding.PasswordEncoder和org.springframework.security.crypto.password.PasswordEncoder。直接通过password-encoder元素的hash属性指定使用内置的PasswordEncoder都是基于org.springframework.security.authentication.encoding.PasswordEncoder的实现，然而它现在已经被废弃了，Spring Security推荐我们使用org.springframework.security.crypto.password.PasswordEncoder，它的设计理念是为了使用随机生成的salt。关于后者Spring Security也已经提供了几个实现类，更多信息请查看Spring Security的API文档。我们在通过password-encoder使用自定义的PasswordEncoder时两种PasswordEncoder的实现类都是支持的。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Spring/Security/配置六：AuthenticationProvider/" data-id="cj6vztsdm007roablqjyiv8c3" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Spring/Security/配置十一：匿名认证" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Spring/Security/配置十一：匿名认证/">配置十一：匿名认证</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/15/Spring/Security/配置十一：匿名认证/" class="article-date"><time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a> / <a class="article-category-link" href="/categories/Spring/Security/">Security</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;对于匿名访问的用户，Spring Security支持为其建立一个匿名的AnonymousAuthenticationToken存放在SecurityContextHolder中，这就是所谓的匿名认证。这样在以后进行权限认证或者做其它操作时我们就不需要再判断SecurityContextHolder中持有的Authentication对象是否为null了，而直接把它当做一个正常的Authentication进行使用就OK了。 </p>
<p>一. <strong>配置</strong><br>&emsp;&emsp;使用NameSpace时，http元素的使用默认就会启用对匿名认证的支持，不过我们也可以通过设置http元素下的anonymous元素的enabled属性为false停用对匿名认证的支持。以下是anonymous元素可以配置的属性，以及它们的默认值。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:anonymous</span> <span class="attr">enabled</span>=<span class="string">"true"</span> <span class="attr">key</span>=<span class="string">"doesNotMatter"</span> <span class="attr">username</span>=<span class="string">"anonymousUser"</span> <span class="attr">granted-authority</span>=<span class="string">"ROLE_ANONYMOUS"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;key用于指定一个在AuthenticationFilter和AuthenticationProvider之间共享的值。username用于指定匿名用户所对应的用户名，granted-authority用于指定匿名用户所具有的权限。<br>&emsp;&emsp;与匿名认证相关的类有三个，AnonymousAuthenticationToken将作为一个Authentication的实例存放在SecurityContextHolder中；过滤器运行到AnonymousAuthenticationFilter时，如果SecurityContextHolder中持有的Authentication还是空的，则AnonymousAuthenticationFilter将创建一个AnonymousAuthenticationToken并存放在SecurityContextHolder中。最后一个相关的类是AnonymousAuthenticationProvider，其会添加到ProviderManager的AuthenticationProvider列表中，以支持对AnonymousAuthenticationToken的认证。AnonymousAuthenticationToken的认证是在AbstractSecurityInterceptor中的beforeInvocation()方法中进行的。使用http元素定义时这些bean都是会自动定义和添加的。如果需要手动定义这些bean的话，那么可以如下定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;anonymousAuthFilter&quot;</div><div class="line">   class=&quot;org.springframework.security.web.authentication.AnonymousAuthenticationFilter&quot;&gt;</div><div class="line">  &lt;property name=&quot;key&quot; value=&quot;doesNotMatter&quot; /&gt;</div><div class="line">  &lt;property name=&quot;userAttribute&quot; value=&quot;anonymousUser,ROLE_ANONYMOUS&quot; /&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;bean id=&quot;anonymousAuthenticationProvider&quot;</div><div class="line">class=&quot;org.springframework.security.authentication.AnonymousAuthenticationProvider&quot;&gt;</div><div class="line">  &lt;property name=&quot;key&quot; value=&quot;doesNotMatter&quot; /&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;key是在AnonymousAuthenticationProvider和AnonymousAuthenticationFilter之间共享的，它们必须保持一致，AnonymousAuthenticationProvider将使用本身拥有的key与传入的AnonymousAuthenticationToken的key作比较，相同则认为可以进行认证，否则将抛出异常BadCredentialsException。userAttribute属性是以usernameInTheAuthenticationToken,grantedAuthority[,grantedAuthority]的形式进行定义的。</p>
<p> 二. <strong>AuthenticationTrustResolver</strong><br> &emsp;&emsp; AuthenticationTrustResolver是一个接口，其中定义有两个方法，isAnonymous()和isRememberMe()，它们都接收一个Authentication对象作为参数。它有一个默认实现类AuthenticationTrustResolverImpl，Spring Security就是使用它来判断一个SecurityContextHolder持有的Authentication是否AnonymousAuthenticationToken或RememberMeAuthenticationToken。如当ExceptionTranslationFilter捕获到一个AccessDecisionManager后就会使用它来判断当前Authentication对象是否为一个AnonymousAuthenticationToken，如果是则交由AuthenticationEntryPoint处理，否则将返回403错误码。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Spring/Security/配置十一：匿名认证/" data-id="cj6vztsdl007poablzvk0uhdv" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Spring/Security/配置十六：基于表达式的权限控制" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Spring/Security/配置十六：基于表达式的权限控制/">配置十六：基于表达式的权限控制</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/15/Spring/Security/配置十六：基于表达式的权限控制/" class="article-date"><time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a> / <a class="article-category-link" href="/categories/Spring/Security/">Security</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;Spring Security允许我们在定义URL访问或方法访问所应有的权限时使用Spring EL表达式，在定义所需的访问权限时如果对应的表达式返回结果为true则表示拥有对应的权限，反之则无。Spring Security可用表达式对象的基类是SecurityExpressionRoot，其为我们提供了如下在使用Spring EL表达式对URL或方法进行权限控制时通用的内置表达式。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>hasRole([role])</td>
<td>当前用户是否拥有指定角色。</td>
</tr>
<tr>
<td>hasAnyRole([role1,role2])</td>
<td>多个角色是一个以逗号进行分隔的字符串。如果当前用户拥有指定角色中的任意一个则返回true。</td>
</tr>
<tr>
<td>hasAuthority([auth])</td>
<td>等同于hasRole</td>
</tr>
<tr>
<td>hasAnyAuthority([auth1,auth2])</td>
<td>等同于hasAnyRole</td>
</tr>
<tr>
<td>Principle</td>
<td>代表当前用户的principle对象</td>
</tr>
<tr>
<td>authentication</td>
<td>直接从SecurityContext获取的当前Authentication对象</td>
</tr>
<tr>
<td>permitAll</td>
<td>总是返回true，表示允许所有的</td>
</tr>
<tr>
<td>denyAll</td>
<td>总是返回false，表示拒绝所有的</td>
</tr>
<tr>
<td>isAnonymous()</td>
<td>当前用户是否是一个匿名用户</td>
</tr>
<tr>
<td>isRememberMe()</td>
<td>表示当前用户是否是通过Remember-Me自动登录的</td>
</tr>
<tr>
<td>isAuthenticated()</td>
<td>表示当前用户是否已经登录认证成功了。</td>
</tr>
<tr>
<td>isFullyAuthenticated()</td>
<td>如果当前用户既不是一个匿名用户，同时又不是通过Remember-Me自动登录的，则返回true。</td>
</tr>
</tbody>
</table>
<p>一. <strong>通过表达式控制URL权限</strong><br>&emsp;&emsp;URL的访问权限是通过http元素下的intercept-url元素进行定义的，其access属性用来定义访问配置属性。默认情况下该属性值只能是以字符串进行分隔的字符串列表，且每一个元素都对应着一个角色，因为默认使用的是RoleVoter。通过设置http元素的use-expressions=”true”可以启用intercept-url元素的access属性对Spring EL表达式的支持，use-expressions的值默认为false。启用access属性对Spring EL表达式的支持后每个access属性值都应该是一个返回结果为boolean类型的表达式，当表达式返回结果为true时表示当前用户拥有访问权限。此外WebExpressionVoter将加入AccessDecisionManager的AccessDecisionVoter列表，所以如果不使用NameSpace时应当手动添加WebExpressionVoter到AccessDecisionVoter。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span> <span class="attr">use-expressions</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:form-login</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:logout</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"hasRole('ROLE_USER')"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在上述配置中我们定义了只有拥有ROLE_USER角色的用户才能访问系统。<br>&emsp;&emsp;使用表达式控制URL权限使用的表达式对象类是继承自SecurityExpressionRoot的WebSecurityExpressionRoot类。其相比基类而言新增了一个表达式hasIpAddress。hasIpAddress可用来限制只有指定IP或指定范围内的IP才可以访问。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span> <span class="attr">use-expressions</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:form-login</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:logout</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"hasRole('ROLE_USER') and hasIpAddress('10.10.10.3')"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在上面的配置中我们限制了只有IP为”10.10.10.3”，且拥有ROLE_USER角色的用户才能访问。hasIpAddress是通过Ip地址或子网掩码来进行匹配的。如果要设置10.10.10下所有的子网都可以使用，那么我们对应的hasIpAddress的参数应为“10.10.10.n/24”，其中n可以是合法IP内的任意值。具体规则可以参照hasIpAddress()表达式用于比较的IpAddressMatcher的matches方法源码。以下是IpAddressMatcher的源码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.security.web.util;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.net.InetAddress;</div><div class="line"><span class="keyword">import</span> java.net.UnknownHostException;</div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</div><div class="line"> </div><div class="line"><span class="comment">/**</span></div><div class="line"> * Matches a request based on IP Address or subnet mask matching against the remote address.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * Both IPv6 and IPv4 addresses are supported, but a matcher which is configured with an IPv4 address will</div><div class="line"> * never match a request which returns an IPv6 address, and vice-versa.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> Luke Taylor</div><div class="line"> * <span class="doctag">@since</span> 3.0.2</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IpAddressMatcher</span> <span class="keyword">implements</span> <span class="title">RequestMatcher</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> nMaskBits;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InetAddress requiredAddress;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Takes a specific IP address or a range specified using the</div><div class="line">     * IP/Netmask (e.g. 192.168.1.0/24 or 202.24.0.0/14).</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> ipAddress the address or range of addresses from which the request must come.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IpAddressMatcher</span><span class="params">(String ipAddress)</span> </span>&#123;</div><div class="line"> </div><div class="line">        <span class="keyword">if</span> (ipAddress.indexOf(<span class="string">'/'</span>) &gt; <span class="number">0</span>) &#123;</div><div class="line">            String[] addressAndMask = StringUtils.split(ipAddress, <span class="string">"/"</span>);</div><div class="line">            ipAddress = addressAndMask[<span class="number">0</span>];</div><div class="line">            nMaskBits = Integer.parseInt(addressAndMask[<span class="number">1</span>]);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            nMaskBits = -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        requiredAddress = parseAddress(ipAddress);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> matches(request.getRemoteAddr());</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String address)</span> </span>&#123;</div><div class="line">        InetAddress remoteAddress = parseAddress(address);</div><div class="line"> </div><div class="line">        <span class="keyword">if</span> (!requiredAddress.getClass().equals(remoteAddress.getClass())) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="keyword">if</span> (nMaskBits &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> remoteAddress.equals(requiredAddress);</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="keyword">byte</span>[] remAddr = remoteAddress.getAddress();</div><div class="line">        <span class="keyword">byte</span>[] reqAddr = requiredAddress.getAddress();</div><div class="line"> </div><div class="line">        <span class="keyword">int</span> oddBits = nMaskBits % <span class="number">8</span>;</div><div class="line">        <span class="keyword">int</span> nMaskBytes = nMaskBits/<span class="number">8</span> + (oddBits == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>);</div><div class="line">        <span class="keyword">byte</span>[] mask = newbyte[nMaskBytes];</div><div class="line"> </div><div class="line">        Arrays.fill(mask, <span class="number">0</span>, oddBits == <span class="number">0</span> ? mask.length : mask.length - <span class="number">1</span>, (<span class="keyword">byte</span>)<span class="number">0xFF</span>);</div><div class="line"> </div><div class="line">        <span class="keyword">if</span> (oddBits != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">int</span> finalByte = (<span class="number">1</span> &lt;&lt; oddBits) - <span class="number">1</span>;</div><div class="line">            finalByte &lt;&lt;= <span class="number">8</span>-oddBits;</div><div class="line">            mask[mask.length - <span class="number">1</span>] = (<span class="keyword">byte</span>) finalByte;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line"> <span class="comment">//       System.out.println("Mask is " + new sun.misc.HexDumpEncoder().encode(mask));</span></div><div class="line"> </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; mask.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> ((remAddr[i] &amp; mask[i]) != (reqAddr[i] &amp; mask[i])) &#123;</div><div class="line">                <span class="keyword">return</span> alse;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">private</span> InetAddress <span class="title">parseAddress</span><span class="params">(String address)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> InetAddress.getByName(address);</div><div class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</div><div class="line">            <span class="function">thrownew <span class="title">IllegalArgumentException</span><span class="params">(<span class="string">"Failed to parse address"</span> + address, e)</span></span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>二. <strong>通过表达式控制方法权限</strong><br>&emsp;&emsp;Spring Security中定义了四个支持使用表达式的注解，分别是@PreAuthorize、@PostAuthorize、@PreFilter和@PostFilter。其中前两者可以用来在方法调用前或者调用后进行权限检查，后两者可以用来对集合类型的参数或者返回值进行过滤。要使它们的定义能够对我们的方法的调用产生影响我们需要设置global-method-security元素的pre-post-annotations=”enabled”，默认为disabled。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:global-method-security</span> <span class="attr">pre-post-annotations</span>=<span class="string">"disabled"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>2.1 使用@PreAuthorize和@PostAuthorize进行访问控制<br>&emsp;&emsp;@PreAuthorize可以用来控制一个方法是否能够被调用。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</div><div class="line"> </div><div class="line">   <span class="meta">@PreAuthorize</span>(<span class="string">"hasRole('ROLE_ADMIN')"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"addUser................"</span> + user);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="meta">@PreAuthorize</span>(<span class="string">"hasRole('ROLE_USER') or hasRole('ROLE_ADMIN')"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"find user by id............."</span> + id);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在上面的代码中我们定义了只有拥有角色ROLE_ADMIN的用户才能访问adduser()方法，而访问find()方法需要有ROLE_USER角色或ROLE_ADMIN角色。使用表达式时我们还可以在表达式中使用方法参数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</div><div class="line"> </div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 限制只能查询Id小于10的用户</div><div class="line">    */</div><div class="line">   <span class="meta">@PreAuthorize</span>(<span class="string">"#id&lt;10"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"find user by id........."</span> + id);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line">  </div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 限制只能查询自己的信息</div><div class="line">    */</div><div class="line">   <span class="meta">@PreAuthorize</span>(<span class="string">"principal.username.equals(#username)"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(String username)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"find user by username......"</span> + username);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 限制只能新增用户名称为abc的用户</div><div class="line">    */</div><div class="line">   <span class="meta">@PreAuthorize</span>(<span class="string">"#user.name.equals('abc')"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"addUser............"</span> + user);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在上面代码中我们定义了调用find(int id)方法时，只允许参数id小于10的调用；调用find(String username)时只允许username为当前用户的用户名；定义了调用add()方法时只有当参数user的name为abc时才可以调用。<br>&emsp;&emsp;有时候可能你会想在方法调用完之后进行权限检查，这种情况比较少，但是如果你有的话，Spring Security也为我们提供了支持，通过@PostAuthorize可以达到这一效果。使用@PostAuthorize时我们可以使用内置的表达式returnObject表示方法的返回值。我们来看下面这一段示例代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PostAuthorize</span>(<span class="string">"returnObject.id%2==0"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">  User user = <span class="keyword">new</span> User();</div><div class="line">  user.setId(id);</div><div class="line">  <span class="keyword">return</span> user;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上面这一段代码表示将在方法find()调用完成后进行权限检查，如果返回值的id是偶数则表示校验通过，否则表示校验失败，将抛出AccessDeniedException。       需要注意的是@PostAuthorize是在方法调用完成后进行权限检查，它不能控制方法是否能被调用，只能在方法调用完成后检查权限决定是否要抛出AccessDeniedException。</p>
<p>2.2 使用@PreFilter和@PostFilter进行过滤<br>&emsp;&emsp;使用@PreFilter和@PostFilter可以对集合类型的参数或返回值进行过滤。使用@PreFilter和@PostFilter时，Spring Security将移除使对应表达式的结果为false的元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@PostFilter</span>(<span class="string">"filterObject.id%2==0"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</div><div class="line">  List&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;User&gt;();</div><div class="line">  User user;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</div><div class="line">     user = <span class="keyword">new</span> User();</div><div class="line">     user.setId(i);</div><div class="line">     userList.add(user);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> userList;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上述代码表示将对返回结果中id不为偶数的user进行移除。filterObject是使用@PreFilter和@PostFilter时的一个内置表达式，表示集合中的当前对象。当@PreFilter标注的方法拥有多个集合类型的参数时，需要通过@PreFilter的filterTarget属性指定当前@PreFilter是针对哪个参数进行过滤的。如下面代码就通过filterTarget指定了当前@PreFilter是用来过滤参数ids的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@PreFilter(filterTarget=&quot;ids&quot;, value=&quot;filterObject%2==0&quot;)</div><div class="line">public void delete(List&lt;Integer&gt; ids, List&lt;String&gt; usernames) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.3 使用hasPermission表达式<br>&emsp;&emsp;Spring Security为我们定义了hasPermission的两种使用方式，它们分别对应着PermissionEvaluator的两个不同的hasPermission()方法。Spring Security默认处理Web、方法的表达式处理器分别为DefaultWebSecurityExpressionHandler和DefaultMethodSecurityExpressionHandler，它们都继承自AbstractSecurityExpressionHandler，其所持有的PermissionEvaluator是DenyAllPermissionEvaluator，其对于所有的hasPermission表达式都将返回false。所以当我们要使用表达式hasPermission时，我们需要自已手动定义SecurityExpressionHandler对应的bean定义，然后指定其PermissionEvaluator为我们自己实现的PermissionEvaluator，然后通过global-method-security元素或http元素下的expression-handler元素指定使用的SecurityExpressionHandler为我们自己手动定义的那个bean。<br>&emsp;&emsp;接下来看一个自己实现PermissionEvaluator使用hasPermission()表达式的简单示例。<br>&emsp;&emsp;首先实现自己的PermissionEvaluator，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPermissionEvaluator</span> <span class="keyword">implements</span> <span class="title">PermissionEvaluator</span> </span>&#123;</div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPermission</span><span class="params">(Authentication authentication,</span></span></div><div class="line">         Object targetDomainObject, Object permission) &#123;</div><div class="line">      <span class="keyword">if</span> (<span class="string">"user"</span>.equals(targetDomainObject)) &#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">this</span>.hasPermission(authentication, permission);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 总是认为有权限</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPermission</span><span class="params">(Authentication authentication,</span></span></div><div class="line">         Serializable targetId, String targetType, Object permission) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">  </div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 简单的字符串比较，相同则认为有权限</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasPermission</span><span class="params">(Authentication authentication, Object permission)</span> </span>&#123;</div><div class="line">      Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();</div><div class="line">      <span class="keyword">for</span> (GrantedAuthority authority : authorities) &#123;</div><div class="line">         <span class="keyword">if</span> (authority.getAuthority().equals(permission)) &#123;</div><div class="line">            returntrue;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;接下来在ApplicationContext中显示的配置一个将使用PermissionEvaluator的SecurityExpressionHandler实现类，然后指定其所使用的PermissionEvaluator为我们自己实现的那个。这里我们选择配置一个针对于方法调用使用的表达式处理器，DefaultMethodSecurityExpressionHandler，具体如下所示。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"expressionHandler"</span></span></div><div class="line">   <span class="attr">class</span>=<span class="string">"org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"permissionEvaluator"</span> <span class="attr">ref</span>=<span class="string">"myPermissionEvaluator"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 自定义的PermissionEvaluator实现 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myPermissionEvaluator"</span> <span class="attr">class</span>=<span class="string">"com.xxx.MyPermissionEvaluator"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;有了SecurityExpressionHandler之后，我们还要告诉Spring Security，在使用SecurityExpressionHandler时应该使用我们显示配置的那个，这样我们自定义的PermissionEvaluator才能起作用。因为我们上面定义的是针对于方法的SecurityExpressionHandler，所以我们要指定在进行方法权限控制时应该使用它来进行处理，同时注意设置pre-post-annotations=”true”以启用对支持使用表达式的@PreAuthorize等注解的支持。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:global-method-security</span></span></div><div class="line">      <span class="attr">pre-post-annotations</span>=<span class="string">"enabled"</span>&gt;</div><div class="line">      <span class="tag">&lt;<span class="name">security:expression-handler</span> <span class="attr">ref</span>=<span class="string">"expressionHandler"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:global-method-security</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;之后我们就可以在需要进行权限控制的方法上使用@PreAuthorize以及hasPermission()表达式进行权限控制了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</div><div class="line"> </div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 将使用方法hasPermission(Authentication authentication,</div><div class="line">         Object targetDomainObject, Object permission)进行验证。</div><div class="line">    */</div><div class="line">   <span class="meta">@PreAuthorize</span>(<span class="string">"hasPermission('user', 'ROLE_USER')"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line">  </div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 将使用PermissionEvaluator的第二个方法，即hasPermission(Authentication authentication,</div><div class="line">         Serializable targetId, String targetType, Object permission)进行验证。</div><div class="line">    */</div><div class="line">   <span class="meta">@PreAuthorize</span>(<span class="string">"hasPermission('targetId','targetType','permission')"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(String username)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="meta">@PreAuthorize</span>(<span class="string">"hasPermission('user', 'ROLE_ADMIN')"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(User user)</span> </span>&#123;</div><div class="line"> </div><div class="line">   &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在上面的配置中，find(int id)和add()方法将使用PermissionEvaluator中接收三个参数的hasPermission()方法进行验证，而find(String username)方法将使用四个参数的hasPermission()方法进行验证。因为hasPermission()表达式与PermissionEvaluator中hasPermission()方法的对应关系就是在hasPermission()表达式使用的参数基础上加上当前Authentication对象调用对应的hasPermission()方法进行验证。<br>&emsp;&emsp;其实Spring Security已经针对于ACL实现了一个AclPermissionEvaluator。关于ACL的内容将在后文进行介绍。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Spring/Security/配置十六：基于表达式的权限控制/" data-id="cj6vztsdw008foablwl668dql" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Spring/Security/配置四：认证过程" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Spring/Security/配置四：认证过程/">配置四：认证过程</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/15/Spring/Security/配置四：认证过程/" class="article-date"><time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a> / <a class="article-category-link" href="/categories/Spring/Security/">Security</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="认证过程"><a href="#认证过程" class="headerlink" title="认证过程"></a>认证过程</h2><ol>
<li>用户使用用户名和密码进行登录。</li>
<li>Spring Security将获取到的用户名和密码封装成一个实现了Authentication接口的UsernamePasswordAuthenticationToken。</li>
<li>将上述产生的token对象传递给AuthenticationManager进行登录认证。</li>
<li>AuthenticationManager认证成功后将会返回一个封装了用户权限等信息的Authentication对象。</li>
<li>通过调用SecurityContextHolder.getContext().setAuthentication(…)将AuthenticationManager返回的Authentication对象赋予给当前的SecurityContext。</li>
</ol>
<p>&emsp;&emsp;上述介绍的就是Spring Security的认证过程。在认证成功后，用户就可以继续操作去访问其它受保护的资源了，但是在访问的时候将会使用保存在SecurityContext中的Authentication对象进行相关的权限鉴定。</p>
<h2 id="Web应用的认证过程"><a href="#Web应用的认证过程" class="headerlink" title="Web应用的认证过程"></a>Web应用的认证过程</h2><p>&emsp;&emsp;如果用户直接访问登录页面，那么认证过程跟上节描述的基本一致，只是在认证完成后将跳转到指定的成功页面，默认是应用的根路径。如果用户直接访问一个受保护的资源，那么认证过程将如下：  </p>
<ol>
<li>引导用户进行登录，通常是重定向到一个基于form表单进行登录的页面，具体视配置而定。</li>
<li>用户输入用户名和密码后请求认证，后台还是会像上节描述的那样获取用户名和密码封装成一个UsernamePasswordAuthenticationToken对象，然后把它传递给AuthenticationManager进行认证。</li>
<li>如果认证失败将继续执行步骤1，如果认证成功则会保存返回的Authentication到SecurityContext，然后默认会将用户重定向到之前访问的页面。</li>
<li>用户登录认证成功后再次访问之前受保护的资源时就会对用户进行权限鉴定，如不存在对应的访问权限，则会返回403错误码。  </li>
</ol>
<p>&emsp;&emsp;在上述步骤中将有很多不同的类参与，但其中主要的参与者是ExceptionTranslationFilter。</p>
<h2 id="ExceptionTranslationFilter"><a href="#ExceptionTranslationFilter" class="headerlink" title="ExceptionTranslationFilter"></a>ExceptionTranslationFilter</h2><p>&emsp;&emsp;ExceptionTranslationFilter是用来处理来自AbstractSecurityInterceptor抛出的AuthenticationException和AccessDeniedException的。AbstractSecurityInterceptor是Spring Security用于拦截请求进行权限鉴定的，其拥有两个具体的子类，拦截方法调用的MethodSecurityInterceptor和拦截URL请求的FilterSecurityInterceptor。当ExceptionTranslationFilter捕获到的是AuthenticationException时将调用AuthenticationEntryPoint引导用户进行登录；如果捕获的是AccessDeniedException，但是用户还没有通过认证，则调用AuthenticationEntryPoint引导用户进行登录认证，否则将返回一个表示不存在对应权限的403错误码。</p>
<h2 id="在request之间共享SecurityContext"><a href="#在request之间共享SecurityContext" class="headerlink" title="在request之间共享SecurityContext"></a>在request之间共享SecurityContext</h2><p>&emsp;&emsp;可能你早就有这么一个疑问了，既然SecurityContext是存放在ThreadLocal中的，而且在每次权限鉴定的时候都是从ThreadLocal中获取SecurityContext中对应的Authentication所拥有的权限，并且不同的request是不同的线程，为什么每次都可以从ThreadLocal中获取到当前用户对应的SecurityContext呢？在Web应用中这是通过SecurityContextPersistentFilter实现的，默认情况下其会在每次请求开始的时候从session中获取SecurityContext，然后把它设置给SecurityContextHolder，在请求结束后又会将SecurityContextHolder所持有的SecurityContext保存在session中，并且清除SecurityContextHolder所持有的SecurityContext。这样当我们第一次访问系统的时候，SecurityContextHolder所持有的SecurityContext肯定是空的，待我们登录成功后，SecurityContextHolder所持有的SecurityContext就不是空的了，且包含有认证成功的Authentication对象，待请求结束后我们就会将SecurityContext存在session中，等到下次请求的时候就可以从session中获取到该SecurityContext并把它赋予给SecurityContextHolder了，由于SecurityContextHolder已经持有认证过的Authentication对象了，所以下次访问的时候也就不再需要进行登录认证了。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Spring/Security/配置四：认证过程/" data-id="cj6vztsdv008eoably0zct8yw" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/基础/java异常" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Java/基础/java异常/">java异常</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/15/Java/基础/java异常/" class="article-date"><time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>　　异常分类</p>
<p><img src="http://diycode.b0.upaiyun.com/photo/2016/ecb86e28e5df3a76a107f50d989f6123.png" alt="image"></p>
<h4 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h4><p>Throwable 类是 Java 语言中所有错误或异常的超类。只有当对象是此类（或其子类之一）的实例时，才能通过 Java 虚拟机或者 Java throw 语句抛出。类似地，只有此类或其子类之一才可以是 catch 子句中的参数类型。</p>
<h4 id="Error（错误）"><a href="#Error（错误）" class="headerlink" title="Error（错误）"></a>Error（错误）</h4><p>表示程序无法处理的错误，一般与程序员的执行操作无关。理论上这些错误是不允许发生的，如果发生，也不应该试图通过程序去处理，所以Error不是try-catch的处理对象，而JVM一般的处理方式是终止发生错误的线程。</p>
<h4 id="Exception（异常）"><a href="#Exception（异常）" class="headerlink" title="Exception（异常）"></a>Exception（异常）</h4><p>Java的异常分为两种</p>
<ul>
<li>checked Exception:检查型异常 或者 编译时异常，也叫非运行时异常</li>
<li>unchecked Exception, RuntimeException：不检查异常，也叫运行时异常</li>
</ul>
<p>运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p>
<p>非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p>
<p>java认为checked异常都是可以再编译阶段被处理的异常，所以它强制程序处理所有的checked异常，而Runtime异常无须处理，java程序必须显式处理checked异常，如果程序没有处理，则在编译时会发生错误，无法通过编译。</p>
<p>Java异常机制主要依赖于try、catch、finally、throw、throws五个关键字。</p>
<ol>
<li><p><code>try</code>：它里面放置可能引发异常的代码</p>
</li>
<li><p><code>catch</code>：后面对应异常类型和一个代码块，用于表明该catch块用于处理这种类型的代码块，可以有多个catch块。</p>
</li>
<li><p><code>finally</code>：主要用于回收在try块里打开的物力资源（如数据库连接、网络连接和磁盘文件），异常机制总是保证finally块总是被执行。</p>
</li>
</ol>
<p>finally的作用：</p>
<ul>
<li>无论try所指定的程序块中是否抛出异常，也无论catch语句的异常类型是否与所抛弃的异常的类型一致，finally中的代码一定会得到执行</li>
<li>finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序的其他部分以前，能够对程序的状态作统一的管理</li>
<li>通常再finally语句中可以进行资源的清楚工作，如关闭打开的文件，删除临时文件等</li>
</ul>
<p>当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。<br>在以下4种特殊情况下，finally块不会被执行：<br>1）在finally语句块中抛出了异常且未处理。<br>2）在前面的代码中用了System.exit()退出程序。<br>3）程序所在的线程死亡。<br>4）CPU出现异常被关闭。  </p>
<ol>
<li><p><code>throw</code>：用于抛出一个实际的异常，可以单独作为语句使用，抛出一个具体的异常对象。</p>
</li>
<li><p><code>throws</code>：用在方法头部中，用于声明该方法可能抛出的异常。</p>
</li>
</ol>
<h5 id="异常执行步骤"><a href="#异常执行步骤" class="headerlink" title="异常执行步骤"></a>异常执行步骤</h5><ol>
<li><p>如果执行try块中的业务逻辑代码时出现异常，系统自动生成一个异常对象，该异常对象被提交给java运行环境，这个过程称为<strong>抛出（throw）异常</strong>。</p>
</li>
<li><p>当java运行环境收到异常对象时，会寻找能处理该异常对象的catch块，如果找到合适的cathc块并把该异常对象交给catch块处理，那这个过程称为<strong>捕获（catch）异常</strong>；如果java运行时环境找不到捕获异常的catch块，则运行时环境终止，jav程序也将退出。</p>
</li>
</ol>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><ol>
<li><p>不管程序代码块是否处于try块中，甚至包括catch块中代码，只要执行该代码时出现了异常，系统都会自动生成一个异常对象，如果程序没有为这段代码定义任何catch块，java运行环境肯定找不到处理该异常的catch块，程序肯定在此退出。</p>
</li>
<li><p>try块后可以有多个catch块，try块后使用多个catch块是为了针对不同异常类提供的不同的异常处理方式。当系统发生不同意外情况时，系统会生成不同的异常对象，java运行时就会根据该异常对象所属的异常类来决定使用哪个catch块来处理该异常。</p>
</li>
<li><p>通常情况下，如果try块被执行一次，则try块后只有一个catch块会被执行，绝不可能有多个catch块被执行，除非在循环中使用类continue开始下一次循环，下一次循环又重新运行了try块，这才可能导致多个catch块被执行。</p>
</li>
<li><p>异常捕获顺序是从上到下的，所以一般将异常范围小放在前面，进行异常捕获时，一定要记住先捕获小的异常，再捕获大的异常。</p>
</li>
<li><p>只有try块石必须的，也就是说如果没有try块，则不可能有后面的catch块和finally块，catch块和finally块都是可选的，但catch块和finally块至少出现其中之一，也可以同时出现</p>
</li>
<li><p>使用throws声明抛出异常时有一个限制：就是方法重写时的“两小”中的一条规则：子类方法声明抛出的异常类型应该是父类方法声明抛出的异常类型的子类或或相等，子类方法中不允许比父类方法声明抛出更多异常。即如果子类抛出的异常是父类抛出的异常的父类，那么程序无法通过编译。</p>
</li>
</ol>
<h4 id="常见的运行时异常"><a href="#常见的运行时异常" class="headerlink" title="常见的运行时异常"></a>常见的运行时异常</h4><p>NullPointerException(空指针)，ArrayIndexOutOfBoundsException(数组下标越界),IndexOutOfBoundsException(索引越界异常),NumberFormatException(数字格式异常),IllegalArgumentException(方法参数错误)</p>
<h4 id="常见的非运行时异常"><a href="#常见的非运行时异常" class="headerlink" title="常见的非运行时异常"></a>常见的非运行时异常</h4><p>IOException(输入输出异常),SQLException(SQL异常)</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Java/基础/java异常/" data-id="cj6vztsbf002yoablp4eh7fyy" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Spring/Security/配置八：intercept-url配置" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Spring/Security/配置八：intercept-url配置/">配置八：intercept-url配置</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/15/Spring/Security/配置八：intercept-url配置/" class="article-date"><time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a> / <a class="article-category-link" href="/categories/Spring/Security/">Security</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>一. <strong>指定拦截的url</strong><br>通过pattern指定当前intercept-url定义应当作用于哪些url。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>二. <strong>指定访问权限</strong><br>&emsp;&emsp;可以通过access属性来指定intercept-url对应URL访问所应当具有的权限。access的值是一个字符串，其可以直接是一个权限的定义，也可以是一个表达式。常用的类型有简单的角色名称定义，多个名称之间用逗号分隔，如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/secure/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER,ROLE_ADMIN"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在上述配置中就表示secure路径下的所有URL请求都应当具有ROLE_USER或ROLE<em>ADMIN权限。当access的值是以“ROLE</em>”开头的则将会交由RoleVoter进行处理。</p>
<p>&emsp;&emsp;此外，其还可以是一个表达式，上述配置如果使用表达式来表示的话则应该是如下这个样子。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span> <span class="attr">use-expressions</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:form-login</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:logout</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/secure/**"</span> <span class="attr">access</span>=<span class="string">"hasAnyRole('ROLE_USER','ROLE_ADMIN')"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;或者是使用hasRole()表达式，然后中间以or连接，如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/secure/**"</span> <span class="attr">access</span>=<span class="string">"hasRole('ROLE_USER') or hasRole('ROLE_ADMIN')"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<strong>需要注意的是使用表达式时需要指定http元素的use-expressions=”true”</strong>。更多关于使用表达式的内容将在后文介绍。当intercept-url的access属性使用表达式时默认将使用WebExpressionVoter进行处理。<br>&emsp;&emsp;       此外，还可以指定三个比较特殊的属性值，默认情况下将使用AuthenticatedVoter来处理它们。</p>
<ul>
<li>IS_AUTHENTICATED_ANONYMOUSLY表示用户不需要登录就可以访问；</li>
<li>IS_AUTHENTICATED_REMEMBERED表示用户需要是通过Remember-Me功能进行自动登录的才能访问；</li>
<li>IS_AUTHENTICATED_FULLY表示用户的认证类型应该是除前两者以外的，也就是用户需要是通过登录入口进行登录认证的才能访问。如我们通常会将登录地址设置为IS_AUTHENTICATED_ANONYMOUSLY。<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:form-login</span> <span class="attr">login-page</span>=<span class="string">"/login.jsp"</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 登录页面可以匿名访问 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/login.jsp*"</span> <span class="attr">access</span>=<span class="string">"IS_AUTHENTICATED_ANONYMOUSLY"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>三. <strong>指定访问协议</strong><br>&emsp;&emsp;如果你的应用同时支持Http和Https访问，且要求某些URL只能通过Https访问，这个需求可以通过指定intercept-url的requires-channel属性来指定。<br>requires-channel支持三个值：<code>http</code>、<code>https</code>和<code>any</code>。any表示http和https都可以访问。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span> <span class="attr">auto-config</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:form-login</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 只能通过https访问 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/admin/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_ADMIN"</span> <span class="attr">requires-channel</span>=<span class="string">"https"</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 只能通过http访问 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span> <span class="attr">requires-channel</span>=<span class="string">"http"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;需要注意的是当试图使用http请求限制了只能通过https访问的资源时会自动跳转到对应的https通道重新请求。如果所使用的http或者https协议不是监听在标准的端口上（http默认是80，https默认是443），则需要我们通过port-mapping元素定义好它们的对应关系。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span> <span class="attr">auto-config</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:form-login</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 只能通过https访问 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/admin/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_ADMIN"</span> <span class="attr">requires-channel</span>=<span class="string">"https"</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 只能通过http访问 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span> <span class="attr">requires-channel</span>=<span class="string">"http"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:port-mappings</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">security:port-mapping</span> <span class="attr">http</span>=<span class="string">"8899"</span> <span class="attr">https</span>=<span class="string">"9988"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">security:port-mappings</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>四. <strong>指定请求方法</strong><br>&emsp;&emsp;通常我们都会要求某些URL只能通过POST请求，某些URL只能通过GET请求。这些限制Spring Security也已经为我们实现了，通过指定intercept-url的method属性可以限制当前intercept-url适用的请求方式，默认为所有的方式都可以。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span> <span class="attr">auto-config</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:form-login</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 只能通过POST访问 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/post/**"</span> <span class="attr">method</span>=<span class="string">"POST"</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 只能通过GET访问 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span> <span class="attr">method</span>=<span class="string">"GET"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>method的可选值有<code>GET</code>、<code>POST</code>、<code>DELETE</code>、<code>PUT</code>、<code>HEAD</code>、<code>OPTIONS</code>和<code>TRACE</code>。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Spring/Security/配置八：intercept-url配置/" data-id="cj6vztsdk007moablr6j1niwb" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Spring/Security/配置十：退出登录" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Spring/Security/配置十：退出登录/">配置十：退出登录</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/15/Spring/Security/配置十：退出登录/" class="article-date"><time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a> / <a class="article-category-link" href="/categories/Spring/Security/">Security</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;要实现退出登录的功能我们需要在http元素下定义logout元素，这样Spring Security将自动为我们添加用于处理退出登录的过滤器LogoutFilter到FilterChain。当我们指定了http元素的auto-config属性为true时logout定义是会自动配置的，此时我们默认退出登录的URL为“/j_spring_security_logout”，可以通过logout元素的logout-url属性来改变退出登录的默认地址。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:logout</span> <span class="attr">logout-url</span>=<span class="string">"/logout.do"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>此外，我们还可以给logout指定如下属性：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>invalidate-session</td>
<td>表示是否要在退出登录后让当前session失效，默认为true。</td>
</tr>
<tr>
<td>delete-cookies</td>
<td>指定退出登录后需要删除的cookie名称，多个cookie之间以逗号分隔。</td>
</tr>
<tr>
<td>logout-success-url</td>
<td>指定成功退出登录后要重定向的URL。需要注意的是对应的URL应当是不需要登录就可以访问的。</td>
</tr>
<tr>
<td>success-handler-ref</td>
<td>指定用来处理成功退出登录的LogoutSuccessHandler的引用。</td>
</tr>
</tbody>
</table>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Spring/Security/配置十：退出登录/" data-id="cj6vztsdt008boablr291eb7o" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Spring/Security/配置二：登录" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Spring/Security/配置二：登录/">配置二：登录</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/15/Spring/Security/配置二：登录/" class="article-date"><time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a> / <a class="article-category-link" href="/categories/Spring/Security/">Security</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="form-login元素介绍"><a href="#form-login元素介绍" class="headerlink" title="form-login元素介绍"></a>form-login元素介绍</h2><p>http元素下的form-login元素是用来定义表单登录信息的。当我们什么属性都不指定的时候Spring Security会为我们生成一个默认的登录页面。如果不想使用默认的登录页面，我们可以指定自己的登录页面。</p>
<h3 id="1-使用自定义登录页面"><a href="#1-使用自定义登录页面" class="headerlink" title="1.使用自定义登录页面"></a>1.使用自定义登录页面</h3><p> 自定义登录页面是通过login-page属性来指定的。提到login-page我们不得不提另外几个属性：</p>
<ul>
<li>username-parameter：表示登录时用户名使用的是哪个参数，默认是“j_username”。</li>
<li>password-parameter：表示登录时密码使用的是哪个参数，默认是“j_password”。</li>
<li>login-processing-url：表示登录时提交的地址，默认是“/j-spring-security-check”。这个只是Spring Security用来标记登录页面使用的提交地址，真正关于登录这个请求是不需要用户自己处理的。<br>所以，我们可以通过如下定义使Spring Security在需要用户登录时跳转到我们自定义的登录页面。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;security:http auto-config=&quot;true&quot;&gt;</div><div class="line">  &lt;security:form-login login-page=&quot;/login.jsp&quot;</div><div class="line">     login-processing-url=&quot;/login.do&quot; username-parameter=&quot;username&quot;</div><div class="line">     password-parameter=&quot;password&quot; /&gt;</div><div class="line">  &lt;!-- 表示匿名用户可以访问 --&gt;</div><div class="line">  &lt;security:intercept-url pattern=&quot;/login.jsp&quot; access=&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot;/&gt;</div><div class="line">  &lt;security:intercept-url pattern=&quot;/**&quot; access=&quot;ROLE_USER&quot; /&gt;</div><div class="line">&lt;/security:http&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>需要注意的是，我们之前配置的是所有的请求都需要ROLE_USER权限，这意味着我们自定义的“/login.jsp”也需要该权限，这样就会形成一个死循环了。解决办法是我们需要给“/login.jsp”放行。通过指定“/login.jsp”的访问权限为“IS_AUTHENTICATED_ANONYMOUSLY”或“ROLE_ANONYMOUS”可以达到这一效果。此外，我们也可以通过指定一个http元素的安全性为none来达到相同的效果。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;security:http security=&quot;none&quot; pattern=&quot;/login.jsp&quot; /&gt;</div><div class="line">&lt;security:http auto-config=&quot;true&quot;&gt;</div><div class="line">  &lt;security:form-login login-page=&quot;/login.jsp&quot;</div><div class="line">     login-processing-url=&quot;/login.do&quot; username-parameter=&quot;username&quot;</div><div class="line">     password-parameter=&quot;password&quot; /&gt;</div><div class="line">  &lt;security:intercept-url pattern=&quot;/**&quot; access=&quot;ROLE_USER&quot; /&gt;</div><div class="line">&lt;/security:http&gt;</div></pre></td></tr></table></figure></p>
<p>它们两者的区别是前者将进入Spring Security定义的一系列用于安全控制的filter，而后者不会。当指定一个http元素的security属性为none时，表示其对应pattern的filter链为空。从3.1开始，Spring Security允许我们定义多个http元素以满足针对不同的pattern请求使用不同的filter链。当为指定pattern属性时表示对应的http元素定义将对所有的请求发生作用。<br>根据上面的配置，我们自定义的登录页面的内容应该是这样子的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;form action=&quot;login.do&quot; method=&quot;post&quot;&gt;</div><div class="line">  &lt;table&gt;</div><div class="line">     &lt;tr&gt;</div><div class="line">        &lt;td&gt;用户名：&lt;/td&gt;</div><div class="line">        &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;/td&gt;</div><div class="line">     &lt;/tr&gt;</div><div class="line">     &lt;tr&gt;</div><div class="line">        &lt;td&gt;密码：&lt;/td&gt;</div><div class="line">        &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;/td&gt;</div><div class="line">     &lt;/tr&gt;</div><div class="line">     &lt;tr&gt;</div><div class="line">        &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;</div><div class="line">            &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;</div><div class="line">            &lt;input type=&quot;reset&quot; value=&quot;重置&quot;/&gt;</div><div class="line">        &lt;/td&gt;</div><div class="line">     &lt;/tr&gt;</div><div class="line">  &lt;/table&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p>
<h3 id="2-指定登录后的页面"><a href="#2-指定登录后的页面" class="headerlink" title="2.指定登录后的页面"></a>2.指定登录后的页面</h3><h4 id="通过default-target-url指定"><a href="#通过default-target-url指定" class="headerlink" title="通过default-target-url指定"></a>通过default-target-url指定</h4><p>默认情况下，我们在登录成功后会返回到原本受限制的页面。但如果用户是直接请求登录页面，登录成功后应该跳转到哪里呢？默认情况下它会跳转到当前应用的根路径，即欢迎页面。通过指定form-login元素的default-target-url属性，我们可以让用户在直接登录后跳转到指定的页面。如果想让用户不管是直接请求登录页面，还是通过Spring Security引导过来的，登录之后都跳转到指定的页面，我们可以通过指定form-login元素的always-use-default-target属性为true来达到这一效果。</p>
<h4 id="通过authentication-success-handler-ref指定"><a href="#通过authentication-success-handler-ref指定" class="headerlink" title="通过authentication-success-handler-ref指定"></a>通过authentication-success-handler-ref指定</h4><p>authentication-success-handler-ref对应一个AuthencticationSuccessHandler实现类的引用。如果指定了authentication-success-handler-ref，登录认证成功后会调用指定AuthenticationSuccessHandler的onAuthenticationSuccess方法。我们需要在该方法体内对认证成功做一个处理，然后返回对应的认证成功页面。使用了authentication-success-handler-ref之后认证成功后的处理就由指定的AuthenticationSuccessHandler来处理，之前的那些default-target-url之类的就都不起作用了。<br>以下是自定义的一个AuthenticationSuccessHandler的实现类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">publicclass AuthenticationSuccessHandlerImpl implements</div><div class="line">      AuthenticationSuccessHandler &#123;</div><div class="line"> </div><div class="line">   publicvoid onAuthenticationSuccess(HttpServletRequest request,</div><div class="line">         HttpServletResponse response, Authentication authentication)</div><div class="line">         throws IOException, ServletException &#123;</div><div class="line">      response.sendRedirect(request.getContextPath());</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其对应使用authentication-success-handler-ref属性的配置是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;security:http auto-config=&quot;true&quot;&gt;</div><div class="line">  &lt;security:form-login login-page=&quot;/login.jsp&quot;</div><div class="line">     login-processing-url=&quot;/login.do&quot; username-parameter=&quot;username&quot;</div><div class="line">     password-parameter=&quot;password&quot;</div><div class="line">     authentication-success-handler-ref=&quot;authSuccess&quot;/&gt;</div><div class="line">  &lt;!-- 表示匿名用户可以访问 --&gt;</div><div class="line">  &lt;security:intercept-url pattern=&quot;/login.jsp&quot;</div><div class="line">     access=&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot; /&gt;</div><div class="line">  &lt;security:intercept-url pattern=&quot;/**&quot; access=&quot;ROLE_USER&quot; /&gt;</div><div class="line">&lt;/security:http&gt;</div><div class="line">&lt;!-- 认证成功后的处理类 --&gt;</div><div class="line">&lt;bean id=&quot;authSuccess&quot; class=&quot;com.xxx.AuthenticationSuccessHandlerImpl&quot;/&gt;</div></pre></td></tr></table></figure></p>
<h3 id="3-指定登录失败后的页面"><a href="#3-指定登录失败后的页面" class="headerlink" title="3.指定登录失败后的页面"></a>3.指定登录失败后的页面</h3><p> 除了可以指定登录认证成功后的页面和对应的AuthenticationSuccessHandler之外，form-login同样允许我们指定认证失败后的页面和对应认证失败后的处理器AuthenticationFailureHandler。</p>
<h4 id="通过authentication-failure-url指定"><a href="#通过authentication-failure-url指定" class="headerlink" title="通过authentication-failure-url指定"></a>通过authentication-failure-url指定</h4><p>默认情况下登录失败后会返回登录页面，我们也可以通过form-login元素的authentication-failure-url来指定登录失败后的页面。需要注意的是登录失败后的页面跟登录页面一样也是需要配置成在未登录的情况下可以访问，否则登录失败后请求失败页面时又会被Spring Security重定向到登录页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;security:http auto-config=&quot;true&quot;&gt;</div><div class="line">  &lt;security:form-login login-page=&quot;/login.jsp&quot;</div><div class="line">     login-processing-url=&quot;/login.do&quot; username-parameter=&quot;username&quot;</div><div class="line">     password-parameter=&quot;password&quot;</div><div class="line">     authentication-failure-url=&quot;/login_failure.jsp&quot;</div><div class="line">     /&gt;</div><div class="line">  &lt;!-- 表示匿名用户可以访问 --&gt;</div><div class="line">  &lt;security:intercept-url pattern=&quot;/login*.jsp*&quot;</div><div class="line">     access=&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot; /&gt;</div><div class="line">  &lt;security:intercept-url pattern=&quot;/**&quot; access=&quot;ROLE_USER&quot; /&gt;</div><div class="line">&lt;/security:http&gt;</div></pre></td></tr></table></figure></p>
<h4 id="通过authentication-failure-handler-ref指定"><a href="#通过authentication-failure-handler-ref指定" class="headerlink" title="通过authentication-failure-handler-ref指定"></a>通过authentication-failure-handler-ref指定</h4><p>类似于authentication-success-handler-ref，authentication-failure-handler-ref对应一个用于处理认证失败的AuthenticationFailureHandler实现类。指定了该属性，Spring Security在认证失败后会调用指定AuthenticationFailureHandler的onAuthenticationFailure方法对认证失败进行处理，此时authentication-failure-url属性将不再发生作用。</p>
<h2 id="http-basic"><a href="#http-basic" class="headerlink" title="http-basic"></a>http-basic</h2><p>之前介绍的都是基于form-login的表单登录，其实Spring Security还支持弹窗进行认证。通过定义http元素下的http-basic元素可以达到这一效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;security:http auto-config=&quot;true&quot;&gt;</div><div class="line">  &lt;security:http-basic/&gt;</div><div class="line">  &lt;security:intercept-url pattern=&quot;/**&quot; access=&quot;ROLE_USER&quot; /&gt;</div><div class="line">&lt;/security:http&gt;</div></pre></td></tr></table></figure></p>
<p>此时，如果我们访问受Spring Security保护的资源时，系统将会弹出一个窗口来要求我们进行登录认证。效果如下：<br><img src="http://dl2.iteye.com/upload/attachment/0103/0663/b54058fa-adcc-3182-9e5c-456bf2658b1f.png" alt="image"><br>当然此时我们的表单登录也还是可以使用的，只不过当我们访问受包含资源的时候Spring Security不会自动跳转到登录页面。这就需要我们自己去请求登录页面进行登录。    </p>
<p>需要注意的是当我们同时定义了http-basic和form-login元素时，form-login将具有更高的优先级。即在需要认证的时候Spring Security将引导我们到登录页面，而不是弹出一个窗口。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Spring/Security/配置二：登录/" data-id="cj6vztsdj007koabl56c42wzp" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li class="active"><span class="page-number">2</span></li><li><a class="page-number" href="/page/3/">3</a></li><li><a class="page-number" href="/page/4/">4</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/19/">19</a></li><li><a class="page-next" rel="next" href="/page/3/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-module-inset">
  <h4>关于</h4>
  <p>该博客内的文章是博主在日常工作或者学习中总结出来，部分内容来自网络.</p>

</div>


  
  <div class="sidebar-module">
    <h4>分类</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Eclipse/">Eclipse</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Github/">Github</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/">Java</a><span class="sidebar-module-list-count">67</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/Cookie/">Cookie</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/JAXB/">JAXB</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/JavaMail/">JavaMail</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/基础/">基础</a><span class="sidebar-module-list-count">15</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/数据类型/">数据类型</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/日记/">日记</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/线程/">线程</a><span class="sidebar-module-list-count">16</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/网络NIO/">网络NIO</a><span class="sidebar-module-list-count">12</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/队列/">队列</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/集合/">集合</a><span class="sidebar-module-list-count">3</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Linux/">Linux</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Maven/">Maven</a><span class="sidebar-module-list-count">9</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/">Spring</a><span class="sidebar-module-list-count">56</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Application-Event/">Application Event</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/JPA/">JPA</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Security/">Security</a><span class="sidebar-module-list-count">22</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Task/">Task</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/spring-MVC/">spring MVC</a><span class="sidebar-module-list-count">17</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/spring-data-redis/">spring data redis</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/基础/">基础</a><span class="sidebar-module-list-count">5</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/前端技术相关/">前端技术相关</a><span class="sidebar-module-list-count">3</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/前端技术相关/forever/">forever</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/前端技术相关/javascript/">javascript</a><span class="sidebar-module-list-count">1</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/数据库相关/">数据库相关</a><span class="sidebar-module-list-count">11</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/数据库相关/mysql/">mysql</a><span class="sidebar-module-list-count">11</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/">服务器相关</a><span class="sidebar-module-list-count">22</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Hessian/">Hessian</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Hudson-Jenkins/">Hudson & Jenkins</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Memcached/">Memcached</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Tomcat/">Tomcat</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/red5/">red5</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/redis/">redis</a><span class="sidebar-module-list-count">9</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/resin/">resin</a><span class="sidebar-module-list-count">3</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/网络/">网络</a><span class="sidebar-module-list-count">7</span></li></ul>
  </div>



  


  

  
  <div class="sidebar-module">
    <h4>归档</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">60</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">124</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>最近文章</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/2017/08/28/Java/基础/java三大特性/">java三大特性</a>
        </li>
      
        <li>
          <a href="/2017/08/28/Java/基础/Filter过滤器/">Filter过滤器</a>
        </li>
      
        <li>
          <a href="/2017/08/27/Java/基础/泛型/">泛型</a>
        </li>
      
        <li>
          <a href="/2017/08/27/Java/基础/面向对象7大原则/">面向对象7大原则</a>
        </li>
      
        <li>
          <a href="/2017/08/16/Java/基础/java动态代理/">java动态代理</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2017 LeoChan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>



<script src="/js/script.js"></script>

</body>
</html>
