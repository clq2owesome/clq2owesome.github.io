<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LeoChan&#39;s 个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="描述啊">
<meta property="og:type" content="website">
<meta property="og:title" content="LeoChan&#39;s 个人博客">
<meta property="og:url" content="https://clq2owesome.github.io/page/2/index.html">
<meta property="og:site_name" content="LeoChan&#39;s 个人博客">
<meta property="og:description" content="描述啊">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeoChan&#39;s 个人博客">
<meta name="twitter:description" content="描述啊">
  
    <link rel="alternate" href="/atom.xml" title="LeoChan&#39;s 个人博客" type="application/atom+xml">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  

</head>

<body>
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">LeoChan&#39;s 个人博客</h1>
  
    <p class="lead blog-description">技术都是通用的，重要的是是否具有自主解决问题的能力！</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-Java/基础/生成随机数" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/12/Java/基础/生成随机数/">生成随机数</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/12/Java/基础/生成随机数/" class="article-date"><time datetime="2017-08-12T02:09:45.000Z" itemprop="datePublished">2017-08-12</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>使用java.util.Random包</p>
<h3 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int randNumber = rand.nextInt(MAX - MIN + 1) + MIN; // randNumber 将被赋值为一个 [MIN,MAX] 范围内的随机数</div></pre></td></tr></table></figure>
<p>例如：生成[1000, 9999]的随机数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Random rand = new Random();</div><div class="line">int random =  rand.nextInt(9999-1000+1) + 1000;</div></pre></td></tr></table></figure></p>
<p>说明：如果没有提供种子，java会默认处理,详情请查阅api</p>
<p>如果指定不变的种子，则每次返回的随机数都是一样的，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Random rand = new Random(100);</div><div class="line">int random =  rand.nextInt(9999-1000+1) + 1000;</div><div class="line">每次返回的random都一样</div></pre></td></tr></table></figure></p>
<h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">import java.util.Random;</div><div class="line">import org.apache.commons.lang3.RandomStringUtils;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 生成随机字符串，随机数工具类</div><div class="line"> * @author  chenliqiang, 2017年4月19日 下午9:47:25 &lt;br/&gt;   </div><div class="line"> * @version  1.0</div><div class="line"> * @see 	 </div><div class="line"> */</div><div class="line">public class RandomUtil extends RandomStringUtils &#123;</div><div class="line">	</div><div class="line">	public static final String stringBase = &quot;abcdefghijklmnopqrstuvwxyz0123456789&quot;;</div><div class="line">	public static final String numberBase = &quot;0123456789&quot;;</div><div class="line">	</div><div class="line">	/**</div><div class="line">	 *  获取特定位数的随机字符串</div><div class="line">	 * @param length  随机串长度</div><div class="line">	 * @param toUpperCase 是否转成大写</div><div class="line">	 * @return</div><div class="line">	 * @author chenliqiang， 2017年4月19日 下午9:48:54 &lt;br/&gt;</div><div class="line">	 */</div><div class="line">	public static String getRandomString(int length, boolean toUpperCase) &#123; //length表示生成字符串的长度  </div><div class="line">	    Random random = new Random();     </div><div class="line">	    StringBuffer sb = new StringBuffer();     </div><div class="line">	    for (int i = 0; i &lt; length; i++) &#123;     </div><div class="line">	        int number = random.nextInt(stringBase.length());     </div><div class="line">	        sb.append(stringBase.charAt(number));     </div><div class="line">	    &#125;</div><div class="line">	    if(toUpperCase) &#123;</div><div class="line">	    	return sb.toString().toUpperCase();  </div><div class="line">	    &#125;</div><div class="line">	    return  sb.toString();</div><div class="line">	 &#125;</div><div class="line">	</div><div class="line">	/**</div><div class="line">	 * 获取特定位数的随机数</div><div class="line">	 * @param length  随机数长度</div><div class="line">	 * @return</div><div class="line">	 * @author chenliqiang， 2017年4月19日 下午9:53:29 &lt;br/&gt;</div><div class="line">	 */</div><div class="line">	public static String getRandomNumber(int length) &#123; </div><div class="line">	    Random random = new Random();     </div><div class="line">	    StringBuffer sb = new StringBuffer();     </div><div class="line">	    for (int i = 0; i &lt; length; i++) &#123;     </div><div class="line">	        int number = random.nextInt(numberBase.length());     </div><div class="line">	        sb.append(numberBase.charAt(number));     </div><div class="line">	    &#125;</div><div class="line">	    return  sb.toString();</div><div class="line">	 &#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		System.out.println(randomAlphanumeric(50));</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/12/Java/基础/生成随机数/" data-id="cj6ao838l002ytcbl5ynvyrfa" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/基础/java 垃圾回收机制" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/12/Java/基础/java 垃圾回收机制/">java 垃圾回收机制</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/12/Java/基础/java 垃圾回收机制/" class="article-date"><time datetime="2017-08-12T02:09:45.000Z" itemprop="datePublished">2017-08-12</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JVM体系结构简介"><a href="#JVM体系结构简介" class="headerlink" title="JVM体系结构简介"></a>JVM体系结构简介</h2><h4 id="JVM-Specification中的JVM整体架构"><a href="#JVM-Specification中的JVM整体架构" class="headerlink" title="JVM Specification中的JVM整体架构"></a>JVM Specification中的JVM整体架构</h4><p><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/7F3773507E124A918989B46388D81BAE/7802" alt="image"><br>主要包括两个子系统和两个组件，<strong>Class Loader(类装载)子系统</strong>，<strong>Execution Engine(执行引擎)子系统</strong>，<strong>Runtime Data Area(运行时数据区)组件</strong>，<strong>Native Interface(本地接口)组件</strong>。 </p>
<ul>
<li>Class loader 子系统的作用 ：根 据给定的全限定名类名(如 java.lang.Object)来装载class文件的内容到 Runtime data area 中的method area(方法区域)。Java 程序员可以extends java.lang.ClassLoader 类来写自己的Class loader。</li>
<li>Execution engine 子系统的作用 ：执 行 classes中的指令。任何 JVM specification实现(JDK)的核心是Execution engine， 换句话说：Sun 的JDK 和IBM的JDK好坏主要取决于他们各自实现的Execution  engine的好坏。每个运行中的线程都有一个 Execution engine的实例。 </li>
<li>Native interface 组件 ：与native libraries 交互，是其它编程语言交互的接口。 </li>
<li>Runtime data area 组件：这个组件就是 JVM中的内存。</li>
</ul>
<p>Runtime data area 的整体架构图：<br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/6AA4AD5DE0324A3C8BEE06B56345725F/7804" alt="image"><br><strong>Runtime data area 主要包括五个部分：Heap (堆), Method Area(方法区域), Java Stack(java 的栈), Program Counter(程序计数器), Native method stack(本地方法栈)。Heap 和Method Area 是被所有线程的共享使用的；而Java stack, Program counter 和 Native method stack 是以线程为粒度的，每个线程独自拥有。</strong>   </p>
<ul>
<li><p><strong>Heap（堆内存）</strong><br>Java程序在运行时创建的所有类实例或数组都放在同一个堆中。而一个Java虚拟实例中只存在一个堆空间，因此所有线程都将共享这个堆。每一个 java程序独占一个JVM实例，因而每个 java程序都有它自己的堆空间，它们不会彼此干扰。但是同一java程序的多个线程都共享着同一个堆空间，就得考虑多线程访问对象（堆数据）的同步问 题。（这里可能出现的异常 java.lang.OutOfMemoryError: Java heap space）  </p>
</li>
<li><p><strong>Method area（方法区）</strong><br>在Java 虚拟机中，被装载的 class的信息存储在 Method area的内存中。当虚拟机装载某个类型时，它使用类装载器定位相应的 class文件，然后读入这个class文件内容并把它传输到虚拟机中。紧接着虚拟机提取其中的类型信息，并将这些信息存储到方法区。该类型中的类（静 态）变量同样也存储在方法区中。与Heap 一样，method area 是多线程共享的，因此要考虑多线程访问的同步问题。比如，假设同时两个线程都企图访问一个名为 Lava的类，而这个类还没有内装载入虚拟机，那么，这时应该只有一个线程去装载它，而另一个线程则只能等待。 （这里可能出现的异常 java.lang.OutOfMemoryError: PermGen full）  </p>
</li>
<li><p><strong>Java stack（java 栈）</strong><br>Java stack 以帧为单位保存线程的运行状态。虚拟机只会直接对 Java stack执行两种操作：以帧为单位的压栈或出栈。每当线程调用一个方法的时候，就对当前状态作为一个帧保存到 java stack 中(压栈)；当一个方法调用返回时，从java stack 弹出一个帧(出栈)。栈的大小是有一定的限制，这个可能出现StackOverFlow 问题，例如递归的层数太深。  </p>
</li>
<li><p><strong>Program counter（程序计数器）</strong><br>每个运行中的Java程序，每一个线程都有它自己的PC寄存器，也是该线程启动时创建的。PC寄存器的内容总是指向下一条将被执行指令的地址，这里的地址可以是一个本地指针，也可以是在方法区中相对应于该方法起始指令的偏移量。  </p>
</li>
<li><p><strong>Native method stack（本地方法栈）</strong><br>对于一个运行中的Java程序而言，它还能会用到一些跟本地方法相关的数据区。当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限 制的世界。本地方法可以通过本地方法接口来访问虚拟机的运行时数据区，不止如此，它还可以做任何它想做的事情。比如，可以调用寄存器，或在操作系统中分配 内存等。总之，本地方法具有和JVM 相同的能力和权限。  (这里出现 JVM无法控制的内存溢出问题 native heap OutOfMemory ) 。  </p>
</li>
</ul>
<h4 id="Sun-JVM-中对-JVM-Specification-的实现（内存部分）"><a href="#Sun-JVM-中对-JVM-Specification-的实现（内存部分）" class="headerlink" title="Sun JVM 中对 JVM Specification 的实现（内存部分）"></a>Sun JVM 中对 JVM Specification 的实现（内存部分）</h4><p>JVM Specification只是抽象的说明了 JVM 实例按照子系统、内存区、数据类型以及指令这几个术语来描述的，  但是规范并非是要强制规定 Java 虚拟机实现内部的体系结构，更多的是为了严格地定义这些实现的外部特征。  Sun JVM 实现中：Runtime data area(JVM  内存)  五个部分中的 Java Stack , Program Counter, Native method stack 三部分和规范中的描述基本一致；但对 Heap  和  Method Area 进行了自己独特的实现。这个实现和 Sun JVM  的Garbage collector（垃圾回收）机制有关。     </p>
<h5 id="垃圾分代回收算法（Generational-Collecting）"><a href="#垃圾分代回收算法（Generational-Collecting）" class="headerlink" title="垃圾分代回收算法（Generational Collecting）"></a>垃圾分代回收算法（Generational Collecting）</h5><p>基于对对象生命周期分析后得出的垃圾回收算法。把对象分为年青代、年老代、持久代，对不同生命周期的对象使用不同的算法（上述方式中的一个）进行回收。现在的垃圾回收器（从J2SE1.2开始）都是使用此算法的。<br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/51FF00BC6F604060B8EE5826F063E7FF/7803" alt="image">    </p>
<p>如上图所示，为Java 堆中的各代分布。   </p>
<ol>
<li>Young（年轻代）JVM specification 中的  Heap的一部分。年轻代分三个区。一个Eden区，两个 Survivor区。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到 Survivor区（两个中的一个），当这个 Survivor区满时，此区的存活对象将被复制到另外一个 Survivor区，当这个 Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到年老区(Tenured)。需要注 意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来的对象，和从前一个 Survivor复制过来的对象，而复制到年老区的只有从第一个 Survivor 区过来的对象。而且，Survivor 区总有一个是空的。  </li>
<li>Tenured（年老代）JVM specification中的  Heap的一部分。年老代存放从年轻代存活的对象。一般来说年老代存放的都是生命期较长的对象。</li>
<li>Perm（持久代）  JVM specification 中的  Method area 用于存放静态文件，如 Java 类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些 class，例如 Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=进行设置。</li>
</ol>
<h2 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h2><p>JVM的内存分代管理结构：<br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/605518F2B1504903B1A126803190723C/7805" alt="image"><br>下面是一些需要关注的常用的JVM内存配置参数，我们来看看它们是如何影响上图中的比例的。        </p>
<h3 id="Heap-Size"><a href="#Heap-Size" class="headerlink" title="Heap Size"></a>Heap Size</h3><p><strong>-Xmx —最大Heap Size</strong>，即上图的Total size（包括Eden+form+to，Tenured，不包含Perm，见上图），限制了年轻代和年老代的可分配最大值；<br><strong>-Xms —初始化分配的Heap Size</strong><br>生产环境中ms一般设置成跟mx相等，因为若ms不等于mx那么在某些场景下JVM可能需要对Heap Size进行频繁的扩展和收缩，增加处理时间；</p>
<h3 id="New-Young-Generation-Size"><a href="#New-Young-Generation-Size" class="headerlink" title="New/Young Generation Size"></a>New/Young Generation Size</h3><p><strong>-Xmn —最大年轻代大小</strong>，即上图中的Eden+S0+S1+Virtual<br><strong>-XX:NewSize —初始化年轻代大小</strong>，即上图中的Eden+S0+S1，在只设置了-Xmn不设置-XX:NewSize的情况下，NewSize等于mn。<br>生产环境中一般只需设置-Xmn或者设置mn和NewSize相等，理由和HeapSize的设置一样，避免容量震荡消耗资源；</p>
<h3 id="Old-Generation-Size-（Tenured）"><a href="#Old-Generation-Size-（Tenured）" class="headerlink" title="Old Generation Size （Tenured）"></a>Old Generation Size （Tenured）</h3><p>-XX:NewRatio — Old Size/New Size，通过年老代和年轻代的比例和Heap Size就可以算出年老代的大小。一般默认为8，若Heap Size为1024m，则 NewSize=HeapSize/(NewRatio+1)=114m，OldSize=HeapSize-NewSize=910m；<br>注意：-Xmn的优先级比-XX:NewRatio高，若-Xmn已指定，则OldSize=HeapSize-NewSize，无需再按比例计算。生产环境中一般只需指定-Xmn就足够了。</p>
<h3 id="Eden和S0、S1"><a href="#Eden和S0、S1" class="headerlink" title="Eden和S0、S1"></a>Eden和S0、S1</h3><p>-XX:SurvivorRatio — Eden/S0，即 Eden区和S0的比例，默认为8，若NewSize为114m，则S0=NewSize/(SurvivorRatio+2)=11.4m;<br>S0==S1，S0、S1的职能是一模一样的，又叫做From space和To space，在每一次minor gc后角色会交换。<br>注意：-XX类型的选项在不同的JDK版本或实现中定义可能有所区别，在近日的实践中发现，在Linux jdk_1_5_0_10_x86版本中，SurvivorRatio=(YoungSize/S0)，而Linux jdk_1_5_0_20_x64版本中，SurvivorRatio=(Eden/S0)，所以，我们在实际的工程实践中还是应该用jmap -heap输出的jvm内存结构信息为准，不要想当然。</p>
<h3 id="Permanent-Generation-Size"><a href="#Permanent-Generation-Size" class="headerlink" title="Permanent Generation Size"></a>Permanent Generation Size</h3><p><strong>-XX:MaxPermSize</strong> —最大持久代大小，默认为64m；<br><strong>-XX:PermSize</strong> —初始化持久代大小，默认为16m；<br>生产环境中一般设置MaxPermSize和PermSize相等，理由和HeapSize的设置一样，避免容量震荡消耗资源；<br>当应用引用的类比较多或者应用了一些动态类生产技术时应该加大该区的值，一般256m对服务器程序都很足够了。  </p>
<h3 id="Thread-Stack-Size"><a href="#Thread-Stack-Size" class="headerlink" title="Thread Stack Size"></a>Thread Stack Size</h3><p><strong>-Xss</strong> —线程堆栈大小，一般用于存放方法入口参数和返回值，以及原子类型的本地变量（即方法内部变量）；<br>一般可设置为128k.</p>
<h3 id="Direct-Memory-Size"><a href="#Direct-Memory-Size" class="headerlink" title="Direct Memory Size"></a>Direct Memory Size</h3><p>-XX:MaxDirectMemorySize —direct byte buffer用到的本地内存，默认跟mx相等，所以生产环境中一般不设置mx大于物理内存的一半。</p>
<h2 id="GC过程"><a href="#GC过程" class="headerlink" title="GC过程"></a>GC过程</h2><p>在讲述GC过程前我先解释一下JVM的两个控制参数：</p>
<ul>
<li>-XX:TargetSurvivorRatio — Survivor Space最大使用率，若存放对象的总大小超过该值，将引起对象向Old区迁移；</li>
<li>-XX:MaxTenuringThreshold — Young区对象的最大任期阀值，即可经历minor gc的次数，超过该次数的对象直接迁移到Old区；</li>
</ul>
<h3 id="Heap在初始状态"><a href="#Heap在初始状态" class="headerlink" title="Heap在初始状态"></a>Heap在初始状态</h3><p><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/D697D9F32C4B49B695E55BA6C17F05BA/7806" alt="image">    </p>
<h3 id="在Eden存放新对象"><a href="#在Eden存放新对象" class="headerlink" title="在Eden存放新对象"></a>在Eden存放新对象</h3><p><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/661FF2FC15A54B968D78771794964F82/7807" alt="image">    </p>
<h3 id="Eden空间不足分配新对象，进行第一次minor-gc"><a href="#Eden空间不足分配新对象，进行第一次minor-gc" class="headerlink" title="Eden空间不足分配新对象，进行第一次minor gc"></a>Eden空间不足分配新对象，进行第一次minor gc</h3><p><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/3055967862EE440593549C52A86D1BFA/7808" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/DCC7EA8095674A87A8B731179AD2C055/7810" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/360E2E4E55074C43A2CEC0BF1E984735/7809" alt="image">    </p>
<h3 id="Eden区再次被写满，进行第二次minor-gc"><a href="#Eden区再次被写满，进行第二次minor-gc" class="headerlink" title="Eden区再次被写满，进行第二次minor gc"></a>Eden区再次被写满，进行第二次minor gc</h3><p><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/D82167248EE1422F9E2E168A2E0BED2C/7811" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/02BD5695A74249788A952C94A2BB6C5B/7813" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/ECFFAB95FB884318BFBC4810FA24C7DE/7812" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/43B37C943BB94ACD98390B311FB7EEE0/7814" alt="image">   </p>
<h3 id="Eden再次被写满，进行第3次minor-gc"><a href="#Eden再次被写满，进行第3次minor-gc" class="headerlink" title="Eden再次被写满，进行第3次minor gc"></a>Eden再次被写满，进行第3次minor gc</h3><p>第3次gc，发生了对象从from space提升到old区的迁移，然后也发生了from space到to space的copy<br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/9C0C8EDA8702471AA5FDA2B245A38442/7816" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/074D37A977464B0A9666B29BEF481E9D/7815" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/4E881AF6D6A94548A6E537AF0C0DEC7F/7817" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/A30D42C7170E468E8C789FAA797ED51F/7819" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/B37B2D99E29543F98F46BFCA716CB9D8/7818" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/61FA00EA2A28452A98CB66A1348D1771/7820" alt="image">   </p>
<p>以下是Survivor space空间不足但对象的minor gc次数未到达MaxTenuringThreshold时的gc情况：<br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/C0BD54B605034553BE7F6CA3877DCD6D/7821" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/E3EBAC9AB610412AA408431B7A448D20/7822" alt="image"><br><img src="http://note.youdao.com/yws/public/resource/5d693f69f15f8d79b4d63b55d6072e6d/xmlnote/4A2675338FF843A295210D7DC59557B3/7823" alt="image">   </p>
<h2 id="GC实战"><a href="#GC实战" class="headerlink" title="GC实战"></a>GC实战</h2><p>在进行GC Tuning时有两个很强大的利器：   </p>
<ul>
<li>jstat：用于查看某java进程的gc情况；</li>
<li>jmap：查看java进程堆栈分配和使用情况，以及dump出当前堆栈内容（可以用Eclipse MAT进行进一步分析） </li>
</ul>
<p>以上两个利器都是jdk自带，且无需java进程添加任何额外的debug信息输出参数的，直接就可以对任意java进程进行跟踪了。</p>
<p>UseParNewGC表示对新生代采用并行gc；<br>ParallelGCThreads表示并行的线程数为8，一般是cpu的核个数，当核个数大于8时可能不是很适用；<br>UseConcMarkSweepGC表示对full gc采用CMS gc；</p>
<p>另外还有几个跟GC有关的有用参数，这里没有用到：<br>-XX:+DisableExplicitGC 表示禁止显式gc，System.gc()<br>-XX:+UseCMSCompactAtFullCollection 适用于CMS gc，表示在进行gc的同时清理内存碎片，但会加长gc的总时间<br>-XX:CMSInitiatingOccupancyFraction=80 适用于CMS gc，表示在年老代达到80%使用率时马上进行回收</p>
<p>另外下面是在JVM Crash时获heap信息的一些配置参数：<br>-XX:ErrorFile=./xxx.log   JVM Crash时记录heap信息<br>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./yyy.log JVM OOM时记录heap信息<br>拿到heap文件后可以用Eclipse MAT进行分析，找出引起内存泄漏的class。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/12/Java/基础/java 垃圾回收机制/" data-id="cj6ao838j002wtcbl1qxbzymx" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/基础/JVM的堆和栈" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/12/Java/基础/JVM的堆和栈/">JVM的堆和栈</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/12/Java/基础/JVM的堆和栈/" class="article-date"><time datetime="2017-08-12T02:09:45.000Z" itemprop="datePublished">2017-08-12</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是java程序运行的关键，在java中，每一个线程都会有一个与之对应的线程栈。它是由许多栈帧（stack frame）或者说帧（frame）组成的，一个栈帧包含一个java方法调用的状态。当线程调用一个java方法时，虚拟机压入一个新的栈帧到该线程的java栈中，当该方法返回时，这个栈帧被从java栈中弹出并抛弃。总结起来就是，<strong>栈负责java程序运行过程中的进程和程序处理逻辑的控制</strong>。  </p>
<p>栈帧由三部分组成：局部变量区，操作数栈和帧数据区。</p>
<ol>
<li>局部变量区，顾名思义，存储对应方法的参数和局部变量。</li>
<li>操作数栈，相当于寄存器，存储虚拟机的程序指令。</li>
<li>帧数据区，除了局部变量区和操作数栈中的数据外，java栈帧还需要一些数据来支持常量池解析，正常方法返回以及异常派发机制，这些信息都保存在帧数据区中。    </li>
</ol>
<p>由于栈的结构和功能设计导致它不适合动态增长，因此在java的虚拟机规范中，<strong>栈只能存储基本类型的数据和对堆中对象的引用</strong>。<strong>java栈上的数据都是此线程私有的，任何线程都不能访问另外一个线程的栈数据</strong>。  </p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是java程序运行时创建的实例和数组的存储空间。每一个java虚拟机实例只会存在一个堆空间，因此，<strong>所有线程都将共享这个堆</strong>。    </p>
<p> 由堆的作用可以很容易的知道，它是一个随时都会有大量新数据产生，大量老数据过期的地方，因此对数据的管理和垃圾回收机制是影响堆性能很重要的指标。java虚拟机并没有强制规定怎么去实现一个堆，它只要求虚拟机必须以某种方式来管理自己的堆空间。因此，堆的构成和处理机制不能一概而论，不同的jvm可能会有各自独特的实现。  </p>
<p>堆一般由两部分构成：年轻代，年老代。</p>
<ol>
<li>年轻代：作用是作为程序中所有刚生成的对象的存储空间，设计这一空间的目的是尽可能快的回收掉那些生命周期不长的对象，提高堆空间的利用率。年轻代的内部还有更细划分，涉及到垃圾回收机制的介绍，在后续笔记中会说明。</li>
<li>年老代：用于存放那些生命周期较长，经历了数次垃圾回收后仍然健在的对象。存放于年老代的数据基本上都经过年轻代的过滤，比较稳定。</li>
</ol>
<h3 id="堆和栈的联系和区别"><a href="#堆和栈的联系和区别" class="headerlink" title="堆和栈的联系和区别"></a>堆和栈的联系和区别</h3><p>堆和栈是程序运行的关键，很有必要把他们的关系说清楚。<br><img src="http://note.youdao.com/yws/public/resource/5ae3ccd96f4823c07e89aa21f066d959/xmlnote/A54E95E4BFD74BCBA2EB0A5FA12C5BD1/7827" alt="image"><br><strong>栈是运行时的单位，而堆是存储的单位</strong>。    </p>
<p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据；堆解决的是数据存储的问题，即数据怎么放、放在哪儿。    </p>
<p>在Java中一个线程就会相应有一个线程栈与之对应，这点很容易理解，因为不同的线程执行逻辑有所不同，因此需要一个独立的线程栈。而堆则是所有线程共享的。栈因为是运行单位，因此里面存储的信息都是跟当前线程（或程序）相关信息的。包括局部变量、程序运行状态、方法返回值等等；而堆只负责存储对象信息。    </p>
<h4 id="为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？"><a href="#为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？" class="headerlink" title="为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？"></a>为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？</h4><ol>
<li>从软件设计的角度看，<strong>栈代表了处理逻辑</strong>，而<strong>堆代表了数据</strong>。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。</li>
<li>堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。</li>
<li>栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。</li>
<li><strong>面向对象就是堆和栈的完美结合</strong>。其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。不得不承认，面向对象的设计，确实很美。</li>
</ol>
<h4 id="在Java中，Main函数就是栈的起始点，也是程序的起始点。"><a href="#在Java中，Main函数就是栈的起始点，也是程序的起始点。" class="headerlink" title="在Java中，Main函数就是栈的起始点，也是程序的起始点。"></a>在Java中，Main函数就是栈的起始点，也是程序的起始点。</h4><p> 程序要运行总是有一个起点的。同C语言一样，java中的Main就是那个起点。无论什么java程序，找到main就找到了程序执行的入口：     </p>
<h5 id="堆中存什么？栈中存什么？"><a href="#堆中存什么？栈中存什么？" class="headerlink" title="堆中存什么？栈中存什么？"></a>堆中存什么？栈中存什么？</h5><p> <strong>堆中存的是对象</strong>。<strong>栈中存的是基本数据类型和堆中对象的引用</strong>。一个对象的大小是不可估计的，或者说是可以动态变化的，但是在栈中，一个对象只对应了一个4btye的引用（堆栈分离的好处）  </p>
<p> 为什么不把基本类型放堆中呢？因为其占用的空间一般是1~8个字节——需要空间比较少，而且因为是基本类型，所以不会出现动态增长的情况——长度固定，因此栈中存储就够了，如果把他存在堆中是没有什么意义的（还会浪费空间，后面说明）。可以这么说，基本类型和对象的引用都是存放在栈中，而且都是几个字节的一个数，因此在程序运行时，他们的处理方式是统一的。但是基本类型、对象引用和对象本身就有所区别了，因为一个是栈中的数据一个是堆中的数据。最常见的一个问题就是，Java中参数传递时的问题。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/12/Java/基础/JVM的堆和栈/" data-id="cj6ao838g002ttcbla9dx6dd3" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/基础/==与equals的区别" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/12/Java/基础/==与equals的区别/">==与equals的区别</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/12/Java/基础/==与equals的区别/" class="article-date"><time datetime="2017-08-12T02:09:45.000Z" itemprop="datePublished">2017-08-12</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><strong>==:对于基本类型来说，比较的是两个对象的值是否想等；对于引用类型来说，比较的是两个引用对象是否指向同一个对象（即两个对象的引用地址是否想等）<br>equals:该方法不能作用于基本类型的对象，比较的是两个引用对象的地址是否想等<br>注意：由于String，Integer，Byte等类重写了equals方法，所以相当于比较两个对象的值是否想等</strong></p>
<hr>
<p>在Java中游8种基本数据类型：</p>
<p>　　浮点型：float(4 byte), double(8 byte)</p>
<p>　　整型：byte(1 byte), short(2 byte), int(4 byte) , long(8 byte)</p>
<p>　　字符型: char(2 byte)</p>
<p>　　布尔型: boolean(JVM规范没有明确规定其所占的空间大小，仅规定其只能够取字面值”true”和”false”)</p>
<p>　　对于这8种基本数据类型的变量，变量直接存储的是“值”，因此在用关系操作符==来进行比较时，比较的就是 “值” 本身。要注意浮点型和整型都是有符号类型的，而char是无符号类型的（char类型取值范围为0~2^16-1).
　　</p>
<ol>
<li><strong>String类型的比较</strong><br>String类型比较不同对象内容是否相同，应该用equals，因为==用于比较引用类型和比较基本数据类型时具有不同的功能。</li>
</ol>
<p>分析如下：</p>
<p>例子一：对象不同，内容相同，”==”返回false，equals返回true<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"java"</span>);</div><div class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"java"</span>);</div><div class="line"></div><div class="line">System.out.println(s1==s2);            <span class="comment">//false</span></div><div class="line">System.out.println(s1.equals(s2));    <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>例子二：同一对象，”==”和equals结果相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String s1 = new String(&quot;java&quot;);</div><div class="line">String s2 = s1;</div><div class="line"></div><div class="line">System.out.println(s1==s2);            //true</div><div class="line">System.out.println(s1.equals(s2));    //true</div></pre></td></tr></table></figure></p>
<p>例子三：String作为一个“基本类型”来使用</p>
<p>如果值不相同，对象就不相同，所以”==” 和equals结果一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String s1 = &quot;java&quot;;</div><div class="line">String s2 = &quot;java&quot;;</div><div class="line"></div><div class="line">System.out.println(s1==s2);            //true</div><div class="line">System.out.println(s1.equals(s2));    //true</div></pre></td></tr></table></figure></p>
<p>如果String缓冲池内不存在与其指定值相同的String对象，那么此时虚拟机将为此创建新的String对象，并存放在String缓冲池内。</p>
<p>如果String缓冲池内存在与其指定值相同的String对象，那么此时虚拟机将不为此创建新的String对象，而直接返回已存在的String对象的引用。</p>
<p>　　</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/12/Java/基础/==与equals的区别/" data-id="cj6ao8389002jtcbljr2zlqo3" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/基础/JVM体系结构" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/12/Java/基础/JVM体系结构/">JVM体系结构</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/12/Java/基础/JVM体系结构/" class="article-date"><time datetime="2017-08-12T02:09:45.000Z" itemprop="datePublished">2017-08-12</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>jvm的全称是Java Virtual Machine，即java虚拟机</strong>，它是构建于操作系统内存中一个虚拟软件，用于支持java程序的运行，是java之所以能够跨平台的关键。对java开发者来说，jvm既重要，又不重要。说它重要是因为我们的每一个程序，每一行代码，都必须通过它才能运行。说他不重要则是因为就算对它一无所知，实际上也不影响绝大部分java开发者日常工作。</p>
<p>当一个java程序被运行时，一个java虚拟机实例也就随之被创建。如果启动多个java程序，对应的，就会有多个虚拟机实例存在于内存中。一言以蔽之，jvm先java程序而生，后Java程序而亡。</p>
<p>那么一个jvm有哪些组成部分呢？如下图所示：<br><img src="http://note.youdao.com/yws/public/resource/1ba13d8b1eecc2e67ee0bff89b1d2735/xmlnote/D0F22E55CAC34EAEB73DCD810FAF8527/7828" alt="image"><br>上图就是jvm的构成图，也就是jvm的基本体系结构，可以看到，jvm大体上可以分为四大部分：   </p>
<ol>
<li><p>class loader，也就是类加载器。它的作用是查找符合java class格式的类文件（也就是图中的class files），并将之加载进Runtime Data Area。值得一提的是，只要文件符合.class文件的格式要求，就会被它加载，至于是否能够顺利运行，就不是它的职责了。</p>
</li>
<li><p>Runtime Data Area，顾名思义，运行时数据区。java程序运行时数据管理，对象的生成与消亡，内存的分配与回收都发生在这个区域。也是程序员主要关注的区域，一般意义上的jvm优化指的就是针对这个区域的优化，它由以下几个部分构成：</p>
</li>
</ol>
<ul>
<li>stack，也就是java栈。栈是java程序运行的关键，java中的每一个线程都会有一个与之相对应的线程栈。里面存储的信息都是跟当前线程相关的信息，包括局部变量，程序运行状态，方法返回值等。每一次方法的调用都将作为一个整体帧被压入栈中，遵循”先入后出”原则。不同的栈无法访问彼此的数据，栈中只能存储基本类型和堆中对象的引用。</li>
<li>heap，堆内存。堆负责java对象信息的存储，堆中的内容可以被多个栈共享，堆的存在，使得java多个线程之间可以共享数据。每一个java虚拟机都只有一个堆内存，它主要由两个部分构成：年轻代、老年代，对堆内存的分配与垃圾的回收机制是jvm优化的一个极端重要的课题，这部分留待在后续的学习笔记中介绍。  </li>
<li>method area，方法区（永久代）。该区域被所有线程所共享，主要用于存储java类信息，常量，静态变量等。</li>
<li>PC Register，程序计数器。每一个java线程都有一个自己的pc register，它的内容总是指向下一条被执行指令的地址，不做深究。</li>
<li>native method stack，本地方法栈。其作用类似于java栈，不同之处是它负责存储本地方法的调用信息，也就是当java程序调用native方法时(简单地讲，一个Native Method就是一个Java调用非java代码的接口)，其相关的运行信息将被压入本地方法栈，而不是Java栈。</li>
</ul>
<ol>
<li><p>Execution Engine，执行引擎，也叫解释器。负责解释命令，执行字节码或本地方法。太偏向于底层，不做深究。</p>
</li>
<li><p>Native Interface，本地接口。它赋予了java调用由其它语言编写而成的接口的能力，通过执行引擎加载执行，现在的用处较少，有兴趣的同学可自行学习。</p>
</li>
</ol>
<p>下面重点讲解一下运行数据区</p>
<h2 id="运行数据区"><a href="#运行数据区" class="headerlink" title="运行数据区"></a>运行数据区</h2><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（第2版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示：<br><img src="http://pic002.cnblogs.com/images/2012/416402/2012101820014328.jpg" alt="image">    </p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。        </p>
<p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：<strong>每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程</strong>。<br>经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”在后面会专门讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变量表部分。  </p>
<p>局部变量表存放了<strong>编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型）</strong>，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。    </p>
<p>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。    </p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。   </p>
<p>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>对于大多数应用来说，<strong>Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建</strong>。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存</strong>。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。    </p>
<p>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以<strong>Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等</strong>。如果从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java堆中的上述各个区域的分配和回收等细节将会是下一章的主题。      </p>
<p>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p><strong>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域</strong>，它<strong>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。  </p>
<p>对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。即使是HotSpot虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory来实现方法区的规划了。    </p>
<p><strong>Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集</strong>。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。在Sun公司的BUG列表中，曾出现过的若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。 根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p><strong>运行时常量池（Runtime Constant Pool）是方法区的一部分</strong>。Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），<strong>用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中</strong>。  </p>
<p>Java虚拟机对Class文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。    </p>
<p><strong>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中</strong>，这种特性被开发人员利用得比较多的便是String类的intern()方法。 既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p>
<h2 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h2><p>介绍完Java虚拟机的运行时数据区之后，我们就可以来探讨一个问题：在Java语言中，对象访问是如何进行的？对象访问在Java语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及Java栈、Java堆、方法区这三个最重要内存区域之间的关联关系，如下面的这句代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object obj = new Object();</div></pre></td></tr></table></figure></p>
<p>假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java栈的本地变量表中，作为一个reference类型数据出现。而“new Object()”这部分的语义将会反映到Java堆中，形成一块存储了Object类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。    </p>
<p>由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，<strong>主流的访问方式有两种：使用句柄和直接指针</strong>。    </p>
<p>如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如下图所示：<br><img src="http://pic002.cnblogs.com/images/2012/416402/2012101820441174.jpg" alt="image">       </p>
<p>如果使用的是直接指针访问方式，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址，如下图所示：<br><img src="http://pic002.cnblogs.com/images/2012/416402/2012101820481861.jpg" alt="image">   </p>
<p>这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/12/Java/基础/JVM体系结构/" data-id="cj6ao838a002mtcbllwbqkx78" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/基础/JVM垃圾回收算法" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/12/Java/基础/JVM垃圾回收算法/">JVM垃圾回收算法</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/12/Java/基础/JVM垃圾回收算法/" class="article-date"><time datetime="2017-08-12T02:09:45.000Z" itemprop="datePublished">2017-08-12</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="GC的类型"><a href="#GC的类型" class="headerlink" title="GC的类型"></a>GC的类型</h2><p>当每个代满了之后都会自动促发collection，各收集器触发的条件不一样，当然也可以通过一些参数进行强制设定。主要分为两种类型：</p>
<ul>
<li>Minor Collection：GC用较高的频率对young进行扫描和回收，采用复制算法。</li>
<li>Major Collection：同时对Young和Old进行内存收集，也叫<strong>Full GC</strong>；因为成本关系对Old的检查回收频率要比Young低很多，采用标记清除/标记整理算法。可以通过调用代码System.gc()引发major collection，使用-XX:+DisableExplicitGC禁止它，或设为CMS并发-XX:+ExplicitGCInvokesConcurrent。</li>
</ul>
<p>更为具体的阐述如下：<br>由于年轻代进进出出的人多而频繁，所以年轻代的GC也就频繁一点，但涉及范围也就年轻代这点弹丸之地内的对象，其特点就是少量，多次，但快速，称之为Minor Collection。当年轻代的内存使用达到一定的阀值时，Minor Collection就被触发，Eden及某一Survior space（from space）之内存活的的对象被移到另一个空的Survior space（to space）中，然后from space和to space角色对调。当一个对象在两个survivor space之间移动过一定次数（达到预设的阀值）时，它就足够old了，够资格呆在年老代了。当然，如果survivor space比较小不足以容下所有live objects时，部分live objects也会直接晋升到年老代。 </p>
<p>Survior spaces可以看作是Eden和年老代之间的缓冲，通过该缓冲可以检验一个对象生命周期是否足够的长，因为某些对象虽然逃过了一次Minor Collection，并不能说明其生命周期足够长，说不定在下一次Minor Collection之前就挂了。这样一定程度上确保了进入年老代的对象是货真价实的，减少了年老代空间使用的增长速度，也就降低年老代GC的频率。    </p>
<p>当年老代或者永久代的内存使用达到一定阀值时，一次基于所有代的GC就触发了，其特定是涉及范围广（量大），耗费的时间相对较长（较慢），但是频率比较低（次数少），称之为Major Collection(Full Collection)。通常，首先使用针对年轻代的GC算法进行年轻代的GC，然后使用针对年老代的GC算法对年老代和永久代进行GC。    </p>
<h2 id="基本GC收集算法"><a href="#基本GC收集算法" class="headerlink" title="基本GC收集算法"></a>基本GC收集算法</h2><p><strong>复制(copying)</strong>：将堆内分成两个相同空间，从根(ThreadLocal的对象，静态对象）开始访问每一个关联的活跃对象，将空间A的活跃对象全部复制到空间B，然后一次性回收整个空间A。</p>
<p>因为只访问活跃对象，将所有活动对象复制走之后就清空整个空间，不用去访问死对象，所以遍历空间的成本较小，但需要巨大的复制成本和较多的内存。可参考如下的示例图：<br><img src="http://note.youdao.com/yws/public/resource/63fd0b1087cd86e931229e472fe87ee0/xmlnote/B30EF1FE809B4E2AABD3328DD2070A06/7829" alt="image"> </p>
<p><strong>标记清除(mark-sweep)</strong>：收集器先从根开始访问所有活跃对象，标记为活跃对象。然后再遍历一次整个内存区域，把所有没有标记活跃的对象进行回收处理。该算法遍历整个空间的成本较大暂停时间随空间大小线性增大，而且整理后堆里的碎片很多。可参考如下的示例图：<br><img src="http://note.youdao.com/yws/public/resource/63fd0b1087cd86e931229e472fe87ee0/xmlnote/CCA572C93C2D41698291596531755BB2/7831" alt="image"> </p>
<p><strong>标记整理(mark-sweep-compact)</strong>：综合了上述两者的做法和优点，先标记活跃对象，然后将其合并成较大的内存块。可参考如下的示例图：<br><img src="http://note.youdao.com/yws/public/resource/63fd0b1087cd86e931229e472fe87ee0/xmlnote/0BCD8C3038BE460A8F667934590C8F36/7830" alt="image"> </p>
<h2 id="GC收集器类型"><a href="#GC收集器类型" class="headerlink" title="GC收集器类型"></a>GC收集器类型</h2><ol>
<li><p>古老的串行收集器(Serial Collector)<br>-XX:+UseSerialGC：策略为年轻代串行复制，年老代串行标记整理。可参考如下的示例图：<br><img src="http://note.youdao.com/yws/public/resource/63fd0b1087cd86e931229e472fe87ee0/xmlnote/A12CF0AE8F964A51B683F4CEDCA62F7A/7832" alt="image"> </p>
</li>
<li><p>吞吐量优先的并行收集器(Throughput Collector)<br>-XX:+UseParallelGC：这是JDK5 -server的默认值。策略为：  </p>
</li>
</ol>
<ul>
<li>年轻代：暂停应用程序，多个垃圾收集线程并行的复制收集，线程数默认为CPU个数，CPU很多时，可用-XX:ParallelGCThreads= 设定线程数。</li>
<li>年老代：暂停应用程序，与串行收集器一样，单垃圾收集线程标记整理。  </li>
</ul>
<p>如上可知该收集器需要2+的CPU时才会优于串行收集器，适用于后台处理，科学计算。<br>可以使用-XX:MaxGCPauseMillis= 和 -XX:GCTimeRatio 来调整GC的时间。可参考如下的示例图：<br><img src="http://note.youdao.com/yws/public/resource/63fd0b1087cd86e931229e472fe87ee0/xmlnote/17A78FA4872B4A038D19829CACC0729B/7833" alt="image"> </p>
<ol>
<li>暂停时间优先的并发收集器(Concurrent Low Pause Collector-CMS)<br>-XX:+UseConcMarkSweepGC：这是以上两种策略的升级版，策略为：</li>
</ol>
<ul>
<li>年轻代：同样是暂停应用程序，多个垃圾收集线程并行的复制收集。</li>
<li>年老代：则只有两次短暂停，其他时间应用程序与收集线程并发的清除。</li>
</ul>
<p>若要采用标记整理算法，则可以通过设置参数实现；可参考如下的示例图：<br><img src="http://note.youdao.com/yws/public/resource/63fd0b1087cd86e931229e472fe87ee0/xmlnote/05D08D75547241658B7B643CC85F476D/7834" alt="image"> </p>
<ol>
<li>增量并发收集器(Incremental Concurrent-Mark-Sweep/i-CMS)：<br>虽然CMS收集算法在最为耗时的内存区域遍历时采用多线程并发操作，但对于服务器CPU资源不够的情况下，其实对性能是没有提升的，反而会导致系统吞吐量的下降，为了尽量避免这种情况的出现，就有了增量CMS收集算法，就是在并发标记、清理的时候让GC线程、用户线程交叉运行，尽量减少GC线程的全程独占式执行；可参考如下的示例图：<br><img src="http://note.youdao.com/yws/public/resource/63fd0b1087cd86e931229e472fe87ee0/xmlnote/DBE249783C8D4BF08521C141F082AE60/7835" alt="image"> </li>
</ol>
<h3 id="并行、并发的区别"><a href="#并行、并发的区别" class="headerlink" title="并行、并发的区别"></a>并行、并发的区别</h3><p>并行(Parallel)与并发(Concurrent)仅一字之差，但体现的意思却完全不同，这可能也是很多同学非常困惑的地方，要想深刻体会这其中的差别，可以多揣摩下上面关于GC收集器的示例图；</p>
<ul>
<li>并行：指多条垃圾收集线程并行，此时用户线程是没有运行的；</li>
<li>并发：指用户线程与垃圾收集线程并发执行，程序在继续运行，而垃圾收集程序运行于另一个CPU上。   </li>
</ul>
<p>并发收集一开始会很短暂的停止一次所有线程来开始初始标记根对象，然后标记线程与应用线程一起并发运行，最后又很短的暂停一次，多线程并行的重新标记之前可能因为并发而漏掉的对象，然后就开始与应用程序并发的清除过程。可见，最长的两个遍历过程都是与应用程序并发执行的，比以前的串行算法改进太多太多了！！！    </p>
<p>串行标记清除是等年老代满了再开始收集的，而并发收集因为要与应用程序一起运行，如果满了才收集，应用程序就无内存可用，所以系统默认68%满的时候就开始收集。内存已设得较大，吃内存又没有这么快的时候，可以用-XX:CMSInitiatingOccupancyFraction=恰当增大该比率。</p>
<h3 id="年轻代的痛"><a href="#年轻代的痛" class="headerlink" title="年轻代的痛"></a>年轻代的痛</h3><p>由于对年轻代的复制收集，依然必须停止所有应用程序线程，原理如此，只能靠多CPU，多收集线程并发来提高收集速度，但除非你的Server独占整台服务器，否则如果服务器上本身还有很多其他线程时，切换起来速度就….. 所以，搞到最后，暂停时间的瓶颈就落在了年轻代的复制算法上。<br>因此Young的大小设置挺重要的，大点就不用频繁GC，而且增大GC的间隔后，可以让多点对象自己死掉而不用复制了。但Young增大时，GC造成的停顿时间攀升得非常恐怖，据某人的测试结果显示：默认8M的Young，只需要几毫秒的时间，64M就升到90毫秒，而升到256M时，就要到300毫秒了，峰值还会攀到恐怖的800ms。谁叫复制算法，要等Young满了才开始收集，开始收集就要停止所有线程呢。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/12/Java/基础/JVM垃圾回收算法/" data-id="cj6ao838c002otcblbrykcpsi" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/基础/单例模式" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/12/Java/基础/单例模式/">单例模式</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/12/Java/基础/单例模式/" class="article-date"><time datetime="2017-08-12T02:09:45.000Z" itemprop="datePublished">2017-08-12</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="第一种（懒汉，线程不安全）："><a href="#第一种（懒汉，线程不安全）：" class="headerlink" title="第一种（懒汉，线程不安全）："></a>第一种（懒汉，线程不安全）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123; </div><div class="line">	private static Singleton instance; </div><div class="line">	private Singleton ()&#123;&#125; </div><div class="line">	    </div><div class="line">	public static Singleton getInstance() &#123; </div><div class="line">		if (instance == null) &#123; </div><div class="line">			instance = new Singleton(); </div><div class="line">		&#125; </div><div class="line">		return instance; </div><div class="line">	&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种写法lazy loading很明显，但是致命的是在多线程不能正常工作。</p>
<h3 id="第二种（懒汉，线程安全）："><a href="#第二种（懒汉，线程安全）：" class="headerlink" title="第二种（懒汉，线程安全）："></a>第二种（懒汉，线程安全）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123; </div><div class="line">    private static Singleton instance; </div><div class="line">    private Singleton ()&#123;&#125; </div><div class="line">    public static synchronized Singleton getInstance() &#123;    </div><div class="line">        if (instance == null) &#123; </div><div class="line">            instance = new Singleton(); </div><div class="line">        &#125; </div><div class="line">        return instance; </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种写法能够在多线程中很好的工作，而且看起来它也具备很好的lazy loading，但是，遗憾的是，效率很低，99%情况下不需要同步。</p>
<h3 id="第三种（饿汉）："><a href="#第三种（饿汉）：" class="headerlink" title="第三种（饿汉）："></a>第三种（饿汉）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123; </div><div class="line">    private static Singleton instance = new Singleton(); </div><div class="line">    private Singleton ()&#123;&#125; </div><div class="line">    public static Singleton getInstance() &#123; </div><div class="line">        return instance; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用getInstance方法，但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到lazy loading的效果。</p>
<h3 id="第四种（饿汉，变种）："><a href="#第四种（饿汉，变种）：" class="headerlink" title="第四种（饿汉，变种）："></a>第四种（饿汉，变种）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123; </div><div class="line">    private Singleton instance = null; </div><div class="line">    static &#123; </div><div class="line">        instance = new Singleton(); </div><div class="line">    &#125; </div><div class="line">    private Singleton ()&#123;&#125; </div><div class="line">    public static Singleton getInstance() &#123; </div><div class="line">        return this.instance; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>表面上看起来差别挺大，其实跟第三种方式差不多，都是在类初始化即实例化instance。</p>
<h3 id="第五种（静态内部类）："><a href="#第五种（静态内部类）：" class="headerlink" title="第五种（静态内部类）："></a>第五种（静态内部类）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123; </div><div class="line">    private static class SingletonHolder &#123; </div><div class="line">        private static final Singleton INSTANCE = new Singleton(); </div><div class="line">    &#125; </div><div class="line">    private Singleton ()&#123;&#125; </div><div class="line">    public static final Singleton getInstance() &#123; </div><div class="line">        return SingletonHolder.INSTANCE; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式同样利用了classloder的机制来保证初始化instance时只有一个线程，它跟第三种和第四种方式不同的是（很细微的差别）：第三种和第四种方式是只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading效果），而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。想象一下，如果实例化instance很消耗资源，我想让他延迟加载，另外一方面，我不希望在Singleton类加载时就实例化，因为我不能确保Singleton类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化instance显然是不合适的。这个时候，这种方式相比第三和第四种方式就显得很合理。</p>
<h3 id="第六种（枚举）："><a href="#第六种（枚举）：" class="headerlink" title="第六种（枚举）："></a>第六种（枚举）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public enum Singleton &#123; </div><div class="line">    INSTANCE; </div><div class="line">    public void whateverMethod() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏，在实际工作中，我也很少看见有人这么写过。</p>
<h3 id="第七种（双重校验锁）："><a href="#第七种（双重校验锁）：" class="headerlink" title="第七种（双重校验锁）："></a>第七种（双重校验锁）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123; </div><div class="line">    private volatile static Singleton singleton; </div><div class="line">    private Singleton ()&#123;&#125; </div><div class="line">    public static Singleton getSingleton() &#123; </div><div class="line">        if (singleton == null) &#123; </div><div class="line">            synchronized (Singleton.class) &#123; </div><div class="line">                if (singleton == null) &#123; </div><div class="line">                    singleton = new Singleton(); </div><div class="line">                &#125;  </div><div class="line">            &#125; </div><div class="line">        &#125; </div><div class="line">        return singleton; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>private Singleton (){}：私有化构造函数，防止外部创建实例</li>
<li>在运用单例模式时，要考虑所在的运行环境，在多线程的环境下，要考虑多线程安全的问题，一般来说，加锁会导致效率变低</li>
<li>要根据调用情况合理选择饿汉还是懒汉的加载方式</li>
</ol>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/12/Java/基础/单例模式/" data-id="cj6ao838e002rtcblih455rj8" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/加密解密／编码解码/对称加密算法与非对称加密算法" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/10/Java/加密解密／编码解码/对称加密算法与非对称加密算法/">对称加密算法与非对称加密算法</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/10/Java/加密解密／编码解码/对称加密算法与非对称加密算法/" class="article-date"><time datetime="2017-08-10T02:09:45.000Z" itemprop="datePublished">2017-08-10</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="对称加密算法与非对称加密算法的区别"><a href="#对称加密算法与非对称加密算法的区别" class="headerlink" title="对称加密算法与非对称加密算法的区别"></a>对称加密算法与非对称加密算法的区别</h3><ul>
<li><p>对称加密算法:<br>加密和解密用到的密钥是相同的，这种加密方式加密速度非常快，适合经常发送数据的场合。缺点是密钥的传输比较麻烦</p>
</li>
<li><p>非对称加密算法:<br>加密和解密用的密钥是不同的，这种加密方式是用数学上的难解问题构造的，通常加密解密的速度比较慢，适合偶尔发送数据的场合。优点是密钥传输方便。常见的非对称加密算法为RSA、ECC和EIGamal</p>
</li>
</ul>
<p>实际中，一般是通过RSA加密AES的密钥，传输到接收方，接收方解密得到AES密钥，然后发送方和接收方用AES密钥来通信</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/10/Java/加密解密／编码解码/对称加密算法与非对称加密算法/" data-id="cj6ao8385002btcbl86w2uzly" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/加密解密／编码解码/AES完整实现（Java）" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/10/Java/加密解密／编码解码/AES完整实现（Java）/">AES完整实现（Java）</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/10/Java/加密解密／编码解码/AES完整实现（Java）/" class="article-date"><time datetime="2017-08-10T02:09:45.000Z" itemprop="datePublished">2017-08-10</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="AES加密解密用到的工具类"><a href="#AES加密解密用到的工具类" class="headerlink" title="AES加密解密用到的工具类"></a>AES加密解密用到的工具类</h2><h3 id="SHA1"><a href="#SHA1" class="headerlink" title="SHA1"></a>SHA1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 对公众平台发送给公众账号的消息加解密示例代码.</div><div class="line"> * </div><div class="line"> * @copyright Copyright (c) 1998-2014 Tencent Inc.</div><div class="line"> */</div><div class="line"></div><div class="line">// ------------------------------------------------------------------------</div><div class="line"></div><div class="line">package com.xx.aes;</div><div class="line"></div><div class="line">import java.security.MessageDigest;</div><div class="line">import java.util.Arrays;</div><div class="line"></div><div class="line">/**</div><div class="line"> * SHA1 class</div><div class="line"> *</div><div class="line"> * 计算公众平台的消息签名接口.</div><div class="line"> */</div><div class="line">class SHA1 &#123;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 用SHA1算法生成安全签名</div><div class="line">	 * @param token 票据</div><div class="line">	 * @param timestamp 时间戳</div><div class="line">	 * @param nonce 随机字符串</div><div class="line">	 * @param encrypt 密文</div><div class="line">	 * @return 安全签名</div><div class="line">	 * @throws AesException </div><div class="line">	 */</div><div class="line">	public static String getSHA1(String token, String timestamp, String nonce, String encrypt) throws AesException &#123;</div><div class="line">		try &#123;</div><div class="line">			String[] array = new String[] &#123; token, timestamp, nonce, encrypt &#125;;</div><div class="line">			StringBuffer sb = new StringBuffer();</div><div class="line">			// 字符串排序</div><div class="line">			Arrays.sort(array);</div><div class="line">			for (int i = 0; i &lt; 4; i++) &#123;</div><div class="line">				sb.append(array[i]);</div><div class="line">			&#125;</div><div class="line">			String str = sb.toString();</div><div class="line">			// SHA1签名生成</div><div class="line">			MessageDigest md = MessageDigest.getInstance(&quot;SHA-1&quot;);</div><div class="line">			md.update(str.getBytes());</div><div class="line">			byte[] digest = md.digest();</div><div class="line"></div><div class="line">			StringBuffer hexstr = new StringBuffer();</div><div class="line">			String shaHex = &quot;&quot;;</div><div class="line">			for (int i = 0; i &lt; digest.length; i++) &#123;</div><div class="line">				shaHex = Integer.toHexString(digest[i] &amp; 0xFF);</div><div class="line">				if (shaHex.length() &lt; 2) &#123;</div><div class="line">					hexstr.append(0);</div><div class="line">				&#125;</div><div class="line">				hexstr.append(shaHex);</div><div class="line">			&#125;</div><div class="line">			return hexstr.toString();</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			throw new AesException(AesException.ComputeSignatureError);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="PKCS7Encoder"><a href="#PKCS7Encoder" class="headerlink" title="PKCS7Encoder"></a>PKCS7Encoder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 对公众平台发送给公众账号的消息加解密示例代码.</div><div class="line"> * </div><div class="line"> * @copyright Copyright (c) 1998-2014 Tencent Inc.</div><div class="line"> */</div><div class="line"></div><div class="line">// ------------------------------------------------------------------------</div><div class="line"></div><div class="line">package com.xx0.aes;</div><div class="line"></div><div class="line">import java.nio.charset.Charset;</div><div class="line">import java.util.Arrays;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 提供基于PKCS7算法的加解密接口.</div><div class="line"> */</div><div class="line">class PKCS7Encoder &#123;</div><div class="line">	static Charset CHARSET = Charset.forName(&quot;utf-8&quot;);</div><div class="line">	static int BLOCK_SIZE = 32;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 获得对明文进行补位填充的字节.</div><div class="line">	 * </div><div class="line">	 * @param count 需要进行填充补位操作的明文字节个数</div><div class="line">	 * @return 补齐用的字节数组</div><div class="line">	 */</div><div class="line">	static byte[] encode(int count) &#123;</div><div class="line">		// 计算需要填充的位数</div><div class="line">		int amountToPad = BLOCK_SIZE - (count % BLOCK_SIZE);</div><div class="line">		if (amountToPad == 0) &#123;</div><div class="line">			amountToPad = BLOCK_SIZE;</div><div class="line">		&#125;</div><div class="line">		// 获得补位所用的字符</div><div class="line">		char padChr = chr(amountToPad);</div><div class="line">		String tmp = new String();</div><div class="line">		for (int index = 0; index &lt; amountToPad; index++) &#123;</div><div class="line">			tmp += padChr;</div><div class="line">		&#125;</div><div class="line">		return tmp.getBytes(CHARSET);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 删除解密后明文的补位字符</div><div class="line">	 * </div><div class="line">	 * @param decrypted 解密后的明文</div><div class="line">	 * @return 删除补位字符后的明文</div><div class="line">	 */</div><div class="line">	static byte[] decode(byte[] decrypted) &#123;</div><div class="line">		int pad = (int) decrypted[decrypted.length - 1];</div><div class="line">		if (pad &lt; 1 || pad &gt; 32) &#123;</div><div class="line">			pad = 0;</div><div class="line">		&#125;</div><div class="line">		return Arrays.copyOfRange(decrypted, 0, decrypted.length - pad);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 将数字转化成ASCII码对应的字符，用于对明文进行补码</div><div class="line">	 * </div><div class="line">	 * @param a 需要转化的数字</div><div class="line">	 * @return 转化得到的字符</div><div class="line">	 */</div><div class="line">	static char chr(int a) &#123;</div><div class="line">		byte target = (byte) (a &amp; 0xFF);</div><div class="line">		return (char) target;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="EncryptedMessage"><a href="#EncryptedMessage" class="headerlink" title="EncryptedMessage"></a>EncryptedMessage</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">package com.xxx.aes;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 携带加密运算后得到的签名、时间戳、随机串和密文的对象</div><div class="line"> */</div><div class="line">public class EncryptedMessage &#123;</div><div class="line"></div><div class="line">	private String signature;</div><div class="line">	private String timestamp;</div><div class="line">	private String nonce;</div><div class="line">	private String data;</div><div class="line">	public EncryptedMessage(String signature, String timestamp, String nonce,</div><div class="line">			String data) &#123;</div><div class="line">		super();</div><div class="line">		this.signature = signature;</div><div class="line">		this.timestamp = timestamp;</div><div class="line">		this.nonce = nonce;</div><div class="line">		this.data = data;</div><div class="line">	&#125;</div><div class="line">	public String getSignature() &#123;</div><div class="line">		return signature;</div><div class="line">	&#125;</div><div class="line">	public void setSignature(String signature) &#123;</div><div class="line">		this.signature = signature;</div><div class="line">	&#125;</div><div class="line">	public String getTimestamp() &#123;</div><div class="line">		return timestamp;</div><div class="line">	&#125;</div><div class="line">	public void setTimestamp(String timeStamp) &#123;</div><div class="line">		this.timestamp = timeStamp;</div><div class="line">	&#125;</div><div class="line">	public String getNonce() &#123;</div><div class="line">		return nonce;</div><div class="line">	&#125;</div><div class="line">	public void setNonce(String nonce) &#123;</div><div class="line">		this.nonce = nonce;</div><div class="line">	&#125;</div><div class="line">	public String getData() &#123;</div><div class="line">		return data;</div><div class="line">	&#125;</div><div class="line">	public void setData(String data) &#123;</div><div class="line">		this.data = data;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public String toString() &#123;</div><div class="line">		return &quot;EncryptedMessage [signature=&quot; + signature + &quot;, timestamp=&quot;</div><div class="line">				+ timestamp + &quot;, nonce=&quot; + nonce + &quot;, data=&quot; + data + &quot;]&quot;;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ByteGroup"><a href="#ByteGroup" class="headerlink" title="ByteGroup"></a>ByteGroup</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">package com.xx.aes;</div><div class="line"></div><div class="line">import java.util.ArrayList;</div><div class="line"></div><div class="line">class ByteGroup &#123;</div><div class="line">	ArrayList&lt;Byte&gt; byteContainer = new ArrayList&lt;Byte&gt;();</div><div class="line"></div><div class="line">	public byte[] toBytes() &#123;</div><div class="line">		byte[] bytes = new byte[byteContainer.size()];</div><div class="line">		for (int i = 0; i &lt; byteContainer.size(); i++) &#123;</div><div class="line">			bytes[i] = byteContainer.get(i);</div><div class="line">		&#125;</div><div class="line">		return bytes;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public ByteGroup addBytes(byte[] bytes) &#123;</div><div class="line">		for (byte b : bytes) &#123;</div><div class="line">			byteContainer.add(b);</div><div class="line">		&#125;</div><div class="line">		return this;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int size() &#123;</div><div class="line">		return byteContainer.size();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="AES加密解密"><a href="#AES加密解密" class="headerlink" title="AES加密解密"></a>AES加密解密</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 针对org.apache.commons.codec.binary.Base64，</div><div class="line"> * 需要导入架包commons-codec-1.9（或commons-codec-1.8等其他版本）</div><div class="line"> * 官方下载地址：http://commons.apache.org/proper/commons-codec/download_codec.cgi</div><div class="line"> */</div><div class="line">package com.xx.aes;</div><div class="line"></div><div class="line">import java.net.URISyntaxException;</div><div class="line">import java.nio.charset.Charset;</div><div class="line">import java.util.Arrays;</div><div class="line">import java.util.Random;</div><div class="line"></div><div class="line">import javax.crypto.Cipher;</div><div class="line">import javax.crypto.spec.IvParameterSpec;</div><div class="line">import javax.crypto.spec.SecretKeySpec;</div><div class="line"></div><div class="line">import org.apache.commons.codec.binary.Base64;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 用于加密和解密网络中互相传送消息，并且验证消息的安全性，消息加密后用Base64进行编码</div><div class="line"> * 说明：异常java.security.InvalidKeyException:illegal Key Size的解决方案</div><div class="line"> * &lt;ol&gt;</div><div class="line"> * 	&lt;li&gt;在官方网站下载JCE无限制权限策略文件（JDK7的下载地址：</div><div class="line"> *      http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html&lt;/li&gt;</div><div class="line"> * 	&lt;li&gt;下载后解压，可以看到local_policy.jar和US_export_policy.jar以及readme.txt&lt;/li&gt;</div><div class="line"> * 	&lt;li&gt;如果安装了JRE，将两个jar文件放到%JRE_HOME%\lib\security目录下覆盖原来的文件&lt;/li&gt;</div><div class="line"> * 	&lt;li&gt;如果安装了JDK，将两个jar文件放到%JDK_HOME%\jre\lib\security目录下覆盖原来文件&lt;/li&gt;</div><div class="line"> * &lt;/ol&gt;</div><div class="line"> */</div><div class="line">public class HBBizMsgCrypt &#123;</div><div class="line">	static Charset CHARSET = Charset.forName(&quot;utf-8&quot;);</div><div class="line">	Base64 base64 = new Base64();</div><div class="line">	byte[] aesKey;</div><div class="line">	String token;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 构造函数</div><div class="line">	 * @param token 开发者设置的token</div><div class="line">	 * @param encodingAesKey 开发者设置的EncodingAESKey</div><div class="line">	 * </div><div class="line">	 * @throws AesException 执行失败，请查看该异常的错误码和具体的错误信息</div><div class="line">	 */</div><div class="line">	public HBBizMsgCrypt(String token, String encodingAesKey) throws AesException &#123;</div><div class="line">		if (encodingAesKey.length() != 43) &#123;</div><div class="line">			throw new AesException(AesException.IllegalAesKey);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		this.token = token;</div><div class="line">		this.aesKey = Base64.decodeBase64(encodingAesKey + &quot;=&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 生成4个字节的网络字节序</div><div class="line">	byte[] getNetworkBytesOrder(int sourceNumber) &#123;</div><div class="line">		byte[] orderBytes = new byte[4];</div><div class="line">		orderBytes[3] = (byte) (sourceNumber &amp; 0xFF);</div><div class="line">		orderBytes[2] = (byte) (sourceNumber &gt;&gt; 8 &amp; 0xFF);</div><div class="line">		orderBytes[1] = (byte) (sourceNumber &gt;&gt; 16 &amp; 0xFF);</div><div class="line">		orderBytes[0] = (byte) (sourceNumber &gt;&gt; 24 &amp; 0xFF);</div><div class="line">		return orderBytes;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 还原4个字节的网络字节序</div><div class="line">	int recoverNetworkBytesOrder(byte[] orderBytes) &#123;</div><div class="line">		int sourceNumber = 0;</div><div class="line">		for (int i = 0; i &lt; 4; i++) &#123;</div><div class="line">			sourceNumber &lt;&lt;= 8;</div><div class="line">			sourceNumber |= orderBytes[i] &amp; 0xff;</div><div class="line">		&#125;</div><div class="line">		return sourceNumber;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 随机生成16位字符串</div><div class="line">	public	String getRandomStr() &#123;</div><div class="line">		String base = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;;</div><div class="line">		Random random = new Random();</div><div class="line">		StringBuffer sb = new StringBuffer();</div><div class="line">		for (int i = 0; i &lt; 16; i++) &#123;</div><div class="line">			int number = random.nextInt(base.length());</div><div class="line">			sb.append(base.charAt(number));</div><div class="line">		&#125;</div><div class="line">		return sb.toString();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 对明文进行加密.</div><div class="line">	 * </div><div class="line">	 * @param randomStr 随机字符串</div><div class="line">	 * @param text 需要加密的明文</div><div class="line">	 * @return 加密后base64编码的字符串</div><div class="line">	 * @throws AesException aes加密失败</div><div class="line">	 */</div><div class="line">	 public String encrypt(String randomStr, String text) throws AesException &#123;</div><div class="line">		ByteGroup byteCollector = new ByteGroup();</div><div class="line">		byte[] randomStrBytes = randomStr.getBytes(CHARSET);</div><div class="line">		byte[] textBytes = text.getBytes(CHARSET);</div><div class="line">		byte[] networkBytesOrder = getNetworkBytesOrder(textBytes.length);</div><div class="line"></div><div class="line">		// randomStr + networkBytesOrder + text</div><div class="line">		byteCollector.addBytes(randomStrBytes);</div><div class="line">		byteCollector.addBytes(networkBytesOrder);</div><div class="line">		byteCollector.addBytes(textBytes);</div><div class="line"></div><div class="line">		// ... + pad: 使用自定义的填充方式对明文进行补位填充</div><div class="line">		byte[] padBytes = PKCS7Encoder.encode(byteCollector.size());</div><div class="line">		byteCollector.addBytes(padBytes);</div><div class="line"></div><div class="line">		// 获得最终的字节流, 未加密</div><div class="line">		byte[] unencrypted = byteCollector.toBytes();</div><div class="line"></div><div class="line">		try &#123;</div><div class="line">			// 设置加密模式为AES的CBC模式</div><div class="line">			Cipher cipher = Cipher.getInstance(&quot;AES/CBC/NoPadding&quot;);</div><div class="line">			SecretKeySpec keySpec = new SecretKeySpec(aesKey, &quot;AES&quot;);</div><div class="line">			IvParameterSpec iv = new IvParameterSpec(aesKey, 0, 16);</div><div class="line">			cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv);</div><div class="line"></div><div class="line">			// 加密</div><div class="line">			byte[] encrypted = cipher.doFinal(unencrypted);</div><div class="line"></div><div class="line">			// 使用BASE64对加密后的字符串进行编码</div><div class="line">			String base64Encrypted = base64.encodeToString(encrypted);</div><div class="line"></div><div class="line">			return base64Encrypted;</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			throw new AesException(AesException.EncryptAESError);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 对密文进行解密.</div><div class="line">	 * </div><div class="line">	 * @param text 需要解密的密文</div><div class="line">	 * @return 解密得到的明文</div><div class="line">	 * @throws AesException aes解密失败</div><div class="line">	 */</div><div class="line">	public String decrypt(String text) throws AesException &#123;</div><div class="line">		byte[] original;</div><div class="line">		try &#123;</div><div class="line">			// 设置解密模式为AES的CBC模式</div><div class="line">			Cipher cipher = Cipher.getInstance(&quot;AES/CBC/NoPadding&quot;);</div><div class="line">			SecretKeySpec key_spec = new SecretKeySpec(aesKey, &quot;AES&quot;);</div><div class="line">			IvParameterSpec iv = new IvParameterSpec(Arrays.copyOfRange(aesKey, 0, 16));</div><div class="line">			cipher.init(Cipher.DECRYPT_MODE, key_spec, iv);</div><div class="line"></div><div class="line">			// 使用BASE64对密文进行解码</div><div class="line">			byte[] encrypted = Base64.decodeBase64(text);</div><div class="line"></div><div class="line">			// 解密</div><div class="line">			original = cipher.doFinal(encrypted);</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			throw new AesException(AesException.DecryptAESError);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		String decrypt;</div><div class="line">		try &#123;</div><div class="line">			// 去除补位字符</div><div class="line">			byte[] bytes = PKCS7Encoder.decode(original);</div><div class="line"></div><div class="line">			// 分离16位随机字符串,网络字节序</div><div class="line">			byte[] networkOrder = Arrays.copyOfRange(bytes, 16, 20);</div><div class="line"></div><div class="line">			int textLength = recoverNetworkBytesOrder(networkOrder);</div><div class="line"></div><div class="line">			decrypt = new String(Arrays.copyOfRange(bytes, 20, 20 + textLength), CHARSET);</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			throw new AesException(AesException.IllegalBuffer);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		return decrypt;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 将发送的消息加密打包.</div><div class="line">	 * &lt;ol&gt;</div><div class="line">	 * 	&lt;li&gt;对要发送的消息进行AES-CBC加密&lt;/li&gt;</div><div class="line">	 * 	&lt;li&gt;生成安全签名&lt;/li&gt;</div><div class="line">	 * &lt;/ol&gt;</div><div class="line">	 * </div><div class="line">	 * @param msg 需要加密的消息</div><div class="line">	 * @param timestamp 时间戳，可以自己生成</div><div class="line">	 * @param nonce 随机串，可以自己生成</div><div class="line">	 * </div><div class="line">	 * @return 加密后的信息载体，包括signature, timestamp, nonce, encrypt的字符串</div><div class="line">	 * @throws AesException 执行失败，请查看该异常的错误码和具体的错误信息</div><div class="line">	 * @throws URISyntaxException URI语法错误</div><div class="line">	 */</div><div class="line">	public EncryptedMessage encryptMsg(String msg, String timestamp, String nonce) throws AesException, URISyntaxException &#123;</div><div class="line">		// 加密</div><div class="line">		String encrypt = encrypt(getRandomStr(), msg);</div><div class="line">		</div><div class="line">		if (timestamp == null || &quot;&quot;.equals(timestamp)) &#123;</div><div class="line">			timestamp = String.valueOf(System.currentTimeMillis());</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		String signature = SHA1.getSHA1(token, timestamp, nonce, encrypt);</div><div class="line"></div><div class="line">		return new EncryptedMessage(signature, timestamp, nonce, encrypt);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 检验消息的真实性，并且获取解密后的明文.</div><div class="line">	 * &lt;ol&gt;</div><div class="line">	 * 	&lt;li&gt;利用收到的密文生成安全签名，进行签名验证&lt;/li&gt;</div><div class="line">	 * 	&lt;li&gt;对消息进行解密&lt;/li&gt;</div><div class="line">	 * &lt;/ol&gt;</div><div class="line">	 * </div><div class="line">	 * @param msgSignature 签名串，对应URL参数的signature</div><div class="line">	 * @param timestamp 时间戳，对应URL参数的timestamp</div><div class="line">	 * @param nonce 随机串，对应URL参数的nonce</div><div class="line">	 * @param data 密文，对应URL参数的data</div><div class="line">	 * </div><div class="line">	 * @return 解密后的原文</div><div class="line">	 * @throws AesException 执行失败，请查看该异常的错误码和具体的错误信息</div><div class="line">	 */</div><div class="line">	public String decryptMsg(String msgSignature, String timestamp, String nonce, String data)</div><div class="line">			throws AesException &#123;</div><div class="line"></div><div class="line">		// 验证安全签名</div><div class="line">		String signature = SHA1.getSHA1(token, timestamp, nonce, data);</div><div class="line"></div><div class="line">		// 和URL中的签名比较是否相等</div><div class="line">		// System.out.println(&quot;URL中的签名：&quot; + msg_sign);</div><div class="line">		// System.out.println(&quot;校验签名：&quot; + signature);</div><div class="line">		if (!signature.equals(msgSignature)) &#123;</div><div class="line">			throw new AesException(AesException.ValidateSignatureError);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// 解密</div><div class="line">		String result = decrypt(data);</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) throws AesException, URISyntaxException &#123;</div><div class="line">		HBBizMsgCrypt hBBizMsgCrypt=new HBBizMsgCrypt(&quot;123456&quot;,&quot;0123456789012345678901234567890123456789123&quot;);</div><div class="line">		</div><div class="line">		String name=&quot;李四&quot;;</div><div class="line">		String idCard=&quot;123456789123456789&quot;;</div><div class="line">		String mobile=&quot;13428825923&quot;;</div><div class="line">		String bankAccount=&quot;123456789&quot;;</div><div class="line">		String s1=hBBizMsgCrypt.encrypt(hBBizMsgCrypt.getRandomStr(), name);</div><div class="line">		String s2=hBBizMsgCrypt.encrypt(hBBizMsgCrypt.getRandomStr(), idCard);</div><div class="line">		String s3=hBBizMsgCrypt.encrypt(hBBizMsgCrypt.getRandomStr(), mobile);</div><div class="line">		String s4=hBBizMsgCrypt.encrypt(hBBizMsgCrypt.getRandomStr(), bankAccount);</div><div class="line">        </div><div class="line"></div><div class="line">		System.out.println(hBBizMsgCrypt.decrypt(s1));</div><div class="line">		System.out.println(hBBizMsgCrypt.decrypt(s2));</div><div class="line">		System.out.println(hBBizMsgCrypt.decrypt(s3));</div><div class="line">		System.out.println(hBBizMsgCrypt.decrypt(s4));</div><div class="line">	</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="加密解密异常类"><a href="#加密解密异常类" class="headerlink" title="加密解密异常类"></a>加密解密异常类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">package com.xx.aes;</div><div class="line"></div><div class="line">@SuppressWarnings(&quot;serial&quot;)</div><div class="line">public class AesException extends Exception &#123;</div><div class="line"></div><div class="line">	public final static int OK = 0;</div><div class="line">	public final static int ValidateSignatureError = -40001;</div><div class="line">	public final static int ParseXmlError = -40002;</div><div class="line">	public final static int ComputeSignatureError = -40003;</div><div class="line">	public final static int IllegalAesKey = -40004;</div><div class="line">	public final static int ValidateAppidError = -40005;</div><div class="line">	public final static int EncryptAESError = -40006;</div><div class="line">	public final static int DecryptAESError = -40007;</div><div class="line">	public final static int IllegalBuffer = -40008;</div><div class="line">	//public final static int EncodeBase64Error = -40009;</div><div class="line">	//public final static int DecodeBase64Error = -40010;</div><div class="line">	//public final static int GenReturnXmlError = -40011;</div><div class="line"></div><div class="line">	private int code;</div><div class="line"></div><div class="line">	private static String getMessage(int code) &#123;</div><div class="line">		switch (code) &#123;</div><div class="line">		case ValidateSignatureError:</div><div class="line">			return &quot;签名验证错误&quot;;</div><div class="line">		case ParseXmlError:</div><div class="line">			return &quot;xml解析失败&quot;;</div><div class="line">		case ComputeSignatureError:</div><div class="line">			return &quot;sha加密生成签名失败&quot;;</div><div class="line">		case IllegalAesKey:</div><div class="line">			return &quot;SymmetricKey非法&quot;;</div><div class="line">		case ValidateAppidError:</div><div class="line">			return &quot;appid校验失败&quot;;</div><div class="line">		case EncryptAESError:</div><div class="line">			return &quot;aes加密失败&quot;;</div><div class="line">		case DecryptAESError:</div><div class="line">			return &quot;aes解密失败&quot;;</div><div class="line">		case IllegalBuffer:</div><div class="line">			return &quot;解密后得到的buffer非法&quot;;</div><div class="line">//		case EncodeBase64Error:</div><div class="line">//			return &quot;base64加密错误&quot;;</div><div class="line">//		case DecodeBase64Error:</div><div class="line">//			return &quot;base64解密错误&quot;;</div><div class="line">//		case GenReturnXmlError:</div><div class="line">//			return &quot;xml生成失败&quot;;</div><div class="line">		default:</div><div class="line">			return null; // cannot be</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int getCode() &#123;</div><div class="line">		return code;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	AesException(int code) &#123;</div><div class="line">		super(getMessage(code));</div><div class="line">		this.code = code;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/10/Java/加密解密／编码解码/AES完整实现（Java）/" data-id="cj6ao837y0025tcblx26lfsyz" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Java/加密解密／编码解码/AES加密算法简单介绍" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/10/Java/加密解密／编码解码/AES加密算法简单介绍/">AES加密算法简单介绍</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/10/Java/加密解密／编码解码/AES加密算法简单介绍/" class="article-date"><time datetime="2017-08-10T02:09:45.000Z" itemprop="datePublished">2017-08-10</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a> / <a class="article-category-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>高级加密标准(AES,Advanced Encryption Standard)为最常见的对称加密算。对称加密算法也就是加密和解密用相同的密钥，具体的加密流程如下图：<br><img src="http://img.blog.csdn.net/20170219082909688?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjgyMDUxNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"><br>下面简单介绍下各个部分的作用与意义： </p>
<ul>
<li><strong>明文P</strong>:没有经过加密的数据</li>
<li><strong>密钥K</strong>:用来加密明文的密码，在对称加密算法中，加密与解密的密钥是相同的。密钥为接收方与发送方协商产生，但不可以直接在网络上传输，否则会导致密钥泄漏，通常是通过非对称加密算法加密密钥，然后再通过网络传输给对方，或者直接面对面商量密钥。密钥是绝对不可以泄漏的，否则会被攻击者还原密文，窃取机密数据</li>
<li><strong>AES加密函数</strong>:设AES加密函数为E，则 C = E(K, P),其中P为明文，K为密钥，C为密文。也就是说，把明文P和密钥K作为加密函数的参数输入，则加密函数E会输出密文C</li>
<li><strong>密文C</strong>:经加密函数处理后的数据</li>
<li><strong>AES解密函数</strong>:设AES解密函数为D，则 P = D(K, C),其中C为密文，K为密钥，P为明文。也就是说，把密文C和密钥K作为解密函数的参数输入，则解密函数会输出明文P。</li>
</ul>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/10/Java/加密解密／编码解码/AES加密算法简单介绍/" data-id="cj6ao837w0024tcbldl5szl5u" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li class="active"><span class="page-number">2</span></li><li><a class="page-number" href="/page/3/">3</a></li><li><a class="page-number" href="/page/4/">4</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/16/">16</a></li><li><a class="page-next" rel="next" href="/page/3/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-module-inset">
  <h4>关于</h4>
  <p>该博客内的文章是博主在日常工作或者学习中总结出来，部分内容来自网络.</p>

</div>


  
  <div class="sidebar-module">
    <h4>分类</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Eclipse/">Eclipse</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Github/">Github</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/">Java</a><span class="sidebar-module-list-count">60</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/Cookie/">Cookie</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/JAXB/">JAXB</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/JavaMail/">JavaMail</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/基础/">基础</a><span class="sidebar-module-list-count">8</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/数据类型/">数据类型</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/日记/">日记</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/线程/">线程</a><span class="sidebar-module-list-count">16</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/网络NIO/">网络NIO</a><span class="sidebar-module-list-count">12</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/队列/">队列</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/集合/">集合</a><span class="sidebar-module-list-count">3</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Linux/">Linux</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Maven/">Maven</a><span class="sidebar-module-list-count">9</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/">Spring</a><span class="sidebar-module-list-count">35</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Application-Event/">Application Event</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/JPA/">JPA</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Security/">Security</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Task/">Task</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/spring-MVC/">spring MVC</a><span class="sidebar-module-list-count">17</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/spring-data-redis/">spring data redis</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/基础/">基础</a><span class="sidebar-module-list-count">5</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/前端技术相关/">前端技术相关</a><span class="sidebar-module-list-count">3</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/前端技术相关/forever/">forever</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/前端技术相关/javascript/">javascript</a><span class="sidebar-module-list-count">1</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/数据库相关/">数据库相关</a><span class="sidebar-module-list-count">11</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/数据库相关/mysql/">mysql</a><span class="sidebar-module-list-count">11</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/">服务器相关</a><span class="sidebar-module-list-count">21</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Hessian/">Hessian</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Hudson-Jenkins/">Hudson & Jenkins</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Memcached/">Memcached</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Tomcat/">Tomcat</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/red5/">red5</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/redis/">redis</a><span class="sidebar-module-list-count">9</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/resin/">resin</a><span class="sidebar-module-list-count">2</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/网络/">网络</a><span class="sidebar-module-list-count">7</span></li></ul>
  </div>



  


  

  
  <div class="sidebar-module">
    <h4>归档</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">31</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">124</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>最近文章</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/2017/08/13/Spring/基础/Bean注入：Autowired和Resource/">Bean注入：Autowired和Resource</a>
        </li>
      
        <li>
          <a href="/2017/08/13/前端技术相关/javascript/js中去掉空格的方法/">js中去掉空格的方法</a>
        </li>
      
        <li>
          <a href="/2017/08/13/前端技术相关/forever/nohup node app.js &/">nohup node app.js &amp;</a>
        </li>
      
        <li>
          <a href="/2017/08/13/前端技术相关/forever/使用forever后台运行node.js/">使用forever后台运行node.js</a>
        </li>
      
        <li>
          <a href="/2017/08/13/Spring/基础/Spring  Bean的scope作用域/">Spring  Bean的scope作用域</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2017 LeoChan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>



<script src="/js/script.js"></script>

</body>
</html>
