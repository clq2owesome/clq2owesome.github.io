<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LeoChan&#39;s 个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="描述啊">
<meta property="og:type" content="website">
<meta property="og:title" content="LeoChan&#39;s 个人博客">
<meta property="og:url" content="https://clq2owesome.github.io/page/2/index.html">
<meta property="og:site_name" content="LeoChan&#39;s 个人博客">
<meta property="og:description" content="描述啊">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeoChan&#39;s 个人博客">
<meta name="twitter:description" content="描述啊">
  
    <link rel="alternate" href="/atom.xml" title="LeoChan&#39;s 个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LeoChan&#39;s 个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术都是通用的，重要的是是否具有自主解决问题的能力！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://clq2owesome.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Java/基础/对象存活" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/基础/对象存活/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/基础/对象存活/">对象存活</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用的</p>
<p>目前主流的java虚拟机里面没有选用引用计数器算法来管理内存，其中主要的原因是它很难解决对象之间相互循环引用的问题</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p><strong>这个算法的基本思路就是通过一系列的称为“GC Roots”的对象为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的</strong>。<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/obj.png" alt="image"><br>如图，object5，object6，object7就是不可用的，可以清除的</p>
<p>在java语言中，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关</p>
<p>在JDK1.2之后，java对引用的概念进行了扩充，将引用分为<code>强引用（Strong Reference）</code>，<code>软引用（Soft Reference）</code>，<code>弱引用（Weak Reference）</code>，<code>虚引用（Phantom Reference）</code>4种，这4种引用强度依次逐渐减弱</p>
<ul>
<li>强引用就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收被引用的对象</li>
<li><strong>软引用是用来描述一些还有用但并非必需的对象</strong>。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出的异常。在JDK1.2之后，提供了SoftReference类来实现软引用</li>
<li><strong>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前</strong>。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用</li>
<li>虚引用也称为幽灵引用或者幻影引用，他是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。<strong>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</strong>。在JDK1.2之后，提供了OhantomReference类实现虚引用</li>
</ul>
<h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>即使在可达性分析算法中被可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，<strong>要真正宣告一个对象死亡，至少要经历两次标识过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”</strong>。</p>
<p>如果这个对象被判定为有必要执行finalize()方法，那么合格对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个虚拟机自动建立的，低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统奔溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()方法中成功拯救自己-只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/基础/对象存活/" data-id="cjei8qk4w004g6gblq5070gu4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/基础/序列化和反序列化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/基础/序列化和反序列化/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/基础/序列化和反序列化/">序列化和反序列化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>将 Java 对象序列化为二进制文件的 Java 序列化技术是 Java 系列技术中一个较为重要的技术点，在大部分情况下，开发人员只需要了解被序列化的类需要实现Serializable接口，使用 ObjectInputStream和ObjectOutputStream 进行对象的读写。然而在有些情况下，光知道这些还远远不够</p>
</blockquote>
<h2 id="java序列化简介"><a href="#java序列化简介" class="headerlink" title="java序列化简介"></a>java序列化简介</h2><p>序列化就是指对象通过写出描述自己状态的数值来记录自己的过程，即将对象表示成一系列有序字节，java提供了将对象写入流和从流中恢复对象的方法。对象能包含其它的对象，而其它的对象又可以包含另外的对象。JAVA序列化能够自动的处理嵌套的对象。对于一个对象的简单域，writeObject()直接将其值写入流中。当遇到一个对象域时，writeObject()被再次调用，如果这个对象内嵌另一个对象，那么，writeObject()又被调用，直到对象能被直接写入流为止。程序员所需要做的是将对象传入ObjectOutputStream的writeObject()方法，剩下的将有系统自动完成。    </p>
<p>要实现序列化的类必须实现的java.io.Serializable或java.io.Externalizable接口，否则将产生一个NotSerializableException。该接口内部并没有任何方法，它只是一个”tagging interface”，仅仅”tags”它自己的对象是一个特殊的类型。类通过实现 java.io.Serializable接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或字段，仅用于标识可序列化的语义。Java的”对象序列化”能让你将一个实现了Serializable接口的对象转换成一组byte，这样日后要用这个对象时候，你就能把这些byte数据恢复出来，并据此重新构建那个对象了。</p>
<h2 id="序列化的必要性及目的"><a href="#序列化的必要性及目的" class="headerlink" title="序列化的必要性及目的"></a>序列化的必要性及目的</h2><p>Java中，一切都是对象，在分布式环境中经常需要将Object从这一端网络或设备传递到另一端。这就需要有一种可以在两端传输数据的协议。Java序列化机制就是为了解决这个问题而产生。</p>
<p>Java序列化支持的两种主要特性：</p>
<ul>
<li>Java 的RMI使本来存在于其他机器的对象可以表现出就象本地机器上的行为。</li>
<li>将消息发给远程对象时，需要通过对象序列化来传输参数和返回值.</li>
</ul>
<p>Java序列化的目的：</p>
<ul>
<li>支持运行在不同虚拟机上不同版本类之间的双向通讯；</li>
<li>定义允许JAVA类读取用相同类较老版本写入的数据流的机制；</li>
<li>定义允许JAVA类写用相同类较老版本读取的数据流的机制；</li>
<li>提供对持久性和RMI的序列化；</li>
<li>产生压缩流且运行良好以使RMI能序列化；</li>
<li>辨别写入的是否是本地流；</li>
<li>保持非版本化类的低负载；</li>
</ul>
<h2 id="序列化异常"><a href="#序列化异常" class="headerlink" title="序列化异常"></a>序列化异常</h2><p>序列化对象期间可能抛出6种异常：</p>
<ul>
<li>InvalidClassException 通常在重序列化流无法确定类型时或返回的类无法在取得对象的系统中表示时抛出此异常。异常也在恢复的类不声明为public时或没有public缺省（无变元）构造器时抛出。</li>
<li>NotSerializableException 通常由具体化对象（负责自身的重序列化）探测到输入流错误时抛出。错误通常由意外不变量值指示，或者表示要序列化的对象不可序列化。</li>
<li>StreamCorruptedException 在存放对象的头或控制数据无效时抛出。</li>
<li>OptionalDataException 流中应包含对象但实际只包含原型数据时抛出。</li>
<li>ClassNotFoundException 流的读取端找不到反序列化对象的类时抛出。</li>
<li>IOException  要读取或写入的对象发生与流有关的错误时抛出。</li>
</ul>
<h2 id="序列化一个对象"><a href="#序列化一个对象" class="headerlink" title="序列化一个对象"></a>序列化一个对象</h2><p>序列化一个对象，以及对序列化后的对象进行操作，需要遵循以下3点：</p>
<ol>
<li>一个对象能够序列化的前提是实现Serializable接口或Externalizable接口，Serializable接口没有方法，更像是个标记。有了这个标记的Class就能被序列化机制处理。</li>
<li>写个程序将对象序列化并输出。ObjectOutputStream能把Object输出成Byte流。</li>
<li>要从持久的文件中读取Bytes重建对象，我们可以使用ObjectInputStream。</li>
</ol>
<p>在序列化时，有几点要注意的：</p>
<ul>
<li>当一个对象被序列化时，只序列化对象的非静态成员变量，不能序列化任何成员方法和静态成员变量。</li>
<li>如果一个对象的成员变量是一个对象，那么这个对象的数据成员也会被保存。</li>
<li>如果一个可序列化的对象包含对某个不可序列化的对象的引用，那么整个序列化操作将会失败，并且会抛出一个NotSerializableException。可以通过将这个引用标记为transient，那么对象仍然可以序列化。对于一些比较敏感的不想序列化的数据，也可以采用该标识进行修饰。</li>
</ul>
<h2 id="Java的序列化算法"><a href="#Java的序列化算法" class="headerlink" title="Java的序列化算法"></a>Java的序列化算法</h2><p>序列化算法一般会按步骤做如下事情：</p>
<ul>
<li>将对象实例相关的类元数据输出。</li>
<li>递归地输出类的超类描述直到不再有超类。</li>
<li>类元数据完了以后，开始从最顶层的超类开始输出对象实例的实际数据值。</li>
<li>从上至下递归输出实例的数据</li>
</ul>
<h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><h3 id="序列化-ID-问题"><a href="#序列化-ID-问题" class="headerlink" title="序列化 ID 问题"></a>序列化 ID 问题</h3><p>情境：两个客户端 A 和 B 试图通过网络传递对象数据，A 端将对象 C 序列化为二进制数据再传给 B，B 反序列化得到 C。    </p>
<p>问题：C 对象的全类路径假设为 com.inout.Test，在 A 和 B 端都有这么一个类文件，功能代码完全一致。也都实现了 Serializable 接口，但是反序列化时总是提示不成功。</p>
<p>解决：虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID = 1L）。清单1中，虽然两个类的功能代码完全一致，但是序列化 ID 不同，他们无法相互序列化和反序列化。</p>
<p>简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。</p>
<p>当实现java.io.Serializable接口的实体（类）没有显式地定义一个名为serialVersionUID，类型为long的变量时，Java序列化机制会根据编译的class自动生成一个serialVersionUID作序列化版本比较用，这种情况下，只有同一次编译生成的class才会生成相同的serialVersionUID 。  </p>
<p>如果我们不希望通过编译来强制划分软件版本，即实现序列化接口的实体能够兼容先前版本，未作更改的类，就需要显式地定义一个名为serialVersionUID，类型为long的变量，不修改这个变量值的序列化实体都可以相互进行串行化和反串行化。</p>
<p>清单 1. 相同功能代码不同序列化 ID 的类对比<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">package com.inout; </div><div class="line"></div><div class="line"> import java.io.Serializable; </div><div class="line"></div><div class="line"> public class A implements Serializable &#123; </div><div class="line"></div><div class="line">	 private static final long serialVersionUID = 1L; </div><div class="line"></div><div class="line">	 private String name; </div><div class="line">	</div><div class="line">	 public String getName() </div><div class="line">	 &#123; </div><div class="line">		 return name; </div><div class="line">	 &#125; </div><div class="line">	</div><div class="line">	 public void setName(String name) </div><div class="line">	 &#123; </div><div class="line">		 this.name = name; </div><div class="line">	 &#125; </div><div class="line"> &#125; </div><div class="line"></div><div class="line"> package com.inout; </div><div class="line"></div><div class="line"> import java.io.Serializable; </div><div class="line"></div><div class="line"> public class A implements Serializable &#123; </div><div class="line"></div><div class="line">	 private static final long serialVersionUID = 2L; </div><div class="line">	</div><div class="line">	 private String name; </div><div class="line">	</div><div class="line">	 public String getName() </div><div class="line">	 &#123; </div><div class="line">		 return name; </div><div class="line">	 &#125; </div><div class="line">	</div><div class="line">	 public void setName(String name) </div><div class="line">	 &#123; </div><div class="line">		 this.name = name; </div><div class="line">	 &#125; </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>序列化 ID 在 Eclipse 下提供了两种生成策略，一个是固定的 1L，一个是随机生成一个不重复的 long 类型数据（实际上是使用 JDK 工具生成），在这里有一个建议，如果没有特殊需求，就是用默认的 1L 就可以，这样可以确保代码一致时反序列化成功。那么随机生成的序列化 ID 有什么作用呢，有些时候，通过改变序列化 ID 可以用来限制某些用户的使用。  </p>
<h4 id="特性使用案例"><a href="#特性使用案例" class="headerlink" title="特性使用案例"></a>特性使用案例</h4><p>读者应该听过 Façade 模式，它是为应用程序提供统一的访问接口，案例程序中的 Client 客户端使用了该模式，案例程序结构图如图 1 所示。<br><img src="http://www.ibm.com/developerworks/cn/java/j-lo-serial/image003.gif" alt="image"><br>Client 端通过 Façade Object 才可以与业务逻辑对象进行交互。而客户端的 Façade Object 不能直接由 Client 生成，而是需要 Server 端生成，然后序列化后通过网络将二进制对象数据传给 Client，Client 负责反序列化得到 Façade 对象。该模式可以使得 Client 端程序的使用需要服务器端的许可，同时 Client 端和服务器端的 Façade Object 类需要保持一致。当服务器端想要进行版本更新时，只要将服务器端的 Façade Object 类的序列化 ID 再次生成，当 Client 端反序列化 Façade Object 就会失败，也就是强制 Client 端从服务器端获取最新程序。</p>
<h3 id="静态变量序列化"><a href="#静态变量序列化" class="headerlink" title="静态变量序列化"></a>静态变量序列化</h3><p>清单 2. 静态变量序列化问题代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class Test implements Serializable &#123;</div><div class="line"></div><div class="line">	private static final long serialVersionUID = 1L;</div><div class="line"></div><div class="line">	public static int staticVar = 5;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		try &#123;</div><div class="line">			//初始时staticVar为5</div><div class="line">			ObjectOutputStream out = new ObjectOutputStream(</div><div class="line">					new FileOutputStream(&quot;result.obj&quot;));</div><div class="line">			out.writeObject(new Test());</div><div class="line">			out.close();</div><div class="line"></div><div class="line">			//序列化后修改为10</div><div class="line">			Test.staticVar = 10;</div><div class="line"></div><div class="line">			ObjectInputStream oin = new ObjectInputStream(new FileInputStream(</div><div class="line">					&quot;result.obj&quot;));</div><div class="line">			Test t = (Test) oin.readObject();</div><div class="line">			oin.close();</div><div class="line">			</div><div class="line">			//再读取，通过t.staticVar打印新的值</div><div class="line">			System.out.println(t.staticVar);</div><div class="line">			</div><div class="line">		&#125; catch (FileNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; catch (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; catch (ClassNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>清单 2 中的 main 方法，将对象序列化后，修改静态变量的数值，再将序列化对象读取出来，然后通过读取出来的对象获得静态变量的数值并打印出来。依照清单 2，这个 System.out.println(t.staticVar) 语句输出的是 10 还是 5 呢？</p>
<p>最后的输出是 10，对于无法理解的读者认为，打印的 staticVar 是从读取的对象里获得的，应该是保存时的状态才对。之所以打印 10 的原因在于序列化时，并不保存静态变量，这其实比较容易理解，<strong>序列化保存的是对象的状态，静态变量属于类的状态</strong>，因此 序列化并不保存静态变量。</p>
<h3 id="父类的序列化与-Transient-关键字"><a href="#父类的序列化与-Transient-关键字" class="headerlink" title="父类的序列化与 Transient 关键字"></a>父类的序列化与 Transient 关键字</h3><p>情境：一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable 接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。  </p>
<p>解决：要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就 需要有默认的无参的构造函数。在父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都是默认声明的值，如 int 型的默认是 0，string 型的默认是 null。  </p>
<p>Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。 </p>
<h4 id="特性使用案例-1"><a href="#特性使用案例-1" class="headerlink" title="特性使用案例"></a>特性使用案例</h4><p>我们熟悉使用 Transient 关键字可以使得字段不被序列化，那么还有别的方法吗？根据父类对象序列化的规则，我们可以将不需要被序列化的字段抽取出来放到父类中，子类实现 Serializable 接口，父类不实现，根据父类序列化规则，父类的字段数据将不被序列化，形成类图如图 2 所示。<br><img src="http://www.ibm.com/developerworks/cn/java/j-lo-serial/image005.gif" alt="image"><br>上图中可以看出，attr1、attr2、attr3、attr5 都不会被序列化，放在父类中的好处在于当有另外一个 Child 类时，attr1、attr2、attr3 依然不会被序列化，不用重复抒写 transient，代码简洁。   </p>
<h3 id="对敏感字段加密"><a href="#对敏感字段加密" class="headerlink" title="对敏感字段加密"></a>对敏感字段加密</h3><p>情境：服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。    </p>
<p>解决：在序列化过程中，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。基于这个原理，可以在实际应用中得到使用，用于敏感字段的加密工作，清单 3 展示了这个过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">private static final long serialVersionUID = 1L;</div><div class="line"></div><div class="line">	private String password = &quot;pass&quot;;</div><div class="line"></div><div class="line">	public String getPassword() &#123;</div><div class="line">		return password;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setPassword(String password) &#123;</div><div class="line">		this.password = password;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private void writeObject(ObjectOutputStream out) &#123;</div><div class="line">		try &#123;</div><div class="line">			PutField putFields = out.putFields();</div><div class="line">			System.out.println(&quot;原密码:&quot; + password);</div><div class="line">			password = &quot;encryption&quot;;//模拟加密</div><div class="line">			putFields.put(&quot;password&quot;, password);</div><div class="line">			System.out.println(&quot;加密后的密码&quot; + password);</div><div class="line">			out.writeFields();</div><div class="line">		&#125; catch (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private void readObject(ObjectInputStream in) &#123;</div><div class="line">		try &#123;</div><div class="line">			GetField readFields = in.readFields();</div><div class="line">			Object object = readFields.get(&quot;password&quot;, &quot;&quot;);</div><div class="line">			System.out.println(&quot;要解密的字符串:&quot; + object.toString());</div><div class="line">			password = &quot;pass&quot;;//模拟解密,需要获得本地的密钥</div><div class="line">		&#125; catch (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; catch (ClassNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		try &#123;</div><div class="line">			ObjectOutputStream out = new ObjectOutputStream(</div><div class="line">					new FileOutputStream(&quot;result.obj&quot;));</div><div class="line">			out.writeObject(new Test());</div><div class="line">			out.close();</div><div class="line"></div><div class="line">			ObjectInputStream oin = new ObjectInputStream(new FileInputStream(</div><div class="line">					&quot;result.obj&quot;));</div><div class="line">			Test t = (Test) oin.readObject();</div><div class="line">			System.out.println(&quot;解密后的字符串:&quot; + t.getPassword());</div><div class="line">			oin.close();</div><div class="line">		&#125; catch (FileNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; catch (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; catch (ClassNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在清单 3 的 writeObject 方法中，对密码进行了加密，在 readObject 中则对 password 进行解密，只有拥有密钥的客户端，才可以正确的解析出密码，确保了数据的安全。执行清单 3 后控制台输出如图 3 所示。<br><img src="http://www.ibm.com/developerworks/cn/java/j-lo-serial/image007.jpg" alt="image">    </p>
<h4 id="特性使用案例-2"><a href="#特性使用案例-2" class="headerlink" title="特性使用案例"></a>特性使用案例</h4><p>RMI 技术是完全基于 Java 序列化技术的，服务器端接口调用所需要的参数对象来至于客户端，它们通过网络相互传输。这就涉及 RMI 的安全传输的问题。一些敏感的字段，如用户名密码（用户登录时需要对密码进行传输），我们希望对其进行加密，这时，就可以采用本节介绍的方法在客户端对密码进行加密，服务器端进行解密，确保数据传输的安全性。</p>
<h3 id="序列化存储规则"><a href="#序列化存储规则" class="headerlink" title="序列化存储规则"></a>序列化存储规则</h3><p>清单 4. 存储规则问题代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">ObjectOutputStream out = new ObjectOutputStream(</div><div class="line">					new FileOutputStream(&quot;result.obj&quot;));</div><div class="line">Test test = new Test();</div><div class="line">//试图将对象两次写入文件</div><div class="line">out.writeObject(test);</div><div class="line">out.flush();</div><div class="line">System.out.println(new File(&quot;result.obj&quot;).length());</div><div class="line">out.writeObject(test);</div><div class="line">out.close();</div><div class="line">System.out.println(new File(&quot;result.obj&quot;).length());</div><div class="line"></div><div class="line">ObjectInputStream oin = new ObjectInputStream(new FileInputStream(</div><div class="line">		&quot;result.obj&quot;));</div><div class="line">//从文件依次读出两个文件</div><div class="line">Test t1 = (Test) oin.readObject();</div><div class="line">Test t2 = (Test) oin.readObject();</div><div class="line">oin.close();</div><div class="line">		</div><div class="line">//判断两个引用是否指向同一个对象</div><div class="line">System.out.println(t1 == t2);</div></pre></td></tr></table></figure></p>
<p>清单 4 中对同一对象两次写入文件，打印出写入一次对象后的存储大小和写入两次后的存储大小，然后从文件中反序列化出两个对象，比较这两个对象是否为同一对象。一般的思维是，两次写入对象，文件大小会变为两倍的大小，反序列化时，由于从文件读取，生成了两个对象，判断相等时应该是输入 false 才对，但是最后结果输出如图 4 所示。<br><img src="http://www.ibm.com/developerworks/cn/java/j-lo-serial/image009.jpg" alt="image"><br>我们看到，第二次写入对象时文件只增加了 5 字节，并且两个对象是相等的，这是为什么呢？    </p>
<p>解答：Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用，上面增加的 5 字节的存储空间就是新增引用和一些控制信息的空间。反序列化时，恢复引用关系，使得清单 3 中的 t1 和 t2 指向唯一的对象，二者相等，输出 true。该存储规则极大的节省了存储空间。</p>
<h4 id="特性案例分析"><a href="#特性案例分析" class="headerlink" title="特性案例分析"></a>特性案例分析</h4><p>清单 5. 案例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;result.obj&quot;));</div><div class="line">Test test = new Test();</div><div class="line">test.i = 1;</div><div class="line">out.writeObject(test);</div><div class="line">out.flush();</div><div class="line">test.i = 2;</div><div class="line">out.writeObject(test);</div><div class="line">out.close();</div><div class="line">ObjectInputStream oin = new ObjectInputStream(new FileInputStream(</div><div class="line">					&quot;result.obj&quot;));</div><div class="line">Test t1 = (Test) oin.readObject();</div><div class="line">Test t2 = (Test) oin.readObject();</div><div class="line">System.out.println(t1.i);</div><div class="line">System.out.println(t2.i);</div></pre></td></tr></table></figure></p>
<p>清单 5 的目的是希望将 test 对象两次保存到 result.obj 文件中，写入一次以后修改对象属性值再次保存第二次，然后从 result.obj 中再依次读出两个对象，输出这两个对象的 i 属性值。案例代码的目的原本是希望一次性传输对象修改前后的状态。<br>结果两个输出的都是 1， 原因就是第一次写入对象以后，第二次再试图写的时候，虚拟机根据引用关系知道已经有一个相同对象已经写入文件，因此只保存第二次写的引用，所以读取时，都是第一次保存的对象。读者在使用一个文件多次 writeObject 需要特别注意这个问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/基础/序列化和反序列化/" data-id="cjei8qk4x004j6gblxivh3g1i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/基础/类加载机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/基础/类加载机制/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/基础/类加载机制/">类加载机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被直接使用的java类型，这就是虚拟机的类加载机制。<br>类的生命周期包括<strong>加载（Loading）</strong>、<strong>验证（Verification）</strong>、<strong>准备（Preparation）</strong>、<strong>解析（Resolution）</strong>、<strong>初始化（Initialization）</strong>、<strong>使用（Using）</strong>、<strong>卸载（Unloading）</strong>等七个阶段，其中<strong>验证、准备和解析三个部分统称为连接（Linking）</strong>。而<strong>类的加载指的就是从加载到初始化这五个阶段</strong>。    </p>
<p>虚拟机规范对于何时进行加载这一阶段并没有强制约束，但对于初始化阶段，虚拟机规范是严格规定了有且只有四种情况必须立即对类进行初始化：</p>
<ol>
<li>遇到new,getstatic,putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指定的场景是：使用new关键字实例化对象，读取或设置一个类的静态字段以及调用一个类的静态方法的时候。当然，被final修饰并在编译期就把结果放入常量池的静态字段不属于这些场景，这类静态字段的值在编译期时就会被编译器优化而直接放入常量池，其引用直接指向其在常量池的入口。</li>
<li>使用java.lang.reflect包的方法对类进行反射调用时，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的类），虚拟机会先初始化这个主类。</li>
<li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic，REF_putStatic，REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ol>
<p>以上四种场景中的行为称为对一个类进行主动引用，除此之外所有引用类的方式都不会触发初始化，称为被动引用。<br>接口的加载过程与类加载过程最主要的区别在于第三点，即当一个类在初始化时，要求其父类全部都已经初始化过了，但是当初始化一个接口时，并不需要先初始化其父接口，而是只有真正使用到父接口中的字段的时候才会初始化。</p>
<h3 id="类加载的各个阶段"><a href="#类加载的各个阶段" class="headerlink" title="类加载的各个阶段"></a>类加载的各个阶段</h3><h5 id="一个简单的类加载过程："><a href="#一个简单的类加载过程：" class="headerlink" title="一个简单的类加载过程："></a>一个简单的类加载过程：</h5><ol>
<li>寻找jre目录，寻找jvm.dll，并初始化JVM；</li>
<li>产生一个Bootstrap Loader（启动类加载器）；</li>
<li>Bootstrap Loader自动加载Extended Loader（标准扩展类加载器），并将其父Loader设为Bootstrap Loader。</li>
<li>Bootstrap Loader自动加载AppClassLoader（系统类加载器），并将其父Loader设为Extended Loader。</li>
<li>最后由AppClassLoader加载HelloWorld类。</li>
</ol>
<h5 id="类记载目录："><a href="#类记载目录：" class="headerlink" title="类记载目录："></a>类记载目录：</h5><ol>
<li>Bootstrap ClassLoader : 将存放于<java_home>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar 名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用</java_home></li>
<li>Extension ClassLoader : 将<java_home>\lib\ext目录下的，或者被java.ext.dirs系统变量所指定的路径中的所有类库加载。开发者可以直接使用扩展类加载器。</java_home></li>
<li>Application ClassLoader : 负责加载用户类路径(ClassPath)上所指定的类库,开发者可直接使用。</li>
</ol>
<p>ExtClassLoader和AppClassLoader在JVM启动后，会在JVM中保存一份，并且在程序运行中无法改变其搜索路径。如果想在运行时从其他搜索路径加载类，就要产生新的类加载器。</p>
<h5 id="类记载器特点："><a href="#类记载器特点：" class="headerlink" title="类记载器特点："></a>类记载器特点：</h5><ol>
<li>运行一个程序时，总是由AppClassLoader（系统类加载器）开始加载指定的类。</li>
<li>在加载类时，每个类加载器会将加载任务上交给其父，如果其父找不到，再由自己去加载。</li>
<li>Bootstrap Loader（启动类加载器）是最顶级的类加载器了，其父加载器为null.</li>
</ol>
<h5 id="类加载有三种方式："><a href="#类加载有三种方式：" class="headerlink" title="类加载有三种方式："></a>类加载有三种方式：</h5><ol>
<li>命令行启动应用时候由JVM初始化加载</li>
<li>通过Class.forName()方法动态加载</li>
<li>通过ClassLoader.loadClass()方法动态加载</li>
</ol>
<p>三种方式区别比较大，看个例子就明白了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class HelloWorld &#123; </div><div class="line">        public static void main(String[] args) throws ClassNotFoundException &#123; </div><div class="line">                ClassLoader loader = HelloWorld.class.getClassLoader(); </div><div class="line">                System.out.println(loader); </div><div class="line">                //使用ClassLoader.loadClass()来加载类，不会执行初始化块 </div><div class="line">                loader.loadClass(&quot;Test2&quot;); </div><div class="line">                //使用Class.forName()来加载类，默认会执行初始化块 </div><div class="line">                //Class.forName(&quot;Test2&quot;); </div><div class="line">                //使用Class.forName()来加载类，并指定ClassLoader，参数2设置为false时初始化时不执行静态块，设置为true时初始化时执行静态块</div><div class="line">                //Class.forName(&quot;Test2&quot;, false, loader); </div><div class="line">        &#125; </div><div class="line">&#125;</div><div class="line"> </div><div class="line">public class Test2 &#123; </div><div class="line">        static &#123; </div><div class="line">                System.out.println(&quot;静态初始化块执行了！&quot;); </div><div class="line">        &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有关ClassLoader还有很重要一点：<br><strong>同一个ClassLoader加载的类文件，只有一个Class实例。但是，如果同一个类文件被不同的ClassLoader载入，则会有两份不同的Class实例</strong>（前提是着两个类加载器不能用相同的父类加载器）。</p>
<p>以下对类加载的各个阶段进行简单的说明。  </p>
<ul>
<li><strong>加载阶段</strong>，虚拟机需要完成三件事：<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li><strong>在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口</strong>。</li>
</ol>
</li>
<li><strong>验证阶段</strong>，不同虚拟机会进行不同类验证的实现，但大致都会完成以下四个阶段的检验过程：文件格式验证（验证字节流是否符合Class文件格式的规范，并能被当前版本的虚拟机处理），元数据验证（对字节码描述信息进行语义分析，保证其描述信息符合java语言规范），字节码验证（对类方法体进行数据流和控制流分析，保证类的方法在运行时不会做出危害虚拟机的行为）和符号引用验证（发生在将符号引用转化为直接引用的时候，在解析阶段中发生）。</li>
<li><strong>准备阶段</strong>，正式为类成员变量（被static修饰的变量）（注意，不是实例成员变量，实例变量会在对象实例化时随着对象一起分配在java堆上）分配内存并设置类变量初始值（通常情况下是数据类型的零值，不进行赋值操作）的阶段，这些内存都将在方法区中进行分配。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例：public static int value=123;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>则在准备阶段过后，value的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<client>()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。</client></p>
<ul>
<li><strong>解析阶段</strong>，虚拟机将常量池内的符号引用替换为直接引用的过程。符号引用与内存布局无关，而直接引用的目标必定已经在内存中存在。<strong>解析动作主要针对类或接口、字段、类方法、接口方法，方法类型，方法句柄和调用限定符号期类符号引用进行</strong>。</li>
<li><strong>初始化阶段</strong>，真正开始执行类中定义的java程序代码（字节码），是执行类构造器<clinit>()方法的过程。</clinit></li>
</ul>
<p><clinit>()方法的一些特点：</clinit></p>
<ol>
<li><p><clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static｛｝）中的语句合并产生的，编译器收集顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</clinit></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public Class test &#123;</div><div class="line">    static &#123;</div><div class="line">        i = 0; //给变量赋值可以正常编译通过</div><div class="line">        System.out.println(i); //这句编译器会提示“非法向前引用”</div><div class="line">    &#125;</div><div class="line">    static int i = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><clinit>()方法与类的构造函数（或者说实例构造器<init>()方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前完成父类<clinit>()方法的执行。因此在虚拟机中第一个被执行的<client>()方法的类肯定是java.lang.Object。   </client></clinit></clinit></init></clinit></p>
</li>
<li>由于父类的<clinit>() 方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作</clinit></li>
<li><p><clinit>()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，则编译器可以不为这个类生成<clinit>()方法。   </clinit></clinit></p>
</li>
<li><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法，不同于类的地方是执行接口的<clinit>()方法时不需要先执行父类的<clinit>()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<client>()方法。</client></clinit></clinit></clinit></p>
</li>
<li><p>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，则只有一个线程去执行这个类的<clinit>()方法，其它线程阻塞等待，直到活动线程执行<clinit>()方法完毕。 如果在一个类的<client>()方法中有耗时很长的操作，就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</client></clinit></clinit></clinit></p>
<p> 需要注意的是，其他线程虽然会被阻塞，但如果执行<client>()方法的那条线程退出<client>()方法后，其他线程唤醒之后不会再次进入<client>()方法。同一个类加载器下，一个类型只会初始化一次。</client></client></client></p>
</li>
</ol>
<p>了解完各个类加载机制的阶段后，我们需要进一步了解类加载器这个概念。类加载器只用于实现类的加载动作，即实现通过一个类的全限定名来获取描述此类的二进制字节流。<strong>但对于类来说，要判断两个类是否相等（instanceof，equal），其前提是两个类是由同一个类加载器所加载，否则，无论两个类是否来源于同一个Class文件，这两个类都必定不等，亦即是说，对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在java虚拟机的唯一性。</strong>  </p>
<p>在Java开发人员看来，类加载器可划分为以下三类系统提供的类加载器：启动类加载器（Boostrap ClassLoader，负责将存放在<java_home>\lib目录中的类库加载到虚拟机内存中，其无法被Java程序直接引用），扩展类加载器（Extension ClassLoader，由sun.misc.Launcher$ExtClassLoader实现，负责加载<java_home>\lib\ext目录中的类库，可被开发者直接使用），应用程序类加载器（由sun.misc.Launcher$AppClassLoader来实现，负责加载用户类路径（ClassPath）上指定的类库，可被开发者直接使用，且为默认的类加载器）。  </java_home></java_home></p>
<p>java中采用<strong>双亲委派模型</strong>（Parents Delegation Model）来实现类的加载模式。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，此处的父子关系不以继承来实现，而是采用组合来利用父加载器。    </p>
<p>双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会自己去加载。</p>
<p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个成为java.lang.Object的类，并放在程序的ClassPath之中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证。</p>
<p>其模型如下图所示：<br><img src="http://note.youdao.com/yws/public/resource/ee75e4361b58214a36b4d854bbd3faf1/xmlnote/EEE7B3274550464AB506A63343F42905/7749" alt="image">    </p>
<h3 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h3><p>了解了以上类文件结构和类加载机制后，我们最后再来看看字节码在虚拟机中是如何被执行的。  </p>
<p>不同的虚拟机实现时硕，执行引擎在执行Java执行的时候可能有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备，甚至可能包含几个不同级别的编译器执行引擎。  </p>
<p>在具体了解虚拟机是如何执行字节码之前，我们先来从概念上理解虚拟机是如何执行程序的。程序的执行可以直接解释为是对方法的递归调用，通过一连串的方法链来最终得出执行结果，亦即是说虚拟机对程序的执行，根本上是对方法的调用和执行。</p>
<p>栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表（最小单位为变量槽Variable Slot）、操作数栈、动态连接和方法返回地址等信息，每一个方法从调用开始到执行完成的过程，就对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。栈帧的内容在编译时就已经完成确定，不受程序运行期变量数据的影响，仅取决于具体的虚拟机实现。    </p>
<p>前面说了，对程序的执行就是对方法链的调用和执行，即可能会出现很多方法同时处于执行状态，此时对于执行引擎来说，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，其关联的方法称为当前方法，执行引擎所运行的所有字节码指令只针对当前栈帧进行操作。    </p>
<p>方法调用包含两种方法：<strong>解析和分派</strong>。解析调用一定是个静态过程，在编译期间完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。而分派调用则可能是动态的也可能是静态的，根据分派依据的宗量数可分为单分派和多分派。（具体情形请参考《深入理解java虚拟机》这本书第8章）</p>
<p>方法执行即是指字节码解释执行引擎，包括解释执行和编译执行。而java编译器输出的指令流，基本上是一种基于栈的指令集架构。即Java虚拟机采用的是基于栈的字节码执行引擎。（具体情形请参考《深入理解java虚拟机》这本书第8章）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/基础/类加载机制/" data-id="cjei8qk4y004k6gbl0a5gi7q2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器相关/redis/redis快速的几个原因" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/服务器相关/redis/redis快速的几个原因/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/服务器相关/redis/redis快速的几个原因/">redis快速的几个原因</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>总体来说快速的原因如下：        </p>
<ol>
<li>绝大部分请求是纯粹的内存操作（非常快速）   </li>
<li>采用单线程,避免了不必要的上下文切换和竞争条件   </li>
<li>非阻塞IO  </li>
</ol>
<p>内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间</p>
<p>这3个条件不是相互独立的，特别是第一条，如果请求都是耗时的，采用单线程吞吐量及性能可想而知了。应该说redis为特殊的场景选择了合适的技术方案。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/服务器相关/redis/redis快速的几个原因/" data-id="cjei8qka400ep6gblxb3hd788" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器相关/redis/Redis集群" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/服务器相关/redis/Redis集群/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/服务器相关/redis/Redis集群/">Redis集群</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Redis集群介绍"><a href="#Redis集群介绍" class="headerlink" title="Redis集群介绍"></a>Redis集群介绍</h3><p>Redis 集群是一个提供在<strong>多个Redis间节点间共享数据</strong>的程序集。 </p>
<p>Redis集群并不支持处理多个keys的命令,因为这需要在不同的节点间移动数据,从而达不到像Redis那样的性能,在高负载的情况下可能会导致不可预料的错误.  </p>
<p>Redis 集群通过分区来提供<strong>一定程度的可用性</strong>,在实际环境中当某个节点宕机或者不可达的情况下继续处理命令. Redis 集群的优势:</p>
<ul>
<li>自动分割数据到不同的节点上。</li>
<li>整个集群的部分节点失败或者不可达的情况下能够继续处理命令。</li>
</ul>
<h3 id="Redis-集群的数据分片"><a href="#Redis-集群的数据分片" class="headerlink" title="Redis 集群的数据分片"></a>Redis 集群的数据分片</h3><p>Redis 集群没有使用一致性hash, 而是引入了 <strong>哈希槽</strong>的概念.</p>
<p>Redis 集群有<strong>16384</strong>个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽,举个例子,比如当前集群有3个节点,那么:</p>
<ul>
<li>节点 A 包含 0 到 5500号哈希槽.</li>
<li>节点 B 包含5501 到 11000 号哈希槽.</li>
<li>节点 C 包含11001 到 16384号哈希槽.</li>
</ul>
<p>这种结构很容易添加或者删除节点. 比如如果我想新添加个节点D, 我需要从节点 A, B, C中得部分槽到D上. 如果我像移除节点A,需要将A中得槽移到B和C节点上,然后将没有任何槽的A节点从集群中移除即可. 由于从一个节点将哈希槽移动到另一个节点并不会停止服务,所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态.</p>
<h3 id="Redis-集群的主从复制模型"><a href="#Redis-集群的主从复制模型" class="headerlink" title="Redis 集群的主从复制模型"></a>Redis 集群的主从复制模型</h3><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品.</p>
<p>在我们例子中具有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用.</p>
<p>然而如果在集群创建的时候（或者过一段时间）我们为每个节点添加一个从节点A1，B1，C1,那么整个集群便有三个master节点和三个slave节点组成，这样在节点B失败后，集群便会选举B1为新的主节点继续服务，整个集群便不会因为槽找不到而不可用了</p>
<p>不过当B和B1 都失败后，集群是不可用的.</p>
<h3 id="Redis-一致性保证"><a href="#Redis-一致性保证" class="headerlink" title="Redis 一致性保证"></a>Redis 一致性保证</h3><p>Redis 并不能保证数据的<strong>强一致性</strong>. 这意味这在实际中集群在特定的条件下可能会丢失写操作.</p>
<p>第一个原因是因为集群是用了异步复制. 写操作过程:</p>
<ol>
<li>客户端向主节点B写入一条命令.</li>
<li>主节点B向客户端回复命令状态.</li>
<li>主节点将写操作复制给他得从节点 B1, B2 和 B3.</li>
</ol>
<p>主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。 注意：Redis 集群可能会在将来提供同步写的方法。 Redis 集群另外一种可能会丢失命令的情况是集群出现了网络分区， 并且一个客户端与至少包括一个主节点在内的少数实例被孤立。</p>
<p>举个例子 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点， 其中 A 、B 、C 为主节点， A1 、B1 、C1 为A，B，C的从节点， 还有一个客户端 Z1 假设集群中发生网络分区，那么集群可能会分为两方，大部分的一方包含节点 A 、C 、A1 、B1 和 C1 ，小部分的一方则包含节点 B 和客户端 Z1 .</p>
<p>Z1仍然能够向主节点B中写入, 如果网络分区发生时间较短,那么集群将会继续正常运作,如果分区的时间足够让大部分的一方将B1选举为新的master，那么Z1写入B中得数据便丢失了.</p>
<p>注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项</p>
<h3 id="搭建并使用Redis集群"><a href="#搭建并使用Redis集群" class="headerlink" title="搭建并使用Redis集群"></a>搭建并使用Redis集群</h3><p>搭建集群的第一件事情我们需要一些运行在 集群模式的Redis实例. 这意味这集群并不是由一些普通的Redis实例组成的，集群模式需要通过配置启用，开启集群模式后的Redis实例便可以使用集群特有的命令和特性了.<br>下面是一个最少选项的集群的配置文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">port 7000</div><div class="line">cluster-enabled yes</div><div class="line">cluster-config-file nodes.conf</div><div class="line">cluster-node-timeout 5000</div><div class="line">appendonly yes</div></pre></td></tr></table></figure></p>
<p>文件中的 cluster-enabled 选项用于开实例的集群模式， 而 cluster-conf-file 选项则设定了保存节点配置文件的路径， 默认值为 nodes.conf.节点配置文件无须人为修改， 它由 Redis 集群在启动时创建， 并在有需要时自动进行更新。 </p>
<p>要让集群正常运作至少需要三个主节点，不过在刚开始试用集群功能时， 强烈建议使用六个节点： 其中三个为主节点， 而其余三个则是各个主节点的从节点。</p>
<p>首先， 让我们进入一个新目录， 并创建六个以端口号为名字的子目录， 稍后我们在将每个目录中运行一个 Redis 实例：  命令如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir cluster-test</div><div class="line">cd cluster-test</div><div class="line">mkdir 7000 7001 7002 7003 7004 7005</div></pre></td></tr></table></figure></p>
<p>在文件夹 7000 至 7005 中， 各创建一个 redis.conf 文件， 文件的内容可以使用上面的示例配置文件， 但记得将配置中的端口号从 7000 改为与文件夹名字相同的号码,并且nodes.conf的文件名也要相应调整，如nodes-7000.conf。</p>
<p>启动6个集群示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/Cellar/redis/3.2.8/bin</div><div class="line">1./usr/local/Cellar/redis/3.2.8/cluster-test/7000/redis.conf</div><div class="line">2./usr/local/Cellar/redis/3.2.8/cluster-test/70010/redis.conf</div><div class="line">3./usr/local/Cellar/redis/3.2.8/cluster-test/7002/redis.conf</div><div class="line">4./usr/local/Cellar/redis/3.2.8/cluster-test/7003/redis.conf</div><div class="line">5./usr/local/Cellar/redis/3.2.8/cluster-test/7004/redis.conf</div><div class="line">6./usr/local/Cellar/redis/3.2.8/cluster-test/7005/redis.conf</div></pre></td></tr></table></figure></p>
<p>实例打印的日志显示， 因为 nodes.conf 文件不存在， 所以每个节点都为它自身指定了一个新的 ID ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[82462] 26 Nov 11:56:55.329 * No cluster configuration found, I&apos;m 97a3a64667477371c4479320d683e4c8db5858b1</div></pre></td></tr></table></figure></p>
<p>实例会一直使用同一个 ID ， 从而在集群中保持一个独一无二（unique）的名字。</p>
<h3 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h3><p>现在我们已经有了六个正在运行中的 Redis 实例， 接下来我们需要使用这些实例来创建集群， 并为每个节点编写配置文件。<br>通过使用 Redis 集群命令行工具 redis-trib ， 编写节点配置文件的工作可以非常容易地完成： redis-trib 位于 Redis 源码的 src 文件夹中， 它是一个 Ruby 程序， 这个程序通过向实例发送特殊命令来完成创建新集群， 检查集群， 或者对集群进行重新分片（reshared）等工作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 \</div><div class="line">127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</div></pre></td></tr></table></figure></p>
<p>这个命令在这里用于创建一个新的集群, 选项–replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。<br>之后跟着的其他参数则是这个集群实例的地址列表,3个master3个slave redis-trib 会打印出一份预想中的配置给你看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</div><div class="line">&gt;&gt;&gt; Creating cluster</div><div class="line">&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...</div><div class="line">Using 3 masters:</div><div class="line">127.0.0.1:7000</div><div class="line">127.0.0.1:7001</div><div class="line">127.0.0.1:7002</div><div class="line">Adding replica 127.0.0.1:7003 to 127.0.0.1:7000</div><div class="line">Adding replica 127.0.0.1:7004 to 127.0.0.1:7001</div><div class="line">Adding replica 127.0.0.1:7005 to 127.0.0.1:7002</div><div class="line">M: 83976d23ea61befbacc383aa03bd2da9f08fa7fa 127.0.0.1:7000</div><div class="line">   slots:0-5460 (5461 slots) master</div><div class="line">M: c2f4de6b29648599ade1d596b96838cdf559f397 127.0.0.1:7001</div><div class="line">   slots:5461-10922 (5462 slots) master</div><div class="line">M: 3e9798d73cc0685745c18cb15cf68c75c746e0a5 127.0.0.1:7002</div><div class="line">   slots:10923-16383 (5461 slots) master</div><div class="line">S: dfcad7da198267663734490dc876a7c072d186f1 127.0.0.1:7003</div><div class="line">   replicates 83976d23ea61befbacc383aa03bd2da9f08fa7fa</div><div class="line">S: d415630bb73d2df4ddbe8032ac3034756dff838c 127.0.0.1:7004</div><div class="line">   replicates c2f4de6b29648599ade1d596b96838cdf559f397</div><div class="line">S: ccda46a376b2a473ac596c80050b464ca9ba30d4 127.0.0.1:7005</div><div class="line">   replicates 3e9798d73cc0685745c18cb15cf68c75c746e0a5</div><div class="line">Can I set the above configuration? (type &apos;yes&apos; to accept):</div></pre></td></tr></table></figure></p>
<p>如果你觉得没问题的话， 就可以输入 yes ， redis-trib 就会将这份配置应用到集群当中,让各个节点开始互相通讯,最后可以得到如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">Can I set the above configuration? (type &apos;yes&apos; to accept): yes</div><div class="line">&gt;&gt;&gt; Nodes configuration updated</div><div class="line">&gt;&gt;&gt; Assign a different config epoch to each node</div><div class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</div><div class="line">Waiting for the cluster to join...</div><div class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)</div><div class="line">M: 83976d23ea61befbacc383aa03bd2da9f08fa7fa 127.0.0.1:7000</div><div class="line">   slots:0-5460 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: d415630bb73d2df4ddbe8032ac3034756dff838c 127.0.0.1:7004</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates c2f4de6b29648599ade1d596b96838cdf559f397</div><div class="line">M: c2f4de6b29648599ade1d596b96838cdf559f397 127.0.0.1:7001</div><div class="line">   slots:5461-10922 (5462 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: ccda46a376b2a473ac596c80050b464ca9ba30d4 127.0.0.1:7005</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates 3e9798d73cc0685745c18cb15cf68c75c746e0a5</div><div class="line">M: 3e9798d73cc0685745c18cb15cf68c75c746e0a5 127.0.0.1:7002</div><div class="line">   slots:10923-16383 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: dfcad7da198267663734490dc876a7c072d186f1 127.0.0.1:7003</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates 83976d23ea61befbacc383aa03bd2da9f08fa7fa</div><div class="line">[OK] All nodes agree about slots configuration.</div><div class="line">&gt;&gt;&gt; Check for open slots...</div><div class="line">&gt;&gt;&gt; Check slots coverage...</div><div class="line">[OK] All 16384 slots covered.</div></pre></td></tr></table></figure></p>
<p>这表示集群中的 16384 个槽都有至少一个主节点在处理， 集群运作正常。</p>
<p><strong>注意</strong>：如果脚本报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">custom_require.rb:36:in `require&apos;: cannot load such file -- redis (LoadError)</div><div class="line">from /usr/lib/ruby/1.9.1/rubygems/custom_require.rb:36:in `require&apos;</div><div class="line">from ./redis-trib.rb:25:in `&lt;main&gt;&apos;</div></pre></td></tr></table></figure></p>
<p>那么说明Ruby的redis接口没有安装，可以通过<code>sudo gem install redis</code>进行安装。</p>
<h3 id="Creating-a-Redis-Cluster-using-the-create-cluster-script"><a href="#Creating-a-Redis-Cluster-using-the-create-cluster-script" class="headerlink" title="Creating a Redis Cluster using the create-cluster script"></a>Creating a Redis Cluster using the create-cluster script</h3><p>If you don’t want to create a Redis Cluster by configuring and executing individual instances manually as explained above, there is a much simpler system (but you’ll not learn the same amount of operational details).</p>
<p>Just check utils/create-cluster directory in the Redis distribution. There is a script called create-cluster inside (same name as the directory it is contained into), it’s a simple bash script. In order to start a 6 nodes cluster with 3 masters and 3 slaves just type the following commands:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1. create-cluster start</div><div class="line">2. create-cluster create</div></pre></td></tr></table></figure></p>
<p>Reply to yes in step 2 when the redis-trib utility wants you to accept the cluster layout.<br>You can now interact with the cluster, the first node will start at port 30001 by default. When you are done, stop the cluster with:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">create-cluster stop</div></pre></td></tr></table></figure></p>
<p>Please read the README inside this directory for more information on how to run the script.</p>
<h3 id="使用集群"><a href="#使用集群" class="headerlink" title="使用集群"></a>使用集群</h3><p>Redis 集群现阶段的一个问题是客户端实现很少。<br>以下是一些我知道的实现：</p>
<ul>
<li><a href="https://github.com/antirez/redis-rb-cluster" target="_blank" rel="external">redis-rb-cluster</a> 是我（@antirez）编写的 Ruby 实现， 用于作为其他实现的参考。 该实现是对 redis-rb 的一个简单包装， 高效地实现了与集群进行通讯所需的最少语义（semantic）.</li>
<li><a href="https://github.com/Grokzen/redis-py-cluster" target="_blank" rel="external">redis-py-cluster</a> 看上去是 redis-rb-cluster 的一个 Python 版本， 这个项目有一段时间没有更新了（最后一次提交是在六个月之前）， 不过可以将这个项目用作学习集群的起点。</li>
<li>流行的 <a href="https://github.com/nrk/predis" target="_blank" rel="external">Predis</a> 曾经对早期的 Redis 集群有过一定的支持， 但我不确定它对集群的支持是否完整， 也不清楚它是否和最新版本的 Redis 集群兼容 （因为新版的 Redis 集群将槽的数量从 4k 改为 16k 了）.</li>
<li>使用最多的时java客户端, <a href="https://github.com/xetorthio/jedis" target="_blank" rel="external">Jedis</a> 最近添加了对集群的支持, 详细请查看项目README中Jedis Cluster部分.</li>
<li><a href="https://github.com/StackExchange/StackExchange.Redis" target="_blank" rel="external">StackExchange.Redis</a> 提供对 C# 的支持(并且包括大部分 .NET 下面的语言，比如： VB, F#等等)</li>
<li><a href="https://github.com/thunks/thunk-redis" target="_blank" rel="external">thunk-redis</a> 提供对 Node.js 和 io.js的支持。</li>
<li>Redis unstable 分支中的 redis-cli 程序实现了非常基本的集群支持， 可以使用命令 redis-cli -c 来启动。</li>
</ul>
<p>测试 Redis 集群比较简单的办法就是使用 redis-rb-cluster 或者 redis-cli ， 接下来我们将使用 redis-cli 为例来进行演示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -c -p 7000</div><div class="line">redis 127.0.0.1:7000&gt; set foo bar</div><div class="line">-&gt; Redirected to slot [12182] located at 127.0.0.1:7002</div><div class="line">OK</div><div class="line">redis 127.0.0.1:7002&gt; set hello world</div><div class="line">-&gt; Redirected to slot [866] located at 127.0.0.1:7000</div><div class="line">OK</div><div class="line">redis 127.0.0.1:7000&gt; get foo</div><div class="line">-&gt; Redirected to slot [12182] located at 127.0.0.1:7002</div><div class="line">&quot;bar&quot;</div><div class="line">redis 127.0.0.1:7000&gt; get hello</div><div class="line">-&gt; Redirected to slot [866] located at 127.0.0.1:7000</div><div class="line">&quot;world&quot;</div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>: 如果你是使用脚本创建的集群节点，那么默认端口可能是从30001开始。</p>
<p>redis-cli 对集群的支持是非常基本的， 所以它总是依靠 Redis 集群节点来将它转向（redirect）至正确的节点。一个真正的（serious）集群客户端应该做得比这更好： 它应该用缓存记录起哈希槽与节点地址之间的映射（map）， 从而直接将命令发送到正确的节点上面。这种映射只会在集群的配置出现某些修改时变化， 比如说， 在一次故障转移（failover）之后， 或者系统管理员通过添加节点或移除节点来修改了集群的布局（layout）之后， 诸如此类。</p>
<h3 id="使用redis-rb-cluster写一个例子"><a href="#使用redis-rb-cluster写一个例子" class="headerlink" title="使用redis-rb-cluster写一个例子"></a>使用redis-rb-cluster写一个例子</h3><p>在展示如何使用集群进行故障转移、重新分片等操作之前， 我们需要创建一个示例应用， 了解一些与 Redis 集群客户端进行交互的基本方法。  </p>
<p>在运行示例应用的过程中， 我们会尝试让节点进入失效状态， 又或者开始一次重新分片， 以此来观察 Redis 集群在真实世界运行时的表现， 并且为了让这个示例尽可能地有用， 我们会让这个应用向集群进行写操作。<br>本节将通过两个示例应用来展示 redis-rb-cluster 的基本用法， 以下是本节的第一个示例应用， 它是一个名为 example.rb 的文件， 包含在redis-rb-cluster 项目里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"> 1  require &apos;./cluster&apos;</div><div class="line"> 2</div><div class="line"> 3  startup_nodes = [</div><div class="line"> 4      &#123;:host =&gt; &quot;127.0.0.1&quot;, :port =&gt; 7000&#125;,</div><div class="line"> 5      &#123;:host =&gt; &quot;127.0.0.1&quot;, :port =&gt; 7001&#125;</div><div class="line"> 6  ]</div><div class="line"> 7  rc = RedisCluster.new(startup_nodes,32,:timeout =&gt; 0.1)</div><div class="line"> 8</div><div class="line"> 9  last = false</div><div class="line">10</div><div class="line">11  while not last</div><div class="line">12      begin</div><div class="line">13          last = rc.get(&quot;__last__&quot;)</div><div class="line">14          last = 0 if !last</div><div class="line">15      rescue =&gt; e</div><div class="line">16          puts &quot;error #&#123;e.to_s&#125;&quot;</div><div class="line">17          sleep 1</div><div class="line">18      end</div><div class="line">19  end</div><div class="line">20</div><div class="line">21  ((last.to_i+1)..1000000000).each&#123;|x|</div><div class="line">22      begin</div><div class="line">23          rc.set(&quot;foo#&#123;x&#125;&quot;,x)</div><div class="line">24          puts rc.get(&quot;foo#&#123;x&#125;&quot;)</div><div class="line">25          rc.set(&quot;__last__&quot;,x)</div><div class="line">26      rescue =&gt; e</div><div class="line">27          puts &quot;error #&#123;e.to_s&#125;&quot;</div><div class="line">28      end</div><div class="line">29      sleep 0.1</div><div class="line">30  &#125;</div></pre></td></tr></table></figure></p>
<p>这个应用所做的工作非常简单： 它不断地以 foo<number> 为键， number 为值， 使用 SET 命令向数据库设置键值对:</number></p>
<ul>
<li>SET foo0 0</li>
<li>SET foo1 1</li>
<li>SET foo2 2</li>
<li>And so forth…</li>
</ul>
<p>代码中的每个集群操作都使用一个 begin 和 rescue 代码块（block）包裹着， 因为我们希望在代码出错时， 将错误打印到终端上面， 而不希望应用因为异常（exception）而退出。</p>
<p>代码的第七行是代码中第一个有趣的地方， 它创建了一个 Redis 集群对象， 其中创建对象所使用的参数及其意义如下：第一个参数是记录了启动节点的 startup_nodes 列表， 列表中包含了两个集群节点的地址。第二个参数指定了对于集群中的各个不同的节点， Redis 集群对象可以获得的最大连接数 ，第三个参数 timeout 指定了一个命令在执行多久之后， 才会被看作是执行失败。</p>
<p>启动列表中并不需要包含所有集群节点的地址， 但这些地址中至少要有一个是有效的： 一旦 redis-rb-cluster 成功连接上集群中的某个节点时， 集群节点列表就会被自动更新， 任何真正的的集群客户端都应该这样做。</p>
<p>现在， 程序创建的 Redis 集群对象实例被保存到 rc 变量里面， 我们可以将这个对象当作普通 Redis 对象实例来使用。<br>在十一至十九行， 我们先尝试阅读计数器中的值， 如果计数器不存在的话， 我们才将计数器初始化为 0 ： 通过将计数值保存到 Redis 的计数器里面， 我们可以在示例重启之后， 仍然继续之前的执行过程， 而不必每次重启之后都从 foo0 开始重新设置键值对。为了让程序在集群下线的情况下， 仍然不断地尝试读取计数器的值， 我们将读取操作包含在了一个 while 循环里面， 一般的应用程序并不需要如此小心。</p>
<p>二十一至三十行是程序的主循环， 这个循环负责设置键值对， 并在设置出错时打印错误信息。程序在主循环的末尾添加了一个 sleep 调用， 让写操作的执行速度变慢， 帮助执行示例的人更容易看清程序的输出。执行 example.rb 程序将产生以下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ruby ./example.rb</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">^C (I stopped the program here)</div></pre></td></tr></table></figure></p>
<p>这个程序并不是十分有趣， 稍后我们就会看到一个更有趣的集群应用示例， 不过在此之前， 让我们先使用这个示例来演示集群的重新分片操作。</p>
<h3 id="集群重新分片"><a href="#集群重新分片" class="headerlink" title="集群重新分片"></a>集群重新分片</h3><p>现在， 让我们来试试对集群进行重新分片操作。在执行重新分片的过程中， 请让你的 example.rb 程序处于运行状态， 这样你就会看到， 重新分片并不会对正在运行的集群程序产生任何影响， 你也可以考虑将 example.rb 中的 sleep 调用删掉， 从而让重新分片操作在近乎真实的写负载下执行 重新分片操作基本上就是将某些节点上的哈希槽移动到另外一些节点上面， 和创建集群一样， 重新分片也可以使用 redis-trib 程序来执行 执行以下命令可以开始一次重新分片操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb reshard 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<p>你只需要指定集群中其中一个节点的地址， redis-trib 就会自动找到集群中的其他节点。<br>目前 redis-trib 只能在管理员的协助下完成重新分片的工作， 要让 redis-trib 自动将哈希槽从一个节点移动到另一个节点， 目前来说还做不到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">你想移动多少个槽( 从1 到 16384)?</div></pre></td></tr></table></figure></p>
<p>我们尝试从将100个槽重新分片， 如果 example.rb 程序一直运行着的话， 现在 1000 个槽里面应该有不少键了。<br>除了移动的哈希槽数量之外， redis-trib 还需要知道重新分片的目标， 也即是， 负责接收这 1000 个哈希槽的节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -p 7000 cluster nodes | grep myself</div><div class="line">97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5460</div></pre></td></tr></table></figure></p>
<p>我的目标节点是 97a3a64667477371c4479320d683e4c8db5858b1.<br>现在需要指定从哪些节点来移动keys到目标节点 我输入的是all ，这样就会从其他每个master上取一些哈希槽。<br>最后确认后你将会看到每个redis-trib移动的槽的信息，每个key的移动的信息也会打印出来        在重新分片的过程中，你的例子程序是不会受到影响的,你可以停止或者重新启动多次。<br>在重新分片结束后你可以通过如下命令检查集群状态:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb check 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<h3 id="一个更有趣的程序"><a href="#一个更有趣的程序" class="headerlink" title="一个更有趣的程序"></a>一个更有趣的程序</h3><p>我们在前面使用的示例程序 example.rb 并不是十分有趣， 因为它只是不断地对集群进行写入， 但并不检查写入结果是否正确。 比如说， 集群可能会错误地将 example.rb 发送的所有 SET 命令都改成了 SET foo 42 ， 但因为 example.rb 并不检查写入后的值， 所以它不会意识到集群实际上写入的值是错误的 因为这个原因， redis-rb-cluster 项目包含了一个名为 consistency-test.rb 的示例应用， 这个应用比起 example.rb 有趣得多： 它创建了多个计数器（默认为 1000 个）， 并通过发送 INCR 命令来增加这些计数器的值。</p>
<p>在增加计数器值的同时， consistency-test.rb 还执行以下操作： 每次使用 INCR 命令更新一个计数器时， 应用会记录下计数器执行 INCR 命令之后应该有的值。 举个例子， 如果计数器的起始值为 0 ， 而这次是程序第 50 次向它发送 INCR 命令， 那么计数器的值应该是 50 。</p>
<p>在每次发送 INCR 命令之前， 程序会随机从集群中读取一个计数器的值， 并将它与自己记录的值进行对比， 看两个值是否相同。</p>
<p>换句话说， 这个程序是一个一致性检查器（consistency checker）： 如果集群在执行 INCR 命令的过程中， 丢失了某条 INCR 命令， 又或者多执行了某条客户端没有确认到的 INCR 命令， 那么检查器将察觉到这一点 —— 在前一种情况中， consistency-test.rb 记录的计数器值将比集群记录的计数器值要大； 而在后一种情况中， consistency-test.rb 记录的计数器值将比集群记录的计数器值要小。</p>
<p>运行 consistency-test 程序将产生类似以下的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ ruby consistency-test.rb</div><div class="line">925 R (0 err) | 925 W (0 err) |</div><div class="line">5030 R (0 err) | 5030 W (0 err) |</div><div class="line">9261 R (0 err) | 9261 W (0 err) |</div><div class="line">13517 R (0 err) | 13517 W (0 err) |</div><div class="line">17780 R (0 err) | 17780 W (0 err) |</div><div class="line">22025 R (0 err) | 22025 W (0 err) |</div><div class="line">25818 R (0 err) | 25818 W (0 err) |</div></pre></td></tr></table></figure></p>
<p>结果展示了执行的读和 写,和错误(由于系统不可用而没有接受的查询发生的错误）的数量.<br>如果程序察觉了不一致的情况出现， 它将在输出行的末尾显式不一致的详细情况。比如说， 如果我们在 consistency-test.rb 运行的过程中， 手动修改某个计数器的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ redis 127.0.0.1:7000&gt; set key_217 0</div><div class="line">OK</div><div class="line"></div><div class="line">(in the other tab I see...)</div><div class="line"></div><div class="line">94774 R (0 err) | 94774 W (0 err) |</div><div class="line">98821 R (0 err) | 98821 W (0 err) |</div><div class="line">102886 R (0 err) | 102886 W (0 err) | 114 lost |</div><div class="line">107046 R (0 err) | 107046 W (0 err) | 114 lost |</div></pre></td></tr></table></figure></p>
<p>在我们修改计数器值的时候， 计数器的正确值是 114 （执行了 114 次 INCR 命令）， 因为我们将计数器的值设成了 0 ， 所以 consistency-test.rb 会向我们报告说丢失了 114 个 INCR 命令。<br>这个程序作为测试程序很有意思，所以我们用这个程序来测试故障恢复.</p>
<h3 id="测试故障转移"><a href="#测试故障转移" class="headerlink" title="测试故障转移"></a>测试故障转移</h3><p>在执行本节操作的过程中， 请一直运行 consistency-test 程序。 要触发一次故障转移， 最简单的办法就是令集群中的某个主节点进入下线状态。首先用以下命令列出集群中的所有主节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -p 7000 cluster nodes | grep master</div><div class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385482984082 0 connected 5960-10921</div><div class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 master - 0 1385482983582 0 connected 11423-16383</div><div class="line">97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422</div></pre></td></tr></table></figure></p>
<p>通过命令输出得知端口号为 7000 、 7001 和 7002 的节点都是主节点， 然后我们可以通过向端口号为7002 的主节点发送 <strong>DEBUG SEGFAULT</strong> 命令， 让这个主节点崩溃：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -p 7002 debug segfault</div><div class="line">Error: Server closed the connection</div></pre></td></tr></table></figure></p>
<p>现在，切换到运行着 consistency-test 的标签页， 可以看到， consistency-test 在 7002 下线之后的一段时间里将产生大量的错误警告信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">18849 R (0 err) | 18849 W (0 err) |</div><div class="line">23151 R (0 err) | 23151 W (0 err) |</div><div class="line">27302 R (0 err) | 27302 W (0 err) |</div><div class="line"></div><div class="line">... many error warnings here ...</div><div class="line"></div><div class="line">29659 R (578 err) | 29660 W (577 err) |</div><div class="line">33749 R (578 err) | 33750 W (577 err) |</div><div class="line">37918 R (578 err) | 37919 W (577 err) |</div><div class="line">42077 R (578 err) | 42078 W (577 err) |</div></pre></td></tr></table></figure></p>
<p>从 consistency-test 的这段输出可以看到， 集群在执行故障转移期间， 总共丢失了 578 个读命令和 577 个写命令， 但是并没有产生任何数据不一致。这听上去可能有点奇怪， 因为在教程的开头我们提到过， Redis 使用的是异步复制， 在执行故障转移期间， 集群可能会丢失写命令。但是在实际上， 丢失命令的情况并不常见， 因为 Redis 几乎是同时执行将命令回复发送给客户端， 以及将命令复制给从节点这两个操作， 所以实际上造成命令丢失的时间窗口是非常小的。不过， 尽管出现的几率不高， 但丢失命令的情况还是有可能会出现的， 所以我们对 Redis 集群不能提供强一致性的这一描述仍然是正确的。现在， 让我们使用 cluster nodes 命令,查看集群在执行故障转移操作之后， 主从节点的布局情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -p 7000 cluster nodes</div><div class="line">3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385503418521 0 connected</div><div class="line">a211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385503419023 0 connected</div><div class="line">97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422</div><div class="line">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385503419023 3 connected 11423-16383</div><div class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385503417005 0 connected 5960-10921</div><div class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385503418016 3 connected</div></pre></td></tr></table></figure></p>
<p>现在masters运行在 7000, 7001 和 7005端口上. 原来的master 7002现在变成了一个7005的一个从节点.<br>CLUSTER NODES 命令的输出看起来有点复杂,其实他非常的简单，含义如下:</p>
<ul>
<li>节点ID</li>
<li>IP:端口</li>
<li>标志: master, slave, myself, fail, …</li>
<li>如果是个从节点, 这里是它的主节点的NODE ID</li>
<li>集群最近一次向节点发送 PING 命令之后， 过去了多长时间还没接到回复。.</li>
<li>节点最近一次返回 PONG 回复的时间。</li>
<li>节点的配置纪元（configuration epoch）：详细信息请参考 Redis 集群规范 。</li>
<li>本节点的网络连接情况：例如 connected 。</li>
<li>节点目前包含的槽：例如 127.0.0.1:7001 目前包含号码为 5960 至 10921 的哈希槽。</li>
</ul>
<h3 id="手动故障转移"><a href="#手动故障转移" class="headerlink" title="手动故障转移"></a>手动故障转移</h3><p>有的时候在主节点没有任何问题的情况下强制手动故障转移也是很有必要的，比如想要升级主节点的Redis进程，我们可以通过故障转移将其转为slave再进行升级操作来避免对集群的可用性造成很大的影响。</p>
<p>Redis集群使用 <code>CLUSTER FAILOVER</code>命令来进行故障转移，不过要被转移的主节点的从节点上执行该命令 手动故障转移比主节点失败自动故障转移更加安全，因为手动故障转移时客户端的切换是在确保新的主节点完全复制了失败的旧的主节点数据的前提下下发生的，所以避免了数据的丢失。<br>执行手动故障转移时从节点日志如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># Manual failover user request accepted.</div><div class="line"># Received replication offset for paused master manual failover: 347540</div><div class="line"># All master replication stream processed, manual failover can start.</div><div class="line"># Start of election delayed for 0 milliseconds (rank #0, offset 347540).</div><div class="line"># Starting a failover election for epoch 7545.</div><div class="line"># Failover election won: I&apos;m the new master.</div></pre></td></tr></table></figure></p>
<p>其基本过程如下：客户端不再链接我们淘汰的主节点，同时主节点向从节点发送复制偏移量,从节点得到复制偏移量后故障转移开始,接着通知主节点进行配置切换,当客户端在旧的master上解锁后重新连接到新的主节点上。</p>
<h3 id="添加一个新节点"><a href="#添加一个新节点" class="headerlink" title="添加一个新节点"></a>添加一个新节点</h3><p>添加新的节点的基本过程就是添加一个空的节点然后移动一些数据给它，有两种情况，添加一个主节点和添加一个从节点（添加从节点时需要将这个新的节点设置为集群中某个节点的复制）<br>针对这两种情况，本节都会介绍，先从添加主节点开始.</p>
<p>两种情况第一步都是要添加 一个空的节点.<br>启动新的7006节点,使用的配置文件和以前的一样,只要把端口号改一下即可，过程如下:   </p>
<ul>
<li>在终端打开一个新的标签页.</li>
<li>进入cluster-test 目录.</li>
<li>创建并进入 7006文件夹.</li>
<li>和其他节点一样，创建redis.conf文件,需要将端口号改成7006.</li>
<li>最后启动节点 ../redis-server ./redis.conf</li>
<li>如果正常的话，节点会正确的启动.</li>
</ul>
<p>接下来使用redis-trib 来添加这个节点到现有的集群中去.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb add-node 127.0.0.1:7006 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<p>可以看到.使用<strong>addnode</strong>命令来添加节点，第一个参数是新节点的地址，第二个参数是任意一个已经存在的节点的IP和端口. 我们可以看到新的节点已经添加到集群中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:7006&gt; cluster nodes</div><div class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385543178575 0 connected 5960-10921</div><div class="line">3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385543179583 0 connected</div><div class="line">f093c80dde814da99c5cf72a7dd01590792b783b :0 myself,master - 0 0 0 connected</div><div class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543178072 3 connected</div><div class="line">a211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385543178575 0 connected</div><div class="line">97a3a64667477371c4479320d683e4c8db5858b1 127.0.0.1:7000 master - 0 1385543179080 0 connected 0-5959 10922-11422</div><div class="line">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385543177568 3 connected 11423-16383</div></pre></td></tr></table></figure></p>
<p>新节点现在已经连接上了集群， 成为集群的一份子， 并且可以对客户端的命令请求进行转向了， 但是和其他主节点相比， 新节点还有两点区别： </p>
<ul>
<li>新节点没有包含任何数据， 因为它没有包含任何哈希槽.</li>
<li>尽管新节点没有包含任何哈希槽， 但它仍然是一个主节点， 所以在集群需要将某个从节点升级为新的主节点时， 这个新节点不会被选中。</li>
</ul>
<p>接下来， 只要使用 redis-trib 程序， 将集群中的某些哈希桶移动到新节点里面， 新节点就会成为真正的主节点了。</p>
<h3 id="添加一个从节点"><a href="#添加一个从节点" class="headerlink" title="添加一个从节点"></a>添加一个从节点</h3><p>有两种方法添加从节点，可以像添加主节点一样使用redis-trib 命令，也可以像下面的例子一样使用 –slave选项:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb add-node --slave 127.0.0.1:7006 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<p>此处的命令和添加一个主节点命令类似，此处并没有指定添加的这个从节点的主节点，这种情况下系统会在其他的复制集中的主节点中随机选取一个作为这个从节点的主节点。<br>你可以通过下面的命令指定主节点:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb add-node --slave --master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7006 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<p>也可以使用CLUSTER REPLICATE 命令添加.这个命令也可以改变一个从节点的主节点。<br>例如，要给主节点 127.0.0.1:7005添加一个从节点，该节点哈希槽的范围1423-16383, 节点 ID 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e,我们需要链接新的节点（已经是空的主节点）并执行命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:7006&gt; cluster replicate 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</div></pre></td></tr></table></figure></p>
<p>我们新的从节点有了一些哈希槽，其他的节点也知道（过几秒后会更新他们自己的配置），可以使用如下命令确认:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -p 7000 cluster nodes | grep slave | grep 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</div><div class="line">f093c80dde814da99c5cf72a7dd01590792b783b 127.0.0.1:7006 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617702 3 connected</div><div class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617198 3 connected</div></pre></td></tr></table></figure></p>
<p>节点 3c3a0c… 有两个从节点， 7002 (已经存在的) 和 7006 (新添加的).</p>
<h3 id="移除一个节点"><a href="#移除一个节点" class="headerlink" title="移除一个节点"></a>移除一个节点</h3><p>只要使用 del-node 命令即可:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb del-node 127.0.0.1:7000 `&lt;node-id&gt;`</div></pre></td></tr></table></figure></p>
<p>第一个参数是任意一个节点的地址,第二个节点是你想要移除的节点地址。<br>使用同样的方法移除主节点,不过在移除主节点前，<strong>需要确保这个主节点是空的</strong>. 如果不是空的,需要将这个节点的数据重新分片到其他主节点上.</p>
<p>替代移除主节点的方法是手动执行故障恢复，被移除的主节点会作为一个从节点存在，不过这种情况下不会减少集群节点的数量，也需要重新分片数据.</p>
<h3 id="从节点的迁移"><a href="#从节点的迁移" class="headerlink" title="从节点的迁移"></a>从节点的迁移</h3><p>在Redis集群中会存在改变一个从节点的主节点的情况，需要执行如下命令 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CLUSTER REPLICATE &lt;master-node-id&gt;</div></pre></td></tr></table></figure></p>
<p>在特定的场景下，不需要系统管理员的协助下，自动将一个从节点从当前的主节点切换到另一个主节 的自动重新配置的过程叫做复制迁移（从节点迁移），从节点的迁移能够提高整个Redis集群的可用性.</p>
<p>你可以阅读（Redis集群规范）<a href="http://www.redis.cn/topics/cluster-spec.html" target="_blank" rel="external">/topics/cluster-spec</a>了解细节.</p>
<p>简短的概况一下从节点迁移</p>
<ul>
<li>集群会在有从节点数量最多的主节点上进行从节点的迁移.</li>
<li>要在一个主节点上添加多个从节点.</li>
<li>参数来控制从节点迁移 replica-migration-barrier:你可以仔细阅读redis.conf 。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/服务器相关/redis/Redis集群/" data-id="cjei8qka100ek6gblax56dezo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器相关/redis/5种数据结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/服务器相关/redis/5种数据结构/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/服务器相关/redis/5种数据结构/">5种数据结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <table>
<thead>
<tr>
<th>结构类型</th>
<th>存储结构的值</th>
<th>结构的读写能力</th>
</tr>
</thead>
<tbody>
<tr>
<td>STRING</td>
<td>可以是字符串，整数，或者浮点数</td>
<td>对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增（increment）或者自减（decrement）操作</td>
</tr>
<tr>
<td>LIST</td>
<td>一个链表，链表上的每个节点都包含了一个字符串</td>
<td>从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪（trim）；读取单个或者多个元素；根据值查找或者移除元素</td>
</tr>
<tr>
<td>SET</td>
<td>包含字符串的无序收集器（unordered collection），并且被包含的每个字符串都是独一无二，各不相同的</td>
<td>添加，获取，移除元素；检查一个元素是否存在于集合中；计算交集，并集，差集；从集合里面随机获取元素</td>
</tr>
<tr>
<td>HASH</td>
<td>包含键值对的无序散列表</td>
<td>添加，获取，移除单个键值对；获取所有的键值对</td>
</tr>
<tr>
<td>ZSET（有序集合）</td>
<td>字符串成员（member）与浮点数分值（score）之间的有序映射，元素的排列顺序由分值的大小决定</td>
<td>添加，获取，删除单个元素；根据分值范围（range）或者成员来获取元素</td>
</tr>
</tbody>
</table>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h5 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>get</td>
<td>get key-name 获取存储在给定键中的值</td>
</tr>
<tr>
<td>set</td>
<td>set key-name value 设置存储在给定键中的值</td>
</tr>
<tr>
<td>del</td>
<td>del  key-name 删除存储在给定键中的值</td>
</tr>
</tbody>
</table>
<h5 id="自增命令和自减命令"><a href="#自增命令和自减命令" class="headerlink" title="自增命令和自减命令"></a>自增命令和自减命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>incr</td>
<td>incr key-name 将键存储的值加上1</td>
</tr>
<tr>
<td>decr</td>
<td>decr key-name 将键存储的值减去1</td>
</tr>
<tr>
<td>incrby</td>
<td>incrby key-name amount 将键存储的值加上整数amount</td>
</tr>
<tr>
<td>decrby</td>
<td>将键存储的值减去整数amount</td>
</tr>
<tr>
<td>incrbyfloat</td>
<td>incrbyfloat key-name amount 将键存储的值加上浮点数amount，这个命令在Redis 2.6 或以上的版本可用</td>
</tr>
</tbody>
</table>
<h5 id="处理子串和二进制位的命令"><a href="#处理子串和二进制位的命令" class="headerlink" title="处理子串和二进制位的命令"></a>处理子串和二进制位的命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>append</td>
<td>append key-name value 将值value追加到给定键key-name当前存储的值的末尾</td>
</tr>
<tr>
<td>getrange</td>
<td>getrange key-name start end 获取一个由偏移量start至偏移量end范围内所有字符组成的子串，包括start和end在内</td>
</tr>
<tr>
<td>setrange</td>
<td>setrange ke-name offset value 将从offset偏移量开始的字串设置为给定值</td>
</tr>
<tr>
<td>getbit</td>
<td>getbit key-name offset 将字符串看作是二进制位串（bit string），并返回位串中偏移量位offset的二进制位的值</td>
</tr>
<tr>
<td>setbit</td>
<td>setbit key-name offset value 将字节串看作是二进制位串，并将位串中的偏移量为offset的二进制位的值设置为value</td>
</tr>
<tr>
<td>bitcount</td>
<td>bitcount key-name [start end] 将统计二进制位串里面值为1的二进制位的数量，如果给定了可选的start偏移量和end偏移量，那么只对偏移量指定范围内的二进制位进行统计</td>
</tr>
<tr>
<td>bitof</td>
<td>bitof operation dest-key key-name [key-name …] 对一个或多个二进制位串执行包括并（and），或（or），异或（xor），非（not）在内的任意一种位运算操作（bitwise operation），并将计算得出的结果保存在dest-key键里面</td>
</tr>
</tbody>
</table>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h5 id="基础命令-1"><a href="#基础命令-1" class="headerlink" title="基础命令"></a>基础命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>rpush</td>
<td>rpush key-name value [value .. .] 将一个或者多个推入列表的右端</td>
</tr>
<tr>
<td>lpush</td>
<td>lpush key-name value [value…] 将一个或者多个值推入列表的左端</td>
</tr>
<tr>
<td>lrange</td>
<td>lrange key-name start end 返回列表从start偏移量到end偏移量范围内的所有元素，其中偏移量为start和end的元素也会包含在被返回的元素之内</td>
</tr>
<tr>
<td>lindex</td>
<td>lindex key-name offset 返回列表中偏移量为offset的元素</td>
</tr>
<tr>
<td>lpop</td>
<td>lpop key-name 移除并返回列表最左端的元素</td>
</tr>
<tr>
<td>rpop</td>
<td>rpop key-name 移除并返回列表最右端的元素</td>
</tr>
<tr>
<td>ltrim</td>
<td>ltrim key-name start end 对列表进行修剪，只保留从start偏移量到end偏移量范围内的元素，其中偏移量为start和end的元素也会被保留</td>
</tr>
</tbody>
</table>
<h5 id="阻塞式的列表弹出命令以及在列表之间移动元素的命令"><a href="#阻塞式的列表弹出命令以及在列表之间移动元素的命令" class="headerlink" title="阻塞式的列表弹出命令以及在列表之间移动元素的命令"></a>阻塞式的列表弹出命令以及在列表之间移动元素的命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>blpop</td>
<td>blpop key-name [key-name …] timeout 从第一个非空列表中弹出位于最左端的元素，或者在timeout秒之内阻塞并等待可弹出的元素出现</td>
</tr>
<tr>
<td>brpop</td>
<td>brpop key-name [key-name …] timeout 从第一个非空列表中弹出位于最右端的元素，或者在timeout秒之内阻塞并等待可弹出的元素出现</td>
</tr>
<tr>
<td>rpoplpush</td>
<td>rpoplrush source-key dest-key 从source-key列表中弹出位于最右端的元素，然后将这个元素推入dest-key列表的最左端，并向用户返回这个元素</td>
</tr>
<tr>
<td>brpoplpush</td>
<td>brpoplrush source-key dest-key timeout 从source-key列表中弹出位于最右端的元素，然后将这个元素推入dest-key列表的最左端，并向用户返回这个元素；如果source-key为空，那么在timeout秒之内阻塞并等待可弹出的元素出现</td>
</tr>
</tbody>
</table>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h5 id="基础命令-2"><a href="#基础命令-2" class="headerlink" title="基础命令"></a>基础命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>sadd</td>
<td>sadd key-name item [item …] 将一个或者多个元素添加到集合里面，并返回被添加元素当中原本并不存在于集合里面的元素数量</td>
</tr>
<tr>
<td>srem</td>
<td>srem key-name item [item …] 从集合里面移除一个或者多个元素，并返回被移除元素的数量</td>
</tr>
<tr>
<td>sismember</td>
<td>sismember key-name item 检查元素item是否存在于集合key-name里</td>
</tr>
<tr>
<td>scard</td>
<td>scard key-name 返回集合包含的元素的数量</td>
</tr>
<tr>
<td>smembers</td>
<td>smembers key-name 返回集合包含的所有元素</td>
</tr>
<tr>
<td>srandmember</td>
<td>srandmember key-name [count] 从集合里面随机地返回一个或者多个元素。当count为正数时，命令返回的随机元素不会重复；当count为负数时，命令返回的随机元素可能会出现重复</td>
</tr>
<tr>
<td>spop</td>
<td>spop key-name 随机地移除集合中的一个元素，并返回被移除的元素</td>
</tr>
<tr>
<td>smove</td>
<td>smove source-key dest-key item 如果集合source-key包含元素item，那么从集合source-key里面移除元素item，并将元素item添加到集合dest-key中；如果item被成功移除，那么命令返回1，否则返回0</td>
</tr>
</tbody>
</table>
<h5 id="用于组合和处理多个集合的命令"><a href="#用于组合和处理多个集合的命令" class="headerlink" title="用于组合和处理多个集合的命令"></a>用于组合和处理多个集合的命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>sdiff</td>
<td>sdiff key-name [key-name …] 返回那些存在于第一集合，但不存在于其他集合中的元素（数学上的差集运算）</td>
</tr>
<tr>
<td>sdiffstore</td>
<td>sdiffstore dest-key key-name [key-name…] 将那些存在于第一个集合但并不存在于其他集合中的元素存储到dest-key键里面</td>
</tr>
<tr>
<td>sinter</td>
<td>sinter key-name [key-name…] 返回那些同时存在于所有集合中的元素（数学上的交集运算）</td>
</tr>
<tr>
<td>sinterstore</td>
<td>sinterstore dest-key key-name [key-name …] 返回那些同时存在于所有集合中的元素并存储到dest-key键里面</td>
</tr>
<tr>
<td>sunion</td>
<td>sunion key-name [key-name…] 返回那些至少存在于一个集合中的元素（数学上的并集计算）</td>
</tr>
<tr>
<td>sunionstore</td>
<td>sunionstore dest-key key-name [key-name…] 返回那些至少存在于一个集合中的元素并存储到dest-key键里面</td>
</tr>
</tbody>
</table>
<h3 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h3><h5 id="基础命令-3"><a href="#基础命令-3" class="headerlink" title="基础命令"></a>基础命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>hset</td>
<td>hset key-name key 为散列里面设置一个值</td>
</tr>
<tr>
<td>hget</td>
<td>hget key-name 为散列里面获取一个键的值</td>
</tr>
<tr>
<td>hgetall</td>
<td>获取散列包含的所有键值对</td>
</tr>
<tr>
<td>hmget</td>
<td>hmget key-name key [key …] 从散列里面获取一个或多个键的值</td>
</tr>
<tr>
<td>hmset</td>
<td>hmset key-name key value [key value …] 为散列里面的一个或多个键设置值</td>
</tr>
<tr>
<td>hdel</td>
<td>hdel key-name key [key …] 删除散列里面的一个或多个键值对，返回成功找到并删除的键值对数量</td>
</tr>
<tr>
<td>hlen</td>
<td>hlen key-name 返回散列表包含的键值对数量</td>
</tr>
</tbody>
</table>
<h5 id="散列的更高级特性"><a href="#散列的更高级特性" class="headerlink" title="散列的更高级特性"></a>散列的更高级特性</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>hexists</td>
<td>hexists key-name key 检查给定键是否存在于散列中</td>
</tr>
<tr>
<td>hkeys</td>
<td>hkeys key-name 获取散列包含的所有键</td>
</tr>
<tr>
<td>hvals</td>
<td>获取散列包含的所有值</td>
</tr>
<tr>
<td>hgetall</td>
<td>hgetall key-name 获取散列包含的所有键值对</td>
</tr>
<tr>
<td>hincrby</td>
<td>hincrby key-name key increment 将键key存储的值加上整数increment</td>
</tr>
<tr>
<td>hincrbyfloat</td>
<td>hincrbyfloat key-name key increment 将键key存储的值加上浮点数increment</td>
</tr>
</tbody>
</table>
<h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>zadd</td>
<td>zadd key-name score member [score member …] 将带有给定分值的成员添加到有序集合里面</td>
</tr>
<tr>
<td>zrem</td>
<td>zrem key-name member [member …] 从有序集合里面移除给定的成员，并返回被移除成员的数量</td>
</tr>
<tr>
<td>zcard</td>
<td>zcard key-name 返回有序集合包含的成员数量</td>
</tr>
<tr>
<td>zincrby</td>
<td>zincrby key-name increment member 将member成员的分值加上</td>
</tr>
<tr>
<td>zcount</td>
<td>zcount key-name min max 返回分值介于min和max之间的成员数量</td>
</tr>
<tr>
<td>zrank</td>
<td>zrank key-name member 返回成员member在有序集合中的排名</td>
</tr>
<tr>
<td>zscore</td>
<td>zscore key-name member 返回成员member的分值</td>
</tr>
<tr>
<td>zrange</td>
<td>zrange key-name start stop [withscores] 返回有序集合中排名介于start和stop之间的成员，如果给定了可选的withscores选项，那么命令会将成员的分值也一并返回</td>
</tr>
</tbody>
</table>
<h5 id="范围型数据获取命令和范围型数据删除命令，以及并集和交集命令"><a href="#范围型数据获取命令和范围型数据删除命令，以及并集和交集命令" class="headerlink" title="范围型数据获取命令和范围型数据删除命令，以及并集和交集命令"></a>范围型数据获取命令和范围型数据删除命令，以及并集和交集命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>zrevrank</td>
<td>zrevrank key-name member 返回有序集合成员member的排名，成员按照分值从大到小排列</td>
</tr>
<tr>
<td>zrevrange</td>
<td>zrevrange key-name start stop [withscores] 返回有序集合给定排名范围内的成员，成员按照分值从大到小排列</td>
</tr>
<tr>
<td>zrangebyscore</td>
<td>zrangebyscore key min max [withscores] [limit offset count] 返回有序集合中，分值介于min和max之间的所有成员</td>
</tr>
<tr>
<td>zrevrangebyscore</td>
<td>zrevrangebyscore key min max [withscores] [limit offset count] 获取有序集合中分值介于min和max之间所有成员，并按照分值从大到小的顺序来返回它们</td>
</tr>
<tr>
<td>zremrangebyrank</td>
<td>zremrangebyrank key-name start stop 移除有序集合中排名介于start和stop之间的所有成员</td>
</tr>
<tr>
<td>zremrangebyscore</td>
<td>zremrangebyscore key-name min max 移除有序集合中分值介于min和max之间的所有成员</td>
</tr>
<tr>
<td>zinterstore</td>
<td>zinterstore dest-key key-count key [key …] [withscores weight [weight …]] [aggregate sum\</td>
<td>min\</td>
<td>max] 对给定的有序集合执行类似于集合的交集运算</td>
</tr>
<tr>
<td>zunionstore</td>
<td>zunionstore dest-key key-count key [key …] [withscores weight [weight …]] [aggregate sum\</td>
<td>min\</td>
<td>max] 对给定的有序集合执行类似于集合的并集运算</td>
</tr>
</tbody>
</table>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>sort</td>
<td>sort source-key [by pattern] [limit offset count] [get pattern [get pattern …]] [asc\</td>
<td>desc] [alpha] [store dest-key] 根据给定的选项，对输入列表，集合或者有序集合进行排序，然后返回或者存储排序的结果</td>
</tr>
</tbody>
</table>
<h5 id="用于处理过期时间的命令"><a href="#用于处理过期时间的命令" class="headerlink" title="用于处理过期时间的命令"></a>用于处理过期时间的命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>persist</td>
<td>persist key-name 移除键的过期时间</td>
</tr>
<tr>
<td>ttl</td>
<td>ttl key-name 查看给定键距离过期还有多少秒</td>
</tr>
<tr>
<td>expire</td>
<td>expire key-name seconds 让给定键在指定的秒数之后过期</td>
</tr>
<tr>
<td>expireat</td>
<td>expireat key-name timestamp 将给定键的过期时间设置为给定的unix时间戳</td>
</tr>
<tr>
<td>pttl</td>
<td>pttl key-name 查看给定键距离过期时间还有多少毫秒，这个命令在Redis 2.6 或以上版本可用</td>
</tr>
<tr>
<td>pexpire</td>
<td>pexpire key-name milliseconds 让给定键在指定的毫秒数之后过期，这个命令在Redis 2.6 或以上版本可用</td>
</tr>
<tr>
<td>pexpireat</td>
<td>pexpireat key-name timestamp-milliseconds 将一个毫秒级精度的unix时间戳设置为给定键的过期时间，这个命令在Redis 2.6 或以上版本可用</td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/服务器相关/redis/5种数据结构/" data-id="cjei8qka000eh6gblgpudupts" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据库相关/mysql/查询性能优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/数据库相关/mysql/查询性能优化/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库相关/">数据库相关</a>►<a class="article-category-link" href="/categories/数据库相关/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/数据库相关/mysql/查询性能优化/">查询性能优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="慢查询基础：优化数据访问"><a href="#慢查询基础：优化数据访问" class="headerlink" title="慢查询基础：优化数据访问"></a>慢查询基础：优化数据访问</h2><p>对于低效的查询，我们发现通过下面两个步骤来分析总是很有效的：</p>
<ul>
<li>确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多列。</li>
<li>确认MySQL服务器层是否在分析大量超过需要的数据行。</li>
</ul>
<p>对于MySQL，最简单的衡量查询开销的三个指标如下：</p>
<ul>
<li>响应时间</li>
<li>扫描的行数</li>
<li>返回的行数</li>
</ul>
<p>一般MySQL能够使用如下三种方式应用WHERE条件，从好到坏依次为：</p>
<ul>
<li>在索引中使用WHERE条件来过滤不匹配的记录。这是在存储引擎层完成的。</li>
<li>使用索引覆盖扫描（在Extra列中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无须再回表查询记录。</li>
<li>从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using Where）。这是在MySQL服务器层完成，MySQL需要先从数据表读出记录然后过滤。</li>
</ul>
<p>如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试下面的技巧去优化它：</p>
<ul>
<li>使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果了</li>
<li>改变库表结构</li>
<li>重写这个复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询</li>
</ul>
<h2 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h2><h6 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h6><p>有时候对于一个大查询我们需要“分而治之”，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果</p>
<h6 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h6><p>很多高性能的应用都会对关联查询进行分解。简单地，可以对每一个表进行一次单表查询，然后将结果在应用程序中进行关联。例如，下面这个查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT * FROM tag</div><div class="line">    -&gt;   JOIN tag_post ON tag_post.tag_id=tag.id</div><div class="line">    -&gt;   JOIN post on tag_post.post_id=post.id</div><div class="line">    -&gt; WHERE tag.tag=&apos;mysql&apos;;</div></pre></td></tr></table></figure></p>
<p>可以分解成下面这些查询来代替：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT * FROM tag WHERE tag=&apos;mysql&apos;;</div><div class="line">mysql&gt; SELECT * FROM tag_post WHERE tag_id=1234;</div><div class="line">mysql&gt; SELECT * FROM post WHERE post.id in(123, 456, 789);</div></pre></td></tr></table></figure></p>
<p>用分解关联查询的方式重构查询有如下的优势：</p>
<ul>
<li>让缓存更高效。许多应用程序可以方便地缓存单表查询对应的结果对象。</li>
<li>将查询分解后，执行单个查询可以减少锁的竞争</li>
<li>在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展</li>
<li>查询本身效率也可能会有所提升。在这个例子中，使用IN()代替关联查询，可以染MySQL按照ID顺序进行查询，这可能比随机的关联要更高效。</li>
<li>可以减少冗余记录的查询。在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复地访问一部分数据。从这点看，这样的重构还可能会减少网络和内存的消耗。</li>
<li>更进一步，这样做相当于在应用中实现了哈希关联，而不是使用MySQL的嵌套循环查询。</li>
</ul>
<h2 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h2><p>MySQL执行一个查询的过程：<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/MySQL8.jpeg" alt="image"></p>
<ol>
<li>客户端发送一条查询给服务器</li>
<li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段</li>
<li>服务器进行SQL解析，预处理，再由优化器生成对应的执行计划</li>
<li>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询</li>
<li>将结果返回给客户端</li>
</ol>
<h6 id="MySQL客户端-服务器通信协议"><a href="#MySQL客户端-服务器通信协议" class="headerlink" title="MySQL客户端/服务器通信协议"></a>MySQL客户端/服务器通信协议</h6><p>MySQL客户端和服务器之间的通信协议是“半双工”的，这意味着，在任何一个时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生。所以，我们无法也无须将一个消息切成小块独立来发送。</p>
<p>这种协议让MySQL通信简单快速，但是也从很多地方限制了MySQL。一个明显的限制是，这意味着无法进行流量控制。一旦一端开始发送消息，另一端要接收完整个消息才能响应它。</p>
<p>客户端用一个单独的数据包将查询传给服务器。这也是为什么当查询的语句很长的时候，参数<code>max_allowed_packet</code>就特别重要了。一旦客户端发送了请求，它能做的事情就只是等待结果了。</p>
<p>相反的，一般服务器响应给用户的数据通常很多，由多个数据包组成。当服务器开始响应客户端请求时，客户端必须完整地接收整个返回结果，而不能简单地只取前面几条结果，然后让服务器停止发送数据。</p>
<p>换一种方式解释这种行为：当客户端从服务器取数据时，看起来是一个拉数据的过程，但实际上是MySQL在向客户端推送数据的过程。客户端不断地接收从服务器推送的数据，客户端也无法让服务器停下来。</p>
<p>多数连接MySQL的库函数都可以获得全部结果集并缓存到内存里，还可以逐行获取需要的数据。默认一般是获得全部结果集并缓存到内存中。MySQL通常需要等所有的数据都已经发送给客户端才能释放这条查询所占用的资源，所以接收全部结果并缓存通常可以减少服务器的压力，让查询能够早点结束，早点释放相应的资源。</p>
<h6 id="查询状态"><a href="#查询状态" class="headerlink" title="查询状态"></a>查询状态</h6><p>对于一个MySQL连接，或者说一个线程，任何时刻都由一个状态，该状态表示了MySQL当前正在做什么。由很多中方式能够查看当前的状态，最简单的是使用<code>SHOW FULL PROCESSLIST</code>命令（该命令返回结果中的Command列就表示当前的状态）</p>
<h6 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h6><p>当不能使用索引生成排序结果的时候，MySQL需要自己进行排序，如果数据量小则在内存中进行，如果数据量大则需要使用磁盘，不过MySQL将这个过程统一称为文件排序（filesort），即使完全是内存排序不需要任何磁盘文件时也是如此。</p>
<p>如果需要排序的数据量小于“排序缓冲区”，MySQL使用内存进行“快速排序”操作。如果内存不够排序，那么MySQL会先将数据分块，对每个独立的块使用“快速排序”进行排序，并将各个块的排序结果存放在磁盘上，然后将各个拍好序的块进行合并（merge），最后返回排序结果。</p>
<p>MySQL有两种排序算法，新版本使用的是<strong>单次传输排序</strong>：<br>先读取查询所需要的所有列，然后再根据给定列进行排序，最后直接返回排序结果。这个算法只在MySQL4.1及后续更新的版本引入。因为不再需要从数据表读取两次数据，对于I/O密集型的应用，这样做的效率高了很多。另外，相比两次传输排序，这个算法只需要一次顺序I/O读取所有的数据，而无须任何的随机I/O。缺点是，如果需要返回的列非常多，非常大，会额外占用大量的空间，而这些列对排序操作本身来说是没有任何作用的。因为单条排序记录很大，所以可能会有更多的排序块需要合并。</p>
<p><strong>在关联查询的时候如果需要排序，MySQL会分两种情况来处理这样的文件排序。如果ORDER BY 子句中的所有列都来自关联的第一个表。那么MySQL在关联处理第一个表的时候就进行文件排序。如果是这样，那么在MySQL的EXPLAIN结果中可以看到Extra字段会有“Using filesort”。除此之外的所有情况，MySQL都会先将关联的结果存放到一个临时表中，然后再所有的关联都结束后，再进行文件排序。这种情况下，在MySQL的EXPLAIN结果的Extra字段可以看到“Using temporary；Using filesort”。如果查询中有LIMIT的话，LIMIT也会在排序之后应用，所以即使需要返回较少的数据，临时表和需要排序的数据量仍然会非常大</strong>。</p>
<h2 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h2><h6 id="优化count-查询"><a href="#优化count-查询" class="headerlink" title="优化count()查询"></a>优化count()查询</h6><p>count()是一个特殊的函数，有两种非常不同的作用：它可以统计某个列值的数量，也可以统计行数。</p>
<p>在统计列值时要求列值是非空的（不统计NULL）。如果在count()的括号中指定了列或者列的表达式，则统计的就是这个表达式有值的结果数。</p>
<p>在统计结果集的行数时，当MySQL确认括号内的表达式值不可能为空时，实际上就是在统计行数。最简单的就是当我们使用count(*)的时候，它会忽略所有的列而直接统计所有的行数。</p>
<h6 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h6><ul>
<li>确保ON 或者 USING 子句中的列上有索引。一般来说，除非有其他理由，否则只需要在关联顺序中的第二个表的相应列上创建索引。</li>
<li>确保任何的 GROUP BY 和 ORDER BY 中的表达式只涉及到一个表中的列。这样MySQL才有可能使用索引来优化这个过程。</li>
<li>当升级MySQL的时候需要注意：关联语法，运算符优先级等其他可能会发生变化的地方。</li>
</ul>
<h6 id="优化GROUP-BY-和-DISTINCT"><a href="#优化GROUP-BY-和-DISTINCT" class="headerlink" title="优化GROUP BY 和 DISTINCT"></a>优化GROUP BY 和 DISTINCT</h6><p>MySQL优化器会在内部处理的时候相互转化这两类查询。它们都可以使用索引来优化，这也是最有效的优化办法。</p>
<p>在MySQL中，当无法使用索引的时候，GROUP BY使用两种策略来完成：<strong>使用临时表或者文件排序来做分组</strong>。</p>
<p><strong>如果没有通过ORDER BY子句显式地指定排序列，当查询使用GROUP BY子句的时候，结果集会自动按照分组的字段进行排序。如果不关心结果集的顺序，而这种默认排序又导致了需要文件排序，则可以使用ORDER BY NULL，让MySQL不再进行文件排序。也可以在GROUP BY子句中直接使用DESC 或ASC关键字，使分组的结果集按需要的方向排序</strong>。</p>
<h6 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h6><p>优化此类分页查询的一个最简单的办法就是尽可能地使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候，这样做的效率会提升非常大。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/数据库相关/mysql/查询性能优化/" data-id="cjei8qk9m00do6gblcw810ahx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据库相关/mysql/索引的类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/数据库相关/mysql/索引的类型/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库相关/">数据库相关</a>►<a class="article-category-link" href="/categories/数据库相关/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/数据库相关/mysql/索引的类型/">索引的类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>这是最基本的索引，它没有任何限制。它有以下几种创建方式：</p>
<h5 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CREATE INDEX indexName ON mytable(username(length));</div></pre></td></tr></table></figure>
<p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length，下同。</p>
<h5 id="修改表结构的方式"><a href="#修改表结构的方式" class="headerlink" title="修改表结构的方式"></a>修改表结构的方式</h5><p>创建表后，修改表的结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER mytable ADD INDEX [indexName] ON (username(length))</div></pre></td></tr></table></figure></p>
<p>创建表的时候直接指定:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE mytable(  </div><div class="line"> </div><div class="line">    ID INT NOT NULL,   </div><div class="line">     </div><div class="line">    username VARCHAR(16) NOT NULL,  </div><div class="line">     </div><div class="line">    INDEX [indexName] (username(length))  </div><div class="line"> </div><div class="line">);</div></pre></td></tr></table></figure></p>
<h5 id="删除索引的语法："><a href="#删除索引的语法：" class="headerlink" title="删除索引的语法："></a>删除索引的语法：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DROP INDEX [indexName] ON mytable;</div></pre></td></tr></table></figure>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：</p>
<h5 id="创建索引-1"><a href="#创建索引-1" class="headerlink" title="创建索引"></a>创建索引</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CREATE UNIQUE INDEX indexName ON mytable(username(length))</div></pre></td></tr></table></figure>
<h5 id="修改表结构的方式-1"><a href="#修改表结构的方式-1" class="headerlink" title="修改表结构的方式"></a>修改表结构的方式</h5><p>创建表后，修改表的结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER mytable ADD UNIQUE [indexName] ON (username(length))</div></pre></td></tr></table></figure></p>
<p>创建表的时候直接指定:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE mytable(  </div><div class="line"> </div><div class="line">    ID INT NOT NULL,   </div><div class="line">     </div><div class="line">    username VARCHAR(16) NOT NULL,  </div><div class="line">     </div><div class="line">    UNIQUE [indexName] (username(length))  </div><div class="line"> </div><div class="line">);</div></pre></td></tr></table></figure></p>
<h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE mytable(  </div><div class="line"> </div><div class="line">    ID INT NOT NULL,   </div><div class="line">     </div><div class="line">    username VARCHAR(16) NOT NULL,  </div><div class="line">     </div><div class="line">    PRIMARY KEY(ID)  </div><div class="line"> </div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>当然也可以用 ALTER 命令。记住：一个表只能有一个主键。</p>
<h3 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h3><p>为了形象地对比单列索引和组合索引，为表添加多个字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE mytable(  </div><div class="line"> </div><div class="line">    ID INT NOT NULL,   </div><div class="line">     </div><div class="line">    username VARCHAR(16) NOT NULL,  </div><div class="line">     </div><div class="line">    city VARCHAR(50) NOT NULL,  </div><div class="line">     </div><div class="line">    age INT NOT NULL </div><div class="line"> </div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>为了进一步榨取MySQL的效率，就要考虑建立组合索引。就是将 name, city, age建到一个索引里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE mytable ADD INDEX name_city_age (name(10),city,age);</div></pre></td></tr></table></figure></p>
<p>建表时，usernname长度为 16，这里用 10。这是因为一般情况下名字的长度不会超过10，这样会加速索引查询速度，还会减少索引文件的大小，提高INSERT的更新速度。    </p>
<p>如果分别在usernname，city，age上建立单列索引，让该表有3个单列索引，查询时和上述的组合索引效率也会大不一样，远远低于我们的组合索引。虽然此时有了三个索引，但MySQL只能用到其中的那个它认为似乎是最有效率的单列索引。</p>
<p>建立这样的组合索引，其实是相当于分别建立了下面三组组合索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">usernname,city,age  </div><div class="line"> </div><div class="line">usernname,city  </div><div class="line"> </div><div class="line">usernname</div></pre></td></tr></table></figure></p>
<p>为什么没有city，age这样的组合索引呢？这是因为MySQL组合索引“<strong>最左前缀</strong>”的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这三列的查询都会用到该组合索引，下面的几个SQL就会用到这个组合索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM mytable WHREE username=&quot;admin&quot; AND city=&quot;郑州&quot; </div><div class="line"> </div><div class="line">SELECT * FROM mytable WHREE username=&quot;admin&quot;</div></pre></td></tr></table></figure></p>
<p>而下面几个则不会用到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM mytable WHREE age=20 AND city=&quot;郑州&quot; </div><div class="line"> </div><div class="line">SELECT * FROM mytable WHREE city=&quot;郑州&quot;</div></pre></td></tr></table></figure></p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>全文索引(也称全文检索)是目前搜索引擎使用的一种关键技术。它能够利用“分词技术”等多种算法智能分析出文本文字中关键字词的频率及重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。</p>
<h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><p>建表的时候确定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE article ( </div><div class="line">      id INT AUTO_INCREMENT NOT NULL PRIMARY KEY, </div><div class="line">      title VARCHAR(200), </div><div class="line">      body TEXT, </div><div class="line">      FULLTEXT(title, body) </div><div class="line">) TYPE=MYISAM;</div></pre></td></tr></table></figure></p>
<p>通过 alter table 的方式来添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> ALTER TABLE `student` ADD FULLTEXT INDEX INDEX_NAME  (`name`) </div><div class="line"></div><div class="line">或者：ALTER TABLE `student` ADD FULLTEXT INDEX_NAME  (`name`)</div></pre></td></tr></table></figure></p>
<p>直接通过create index的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CREATE FULLTEXT INDEX INDEX_NAME ON `student` (`name`)</div><div class="line"></div><div class="line">也可以在创建索引的时候指定索引的长度：</div><div class="line">CREATE FULLTEXT INDEX INDEX_NAME ON `student` (`name`(20))</div></pre></td></tr></table></figure></p>
<h5 id="删除全文索引"><a href="#删除全文索引" class="headerlink" title="删除全文索引"></a>删除全文索引</h5><p>直接使用 drop index(注意：没有 drop fulltext index 这种用法)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DROP INDEX INDEX_NAME ON TABLENAME ;</div></pre></td></tr></table></figure></p>
<p>使用 alter table的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE TABLENAME DROP INDEX INDEX_NAME;</div></pre></td></tr></table></figure></p>
<h5 id="使用全文索引"><a href="#使用全文索引" class="headerlink" title="使用全文索引"></a>使用全文索引</h5><p>跟普通索引稍有不同,使用全文索引的格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MATCH (columnName) AGAINST (&apos;string&apos;)</div></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM `student` WHERE MATCH(`name`) AGAINST(&apos;聪&apos;)</div></pre></td></tr></table></figure></p>
<h5 id="设置条件"><a href="#设置条件" class="headerlink" title="设置条件"></a>设置条件</h5><ol>
<li>表的存储引擎是MyISAM，默认存储引擎InnoDB不支持全文索引（新版本MYSQL5.6的InnoDB支持全文索引）    </li>
<li>字段类型：char、varchar和text</li>
</ol>
<p>MySQL自带的全文索引只能对英文进行全文检索，目前无法对中文进行全文检索。如果需要对包含中文在内的文本数据进行全文检索，我们需要采用Sphinx(斯芬克斯)/Coreseek技术来处理中文</p>
<h5 id="全文索引应用流程："><a href="#全文索引应用流程：" class="headerlink" title="全文索引应用流程："></a>全文索引应用流程：</h5><ol>
<li>接收数据-数据分词-入库</li>
<li>接收数据-数据分词-查询</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/数据库相关/mysql/索引的类型/" data-id="cjei8qk9l00dm6gblei4dckrn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据库相关/mysql/创建高性能的索引" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/数据库相关/mysql/创建高性能的索引/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库相关/">数据库相关</a>►<a class="article-category-link" href="/categories/数据库相关/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/数据库相关/mysql/创建高性能的索引/">创建高性能的索引</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>索引（在MySQL中也叫做“键（key）”）是存储引擎用于快速找到记录的一种数据结构。索引优化应该是对查询性能优化最有效的手段了。</p>
<h2 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h2><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><p>在MySQL中，索引是在存储引擎层而不是服务器层实现的。所以，并没有统一的索引标准：不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。</p>
<h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h4><p>存储引擎以不同的方式使用B-Tree索引，性能也各有不同，各有优劣。例如，MyISAM使用前缀压缩计数使得索引更小，但InnoDB则按照原数据格式进行存储。再如MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。</p>
<p>B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。如下图展示了B-Tree索引的抽象表示：<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/mysql1.jpeg" alt="image"><br>B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点（图示并未画出）开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么是找到对应的值，要么该记录不存在。</p>
<p>叶子节点比较特别，它们的指针指向的是被索引的数据，而不是其他节点页。上图仅绘制了一个节点和其对应的叶子节点，其实在根节点和叶子节点之间可能有很多层节点页。树的深度和表的大小直接相关。</p>
<p><strong>索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序。</strong></p>
<p><strong>B-Tree索引适用于全键值，键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找</strong>。</p>
<ul>
<li><strong>全值匹配</strong><br>  全值匹配指的是和索引中的所有列进行匹配</li>
<li><strong>匹配最左前缀</strong><br>  即按定义好的索引顺序，只使用索引的第一列或几列（按顺序）</li>
<li><strong>匹配列前缀</strong><br>  也可以只匹配某一列的值的开头部分</li>
<li><strong>匹配范围值</strong><br>  匹配某一范围内的值</li>
<li><strong>精确匹配某一列并范围匹配另外一列</strong><br>  即第一列或几列是全值匹配，跟着一列是范围匹配，往后的列不能用于索引查询</li>
<li><strong>只访问索引的查询</strong><br>  B-Tree通常可以支持“只访问索引的查询”，即查询只需要访问索引，而无须访问数据行</li>
</ul>
<p>B-Tree索引的限制：</p>
<ul>
<li>如果不是按照索引的最左列开始查找，则无法使用索引。</li>
<li>不能跳过索引中的列</li>
<li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查询。</li>
</ul>
<p>索引列的顺序很重要：这些限制都和索引列的顺序有关。在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。</p>
<h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p>
<p>在Mysql中，只有Memory引擎显式支持哈希索引。这也是Memory引擎表的默认索引类型，Memory引擎同时也支持B-Tree索引。值得一提的是，Memory引擎是支持非唯一哈希索引的，这在数据库世界里面是比较与众不同的。如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中。</p>
<p>例如：<br>创建一个测试表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `testhash` (</div><div class="line">  `fname` varchar(50) COLLATE utf8_unicode_ci NOT NULL,</div><div class="line">  `lanme` varchar(50) COLLATE utf8_unicode_ci NOT NULL,</div><div class="line">  KEY `fname` (`fname`) USING HASH</div><div class="line">) ENGINE=MEMORY DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci</div></pre></td></tr></table></figure></p>
<p>表中数据如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select * from testhash;</div><div class="line">+-------+-----------+</div><div class="line">| fname | lanme     |</div><div class="line">+-------+-----------+</div><div class="line">| Arjen | Lentz     |</div><div class="line">| Baron | Schwartz  |</div><div class="line">| Peter | Zaitsev   |</div><div class="line">| Vadim | Tkachenko |</div><div class="line">+-------+-----------+</div><div class="line">4 行于数据集 (0.05 秒)</div></pre></td></tr></table></figure></p>
<p>假设索引使用假想的哈希函数f(),它返回下面的值（都是示例数据，非真实数据）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">f(&apos;Arjen&apos;)=2323</div><div class="line">f(&apos;Baron&apos;)=7437</div><div class="line">f(&apos;Peter&apos;)=8784</div><div class="line">f(&apos;Vadim&apos;)=2458</div></pre></td></tr></table></figure></p>
<p>则哈希索引的数据结构如下：</p>
<table>
<thead>
<tr>
<th>槽（Slot）</th>
<th>值（Value）</th>
</tr>
</thead>
<tbody>
<tr>
<td>2323</td>
<td>指向第1行的指针</td>
</tr>
<tr>
<td>2458</td>
<td>指向第4行的指针</td>
</tr>
<tr>
<td>7437</td>
<td>指向第2行的指针</td>
</tr>
<tr>
<td>8784</td>
<td>指向第3行的指针</td>
</tr>
</tbody>
</table>
<p>注意每个槽的编号是顺序的，但是数据行不是，现在来看如下查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT lanme FROM testhash WHERE fname = &apos;Peter&apos;;</div></pre></td></tr></table></figure></p>
<p>MySQL先计算’Peter’的哈希值，并使用该值寻找对应的记录指针。因为f(‘Peter’)=8784，索引MySQL在索引中查找8784，可以找到指向第3行的指针，最后一步是比较第3行的值是否为’Peter’，以确保就是要查找的行。</p>
<p>因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引查找的速度非常快。然而，哈希索引也有它的限制：</p>
<ul>
<li><strong>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行</strong>。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显。</li>
<li><strong>哈希索引数据并不是按照索引值顺序存储的，而是按照索引值的哈希值大小存储的，原数据的大小跟索引值的哈希值大小并不一致，所以也就无法用于排序</strong>。</li>
<li><strong>哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的</strong>。例如，在数据列（A，B）上建立哈希索引，如果查询只有数据列A，则无法使用该索引。</li>
<li><p><strong>哈希索引只支持等值比较查询，包括=，IN()，&lt;=&gt;（注意，&lt;&gt;和&lt;=&gt;是不同的操作），也不支持任何范围查询</strong>。例如WHERE price &gt; 100。<br>  注：&lt;=&gt;用于比较可能含有NULL的值，如</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">... WHERE col_a &lt;=&gt; ? ...</div></pre></td></tr></table></figure>
<p>  这里的占位符有可能是常量也有可能是NULL，当使用&lt;=&gt;运算符时，你没有必要对查询语句做任何修改。</p>
</li>
<li><strong>访问哈希索引的数据非常快，除非有很多哈希冲突（不同的索引列值却有相同的哈希值）</strong>。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。</li>
<li><strong>如果哈希冲突很多的话，一些索引维护操作的代价也会很高</strong>。例如，如果在某个选择性很低 （哈希冲突很多）的列上建立哈希索引，那么当从表中删除一行时，存储引擎需要遍历对应哈希值的链表中的每一行，找到并删除对应行的引用，冲突越多，代价越大。</li>
</ul>
<h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><p>最常见的B-Tree索引，按照顺序存储数据，所以MySQL可以用来做ORDER BY和GROUP BY操作。因为数据是有序的，所以B-Tree也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询。据此特性，总结下来索引有如下三个优点：</p>
<ul>
<li>索引大大减少了服务器需要扫描的数据量</li>
<li>索引可以帮助服务器避免排序和临时表</li>
<li>索引可以将随机I/O变为顺序I/O</li>
</ul>
<h2 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h2><h3 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h3><p>如果查询中的列不是独立的，则MySQL就不会使用索引。“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。<br>例如，下面这个查询无法使用actor_id列的索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT actor_id FORM sakila.actor WHERE actor_id + 1 = 5</div></pre></td></tr></table></figure></p>
<h3 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h3><p>通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。<strong>索引的选择性是指，不重复的索引值（也称为基数，cardinality）和数据表的记录总数（#T）的比值，范围从1/#T到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的</strong>。</p>
<p>一般情况下某个列前缀的选择性也是足够高的，足以满足查询性能。对于OLOB，TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。</p>
<p>诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间）。前缀应该足够长，以使得前缀索引的选择性接近于索引整个列。换句话说，前缀的“基数”因该接近于完整列的“<strong>基数</strong>”。</p>
<p>选择合适的前缀需要反复进行实验：比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT COUNT(*) AS cnt, LEFT(city, 7) AS pref FROM sakila.city_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10;</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>cnt</th>
<th>pref</th>
</tr>
</thead>
<tbody>
<tr>
<td>70</td>
<td>Santing</td>
</tr>
<tr>
<td>68</td>
<td>San Fel</td>
</tr>
<tr>
<td>65</td>
<td>London</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>不断改变前缀的长度，发现长度为7时最合适。</p>
<p>计算合适的前缀长度的另外一个办法就是计算完整列的选择性，并使前缀的选择性接近于完整列的选择性。下面显示如何计算完整列的选择性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT COUNT(DISTINCT city) / COUNT(*) FROM sakila.city_demo;</div><div class="line"></div><div class="line">+---------------------------------+</div><div class="line">| COUNT(DISTINCT city) / COUNT(*) | </div><div class="line">+---------------------------------+</div><div class="line">|  0.0312                         |</div><div class="line">+---------------------------------+</div></pre></td></tr></table></figure></p>
<p>下面演示一下如何创建前缀索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; ALTER TABLE sakila.city_demo ADD KEY (city(7));</div></pre></td></tr></table></figure></p>
<p><strong>前缀索引是一种能使索引更小，更快的有效办法，但另一方面也有其缺点：MySQL无法使用前缀索引做ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描</strong>。</p>
<h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p>在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。MySQL5.0和更新版本引入了一种叫“<strong>索引合并</strong>”（index merge）策略，一定程度上可以使用表上的多个单列索引来定位指定的行。</p>
<p>在MySQL5.0和更新的版本中，查询能够同时使用这两个单列索引进行扫描，并将扫描结果进行合并。这种算法有三个变种：</p>
<ul>
<li>OR条件的联合（union）</li>
<li>AND条件的相交（intersection）</li>
<li>组合前两种情况的联合及相交</li>
</ul>
<p>例如有单索引列actor_id和film_id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT film_id, actor_id FROM sakila.film_actor WHERE actor_id = 1 OR film_id = 1;</div></pre></td></tr></table></figure></p>
<p>索引合并策略有时候是一种优化的结果，但实际上更多时候说明了表上的索引建得很糟糕：</p>
<ul>
<li>当出现服务器对多个索引做相交操作时（通常有多个AND条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。</li>
<li>当服务器需要对多个索引做联合操作时（通常有多个OR条件），通常需要耗费大量CPU和内存资源在算法的缓存，排序和合并操作上。特别是当其中有些索引的选择性不高，需要合并并扫描返回的大量数据的时候。</li>
<li>更重要的是，优化器不会把这些计算到“查询成本”（cost）中，优化器只关心随机页面读取。这会使得查询的成本被“低估”，导致该执行计划还不如直接走全表扫描。这样做不但会消耗更多的CPU和内存资源，还可能会影响查询的并发性，但如果是单独运行这样的查询则往往会忽略对并发性的影响。</li>
</ul>
<h3 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h3><p>在一个多列B-Tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。所以，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的ORDER BY 和 GROUP BY 和 DISTINCT 等子句的查询需求。</p>
<p>多列索引的列顺序至关重要。<strong>对于如何选择索引的列顺序有一个经验法则：将选择性最高的列放到索引最前列</strong>。</p>
<p>当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的。</p>
<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。当表有聚簇索引时，它的数据行实际上存放在索引的叶子页（leaf page）中。术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<p>因为是存储引擎负责实现索引，因此不是所有的存储引擎都支持聚簇索引。</p>
<p>InnoDB将通过主键聚集数据。如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引。InnoDB会隐式定义一个主键来作为聚簇索引。InnoDB只聚集在同一个页面中的记录。包含相邻键值的页面可能会相距甚远。</p>
<p>聚集数据的一些重要的优点：</p>
<ul>
<li>可以把相关数据保存到一起。</li>
<li>数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找更快。</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值</li>
</ul>
<p>聚簇索引的一些缺点：</p>
<ul>
<li>聚簇数据最大限度地提高了I/O密集型应用的性能。但如果数据全部都放在内存中，则访问的顺序就没那么重要了，聚簇索引也就没什么优势了。</li>
<li>插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用<code>OPTIMIZE TABLE</code>命令重新组织一下表。</li>
<li>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。</li>
<li>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂（page split）”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳改行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间。</li>
<li>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。</li>
<li>二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。</li>
<li>二级索引访问需要两次索引查找，而不是一次。要记住，二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。</li>
</ul>
<h3 id="InnoDB和MyISAM的数据分布对比"><a href="#InnoDB和MyISAM的数据分布对比" class="headerlink" title="InnoDB和MyISAM的数据分布对比"></a>InnoDB和MyISAM的数据分布对比</h3><p>来看看InnoDB和MyISAM是如何存储下面这个表的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE layout_test (</div><div class="line"> col1 int not null,</div><div class="line"> col2 int not null,</div><div class="line"> PRIMARY KEY(col1),</div><div class="line"> KEY(col2)</div><div class="line">);</div></pre></td></tr></table></figure></p>
<h6 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h6><p>MyISAM按照数据插入的顺序存储在磁盘上，如下图：<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/MyISAM1.jpeg" alt="image"><br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/MyISAM2.jpeg" alt="image"><br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/MyISAM3.jpeg" alt="image"></p>
<h6 id="InnoDB的数据分布"><a href="#InnoDB的数据分布" class="headerlink" title="InnoDB的数据分布"></a>InnoDB的数据分布</h6><p><img src="https://raw.githubusercontent.com/clq2owesome/image/master/MyISAM4.jpeg" alt="image"><br>该图显示了整个表，而不是只有索引。因为在InnoDB中，聚簇索引“就是”表，所以不像MyISAM那样需要独立的行存储。</p>
<p><strong>聚簇所以的每一个叶子节点都包含了主键值，事务ID，用于事务和MVCC的回滚指针以及所有的剩余列。如果主键是一个列前缀索引，InnoDB也会包含完整的主键列和剩下的其他列</strong>。</p>
<p>还有一点和MyISAM的不同是，InnoDB的二级索引和聚簇索引很不同。InnoDB二级索引的叶子节点中存储的不是“行指针”，而是主键值，并以此作为指向行的“指针”。这样的策略减少了当出现行一定或者数据页分裂时二级索引的维护工作。使用主键值当作指针会让二级索引占用更多的空间，换来的好处是，InnoDB在移动行时无须更新二级索引中的这个“指针”。</p>
<p>下面是二级索引分布图：<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/MyISAM5.jpeg" alt="image"></p>
<p>下图是描述InnoDB和MyISAM如何存放表的抽象图：<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/MyISAM6.jpeg" alt="image"></p>
<h3 id="在InnoDB表中按主键顺序插入行"><a href="#在InnoDB表中按主键顺序插入行" class="headerlink" title="在InnoDB表中按主键顺序插入行"></a>在InnoDB表中按主键顺序插入行</h3><p>如果正在使用InnoDB表并且没有什么数据需要聚集，那么可以定义一个代理键（surrogate key）作为主键，这种主键的数据应该和应用无关，最简单的方法是使用<code>AUTO_INCREMENT</code>自增列。这样可以保证数据行是按顺序写入，对于根据主键做关联操作的性能会更好。</p>
<p>向聚簇索引中顺序插入数据：<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/MyISAM7.jpeg" alt="image"><br>因为主键的值是顺序的，所以InnoDB把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时（InnoDB默认最大填充因子是页大小的15/16，流出部分空间用于以后修改），下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满，这页正是所期望的结果（然而，二级索引页可能是不一样的）。</p>
<p>最好避免随机的（不连续且值的分布范围非常大）聚簇索引，特别是对于I/O密集型的应用。例如，从性能的角度考虑，使用UUID来作为聚簇索引则会很糟糕：它使得聚簇索引的插入变得完全随机，这是最坏的情况，使得数据没有任何聚集特性。</p>
<p>随机聚簇索引的缺点：</p>
<ul>
<li>写入的目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，InnoDB在插入之前不得不先找到并从磁盘读取目标页到内存中。这将导致大量的随机I/O</li>
<li>因为写入是乱序的，InnoDB不得不频繁地做页分裂操作，以便为新的行分配空间，页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个页。</li>
<li>由于频繁的页分裂，页会变得稀疏并被不规则填充，所以最终数据会有碎片。</li>
</ul>
<p>在把这些随机值载入到聚簇索引以后，也行需要做一次<code>OPTIMIZE TABLE</code>来重建表并优化页的填充。</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。</p>
<p>覆盖索引是非常有用的工具，能够极大地提高性能。考虑一下如果查询只需要扫描索引而无须回表，会带来多少好处：</p>
<ul>
<li><strong>索引条目通常远小于数据行大小，所以如果只需要读取索引，那MySQL机会极大地减少数据访问量</strong>。这对缓存负载非常重要，因为这种情况下响应时间大部分花费在数据拷贝上。覆盖索引对于I/O密集型的应用也有帮助，因为索引比数据更小，更容易全部放入内存中（这对于MyISAM尤其正确，因为MyISAM能压缩索引以变的更小）。</li>
<li><strong>因为索引是按照列值顺序存储的（至少在单个页内是如此），所以对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少的多</strong>。</li>
<li><strong>一些存储引擎如MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存</strong>，因此要访问数据需要一次系统调用。这可能会导致严重的性能问题，尤其是那些系统调用占了数据访问中的最大开销的场景。</li>
<li>由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。</li>
</ul>
<p><strong>不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引列的值，而哈希索引，空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引</strong>。另外，不同的存储引擎实现覆盖索引的方式也不同，而且不是所有的引擎都支持覆盖索引。</p>
<p>比如，表inventory有一个多列索引（store_id, film_id）。MySQL如果只需访问这两列，就可以使用这个索引做覆盖索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT store_id, film_id FROM inventory;</div></pre></td></tr></table></figure></p>
<p>下面的查询不会使用覆盖查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT * FROM products WHERE actor=&apos;SEAN CARREY&apos; AND title like &apos;%APOLLO%&apos;</div></pre></td></tr></table></figure></p>
<p>这里的索引无法覆盖该查询，有两个原因：</p>
<ul>
<li>没有任何索引能够覆盖这个查询。因为查询从表中选择了所有的列，而没有任何索引覆盖了所有的列。不过，理论上MySQL还有一个捷径可以利用：WHERE条件中的列是由索引可以覆盖的，因此MySQL可以使用该索引找到对应的actor并检查title是否匹配，过滤之后再读取需要的数据行。</li>
<li>MySQL不能在索引中执行LIKE操作。MySQL能在索引中做最左前缀匹配的LIKE比较，因为该操作可以转换为简单的比较操作，但是如果是通配符开头的LIKE查询，存储引擎就无法做比较匹配。这种情况下，MySQL服务器只能提取数据行的值而不是索引值来做比较。</li>
</ul>
<p>也有办法可以解决上面说的两个问题，需要重写查询并巧妙地设计索引。先将索引扩展至覆盖三个数据列（artist, title, prod_id），然后按如下方式重写查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT * FROM products JOIN (</div><div class="line">-&gt; SELECT prod_id FROM products WHERE actor=&apos;SEAN CARREY&apos; AND title LIKE &apos;%APOLLO&apos;</div><div class="line">-&gt; ) AS t1 ON (t1.prod_id = products.prod_id)</div></pre></td></tr></table></figure></p>
<p>我们把这种方式叫做“<strong>延迟关联（deferred join）</strong>”,因为延迟了对列的访问。在查询的第一阶段MySQL可以使用覆盖索引，在FROM子句的子查询中找到匹配的prod_id，然后根据这些prod_id值在外层查询匹配获取需要的所有列值。虽然无法使用索引覆盖整个查询，但总算比完全无法利用索引覆盖好。</p>
<h3 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h3><p>MySQL有两种方式可以生成有序的结果：</p>
<ul>
<li>通过排序操作</li>
<li>按索引顺序扫描</li>
</ul>
<p><strong>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一张表时，才能使用索引做排序。ORDER BY子句和查找型查询的限制是一样的：需要满足索引的最左前缀的要求，否则MySQL都需要执行排序操作，而无法利用索引排序</strong>。</p>
<p>有一种情况下ORDER BY子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。如果WHERE子句或者JOIN子句对这些列指定了常量，就可以“弥补”索引的不足。</p>
<p>例如：表rental在列（rental_data，inv_id, cust_id）上设置了索引，则以下SQL语句可以用索引排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT rental_id, staff_id FROM rental WHERE retal_data = &apos;2018-01-01&apos; ORDER BY inv_id, cust_id;</div><div class="line"></div><div class="line">mysql&gt; ... WHERE retal_data = &apos;2018-01-01&apos; ORDER BY inv_id DESC;</div><div class="line"></div><div class="line">mysql&gt; ... WHERE retal_data &gt; &apos;2018-01-01&apos; ORDER BY retal_date, inv_id;</div></pre></td></tr></table></figure></p>
<p>下面是一些不能使用索引做排序的查询：</p>
<ol>
<li><p>这个查询使用了两种不同的排序方向，但是索引列都是正序排序的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; ... WHERE retal_data = &apos;2018-01-01&apos; ORDER BY inv_id DESC, cust_id ASC;</div></pre></td></tr></table></figure>
</li>
<li><p>这个查询的ORDER BY 子句中引用了一个不在索引中的列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; ... WHERE retal_data = &apos;2018-01-01&apos; ORDER BY inv_id, staff_id</div></pre></td></tr></table></figure>
</li>
<li><p>这个查询的WHERE 和 ORDER BY中的列无法组合成索引的最左前缀：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; ... WHERE retal_data = &apos;2018-01-01&apos; ORDER BY cust_id;</div></pre></td></tr></table></figure>
</li>
<li><p>这个查询在索引列的第一列上是范围条件，所以MySQL无法使用索引的其余列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; ... WHERE retal_data &gt; &apos;2018-01-01&apos; ORDER BY inv_id, cust_id;</div></pre></td></tr></table></figure>
</li>
<li><p>这个查询在inv_id列上有多个等于条件。对于排序来说，这也是一种范围查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; ... WHERE retal_data = &apos;2018-01-01&apos; AND inv_id IN(1,2) ORDER BY cust_id;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="压缩（前缀压缩）索引"><a href="#压缩（前缀压缩）索引" class="headerlink" title="压缩（前缀压缩）索引"></a>压缩（前缀压缩）索引</h3><p>MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中，这在某些情况下能极大地提高性能。默认只压缩字符串，但通过参数设置也可以对整数做压缩。</p>
<p><strong>MyISAM压缩每个索引块的方法是，先完全保存索引块中的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分，把这部分存储起来即可。例如，索引块中第一个值是“perfform”，第二值是“performance”，那么第二个值的前缀压缩后存储的是类似“7,ance”这样的形式。MyISAM对行指针也采用类似的前缀压缩方式</strong>。</p>
<p>压缩块使用更少的空间，代价是某些操作可能更慢。因为每个值的压缩前缀都依赖前面的值，所以MyISAM查找时无法在索引块使用二分查找而只能从从头开始扫描。正序的扫描速度还不错，但是如果是倒序扫描就不是很好了。</p>
<h3 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h3><p>MySQL允许在相同列上创建多个索引。重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。应该避免这样创建重复索引，发现以后也应该立即移除。</p>
<p>冗余索引通常发生在为表添加新索引的时候。例如有人可能会添加一个新的索引（A,B）而不是扩展已有的索引（A）。还有一种情况是将一个索引扩展为（A, ID），其中ID是主键，对于InnoDB来说主键列已经包含在二级索引中了，所以这也是冗余的。</p>
<p>大多数情况下都不需要冗余索引，应该尽量扩展已有的索引而不是创建新索引。但也有时候出于性能方面的考虑需要冗余索引，因为扩展已有的索引会导致其变的太大，从而影响其他使用该索引的查询的性能。</p>
<p>表中的索引越多插入速度会越慢。一般来说，增加新索引将会导致INSERT，UPDATE，DELETE等操作的速度变慢，特别是新增索引后导致达到了内存瓶颈的时候。</p>
<p>可以使用Percona Toolkit中的<code>pt-duplicate-key-checker</code>分析表结构来找出冗余和重复的索引。</p>
<h3 id="未使用的索引"><a href="#未使用的索引" class="headerlink" title="未使用的索引"></a>未使用的索引</h3><p>可以使用Percona Toolkit中的<code>pt-index-usage</code>，该工具可以读取查询日志，并对日志中的每条查询进行EXPLAIN操作，然后打印出关于索引和查询的报告。</p>
<h3 id="索引的锁"><a href="#索引的锁" class="headerlink" title="索引的锁"></a>索引的锁</h3><p>InnoDB只有在访问行的时候才会对其加锁，而索引能够减少InnoDB访问的行数，从而减少锁的数量。但这只有当InnoDB在存储引擎层能够过滤掉所有不需要的行时才有效。如果索引无法过滤掉无效的行，那么在InnoDB检索到数据并返回给服务器层以后，MySQL服务器才能应用WHERE子句。</p>
<p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">mysql&gt; set AUTOCOMMIT=0;</div><div class="line">mysql&gt; BEGIN;</div><div class="line">mysql&gt; SELECT actor_id FROM actor WHERE actor_id &lt; 5 AND actor_id &lt;&gt; 1 FOR UPDATE;</div><div class="line"></div><div class="line">+----------+</div><div class="line">| actor_id | </div><div class="line">+----------+</div><div class="line">| 2        |</div><div class="line">| 3        |</div><div class="line">| 4        |</div><div class="line">+----------+</div></pre></td></tr></table></figure></p>
<p>这条查询仅仅会返回2～4之间的行，但是实际上获取了1～4之间的行的排他锁。InnoDB会锁住第一行。此时其他事务想获取第一行数据时不得不等待。</p>
<p>关于InnoDB，索引和锁有一些很少有人知道的细节：InnoDB在二级索引上使用共享（读）锁，但访问主键索引需要排他（写）锁。这消除了使用覆盖索引的可能性，并且使得<code>SELECT FOR UPDATE</code> 比 <code>LOCK IN SHARE MODE</code> 或 非锁定查询要慢很多。</p>
<h3 id="优化排序"><a href="#优化排序" class="headerlink" title="优化排序"></a>优化排序</h3><p>对于那些选择性非常低的列，可以增加一些特殊的索引来做排序。例如，可以创建（sex, rating）索引用于下面的查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT &lt;cols&gt; FROM profiles WHERE sex=&apos;M&apos; ORDER BY rating LIMIT 10;</div></pre></td></tr></table></figure></p>
<p>这个查询同时使用了ORDER BY 和 LIMIT，如果没有索引的话会很慢。</p>
<p>即使有索引，如果用户界面上需要翻页，并且翻页到比较靠后时查询也可能非常慢。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt;SELECT &lt;cols&gt; FROM profiles WHERE sex=&apos;M&apos; ORDER BY rating LIMIT 100000, 10;</div></pre></td></tr></table></figure></p>
<p>无论如何创建索引，这种查询都是个严重的问题，因为随着偏移量的增加，MySQL需要花费大量的时间来扫描需要丢弃的数据。一个更好的办法是限制用户能够翻页的数量，实际上这对用户体验的影响不大，因为用户很少会真正在乎搜索结果的第100000页。</p>
<p>优化这类搜索的另一个比较好的策略是使用延迟关联，通过使用覆盖索引查询返回需要的主键，再根据这些主键关联原来的表获取需要的行。这可以减少MySQL扫描那些需要丢弃的行数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT &lt;cols&gt; FROM profiles INNER JOIN (</div><div class="line">-&gt; SELECT &lt;primary key cols&gt; FROM profiles</div><div class="line">-&gt; WHERE x.sex=&apos;M&apos; ORDER BY rating LIMIT 100000, 10</div><div class="line">-&gt; ) AS x USING(&lt;primary key cols&gt;);</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/数据库相关/mysql/创建高性能的索引/" data-id="cjei8qk9i00de6gblm811qmha" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网络/HTTP完整请求过程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/网络/HTTP完整请求过程/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络/">网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/网络/HTTP完整请求过程/">HTTP完整请求过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：</p>
<ol>
<li><p>建立TCP连接：</p>
<p> 在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，</p>
<p> 即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能进行更高层协议的连接，</p>
<p> 因此，首先要建立TCP连接，一般TCP连接的端口号是80。</p>
</li>
<li><p>Web浏览器向Web服务器发送请求命令： </p>
<p> 一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。</p>
</li>
</ol>
<ol>
<li><p>Web浏览器发送请求头信息 ：</p>
<p> 浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。</p>
</li>
</ol>
<ol>
<li><p>Web服务器应答 ：</p>
<p> 客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。</p>
</li>
</ol>
<ol>
<li><p>Web服务器发送应答头信息： </p>
<p> 正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。</p>
</li>
</ol>
<ol>
<li><p>Web服务器向浏览器发送数据： </p>
<p> Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。</p>
</li>
<li><p>Web服务器关闭TCP连接 ：</p>
<p> 一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive；</p>
<p> TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>
<p> ​</p>
</li>
</ol>
<p>下面以Chrome浏览器为例，分析一下整个过程：</p>
<ol>
<li><strong>域名解析</strong></li>
</ol>
<p>首先Chrome浏览器会解析 www.baidu.com 这个域名（准确的叫法应该是主机名）对应的IP地址。怎么解析到对应的IP地址？</p>
<p>① Chrome浏览器 会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有www.baidu.com 对应的条目，而且没有过期，如果有且没有过期则解析到此结束。</p>
<pre><code>注：我们怎么查看Chrome自身的缓存？可以使用 chrome://net-internals/#dns 来进行查看
</code></pre><p>② 如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索解析到此结束.</p>
<pre><code>注：怎么查看操作系统自身的DNS缓存，以Windows系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看  
</code></pre><p>③ 如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于C:\Windows\System32\drivers\etc），看看这里面有没有该域名对应的IP地址，如果有则解析成功。</p>
<p>④ 如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找打根域的DNS地址，就会向其发起请求（请问www.baidu.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.baidu.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.baidu.com这个域名的IP地址，但是我知道www.baidu.com这个域的DNS地址，你去找它去，于是运营商的DNS又向www.baidu.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.baidu.com这个域名的IP地址是多少？），这个时候www.baidu.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.baidu.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.baidu.com 对应的IP地址，该进行一步的动作了。</p>
<ol>
<li><strong>发起TCP的3次握手</strong>     </li>
</ol>
<p>拿到域名对应的IP地址之后，User-Agent（一般是指浏览器）会以一个随机端口（1024 &lt; 端口 &lt; 65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求（原始的http请求经过TCP/IP4层模型的层层封包）到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。</p>
<p>如下图：<br><img src="http://s3.51cto.com/wyfs02/M01/11/7C/wKioL1LSW6rjI1nhAAE63Uv8ZRY731.jpg?_=5959335" alt="image"><br>1） Client首先发送一个连接试探，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示Client自己的初始序号（seq = 0 就代表这是第0号包），这时候Client进入syn_sent状态，表示客户端等待服务器的回复</p>
<p>2） Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN 和 ACK都置1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server 自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待client的确认。</p>
<p>3） Client收到确认后还需再次发送确认，同时携带要发送给Server的数据。ACK 置1 表示确认号ack= y + 1 有效（代表期望收到服务器的第1个包），Client自己的序号seq= x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到Client的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。</p>
<ol>
<li><strong>建立TCP连接后发起http请求</strong>    </li>
</ol>
<p>HTTP请求信息由3部分组成：   </p>
<ul>
<li>请求行（请求方法（GET/POST）、URI、协议/版本）</li>
<li>请求头(Request Header)</li>
<li>请求正文</li>
</ul>
<p>http响应消息由3部分组成：</p>
<ul>
<li>状态行</li>
<li>响应头(Response Header)</li>
<li>响应正文</li>
</ul>
<ol>
<li><strong>服务器端响应http请求，浏览器得到html代码</strong></li>
<li><strong>浏览器解析html代码，并请求html代码中的资源</strong></li>
<li><strong>浏览器对页面进行渲染呈现给用户</strong></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/网络/HTTP完整请求过程/" data-id="cjei8qk27002a6gblhzwrbte5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Eclipse/">Eclipse</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Github/">Github</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Cookie/">Cookie</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JAXB/">JAXB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JavaMail/">JavaMail</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/基础/">基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/数据类型/">数据类型</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/日记/">日记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/时间日期/">时间日期</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/线程/">线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/网络NIO/">网络NIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/队列/">队列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/集合/">集合</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Application-Event/">Application Event</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/JPA/">JPA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Security/">Security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Spring-Boot/">Spring Boot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Spring-Session/">Spring Session</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Task/">Task</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-MVC/">spring MVC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-data-redis/">spring data redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/基础/">基础</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/">前端技术相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/forever/">forever</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/javascript/">javascript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库相关/">数据库相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据库相关/mysql/">mysql</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/">服务器相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hessian/">Hessian</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hudson-Jenkins/">Hudson & Jenkins</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Memcached/">Memcached</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Nginx/">Nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Tomcat/">Tomcat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/red5/">red5</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/resin/">resin</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/正则表达式/">正则表达式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/08/正则表达式/正则表达式/">正则表达式</a>
          </li>
        
          <li>
            <a href="/2018/02/25/Java/集合/HashSet原理/">HashSet原理</a>
          </li>
        
          <li>
            <a href="/2018/02/25/Java/分布式/分布式事务/">分布式事务</a>
          </li>
        
          <li>
            <a href="/2018/02/25/Java/分布式/分布式锁/">分布式锁</a>
          </li>
        
          <li>
            <a href="/2018/02/25/Java/集合/几种常见的map/">几种常见的map</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 LeoChan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>