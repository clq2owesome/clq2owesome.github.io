<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LeoChan&#39;s 个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="描述啊">
<meta property="og:type" content="website">
<meta property="og:title" content="LeoChan&#39;s 个人博客">
<meta property="og:url" content="https://clq2owesome.github.io/page/2/index.html">
<meta property="og:site_name" content="LeoChan&#39;s 个人博客">
<meta property="og:description" content="描述啊">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeoChan&#39;s 个人博客">
<meta name="twitter:description" content="描述啊">
  
    <link rel="alternate" href="/atom.xml" title="LeoChan&#39;s 个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LeoChan&#39;s 个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术都是通用的，重要的是是否具有自主解决问题的能力！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://clq2owesome.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Java/基础/java运行期优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/基础/java运行期优化/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/基础/java运行期优化/">java运行期优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在部分的商用虚拟机（Sun HotSpot， IMB J9）中，Java程序最初是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码定位“<strong>热点代码</strong>”（Hot Spot Code）。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为<strong>即时编译器</strong>（Just In TimenCompiler，简称JIT编译器）。</p>
<p>即时编辑器并不是虚拟机必须的部分，Java虚拟机规范并没有规定Java虚拟机内必须要有即时编译器的存在，更没有限定或指导即时编译器应该如何实现。但是，即时编译器编译性能的好坏，代码优化程度的高低却是衡量一款商用虚拟机优秀与否的最关键的技术指标之一。</p>
<h3 id="HotSpot虚拟机内的即时编译器"><a href="#HotSpot虚拟机内的即时编译器" class="headerlink" title="HotSpot虚拟机内的即时编译器"></a>HotSpot虚拟机内的即时编译器</h3><h4 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h4><p>解释器与编译器两者各有优势：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。</p>
<p>当程序运行环境中内存资源限制较大（如部分嵌入式系统中），可以使用解释执行节约内存，反之可以使用编译执行来提升效率。同时，解释器还可以作为编译器激进优化时的一个“逃生门”，让编译器根据概率选择一些大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，如加载了新类后类型继承结构出现变化，出现“罕见陷阱”时可以通过逆优化退回到解释状态继续执行。如下图所示：<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/jieshi.png" alt="image"></p>
<p>HotSpot虚拟机中内置了两个即时编译器，分别称为<strong>Client Compiler</strong>（C1 编译器） 和 <strong>Server Compiler</strong>（C2 编译器），默认采用解释器与其中一个编译器直接配合的方式工作，程序使用哪个编译器，取决于虚拟机运行的模式，HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用“<strong>-client</strong>”或“<strong>-server</strong>”参数去强制指定虚拟机运行在Client模式或Server模式。</p>
<p>虚拟机中的三种模式：</p>
<ul>
<li>混合模式（Mixed Mode）：解释器与编译器搭配使用的方式</li>
<li>解释模式（Interpreted Mode）：使用参数“-Xint”强制虚拟机运行于解释模式，这时编译器完全不介入工作，全部代码都使用解释方式执行</li>
<li>编译模式（Compiled Mode）：使用参数“—Xcomp”强制让虚拟机运行于编译模式，这时将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程</li>
</ul>
<p>由于即使编译器编译本地代码需要占用程序运行时间，要编译出优化程度更高的代码，所花费的时间可能更长；而且想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，这对解释执行的速度也有影响。  </p>
<p>为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot虚拟机还会逐渐启用<strong>分层编译</strong>（Tiered Compilation）的策略。这个策略最终在JDK1.7的Server模式虚拟机中作为默认编译策略被开启。</p>
<p>分层编译根据编译器编译，优化的规模与耗时，划分出不同的编译层次，其中包括：</p>
<ol>
<li>第0层，程序解释执行，解释器不开启性能监控功能（Profiling）。可触发第1层编译。</li>
<li>第1层，也称为C1编译，将字节码编译为本地代码，进行简单，可靠的优化，如有必要将加入性能监控的逻辑。</li>
<li>第2层（或2层以上），也称为C2编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化</li>
</ol>
<p>实施分层编译后，Client Compiler 和 Server Compiler将会同时工作，许多代码都可能会被多次编译，用Client Compiler获取更高的编译速度，用Server Compiler来获取更好的编译质量，在解释执行的时候也无须再承担收集性能监控信息的任务。</p>
<h4 id="编译对象和触发条件"><a href="#编译对象和触发条件" class="headerlink" title="编译对象和触发条件"></a>编译对象和触发条件</h4><p>在运行过程中会被即时编译器编译的“热点代码”有两类，即：</p>
<ul>
<li>被多次调用的方法</li>
<li>被多次执行的循环体</li>
</ul>
<p>方法和循环体都是以整个方法作为<strong>编译对象</strong>的。这种编译方式因为编译发生在方法执行过程之中，因此形象地称之为<strong>栈上替换</strong>（On Stack Replacement，简称<strong>OSR编译</strong>）。</p>
<p>判断一段代码是不是热点代码，是不是需要触发即时编译，这样的行为称为<strong>热点探测</strong>（Hot Spot Detection）。目前有两种方式：</p>
<ul>
<li><strong>基于采样的热点探测</strong>（Sample Based Hot Spot Detection）：采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”。<ul>
<li>好处：实现简单，高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可）</li>
<li>缺点：很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测</li>
</ul>
</li>
<li><strong>基于计数器的热点探测</strong>（Counter Based Hot Spot Detection）：采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值就认为它是“热点方法”。<ul>
<li>好处：统计结果相对来说更加精确和严谨</li>
<li>缺点：实现起来麻烦一些，需要为每个方法建立并维护计数器，而不能直接获取到方法的调用关系</li>
</ul>
</li>
</ul>
<p>在HotSpot虚拟机中使用的是第二种方式，因此它为每个方法准备了两类计数器：<strong>方法调用计数器</strong>（Invocation Counter）和<strong>回边计数器</strong>（Back Edge Counter）。</p>
<h6 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h6><p>默认阀值在Client模式下是1500次，在Server模式下是10000次，可以通过参数<code>-XX:CompileThreshold</code>来设定。</p>
<p><strong>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。如果已超过阀值，那么将会向即时编译器提交一个该方法的代码编译请求</strong>。</p>
<p>如果不做任何设置，执行引擎并不会同步等待编译请求完成，而是继续进行解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成。当编译工作完成之后，这个方法的调用入口地址就会被系统自动改写成新的，下一次调用该方法时 就会使用已编译的版本，如下图所示：<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/jit.png" alt="image">   </p>
<p><strong>方法调用计数器热度的衰减</strong>（Counter Decay）：如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行效率，即一段时间之内方法被调用的次数。超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程就称为方法调用计数器热度的衰减。而这段时间就称为<strong>此方法统计的半衰周期</strong>（Counter Half Life Time）。</p>
<p><code>-XX:-UseCounterDeacy</code>：关闭热度衰减<br><code>-XX:CounterHalfLifeTime</code>：设置半衰周期的时间，单位是秒</p>
<h6 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h6><p>通过参数：<code>-XX:OnStackReplacPercentage</code>来间接调整回边计数器的阀值</p>
<ul>
<li><p>Client模式下：<br>  回边计数器的阀值计算公式为：<strong>方法调用计数器阀值 x OSR比率（OnStackReplacePercentage） / 100</strong>   </p>
<p>  其中，OnStackReplacePercentage默认值为933，如果都取默认值，那Client模式虚拟机的回边计数器的阀值为13995</p>
</li>
<li><p>Server模式下：<br>  回边计数器的阀值计算公式为：<strong>方法调用计数器阀值 x ( OSR比率（OnStackReplacePercentage） - 解释器监控比率（InterpreterProfilePercentage） ) / 100</strong>  </p>
<p>  其中，OnStackReplacePercentage默认值为140，InterpreterProfilePercentage默认值为33，如果都取默认值，那Server模式虚拟机的回边计数器的阀值为10700</p>
</li>
</ul>
<p><strong>当解释器遇到一条回边指令时，会先查找讲要执行的代码片段是否有已经编译好的版本，如果有，它将会优先执行已编译的代码，否则就把回边计数器的值加1，然后判断方法调用计数器与回边计数之和是否超过回边计数器的阀值。当超过阀值的时候，将会提交一个OSR编译请求，并且把回边计数器的值降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果</strong>，如下图所示：<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/osr.png" alt="image">   </p>
<p>与方法计数不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出状态，这样下次再进入该方法的时候就会执行标准编译过程。</p>
<p>注意：上面的描述都是仅仅描述了Client VM的即时编译方式，对于Server VM来说，执行情况会比上面的描述更复杂一些。</p>
<h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><p>在默认设置下，无论是方法调用产生的即时编译请求，还是OSR编译请求，虚拟机在代码编译器还未完成之前，都仍然将按照解释方式继续执行，而编译动作则在后台的编译线程中进行。用户可以通过参数<code>-XX:-BackgroundCompilation</code>来禁止后台编译，在禁止后台编译后，一旦达到JIT的编译条件，执行线程向虚拟机提交编译请求后将会一直等待，直到编译过程完成后再开始执行编译器输出的本地代码。</p>
<p>Client Compiler编译的三个过程：</p>
<ol>
<li>在第一个阶段，一个平台独立的前端字节码构造成一种高级中间代码表示（High-Level Intermediate Repressentation，HIR）。HIR使用静态单分配（Static Single Assignment，SSA）的形式来代表代码值，这可以使得一些在HIR的构造过程之中和之后进行的优化动作更容易实现。在此之前编译器会在字节码上完成一部分基础优化，如方法内联，常量传播等优化将会在字节码被构造成HIR之前完成</li>
<li>在第二阶段，一个平台相关的后端从HIR中产生低级中间代码表示（Low-Level Intermediate Representation，LIR），而在此之前会在HIR上完成另外一些优化，如空值检查消除，范围检查消除等，以便让HIR达到更高效的代码表示形式</li>
<li>最后阶段是在平台相关的后端使用线性扫描算法（Linear Scan Register Allocation）在LIR上分配寄存器，并在LIR上做窥孔（Peephole）优化，然后产生机器代码。</li>
</ol>
<p>各阶段的流程如下图所示：<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/com1.png" alt="image"></p>
<h4 id="最具代表性的优化技术"><a href="#最具代表性的优化技术" class="headerlink" title="最具代表性的优化技术"></a>最具代表性的优化技术</h4><ul>
<li>语言无关的经典优化技术之一：公共子表达式消除</li>
<li>语言无关的经典优化技术之一：数组范围检查消除</li>
<li>最重要的优化技术之一：方法内联</li>
<li>最前沿的优化技术之一：逃逸分析</li>
</ul>
<h6 id="公共子表达式消除"><a href="#公共子表达式消除" class="headerlink" title="公共子表达式消除"></a>公共子表达式消除</h6><p>含义：如果一个表达式E已经计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成为了<strong>公共子表达式</strong>。对于这种表达式，没有必要花时间再对它进行计算，只需要直接用前面计算过的表达式结果代替E就可以了。如果这种优化仅限于程序的基本块内，便称为<strong>局部公共子表达式消除</strong>。如果这种优化的范围涵盖了多个基本块，那就称为<strong>全局公共子表达式消除</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">假设有如下代码：</div><div class="line">int d = (c * b) * 12 + a + (a + b * c);</div><div class="line">当这段代码进入到虚拟机即时编译器后，它将进行如下优化：</div><div class="line">编译器检测到“c*b”与“b*c”是一样的表达式，而且在计算期间b与c的值是不变的，</div><div class="line">因此，这条表达式就可能被视为：</div><div class="line">int d = E * 12 + a + (a + E);</div><div class="line">这时，编译器还可能进行另外一种优化：代数化简</div><div class="line">int d = E * 13 + a * 2;</div></pre></td></tr></table></figure></p>
<h6 id="数组边界检查消除"><a href="#数组边界检查消除" class="headerlink" title="数组边界检查消除"></a>数组边界检查消除</h6><p>Java语言是一门动态安全的语言，对数组的读写访问也不像C，C++那样在本质上是裸指针操作。</p>
<p>如果有一个数组foo[]，在java语言中访问数组元素foo[i]的时候系统将会自动进行上下界的范围检查，即检查i必须满足i&gt;=0&amp;&amp;i&lt;foo.length这个条件，否则将抛出一个运行时异常：java.lang.ArrayIndexOutOfBoundsException。这对软件开发者来说是一件很好的事情，即使程序员没有专门编写防御代码，也可以避免大部分的溢出攻击。但是对于虚拟机的执行子系统来说，每次数组元素的读写都带有一次隐含的条件判定操作，对于拥有大量数组访问的程序代码，这无疑是一种性能负担。</p>
<p>无论如何，为了安全，数组边界检查肯定是必须做的，但数组边界检查是不是必须在运行期间一次不漏地检查则是可以“商量”的。例如下面这个简单的情况：数组下标是一个常量，如foo[3]，只要在编译期根据数据流分析来确定foo.length的值，并判断下标“3”没有越界，执行的时候就无须判断了。更加常见的情况是数组访问发生在循环之中，并且使用循环变量来进行数组访问，如果编译器只要通过数据流分析就可以判定循环变量的取值范围永远在区间[0, foo.length)之内，那在整个循环中就可以把数组的上下界检查消除，这可以节省很多次的条件判断操作。</p>
<p>要消除这些隐式开销，除了如数组边界检查优化这种尽可能把运行期检查提到编译器完成的思路之外，另外还有一种避免思路-<strong>隐式异常处理</strong>。Java中空指针检查和算术运算中除数为0的检查都采用了这种思路。举个例子，例如程序访问一个对象（假设对象叫foo）的某个属性（假设属性叫value），那以java伪代码来表示虚拟机访问foo.value过程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (foo != null) &#123;</div><div class="line">    return foo.value;</div><div class="line">&#125; else &#123;</div><div class="line">    throw new NullPointException();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在用隐式异常优化后，虚拟机会把上面的伪代码所表示的访问过程变为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">    return foo.value;</div><div class="line">&#125; catch(segment_fault) &#123;</div><div class="line">    uncommon_trap();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虚拟机会注册一个Segment Fault信号的异常处理器，这样当foo不为空的时候，对value的访问是不会额外消耗一次对foo判空的开销的。代价就是当foo真的为空时，必须转入到异常处理器中恢复并抛出NullpointException异常，这个过程必须从用户态转到内核态中处理，结束后再回到用户态，速度远比一次判空检查慢。当foo极少为空的时候，隐式异常优化是值得的，但假如foo经常为空的话，这样的优化反而会让程序更慢，还好HotSpot虚拟机足够“聪明”，它会根据运行期收集到的Profile信息自动选择最优方案。</p>
<p>与语言相关的其他消除操作还有：<strong>自动装箱消除</strong>（Autobox Elimination），<strong>安全点消除</strong>（Safepoint Elimination），<strong>消除反射</strong>（Dereflection）等</p>
<h6 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h6><p>编译器最重要的优化手段之一，除了消除方法调用的成本外，它更重要的意义是为其他优化手段建立良好的基础。<br>例如：内联对其他优化手段的意义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static void foo(Object obj) &#123;</div><div class="line">    if(obj != null) &#123;</div><div class="line">        System.out.println(&quot;do something&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void testInline(String[] args) &#123;</div><div class="line">    Object obj = null;</div><div class="line">    foo(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>事实上，testInline()方法内部全部都是无用的代码，如果不做内联，后续即使进行了无用代码消除的优化，也无法发现任何“Dead Code”，因为如果分开来看，foo()和testInline()两个方法里面的操作都可能是有意义的。</p>
<p>含义：<strong>方法内联的优化行为看起来很简单，不过是把目标方法的代码“复制”到发起调用的方法之中，避免发生真实的方法调用而已</strong>。但实际上Java虚拟机中的内联过程远远没有那么简单，因为如果不是即时编译器做了一些特别的努力，按照经典编译原理的优化理论，大多数的java方法都无法进行内联。</p>
<p>只有使用invokespecial指令调用的私有方法，实例构造器，父类方法以及使用invokestatic指令进行调用的静态方法才是在编译器进行解析的，除了上述4种方法外，其他的java方法调用都需要在运行时进行方法接收者的多态选择，并且都有可能存在多于一个版本的方法接收者（最多再除去被final修饰的方法这种特殊情况，尽管它使用invokevirtual指令调用，但也是非虚方法，Java语言规范中明确说明了这点）。简而言之，<strong>Java语言中默认的实例方法是虚方法</strong>。</p>
<p>为了解决虚方法的内联问题，Java虚拟机团队想了很多办法，首先是引入了一种名为“<strong>类型继承关系分析</strong>”（Class Hierarchy Analysis， <strong>CHA</strong>）的技术。<strong>这是一种基于整个应用程序的类型分析技术，它用于确定在目前已加载的类中，某个接口是否有多于一种的实现，某个类是否存在子类，子类是否为抽象类等信息</strong>。</p>
<p>编译器在进行内联时，如果是非虚方法，那么直接进行内联就可以了，这时候的内联是有稳定前提保障的。如果遇到虚方法，则会向CHA查询此方法在当前程序下是否有多个目标版本可供选择，如果查询结果只有一个版本，那也可以进行内联，不过这种内联就属于激进优化，需要预留一个“逃生门”（Guard条件不成立时的Slow Path），称为<strong>守护内联</strong>（Guarded Inlining）。如果程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的接收者的继承关系发生变化的类，那这个内联优化的代码就可以一直使用下去。但如果加载了导致继承关系发生变化的新类，那就需要抛弃已经编译的代码，退回到解释状态执行，或者重新编译。</p>
<p>如果向CHA查询出来的结果是有多个版本的目标方法可供选择，则编译器还将会进行最后一次努力，使用内联缓存（Inline Cache）来完成方法内联，这是一个建立在目标方法正常入口之前的缓存，它的工作原理大致是：<strong>在未发生方法调用之前，内联缓存状态为空，当第一次调用发生后，缓存记录下方法接收者的版本信息，并且每次进行方法调用时都比较接收者版本，如果以后进来的每次调用的方法接收者版本都是一样的，那这个内联还可以一直用下去。如果发生了方法接收者不一致的情况，就说明程序真正使用了虚方法的多态特性，这时才会取消内联，查找虚方法表进行方法分派</strong>。</p>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>逃逸分析（Escape Analysis）是目前java虚拟机中比较前沿的优化技术，它与类型继承关系分析一样，并不是直接优化代码的手段，而是为其他优化手段提供依据的分析技术。</p>
<p>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为<strong>方法逃逸</strong>。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为<strong>线程逃逸</strong>。</p>
<p>如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可能会为这个变量进行一些高效的优化：</p>
<ul>
<li>栈上分配（Stack Allocation）：Java虚拟机中，在Java堆上分配创建对象的内存空间几乎是Java程序员都清楚的常识了，Java堆中的对象对于各个线程都是共享可见的，只要持有这个对象的引用，就可以访问堆中存储的对象数据。虚拟机的垃圾收集系统可以回收堆中不再使用的对象，但回收动作无论是筛选可回收对象，还是回收和整理内存都需要耗费时间。<strong>如果确定一个对象不会逃逸除方法之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中，不会逃逸的局部对象所占的比例很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾收集系统的压力将会小很多</strong>。</li>
<li>同步消除（Synchronization Elimination）；线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那这个变量的读写肯定不会有竞争，对这个变量实施的同步措施也就可以消除掉。</li>
<li>标量替换（Scalar Replacement）：标量（Scalar）是指一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型（int，long等数值类型以及reference类型等）都不能再进一步分解，它们就可以称为<strong>标量</strong>。相对的，如果一个数据可以继续分解，那它就称作<strong>聚合量</strong>（Aggregate），Java中的对象就是最典型的聚合量。如果把一个Java对象拆散，根据程序访问的情况，将其使用到的成员变量恢复原始类型来访问就叫做<strong>标量替换</strong>。如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话，那程序真正执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。将对象拆分后，除了可以让对象的成员变量在栈上（栈上存储的数据，有很大的概率会被虚拟机分配至物理机器的高速寄存器中存储）分配和读写之外，还可以为后续进一步的优化手段创建条件。</li>
</ul>
<p>逃逸分析不成熟的原因主要是不能保证逃逸分析的性能收益必定高于它的消耗。</p>
<p><code>-XX:+DoEscapeAnalysis</code>:手动开启逃逸分析<br><code>-XX:+PrintEscapeAnalysis</code>:查看分析结果<br><code>-XX:+EliminateAllocations</code>:开启标量替换<br><code>-XX:+EliminateLocks</code>:开启同步消除<br><code>-XX:+PrintEliminateAllocations</code>:查看标量的替换情况   </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/基础/java运行期优化/" data-id="cjfvvphkm005wm9fyhjkhxjlv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/集合/几种常见的map" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/集合/几种常见的map/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/集合/">集合</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/集合/几种常见的map/">几种常见的map</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>java为数据结构中的映射定义了一个接口java.util.Map;它有四个实现类,分别是HashMap Hashtable LinkedHashMap 和TreeMap.<br>Map主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重复。</p>
<h3 id="Hashmap"><a href="#Hashmap" class="headerlink" title="Hashmap"></a>Hashmap</h3><p><img src="http://img.blog.csdn.net/20150725203054803" alt="image"><br>Hashmap 是一个最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。</p>
<p>一般情况下，我们用的最多的是HashMap,在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。如果需要输出的顺序和输入的相同,那么用LinkedHashMap 可以实现,它还可以按读取顺序来排列.</p>
<p>HashMap是一个最常用的Map，它根据键的hashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为NULL，允许多条记录的值为NULL。</p>
<p>HashMap不支持线程同步，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致性。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。</p>
<p>在散列表中有一下名词需要了解: </p>
<ul>
<li><code>Capacity</code>：容量, hash表里bucket(桶)的数量, 也就是散列数组大小.默认为16，如果HashMap要存x=100个元素，那么HashMap的容量应该设置为2\^n次方，由于100/0.75 = 133.33。为了防止rehash，向上取整，为134。最接近134的数为2\^n=128,由于128比134小，所以要取n的下一个数，即2\^n=256,所以HashMap的初始容量应该为256</li>
<li><code>Initial capacity</code>：初始容量, 创建hash表的时 初始bucket的数量, 默认构建容量是16. 也可以使用特定容量. </li>
<li><code>Size</code> ： 大小, 当前散列表中存储数据的数量. </li>
<li><code>Load factor</code>：加载因子, 默认值0.75(就是75%), 向散列表增加数据时如果 size/capacity 的值大于Load factor则发生扩容并且重新散列(rehash).<br>那么当加载因子较小时候散列查找性能会提高, 同时也浪费了散列桶空间容量. 0.75是性能和空间相对平衡结果. 在创建散列表时候指定合理容量, 从而可以减少rehash提高性能。 </li>
</ul>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(10000);</div></pre></td></tr></table></figure></p>
<p>存入大量数据时可以使用该方法，减少扩容次数，提高性能 </p>
<p>如果数据量很小，不推荐使用此方法，会造成空间浪费，用默认无参的即可</p>
<h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>Hashtable与 HashMap类似,它继承自Dictionary类，不同的是:它不允许记录的键或者值为空;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了 Hashtable在写入时会比较慢。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashMap 是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。</p>
<p>HashMap和LinkedHashMap区别在于HashMap是无序的，LinkedHashMap是有序的。在使用HashMap时，要根据实际情况选择最优的解决方案，降低性能和空间上的浪费。</p>
<p>LinkedHashMap维护着一个双向循环链表。此链表定义了迭代顺序，该迭代顺序通常就是将存放元素的顺序。</p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/集合/几种常见的map/" data-id="cjfvvphlt008km9fyrkrcvjah" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/基础/序列化和反序列化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/基础/序列化和反序列化/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/基础/序列化和反序列化/">序列化和反序列化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>将 Java 对象序列化为二进制文件的 Java 序列化技术是 Java 系列技术中一个较为重要的技术点，在大部分情况下，开发人员只需要了解被序列化的类需要实现Serializable接口，使用 ObjectInputStream和ObjectOutputStream 进行对象的读写。然而在有些情况下，光知道这些还远远不够</p>
</blockquote>
<h2 id="java序列化简介"><a href="#java序列化简介" class="headerlink" title="java序列化简介"></a>java序列化简介</h2><p>序列化就是指对象通过写出描述自己状态的数值来记录自己的过程，即将对象表示成一系列有序字节，java提供了将对象写入流和从流中恢复对象的方法。对象能包含其它的对象，而其它的对象又可以包含另外的对象。JAVA序列化能够自动的处理嵌套的对象。对于一个对象的简单域，writeObject()直接将其值写入流中。当遇到一个对象域时，writeObject()被再次调用，如果这个对象内嵌另一个对象，那么，writeObject()又被调用，直到对象能被直接写入流为止。程序员所需要做的是将对象传入ObjectOutputStream的writeObject()方法，剩下的将有系统自动完成。    </p>
<p>要实现序列化的类必须实现的java.io.Serializable或java.io.Externalizable接口，否则将产生一个NotSerializableException。该接口内部并没有任何方法，它只是一个”tagging interface”，仅仅”tags”它自己的对象是一个特殊的类型。类通过实现 java.io.Serializable接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或字段，仅用于标识可序列化的语义。Java的”对象序列化”能让你将一个实现了Serializable接口的对象转换成一组byte，这样日后要用这个对象时候，你就能把这些byte数据恢复出来，并据此重新构建那个对象了。</p>
<h2 id="序列化的必要性及目的"><a href="#序列化的必要性及目的" class="headerlink" title="序列化的必要性及目的"></a>序列化的必要性及目的</h2><p>Java中，一切都是对象，在分布式环境中经常需要将Object从这一端网络或设备传递到另一端。这就需要有一种可以在两端传输数据的协议。Java序列化机制就是为了解决这个问题而产生。</p>
<p>Java序列化支持的两种主要特性：</p>
<ul>
<li>Java 的RMI使本来存在于其他机器的对象可以表现出就象本地机器上的行为。</li>
<li>将消息发给远程对象时，需要通过对象序列化来传输参数和返回值.</li>
</ul>
<p>Java序列化的目的：</p>
<ul>
<li>支持运行在不同虚拟机上不同版本类之间的双向通讯；</li>
<li>定义允许JAVA类读取用相同类较老版本写入的数据流的机制；</li>
<li>定义允许JAVA类写用相同类较老版本读取的数据流的机制；</li>
<li>提供对持久性和RMI的序列化；</li>
<li>产生压缩流且运行良好以使RMI能序列化；</li>
<li>辨别写入的是否是本地流；</li>
<li>保持非版本化类的低负载；</li>
</ul>
<h2 id="序列化异常"><a href="#序列化异常" class="headerlink" title="序列化异常"></a>序列化异常</h2><p>序列化对象期间可能抛出6种异常：</p>
<ul>
<li>InvalidClassException 通常在重序列化流无法确定类型时或返回的类无法在取得对象的系统中表示时抛出此异常。异常也在恢复的类不声明为public时或没有public缺省（无变元）构造器时抛出。</li>
<li>NotSerializableException 通常由具体化对象（负责自身的重序列化）探测到输入流错误时抛出。错误通常由意外不变量值指示，或者表示要序列化的对象不可序列化。</li>
<li>StreamCorruptedException 在存放对象的头或控制数据无效时抛出。</li>
<li>OptionalDataException 流中应包含对象但实际只包含原型数据时抛出。</li>
<li>ClassNotFoundException 流的读取端找不到反序列化对象的类时抛出。</li>
<li>IOException  要读取或写入的对象发生与流有关的错误时抛出。</li>
</ul>
<h2 id="序列化一个对象"><a href="#序列化一个对象" class="headerlink" title="序列化一个对象"></a>序列化一个对象</h2><p>序列化一个对象，以及对序列化后的对象进行操作，需要遵循以下3点：</p>
<ol>
<li>一个对象能够序列化的前提是实现Serializable接口或Externalizable接口，Serializable接口没有方法，更像是个标记。有了这个标记的Class就能被序列化机制处理。</li>
<li>写个程序将对象序列化并输出。ObjectOutputStream能把Object输出成Byte流。</li>
<li>要从持久的文件中读取Bytes重建对象，我们可以使用ObjectInputStream。</li>
</ol>
<p>在序列化时，有几点要注意的：</p>
<ul>
<li>当一个对象被序列化时，只序列化对象的非静态成员变量，不能序列化任何成员方法和静态成员变量。</li>
<li>如果一个对象的成员变量是一个对象，那么这个对象的数据成员也会被保存。</li>
<li>如果一个可序列化的对象包含对某个不可序列化的对象的引用，那么整个序列化操作将会失败，并且会抛出一个NotSerializableException。可以通过将这个引用标记为transient，那么对象仍然可以序列化。对于一些比较敏感的不想序列化的数据，也可以采用该标识进行修饰。</li>
</ul>
<h2 id="Java的序列化算法"><a href="#Java的序列化算法" class="headerlink" title="Java的序列化算法"></a>Java的序列化算法</h2><p>序列化算法一般会按步骤做如下事情：</p>
<ul>
<li>将对象实例相关的类元数据输出。</li>
<li>递归地输出类的超类描述直到不再有超类。</li>
<li>类元数据完了以后，开始从最顶层的超类开始输出对象实例的实际数据值。</li>
<li>从上至下递归输出实例的数据</li>
</ul>
<h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><h3 id="序列化-ID-问题"><a href="#序列化-ID-问题" class="headerlink" title="序列化 ID 问题"></a>序列化 ID 问题</h3><p>情境：两个客户端 A 和 B 试图通过网络传递对象数据，A 端将对象 C 序列化为二进制数据再传给 B，B 反序列化得到 C。    </p>
<p>问题：C 对象的全类路径假设为 com.inout.Test，在 A 和 B 端都有这么一个类文件，功能代码完全一致。也都实现了 Serializable 接口，但是反序列化时总是提示不成功。</p>
<p>解决：虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID = 1L）。清单1中，虽然两个类的功能代码完全一致，但是序列化 ID 不同，他们无法相互序列化和反序列化。</p>
<p>简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。</p>
<p>当实现java.io.Serializable接口的实体（类）没有显式地定义一个名为serialVersionUID，类型为long的变量时，Java序列化机制会根据编译的class自动生成一个serialVersionUID作序列化版本比较用，这种情况下，只有同一次编译生成的class才会生成相同的serialVersionUID 。  </p>
<p>如果我们不希望通过编译来强制划分软件版本，即实现序列化接口的实体能够兼容先前版本，未作更改的类，就需要显式地定义一个名为serialVersionUID，类型为long的变量，不修改这个变量值的序列化实体都可以相互进行串行化和反串行化。</p>
<p>清单 1. 相同功能代码不同序列化 ID 的类对比<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">package com.inout; </div><div class="line"></div><div class="line"> import java.io.Serializable; </div><div class="line"></div><div class="line"> public class A implements Serializable &#123; </div><div class="line"></div><div class="line">	 private static final long serialVersionUID = 1L; </div><div class="line"></div><div class="line">	 private String name; </div><div class="line">	</div><div class="line">	 public String getName() </div><div class="line">	 &#123; </div><div class="line">		 return name; </div><div class="line">	 &#125; </div><div class="line">	</div><div class="line">	 public void setName(String name) </div><div class="line">	 &#123; </div><div class="line">		 this.name = name; </div><div class="line">	 &#125; </div><div class="line"> &#125; </div><div class="line"></div><div class="line"> package com.inout; </div><div class="line"></div><div class="line"> import java.io.Serializable; </div><div class="line"></div><div class="line"> public class A implements Serializable &#123; </div><div class="line"></div><div class="line">	 private static final long serialVersionUID = 2L; </div><div class="line">	</div><div class="line">	 private String name; </div><div class="line">	</div><div class="line">	 public String getName() </div><div class="line">	 &#123; </div><div class="line">		 return name; </div><div class="line">	 &#125; </div><div class="line">	</div><div class="line">	 public void setName(String name) </div><div class="line">	 &#123; </div><div class="line">		 this.name = name; </div><div class="line">	 &#125; </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>序列化 ID 在 Eclipse 下提供了两种生成策略，一个是固定的 1L，一个是随机生成一个不重复的 long 类型数据（实际上是使用 JDK 工具生成），在这里有一个建议，如果没有特殊需求，就是用默认的 1L 就可以，这样可以确保代码一致时反序列化成功。那么随机生成的序列化 ID 有什么作用呢，有些时候，通过改变序列化 ID 可以用来限制某些用户的使用。  </p>
<h4 id="特性使用案例"><a href="#特性使用案例" class="headerlink" title="特性使用案例"></a>特性使用案例</h4><p>读者应该听过 Façade 模式，它是为应用程序提供统一的访问接口，案例程序中的 Client 客户端使用了该模式，案例程序结构图如图 1 所示。<br><img src="http://www.ibm.com/developerworks/cn/java/j-lo-serial/image003.gif" alt="image"><br>Client 端通过 Façade Object 才可以与业务逻辑对象进行交互。而客户端的 Façade Object 不能直接由 Client 生成，而是需要 Server 端生成，然后序列化后通过网络将二进制对象数据传给 Client，Client 负责反序列化得到 Façade 对象。该模式可以使得 Client 端程序的使用需要服务器端的许可，同时 Client 端和服务器端的 Façade Object 类需要保持一致。当服务器端想要进行版本更新时，只要将服务器端的 Façade Object 类的序列化 ID 再次生成，当 Client 端反序列化 Façade Object 就会失败，也就是强制 Client 端从服务器端获取最新程序。</p>
<h3 id="静态变量序列化"><a href="#静态变量序列化" class="headerlink" title="静态变量序列化"></a>静态变量序列化</h3><p>清单 2. 静态变量序列化问题代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class Test implements Serializable &#123;</div><div class="line"></div><div class="line">	private static final long serialVersionUID = 1L;</div><div class="line"></div><div class="line">	public static int staticVar = 5;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		try &#123;</div><div class="line">			//初始时staticVar为5</div><div class="line">			ObjectOutputStream out = new ObjectOutputStream(</div><div class="line">					new FileOutputStream(&quot;result.obj&quot;));</div><div class="line">			out.writeObject(new Test());</div><div class="line">			out.close();</div><div class="line"></div><div class="line">			//序列化后修改为10</div><div class="line">			Test.staticVar = 10;</div><div class="line"></div><div class="line">			ObjectInputStream oin = new ObjectInputStream(new FileInputStream(</div><div class="line">					&quot;result.obj&quot;));</div><div class="line">			Test t = (Test) oin.readObject();</div><div class="line">			oin.close();</div><div class="line">			</div><div class="line">			//再读取，通过t.staticVar打印新的值</div><div class="line">			System.out.println(t.staticVar);</div><div class="line">			</div><div class="line">		&#125; catch (FileNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; catch (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; catch (ClassNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>清单 2 中的 main 方法，将对象序列化后，修改静态变量的数值，再将序列化对象读取出来，然后通过读取出来的对象获得静态变量的数值并打印出来。依照清单 2，这个 System.out.println(t.staticVar) 语句输出的是 10 还是 5 呢？</p>
<p>最后的输出是 10，对于无法理解的读者认为，打印的 staticVar 是从读取的对象里获得的，应该是保存时的状态才对。之所以打印 10 的原因在于序列化时，并不保存静态变量，这其实比较容易理解，<strong>序列化保存的是对象的状态，静态变量属于类的状态</strong>，因此 序列化并不保存静态变量。</p>
<h3 id="父类的序列化与-Transient-关键字"><a href="#父类的序列化与-Transient-关键字" class="headerlink" title="父类的序列化与 Transient 关键字"></a>父类的序列化与 Transient 关键字</h3><p>情境：一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable 接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。  </p>
<p>解决：要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就 需要有默认的无参的构造函数。在父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都是默认声明的值，如 int 型的默认是 0，string 型的默认是 null。  </p>
<p>Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。 </p>
<h4 id="特性使用案例-1"><a href="#特性使用案例-1" class="headerlink" title="特性使用案例"></a>特性使用案例</h4><p>我们熟悉使用 Transient 关键字可以使得字段不被序列化，那么还有别的方法吗？根据父类对象序列化的规则，我们可以将不需要被序列化的字段抽取出来放到父类中，子类实现 Serializable 接口，父类不实现，根据父类序列化规则，父类的字段数据将不被序列化，形成类图如图 2 所示。<br><img src="http://www.ibm.com/developerworks/cn/java/j-lo-serial/image005.gif" alt="image"><br>上图中可以看出，attr1、attr2、attr3、attr5 都不会被序列化，放在父类中的好处在于当有另外一个 Child 类时，attr1、attr2、attr3 依然不会被序列化，不用重复抒写 transient，代码简洁。   </p>
<h3 id="对敏感字段加密"><a href="#对敏感字段加密" class="headerlink" title="对敏感字段加密"></a>对敏感字段加密</h3><p>情境：服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。    </p>
<p>解决：在序列化过程中，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。基于这个原理，可以在实际应用中得到使用，用于敏感字段的加密工作，清单 3 展示了这个过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">private static final long serialVersionUID = 1L;</div><div class="line"></div><div class="line">	private String password = &quot;pass&quot;;</div><div class="line"></div><div class="line">	public String getPassword() &#123;</div><div class="line">		return password;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setPassword(String password) &#123;</div><div class="line">		this.password = password;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private void writeObject(ObjectOutputStream out) &#123;</div><div class="line">		try &#123;</div><div class="line">			PutField putFields = out.putFields();</div><div class="line">			System.out.println(&quot;原密码:&quot; + password);</div><div class="line">			password = &quot;encryption&quot;;//模拟加密</div><div class="line">			putFields.put(&quot;password&quot;, password);</div><div class="line">			System.out.println(&quot;加密后的密码&quot; + password);</div><div class="line">			out.writeFields();</div><div class="line">		&#125; catch (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private void readObject(ObjectInputStream in) &#123;</div><div class="line">		try &#123;</div><div class="line">			GetField readFields = in.readFields();</div><div class="line">			Object object = readFields.get(&quot;password&quot;, &quot;&quot;);</div><div class="line">			System.out.println(&quot;要解密的字符串:&quot; + object.toString());</div><div class="line">			password = &quot;pass&quot;;//模拟解密,需要获得本地的密钥</div><div class="line">		&#125; catch (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; catch (ClassNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		try &#123;</div><div class="line">			ObjectOutputStream out = new ObjectOutputStream(</div><div class="line">					new FileOutputStream(&quot;result.obj&quot;));</div><div class="line">			out.writeObject(new Test());</div><div class="line">			out.close();</div><div class="line"></div><div class="line">			ObjectInputStream oin = new ObjectInputStream(new FileInputStream(</div><div class="line">					&quot;result.obj&quot;));</div><div class="line">			Test t = (Test) oin.readObject();</div><div class="line">			System.out.println(&quot;解密后的字符串:&quot; + t.getPassword());</div><div class="line">			oin.close();</div><div class="line">		&#125; catch (FileNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; catch (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; catch (ClassNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在清单 3 的 writeObject 方法中，对密码进行了加密，在 readObject 中则对 password 进行解密，只有拥有密钥的客户端，才可以正确的解析出密码，确保了数据的安全。执行清单 3 后控制台输出如图 3 所示。<br><img src="http://www.ibm.com/developerworks/cn/java/j-lo-serial/image007.jpg" alt="image">    </p>
<h4 id="特性使用案例-2"><a href="#特性使用案例-2" class="headerlink" title="特性使用案例"></a>特性使用案例</h4><p>RMI 技术是完全基于 Java 序列化技术的，服务器端接口调用所需要的参数对象来至于客户端，它们通过网络相互传输。这就涉及 RMI 的安全传输的问题。一些敏感的字段，如用户名密码（用户登录时需要对密码进行传输），我们希望对其进行加密，这时，就可以采用本节介绍的方法在客户端对密码进行加密，服务器端进行解密，确保数据传输的安全性。</p>
<h3 id="序列化存储规则"><a href="#序列化存储规则" class="headerlink" title="序列化存储规则"></a>序列化存储规则</h3><p>清单 4. 存储规则问题代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">ObjectOutputStream out = new ObjectOutputStream(</div><div class="line">					new FileOutputStream(&quot;result.obj&quot;));</div><div class="line">Test test = new Test();</div><div class="line">//试图将对象两次写入文件</div><div class="line">out.writeObject(test);</div><div class="line">out.flush();</div><div class="line">System.out.println(new File(&quot;result.obj&quot;).length());</div><div class="line">out.writeObject(test);</div><div class="line">out.close();</div><div class="line">System.out.println(new File(&quot;result.obj&quot;).length());</div><div class="line"></div><div class="line">ObjectInputStream oin = new ObjectInputStream(new FileInputStream(</div><div class="line">		&quot;result.obj&quot;));</div><div class="line">//从文件依次读出两个文件</div><div class="line">Test t1 = (Test) oin.readObject();</div><div class="line">Test t2 = (Test) oin.readObject();</div><div class="line">oin.close();</div><div class="line">		</div><div class="line">//判断两个引用是否指向同一个对象</div><div class="line">System.out.println(t1 == t2);</div></pre></td></tr></table></figure></p>
<p>清单 4 中对同一对象两次写入文件，打印出写入一次对象后的存储大小和写入两次后的存储大小，然后从文件中反序列化出两个对象，比较这两个对象是否为同一对象。一般的思维是，两次写入对象，文件大小会变为两倍的大小，反序列化时，由于从文件读取，生成了两个对象，判断相等时应该是输入 false 才对，但是最后结果输出如图 4 所示。<br><img src="http://www.ibm.com/developerworks/cn/java/j-lo-serial/image009.jpg" alt="image"><br>我们看到，第二次写入对象时文件只增加了 5 字节，并且两个对象是相等的，这是为什么呢？    </p>
<p>解答：Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用，上面增加的 5 字节的存储空间就是新增引用和一些控制信息的空间。反序列化时，恢复引用关系，使得清单 3 中的 t1 和 t2 指向唯一的对象，二者相等，输出 true。该存储规则极大的节省了存储空间。</p>
<h4 id="特性案例分析"><a href="#特性案例分析" class="headerlink" title="特性案例分析"></a>特性案例分析</h4><p>清单 5. 案例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;result.obj&quot;));</div><div class="line">Test test = new Test();</div><div class="line">test.i = 1;</div><div class="line">out.writeObject(test);</div><div class="line">out.flush();</div><div class="line">test.i = 2;</div><div class="line">out.writeObject(test);</div><div class="line">out.close();</div><div class="line">ObjectInputStream oin = new ObjectInputStream(new FileInputStream(</div><div class="line">					&quot;result.obj&quot;));</div><div class="line">Test t1 = (Test) oin.readObject();</div><div class="line">Test t2 = (Test) oin.readObject();</div><div class="line">System.out.println(t1.i);</div><div class="line">System.out.println(t2.i);</div></pre></td></tr></table></figure></p>
<p>清单 5 的目的是希望将 test 对象两次保存到 result.obj 文件中，写入一次以后修改对象属性值再次保存第二次，然后从 result.obj 中再依次读出两个对象，输出这两个对象的 i 属性值。案例代码的目的原本是希望一次性传输对象修改前后的状态。<br>结果两个输出的都是 1， 原因就是第一次写入对象以后，第二次再试图写的时候，虚拟机根据引用关系知道已经有一个相同对象已经写入文件，因此只保存第二次写的引用，所以读取时，都是第一次保存的对象。读者在使用一个文件多次 writeObject 需要特别注意这个问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/基础/序列化和反序列化/" data-id="cjfvvphkp0064m9fy8n3nokuu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/集合/Hashtable与ConcurrentHashMap区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/集合/Hashtable与ConcurrentHashMap区别/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/集合/">集合</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/集合/Hashtable与ConcurrentHashMap区别/">Hashtable与ConcurrentHashMap区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://note.youdao.com/yws/public/resource/60a3d77c47e4530035e791fad744780f/7194365EC16245ED9B0AAAF1128B2232" alt="image"><br>如上图所示，HashTable每次都要锁住整个结构，而ConcurrentHashMap锁的方式是稍微细粒度的。ConcurrentHashMap将hash表分为16个桶（默认值），诸如get,put,remove等常用操作只锁当前需要用到的桶。 </p>
<p>试想，原来 只能一个线程进入，现在却能同时16个写线程进入（写线程才需要锁定，而读线程几乎不受限制，之后会提到），并发性的提升是显而易见的。  </p>
<p>更令人惊讶的是ConcurrentHashMap的读取并发，因为在读取的大多数时候都没有用到锁定，所以读取操作几乎是完全的并发操作，而写操作锁定的粒度又非常细，比起之前又更加快速（这一点在桶更多时表现得更明显些）。<strong>只有在求size等操作时才需要锁定整个表</strong>。    </p>
<p>在迭代时，ConcurrentHashMap使用了不同于传统集合的快速失败迭代器的另一种迭代方式，我们称为弱一致迭代器。在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出 ConcurrentModificationException，取而代之的是在改变时new新的数据从而不影响原有的数 据，iterator完成后再将头指针替换为新的数据，这样iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变，更重要的，这保证了多个线程并发执行的连续性和扩展性，是性能提升的关键。  </p>
<h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ol>
<li>Hashtable 和 ConcurrentHashMap都是线程安全的，可以在多线程环境中运行；<br>ConcurrentHashMap 是设计为非阻塞的。在更新时会局部锁住某部分数据，但不会把整个表都锁住。同步读取操作则是完全非阻塞的。好处是在保证合理的同步前提下，效率很高。坏处 是严格来说读取操作不能保证反映最近的更新。例如线程A调用putAll写入大量数据，期间线程B调用get，则只能get到目前为止已经顺利插入的部分 数据。此外，使用默认构造器创建的ConcurrentHashMap比较占内存，如果程序需要创建巨量ConcurrentHashMap，应该在构造 时指定concurrencyLevel </li>
<li>key跟value都不能是null</li>
</ol>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol>
<li><p>两者主要是性能上的差异，Hashtable的所有操作都会锁住整个对象，，是阻塞的,虽然能够保证线程安全，但是性能较差；好处是总能获取最实时的更新，比如说线程A调用putAll写入大量数据，期间线程B调用get，线程B就会被阻塞，直到线程A完成putAll，因此线程B肯定能获取到线程A写入的完整数据。坏处是所有调用都要排队，效率较低。</p>
</li>
<li><p>ConcurrentHashMap内部使用Segment数组，每个Segment类似于Hashtable，在“写”线程或者部分特殊的“读”线程中锁住的是某个Segment对象，其它的线程能够并发执行其它的Segment对象。 ConcurrentHashMap 是设计为非阻塞的。在更新时会局部锁住某部分数据，但不会把整个表都锁住。同步读取操作则是完全非阻塞的。好处是在保证合理的同步前提下，效率很高。坏处 是严格来说读取操作不能保证反映最近的更新。例如线程A调用putAll写入大量数据，期间线程B调用get，则只能get到目前为止已经顺利插入的部分 数据。此外，使用默认构造器创建的ConcurrentHashMap比较占内存，如果程序需要创建巨量ConcurrentHashMap，应该在构造 时指定concurrencyLevel  </p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/集合/Hashtable与ConcurrentHashMap区别/" data-id="cjfvvphls008im9fym5ul7l1u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/基础/对象存活" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/基础/对象存活/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/基础/对象存活/">对象存活</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用的</p>
<p>目前主流的java虚拟机里面没有选用引用计数器算法来管理内存，其中主要的原因是它很难解决对象之间相互循环引用的问题</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p><strong>这个算法的基本思路就是通过一系列的称为“GC Roots”的对象为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的</strong>。<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/obj.png" alt="image"><br>如图，object5，object6，object7就是不可用的，可以清除的</p>
<p>在java语言中，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关</p>
<p>在JDK1.2之后，java对引用的概念进行了扩充，将引用分为<code>强引用（Strong Reference）</code>，<code>软引用（Soft Reference）</code>，<code>弱引用（Weak Reference）</code>，<code>虚引用（Phantom Reference）</code>4种，这4种引用强度依次逐渐减弱</p>
<ul>
<li>强引用就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收被引用的对象</li>
<li><strong>软引用是用来描述一些还有用但并非必需的对象</strong>。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出的异常。在JDK1.2之后，提供了SoftReference类来实现软引用</li>
<li><strong>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前</strong>。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用</li>
<li>虚引用也称为幽灵引用或者幻影引用，他是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。<strong>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</strong>。在JDK1.2之后，提供了OhantomReference类实现虚引用</li>
</ul>
<h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>即使在可达性分析算法中被可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，<strong>要真正宣告一个对象死亡，至少要经历两次标识过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”</strong>。</p>
<p>如果这个对象被判定为有必要执行finalize()方法，那么合格对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个虚拟机自动建立的，低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统奔溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()方法中成功拯救自己-只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/基础/对象存活/" data-id="cjfvvphkq0068m9fykg9y8inx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/基础/类加载机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/基础/类加载机制/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/基础/类加载机制/">类加载机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被直接使用的java类型，这就是虚拟机的类加载机制。<br>类的生命周期包括<strong>加载（Loading）</strong>、<strong>验证（Verification）</strong>、<strong>准备（Preparation）</strong>、<strong>解析（Resolution）</strong>、<strong>初始化（Initialization）</strong>、<strong>使用（Using）</strong>、<strong>卸载（Unloading）</strong>等七个阶段，其中<strong>验证、准备和解析三个部分统称为连接（Linking）</strong>。而<strong>类的加载指的就是从加载到初始化这五个阶段</strong>。    </p>
<p>虚拟机规范对于何时进行加载这一阶段并没有强制约束，但对于初始化阶段，虚拟机规范是严格规定了有且只有四种情况必须立即对类进行初始化：</p>
<ol>
<li>遇到new,getstatic,putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指定的场景是：使用new关键字实例化对象，读取或设置一个类的静态字段以及调用一个类的静态方法的时候。当然，被final修饰并在编译期就把结果放入常量池的静态字段不属于这些场景，这类静态字段的值在编译期时就会被编译器优化而直接放入常量池，其引用直接指向其在常量池的入口。</li>
<li>使用java.lang.reflect包的方法对类进行反射调用时，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的类），虚拟机会先初始化这个主类。</li>
<li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic，REF_putStatic，REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ol>
<p>以上四种场景中的行为称为对一个类进行主动引用，除此之外所有引用类的方式都不会触发初始化，称为被动引用。<br>接口的加载过程与类加载过程最主要的区别在于第三点，即当一个类在初始化时，要求其父类全部都已经初始化过了，但是当初始化一个接口时，并不需要先初始化其父接口，而是只有真正使用到父接口中的字段的时候才会初始化。</p>
<h3 id="类加载的各个阶段"><a href="#类加载的各个阶段" class="headerlink" title="类加载的各个阶段"></a>类加载的各个阶段</h3><h5 id="一个简单的类加载过程："><a href="#一个简单的类加载过程：" class="headerlink" title="一个简单的类加载过程："></a>一个简单的类加载过程：</h5><ol>
<li>寻找jre目录，寻找jvm.dll，并初始化JVM；</li>
<li>产生一个Bootstrap Loader（启动类加载器）；</li>
<li>Bootstrap Loader自动加载Extended Loader（标准扩展类加载器），并将其父Loader设为Bootstrap Loader。</li>
<li>Bootstrap Loader自动加载AppClassLoader（系统类加载器），并将其父Loader设为Extended Loader。</li>
<li>最后由AppClassLoader加载HelloWorld类。</li>
</ol>
<h5 id="类记载目录："><a href="#类记载目录：" class="headerlink" title="类记载目录："></a>类记载目录：</h5><ol>
<li>Bootstrap ClassLoader : 将存放于<java_home>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar 名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用</java_home></li>
<li>Extension ClassLoader : 将<java_home>\lib\ext目录下的，或者被java.ext.dirs系统变量所指定的路径中的所有类库加载。开发者可以直接使用扩展类加载器。</java_home></li>
<li>Application ClassLoader : 负责加载用户类路径(ClassPath)上所指定的类库,开发者可直接使用。</li>
</ol>
<p>ExtClassLoader和AppClassLoader在JVM启动后，会在JVM中保存一份，并且在程序运行中无法改变其搜索路径。如果想在运行时从其他搜索路径加载类，就要产生新的类加载器。</p>
<h5 id="类记载器特点："><a href="#类记载器特点：" class="headerlink" title="类记载器特点："></a>类记载器特点：</h5><ol>
<li>运行一个程序时，总是由AppClassLoader（系统类加载器）开始加载指定的类。</li>
<li>在加载类时，每个类加载器会将加载任务上交给其父，如果其父找不到，再由自己去加载。</li>
<li>Bootstrap Loader（启动类加载器）是最顶级的类加载器了，其父加载器为null.</li>
</ol>
<h5 id="类加载有三种方式："><a href="#类加载有三种方式：" class="headerlink" title="类加载有三种方式："></a>类加载有三种方式：</h5><ol>
<li>命令行启动应用时候由JVM初始化加载</li>
<li>通过Class.forName()方法动态加载</li>
<li>通过ClassLoader.loadClass()方法动态加载</li>
</ol>
<p>三种方式区别比较大，看个例子就明白了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class HelloWorld &#123; </div><div class="line">        public static void main(String[] args) throws ClassNotFoundException &#123; </div><div class="line">                ClassLoader loader = HelloWorld.class.getClassLoader(); </div><div class="line">                System.out.println(loader); </div><div class="line">                //使用ClassLoader.loadClass()来加载类，不会执行初始化块 </div><div class="line">                loader.loadClass(&quot;Test2&quot;); </div><div class="line">                //使用Class.forName()来加载类，默认会执行初始化块 </div><div class="line">                //Class.forName(&quot;Test2&quot;); </div><div class="line">                //使用Class.forName()来加载类，并指定ClassLoader，参数2设置为false时初始化时不执行静态块，设置为true时初始化时执行静态块</div><div class="line">                //Class.forName(&quot;Test2&quot;, false, loader); </div><div class="line">        &#125; </div><div class="line">&#125;</div><div class="line"> </div><div class="line">public class Test2 &#123; </div><div class="line">        static &#123; </div><div class="line">                System.out.println(&quot;静态初始化块执行了！&quot;); </div><div class="line">        &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有关ClassLoader还有很重要一点：<br><strong>同一个ClassLoader加载的类文件，只有一个Class实例。但是，如果同一个类文件被不同的ClassLoader载入，则会有两份不同的Class实例</strong>（前提是着两个类加载器不能用相同的父类加载器）。</p>
<p>以下对类加载的各个阶段进行简单的说明。  </p>
<ul>
<li><strong>加载阶段</strong>，虚拟机需要完成三件事：<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li><strong>在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口</strong>。</li>
</ol>
</li>
<li><strong>验证阶段</strong>，不同虚拟机会进行不同类验证的实现，但大致都会完成以下四个阶段的检验过程：文件格式验证（验证字节流是否符合Class文件格式的规范，并能被当前版本的虚拟机处理），元数据验证（对字节码描述信息进行语义分析，保证其描述信息符合java语言规范），字节码验证（对类方法体进行数据流和控制流分析，保证类的方法在运行时不会做出危害虚拟机的行为）和符号引用验证（发生在将符号引用转化为直接引用的时候，在解析阶段中发生）。</li>
<li><strong>准备阶段</strong>，正式为类成员变量（被static修饰的变量）（注意，不是实例成员变量，实例变量会在对象实例化时随着对象一起分配在java堆上）分配内存并设置类变量初始值（通常情况下是数据类型的零值，不进行赋值操作）的阶段，这些内存都将在方法区中进行分配。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例：public static int value=123;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>则在准备阶段过后，value的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<client>()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。</client></p>
<ul>
<li><strong>解析阶段</strong>，虚拟机将常量池内的符号引用替换为直接引用的过程。符号引用与内存布局无关，而直接引用的目标必定已经在内存中存在。<strong>解析动作主要针对类或接口、字段、类方法、接口方法，方法类型，方法句柄和调用限定符号期类符号引用进行</strong>。</li>
<li><strong>初始化阶段</strong>，真正开始执行类中定义的java程序代码（字节码），是执行类构造器<clinit>()方法的过程。</clinit></li>
</ul>
<p><clinit>()方法的一些特点：</clinit></p>
<ol>
<li><p><clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static｛｝）中的语句合并产生的，编译器收集顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</clinit></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public Class test &#123;</div><div class="line">    static &#123;</div><div class="line">        i = 0; //给变量赋值可以正常编译通过</div><div class="line">        System.out.println(i); //这句编译器会提示“非法向前引用”</div><div class="line">    &#125;</div><div class="line">    static int i = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><clinit>()方法与类的构造函数（或者说实例构造器<init>()方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前完成父类<clinit>()方法的执行。因此在虚拟机中第一个被执行的<client>()方法的类肯定是java.lang.Object。   </client></clinit></clinit></init></clinit></p>
</li>
<li>由于父类的<clinit>() 方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作</clinit></li>
<li><p><clinit>()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，则编译器可以不为这个类生成<clinit>()方法。   </clinit></clinit></p>
</li>
<li><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法，不同于类的地方是执行接口的<clinit>()方法时不需要先执行父类的<clinit>()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<client>()方法。</client></clinit></clinit></clinit></p>
</li>
<li><p>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，则只有一个线程去执行这个类的<clinit>()方法，其它线程阻塞等待，直到活动线程执行<clinit>()方法完毕。 如果在一个类的<client>()方法中有耗时很长的操作，就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</client></clinit></clinit></clinit></p>
<p> 需要注意的是，其他线程虽然会被阻塞，但如果执行<client>()方法的那条线程退出<client>()方法后，其他线程唤醒之后不会再次进入<client>()方法。同一个类加载器下，一个类型只会初始化一次。</client></client></client></p>
</li>
</ol>
<p>了解完各个类加载机制的阶段后，我们需要进一步了解类加载器这个概念。类加载器只用于实现类的加载动作，即实现通过一个类的全限定名来获取描述此类的二进制字节流。<strong>但对于类来说，要判断两个类是否相等（instanceof，equal），其前提是两个类是由同一个类加载器所加载，否则，无论两个类是否来源于同一个Class文件，这两个类都必定不等，亦即是说，对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在java虚拟机的唯一性。</strong>  </p>
<p>在Java开发人员看来，类加载器可划分为以下三类系统提供的类加载器：启动类加载器（Boostrap ClassLoader，负责将存放在<java_home>\lib目录中的类库加载到虚拟机内存中，其无法被Java程序直接引用），扩展类加载器（Extension ClassLoader，由sun.misc.Launcher$ExtClassLoader实现，负责加载<java_home>\lib\ext目录中的类库，可被开发者直接使用），应用程序类加载器（由sun.misc.Launcher$AppClassLoader来实现，负责加载用户类路径（ClassPath）上指定的类库，可被开发者直接使用，且为默认的类加载器）。  </java_home></java_home></p>
<p>java中采用<strong>双亲委派模型</strong>（Parents Delegation Model）来实现类的加载模式。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，此处的父子关系不以继承来实现，而是采用组合来利用父加载器。    </p>
<p>双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会自己去加载。</p>
<p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个成为java.lang.Object的类，并放在程序的ClassPath之中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证。</p>
<p>其模型如下图所示：<br><img src="http://note.youdao.com/yws/public/resource/ee75e4361b58214a36b4d854bbd3faf1/xmlnote/EEE7B3274550464AB506A63343F42905/7749" alt="image">    </p>
<h3 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h3><p>了解了以上类文件结构和类加载机制后，我们最后再来看看字节码在虚拟机中是如何被执行的。  </p>
<p>不同的虚拟机实现时硕，执行引擎在执行Java执行的时候可能有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备，甚至可能包含几个不同级别的编译器执行引擎。  </p>
<p>在具体了解虚拟机是如何执行字节码之前，我们先来从概念上理解虚拟机是如何执行程序的。程序的执行可以直接解释为是对方法的递归调用，通过一连串的方法链来最终得出执行结果，亦即是说虚拟机对程序的执行，根本上是对方法的调用和执行。</p>
<p>栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表（最小单位为变量槽Variable Slot）、操作数栈、动态连接和方法返回地址等信息，每一个方法从调用开始到执行完成的过程，就对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。栈帧的内容在编译时就已经完成确定，不受程序运行期变量数据的影响，仅取决于具体的虚拟机实现。    </p>
<p>前面说了，对程序的执行就是对方法链的调用和执行，即可能会出现很多方法同时处于执行状态，此时对于执行引擎来说，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，其关联的方法称为当前方法，执行引擎所运行的所有字节码指令只针对当前栈帧进行操作。    </p>
<p>方法调用包含两种方法：<strong>解析和分派</strong>。解析调用一定是个静态过程，在编译期间完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。而分派调用则可能是动态的也可能是静态的，根据分派依据的宗量数可分为单分派和多分派。（具体情形请参考《深入理解java虚拟机》这本书第8章）</p>
<p>方法执行即是指字节码解释执行引擎，包括解释执行和编译执行。而java编译器输出的指令流，基本上是一种基于栈的指令集架构。即Java虚拟机采用的是基于栈的字节码执行引擎。（具体情形请参考《深入理解java虚拟机》这本书第8章）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/基础/类加载机制/" data-id="cjfvvphkt006dm9fylqdxa8ob" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/集合/在List循环中删除元素" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/集合/在List循环中删除元素/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/集合/">集合</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/集合/在List循环中删除元素/">在List循环中删除元素</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="测试list"><a href="#测试list" class="headerlink" title="测试list"></a>测试list</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line">list.add(&quot;a&quot;);</div><div class="line">list.add(&quot;b&quot;);</div><div class="line">list.add(&quot;c&quot;);</div></pre></td></tr></table></figure>
<h3 id="普通下标方式一"><a href="#普通下标方式一" class="headerlink" title="普通下标方式一"></a>普通下标方式一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">for(int i=0; i&lt;3;i++) &#123;</div><div class="line">	for(int j=0;j&lt;list.size(); j++) &#123;</div><div class="line">        if (list.get(j).equals(&quot;b&quot;)) &#123;</div><div class="line">        		list.remove(j);</div><div class="line">            System.out.println(&quot;delete&quot;);</div><div class="line">            j--;//关键</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        System.out.println(list.get(j));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="迭代方式"><a href="#迭代方式" class="headerlink" title="迭代方式"></a>迭代方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">for(int i=0; i&lt;3;i++) &#123;</div><div class="line">	Iterator&lt;String&gt; iter = list.iterator();</div><div class="line">    while (iter.hasNext()) &#123;</div><div class="line">        String item = iter.next();</div><div class="line">        if (item.equals(&quot;b&quot;)) &#123;</div><div class="line">            iter.remove();</div><div class="line">            System.out.println(&quot;delete&quot;);</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        System.out.println(item);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CopyOnWriteArrayList方式"><a href="#CopyOnWriteArrayList方式" class="headerlink" title="CopyOnWriteArrayList方式"></a>CopyOnWriteArrayList方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">final CopyOnWriteArrayList&lt;String&gt; cowList = new CopyOnWriteArrayList&lt;String&gt;(list);</div><div class="line">for(int i=0; i&lt;3;i++) &#123;</div><div class="line">	for (String item : cowList) &#123;</div><div class="line">        if (item.equals(&quot;b&quot;)) &#123;</div><div class="line">            cowList.remove(item);</div><div class="line">            System.out.println(&quot;delete&quot;);</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        System.out.println(item);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="统一输出"><a href="#统一输出" class="headerlink" title="统一输出"></a>统一输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">a</div><div class="line">delete</div><div class="line">c</div><div class="line">a</div><div class="line">c</div><div class="line">a</div><div class="line">c</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/集合/在List循环中删除元素/" data-id="cjfvvphlo008am9fyc4fqd6sp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/集合/HashSet原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/集合/HashSet原理/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/集合/">集合</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/集合/HashSet原理/">HashSet原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="HashSet的实现原理"><a href="#HashSet的实现原理" class="headerlink" title="HashSet的实现原理"></a>HashSet的实现原理</h2><ol>
<li>HashSet是基于HashMap实现的，默认构造函数是构建一个初始容量为16，负载因子为0.75 的HashMap。封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的 Object 对象。</li>
<li>当我们试图把某个类的对象当成 HashMap的 key，或试图将这个类的对象放入 HashSet中保存时，重写该类的equals(Object obj)方法和 hashCode() 方法很重要，而且这两个方法的返回值必须保持一致：当该类的两个的 hashCode() 返回值相同时，它们通过 equals() 方法比较也应该返回 true。通常来说，所有参与计算 hashCode()返回值的关键属性，都应该用于作为 equals() 比较的标准。</li>
<li>HashSet的其他操作都是基于HashMap的。</li>
</ol>
<p>HashSet实现Set接口，由哈希表（实际上是一个HashMap实例）支持。它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素，但是HashSet中不允许有重复元素</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>对于HashSet而言，它是基于HashMap实现的，HashSet底层使用HashMap来保存所有元素，因此HashSet 的实现比较简单，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成， HashSet的源代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div></pre></td><td class="code"><pre><div class="line">public class HashSet&lt;E&gt;  </div><div class="line">    extends AbstractSet&lt;E&gt;  </div><div class="line">    implements Set&lt;E&gt;, Cloneable, java.io.Serializable  </div><div class="line">&#123;  </div><div class="line">    static final long serialVersionUID = -5024744406713321676L;  </div><div class="line">  </div><div class="line">    // 底层使用HashMap来保存HashSet中所有元素。  </div><div class="line">    private transient HashMap&lt;E,Object&gt; map;  </div><div class="line">      </div><div class="line">    // 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。  </div><div class="line">    private static final Object PRESENT = new Object();  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 默认的无参构造器，构造一个空的HashSet。 </div><div class="line">     *  </div><div class="line">     * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 </div><div class="line">     */  </div><div class="line">    public HashSet() &#123;  </div><div class="line">        map = new HashMap&lt;E,Object&gt;();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 构造一个包含指定collection中的元素的新set。 </div><div class="line">     * </div><div class="line">     * 实际底层使用默认的加载因子0.75和足以包含指定 </div><div class="line">     * collection中所有元素的初始容量来创建一个HashMap。 </div><div class="line">     * @param c 其中的元素将存放在此set中的collection。 </div><div class="line">     */  </div><div class="line">    public HashSet(Collection&lt;? extends E&gt; c) &#123;  </div><div class="line">        map = new HashMap&lt;E,Object&gt;(Math.max((int) (c.size()/.75f) + 1, 16));  </div><div class="line">        addAll(c);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 以指定的initialCapacity和loadFactor构造一个空的HashSet。 </div><div class="line">     * </div><div class="line">     * 实际底层以相应的参数构造一个空的HashMap。 </div><div class="line">     * @param initialCapacity 初始容量。 </div><div class="line">     * @param loadFactor 加载因子。 </div><div class="line">     */  </div><div class="line">    public HashSet(int initialCapacity, float loadFactor) &#123;  </div><div class="line">        map = new HashMap&lt;E,Object&gt;(initialCapacity, loadFactor);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 以指定的initialCapacity构造一个空的HashSet。 </div><div class="line">     * </div><div class="line">     * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。 </div><div class="line">     * @param initialCapacity 初始容量。 </div><div class="line">     */  </div><div class="line">    public HashSet(int initialCapacity) &#123;  </div><div class="line">        map = new HashMap&lt;E,Object&gt;(initialCapacity);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 </div><div class="line">     * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。 </div><div class="line">     * </div><div class="line">     * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。 </div><div class="line">     * @param initialCapacity 初始容量。 </div><div class="line">     * @param loadFactor 加载因子。 </div><div class="line">     * @param dummy 标记。 </div><div class="line">     */  </div><div class="line">    HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;  </div><div class="line">        map = new LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 返回对此set中元素进行迭代的迭代器。返回元素的顺序并不是特定的。 </div><div class="line">     *  </div><div class="line">     * 底层实际调用底层HashMap的keySet来返回所有的key。 </div><div class="line">     * 可见HashSet中的元素，只是存放在了底层HashMap的key上， </div><div class="line">     * value使用一个static final的Object对象标识。 </div><div class="line">     * @return 对此set中元素进行迭代的Iterator。 </div><div class="line">     */  </div><div class="line">    public Iterator&lt;E&gt; iterator() &#123;  </div><div class="line">        return map.keySet().iterator();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 返回此set中的元素的数量（set的容量）。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。 </div><div class="line">     * @return 此set中的元素的数量（set的容量）。 </div><div class="line">     */  </div><div class="line">    public int size() &#123;  </div><div class="line">        return map.size();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 如果此set不包含任何元素，则返回true。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。 </div><div class="line">     * @return 如果此set不包含任何元素，则返回true。 </div><div class="line">     */  </div><div class="line">    public boolean isEmpty() &#123;  </div><div class="line">        return map.isEmpty();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 如果此set包含指定元素，则返回true。 </div><div class="line">     * 更确切地讲，当且仅当此set包含一个满足(o==null ? e==null : o.equals(e)) </div><div class="line">     * 的e元素时，返回true。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的containsKey判断是否包含指定key。 </div><div class="line">     * @param o 在此set中的存在已得到测试的元素。 </div><div class="line">     * @return 如果此set包含指定元素，则返回true。 </div><div class="line">     */  </div><div class="line">    public boolean contains(Object o) &#123;  </div><div class="line">        return map.containsKey(o);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 如果此set中尚未包含指定元素，则添加指定元素。 </div><div class="line">     * 更确切地讲，如果此 set 没有包含满足(e==null ? e2==null : e.equals(e2)) </div><div class="line">     * 的元素e2，则向此set 添加指定的元素e。 </div><div class="line">     * 如果此set已包含该元素，则该调用不更改set并返回false。 </div><div class="line">     * </div><div class="line">     * 底层实际将将该元素作为key放入HashMap。 </div><div class="line">     * 由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key </div><div class="line">     * 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true）， </div><div class="line">     * 新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变， </div><div class="line">     * 因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中， </div><div class="line">     * 原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。 </div><div class="line">     * @param e 将添加到此set中的元素。 </div><div class="line">     * @return 如果此set尚未包含指定元素，则返回true。 </div><div class="line">     */  </div><div class="line">    public boolean add(E e) &#123;  </div><div class="line">        return map.put(e, PRESENT)==null;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 如果指定元素存在于此set中，则将其移除。 </div><div class="line">     * 更确切地讲，如果此set包含一个满足(o==null ? e==null : o.equals(e))的元素e， </div><div class="line">     * 则将其移除。如果此set已包含该元素，则返回true </div><div class="line">     * （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的remove方法删除指定Entry。 </div><div class="line">     * @param o 如果存在于此set中则需要将其移除的对象。 </div><div class="line">     * @return 如果set包含指定元素，则返回true。 </div><div class="line">     */  </div><div class="line">    public boolean remove(Object o) &#123;  </div><div class="line">        return map.remove(o)==PRESENT;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 从此set中移除所有元素。此调用返回后，该set将为空。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的clear方法清空Entry中所有元素。 </div><div class="line">     */  </div><div class="line">    public void clear() &#123;  </div><div class="line">        map.clear();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到HashSet中。 </div><div class="line">     */  </div><div class="line">    public Object clone() &#123;  </div><div class="line">        try &#123;  </div><div class="line">            HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone();  </div><div class="line">            newSet.map = (HashMap&lt;E, Object&gt;) map.clone();  </div><div class="line">            return newSet;  </div><div class="line">        &#125; catch (CloneNotSupportedException e) &#123;  </div><div class="line">            throw new InternalError();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/集合/HashSet原理/" data-id="cjfvvphlo0088m9fytp9lutfb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/集合/CopyOnWrite容器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/集合/CopyOnWrite容器/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/集合/">集合</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/集合/CopyOnWrite容器/">CopyOnWrite容器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p>
<h3 id="什么是CopyOnWrite容器"><a href="#什么是CopyOnWrite容器" class="headerlink" title="什么是CopyOnWrite容器"></a>什么是CopyOnWrite容器</h3><p><strong>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器</strong>。</p>
<h3 id="CopyOnWriteArrayList的实现原理"><a href="#CopyOnWriteArrayList的实现原理" class="headerlink" title="CopyOnWriteArrayList的实现原理"></a>CopyOnWriteArrayList的实现原理</h3><p>在使用CopyOnWriteArrayList之前，我们先阅读其源码了解下它是如何实现的。以下代码是向ArrayList里添加元素，可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public boolean add(T e) &#123;</div><div class="line">	</div><div class="line">	final ReentrantLock lock = this.lock;</div><div class="line">	lock.lock();</div><div class="line">	try &#123;</div><div class="line"></div><div class="line">		Object[] elements = getArray();</div><div class="line"></div><div class="line">		int len = elements.length;</div><div class="line">		// 复制出新数组</div><div class="line">		Object[] newElements = Arrays.copyOf(elements, len + 1);</div><div class="line"></div><div class="line">		// 把新元素添加到新数组里</div><div class="line">		newElements[len] = e;</div><div class="line">		</div><div class="line">		// 把原数组引用指向新数组</div><div class="line">		setArray(newElements);</div><div class="line"></div><div class="line">		return true;</div><div class="line"></div><div class="line">	&#125; finally &#123;</div><div class="line"></div><div class="line">		lock.unlock();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">final void setArray(Object[] a) &#123;</div><div class="line">	array = a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public E get(int index) &#123;</div><div class="line">    return get(getArray(), index);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>JDK中并没有提供CopyOnWriteMap，我们可以参考CopyOnWriteArrayList来实现一个，基本代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">import java.util.Collection;</div><div class="line">import java.util.Map;</div><div class="line">import java.util.Set;</div><div class="line"></div><div class="line">public class CopyOnWriteMap&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable &#123;</div><div class="line">    private volatile Map&lt;K, V&gt; internalMap;</div><div class="line"></div><div class="line">    public CopyOnWriteMap() &#123;</div><div class="line">        internalMap = new HashMap&lt;K, V&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public V put(K key, V value) &#123;</div><div class="line"></div><div class="line">        synchronized (this) &#123;</div><div class="line">            Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap);</div><div class="line">            V val = newMap.put(key, value);</div><div class="line">            internalMap = newMap;</div><div class="line">            return val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public V get(Object key) &#123;</div><div class="line">        return internalMap.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void putAll(Map&lt;? extends K, ? extends V&gt; newData) &#123;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap);</div><div class="line">            newMap.putAll(newData);</div><div class="line">            internalMap = newMap;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现很简单，只要了解了CopyOnWrite机制，我们可以实现各种CopyOnWrite容器，并且在不同的应用场景中使用。</p>
<h3 id="CopyOnWrite的应用场景"><a href="#CopyOnWrite的应用场景" class="headerlink" title="CopyOnWrite的应用场景"></a>CopyOnWrite的应用场景</h3><p>CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">package com.ifeve.book;</div><div class="line"></div><div class="line">import java.util.Map;</div><div class="line"></div><div class="line">import com.ifeve.book.forkjoin.CopyOnWriteMap;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 黑名单服务</div><div class="line"> *</div><div class="line"> * @author fangtengfei</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class BlackListServiceImpl &#123;</div><div class="line"></div><div class="line">    private static CopyOnWriteMap&lt;String, Boolean&gt; blackListMap = new CopyOnWriteMap&lt;String, Boolean&gt;(</div><div class="line">            1000);</div><div class="line"></div><div class="line">    public static boolean isBlackList(String id) &#123;</div><div class="line">        return blackListMap.get(id) == null ? false : true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void addBlackList(String id) &#123;</div><div class="line">        blackListMap.put(id, Boolean.TRUE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 批量添加黑名单</div><div class="line">     *</div><div class="line">     * @param ids</div><div class="line">     */</div><div class="line">    public static void addBlackList(Map&lt;String,Boolean&gt; ids) &#123;</div><div class="line">        blackListMap.putAll(ids);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码很简单，但是使用CopyOnWriteMap需要注意两件事情：</p>
<ol>
<li><p>减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。</p>
</li>
<li><p>使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。如使用上面代码里的addBlackList方法。</p>
</li>
</ol>
<h3 id="CopyOnWrite的缺点"><a href="#CopyOnWrite的缺点" class="headerlink" title="CopyOnWrite的缺点"></a>CopyOnWrite的缺点</h3><p>CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p>
<p><strong>内存占用问题</strong>。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</p>
<p>针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。</p>
<p><strong>数据一致性问题</strong>。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/集合/CopyOnWrite容器/" data-id="cjfvvphlm0085m9fy3h82z3sm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据库相关/mysql/事务" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/数据库相关/mysql/事务/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库相关/">数据库相关</a>►<a class="article-category-link" href="/categories/数据库相关/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/数据库相关/mysql/事务/">事务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>事务(Transaction)是并发控制的基本单位。所谓事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。例如，银行转帐工作：从一个帐号扣款并使另一个帐号增款，这两个操作要么都执行，要么都不执行。  </p>
<h3 id="数据库事务必须具备ACID特性，ACID是Atomic（原子性）、Consistency（一致性）、Isolation（隔离性）和Durability（持久性）的英文缩写。"><a href="#数据库事务必须具备ACID特性，ACID是Atomic（原子性）、Consistency（一致性）、Isolation（隔离性）和Durability（持久性）的英文缩写。" class="headerlink" title="数据库事务必须具备ACID特性，ACID是Atomic（原子性）、Consistency（一致性）、Isolation（隔离性）和Durability（持久性）的英文缩写。"></a>数据库事务必须具备ACID特性，ACID是Atomic（原子性）、Consistency（一致性）、Isolation（隔离性）和Durability（持久性）的英文缩写。</h3><h4 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h4><p>一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>
<h4 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h4><p>事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。    </p>
<h4 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h4><p>指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</p>
<h4 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h4><p>指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。</p>
<p>事务的（ACID）特性是由关系数据库管理系统（RDBMS，数据库系统）来实现的。<strong>数据库管理系统采用日志来保证事务的原子性、一致性和持久性</strong>。日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。  </p>
<p><strong>数据库管理系统采用锁机制来实现事务的隔离性</strong>。当多个事务同时更新数据库中相同的数据时，只允许持有锁的事务能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。  </p>
<p>在关系型数据库中，事务的隔离性分为四个隔离级别，在解读这四个级别前先介绍几个关于读数据的概念。</p>
<ol>
<li><p>脏读（Dirty Reads）：所谓脏读就是对脏数据（Drity Data）的读取，而脏数据所指的就是未提交的数据。也就是说，一个事务正在对一条记录做修改，在这个事务完成并提交之前，这条数据是处于待定状态的（可能提交也可能回滚），这时，第二个事务来读取这条没有提交的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被称为脏读。</p>
</li>
<li><p>不可重复读（Non-Repeatable Reads）：一个事务先后读取同一条记录，但两次读取的数据不同，我们称之为不可重复读。也就是说，这个事务在两次读取之间该数据被其它事务所修改。</p>
</li>
<li><p>幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。</p>
</li>
</ol>
<h3 id="事务四个隔离级别对比"><a href="#事务四个隔离级别对比" class="headerlink" title="事务四个隔离级别对比"></a>事务四个隔离级别对比</h3><ol>
<li><p>未提交读（Read Uncommitted）：SELECT语句以非锁定方式被执行，所以有可能读到脏数据，隔离级别最低。</p>
</li>
<li><p>提交读（Read Committed）：只能读取到已经提交的数据。即解决了脏读，但未解决不可重复读。</p>
</li>
<li><p>可重复读（Repeated Read）：在同一个事务内的查询都是事务开始时刻一致的，InnoDB的默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻读。</p>
</li>
<li><p>串行读（Serializable）：完全的串行化读，所有SELECT语句都被隐式的转换成SELECT … LOCK IN SHARE MODE，即读取使用表级共享锁，读写相互都会阻塞。隔离级别最高。简单来说，Serializable会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。</p>
</li>
</ol>
<p>隔离级别对比表：</p>
<table>
<thead>
<tr>
<th></th>
<th>\</th>
<th>脏读</th>
<th>可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>未提交读</td>
<td>✖️️</td>
<td>✖️️</td>
<td>✖️ ️️️</td>
</tr>
<tr>
<td>提交读</td>
<td>✔️</td>
<td>✖️️</td>
<td>✖️️</td>
</tr>
<tr>
<td>可重复读</td>
<td>✔️</td>
<td>✔️</td>
<td>✖️</td>
</tr>
<tr>
<td>串行读</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️ </td>
</tr>
</tbody>
</table>
<h4 id="自动提交（AUTOCOMMIT）"><a href="#自动提交（AUTOCOMMIT）" class="headerlink" title="自动提交（AUTOCOMMIT）"></a>自动提交（AUTOCOMMIT）</h4><p>MySQL提供了两种事务型的存储引擎：<strong>InnoBD</strong>和<strong>NDB Cluster</strong>。</p>
<p><strong>MySQL默认采用自动提交（AUTOCOMMIT）模式</strong>。也就是说，如果不是显式地开始一个事务，则每个查询都被当作一个事务执行提交操作。</p>
<p>可以通过设置AUTOCOMMIT变量来启用或者禁用自动提交模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show VARIABLES LIKE &apos;AUTOCOMMIT&apos;;</div><div class="line">+---------------+-------+</div><div class="line">| Variable_name | Value |</div><div class="line">+---------------+-------+</div><div class="line">| autocommit    | ON    |</div><div class="line">+---------------+-------+</div><div class="line">1 行于数据集 (0.05 秒)</div><div class="line"></div><div class="line">mysql&gt; SET AUTOCOMMIT = 1;</div></pre></td></tr></table></figure></p>
<ul>
<li>启用：1或者ON</li>
<li>禁用：0或者OFF</li>
</ul>
<p>当AUTOCOMMIT=0时，所有的查询都是在一个事务中，直到显式地执行COMMIT提交或者ROLLBACK回滚，该事务结束，同时又开始了另一个新事务。</p>
<h4 id="事务隔离级别的查看与设置"><a href="#事务隔离级别的查看与设置" class="headerlink" title="事务隔离级别的查看与设置"></a>事务隔离级别的查看与设置</h4><h5 id="查看隔离级别"><a href="#查看隔离级别" class="headerlink" title="查看隔离级别"></a>查看隔离级别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT @@tx_isolation;</div><div class="line">+-----------------+</div><div class="line">| @@tx_isolation  |</div><div class="line">+-----------------+</div><div class="line">| REPEATABLE-READ |</div><div class="line">+-----------------+</div><div class="line">1 行于数据集 (0.01 秒)</div></pre></td></tr></table></figure>
<h5 id="设置隔离级别"><a href="#设置隔离级别" class="headerlink" title="设置隔离级别"></a>设置隔离级别</h5><p>服务启动选项–transaction-isolation或在配置文件中设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[mysqld]</div><div class="line">transaction-isolation = &#123;READ-UNCOMMITTED | READ-COMMITTED</div><div class="line"> | REPEATABLE-READ | SERIALIZABLE&#125;</div></pre></td></tr></table></figure></p>
<p>2）服务启动后的设置（新的隔离级别会在下一个事务开始的时候生效）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL</div><div class="line">&#123; READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;</div></pre></td></tr></table></figure></p>
<p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</div></pre></td></tr></table></figure></p>
<h3 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h3><p><strong>事务日志可以帮助提供事务的效率</strong>。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。</p>
<p><strong>事务日志采用的是追加的方式</strong>，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。</p>
<p>目前大多数存储引擎都是这样实现的，我们通常称为<strong>预写式日志</strong>（Write-Ahead-Logging），修改数据需要写两次磁盘。</p>
<p>如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统奔溃，存储引擎在重启时能够自动恢复这部分修改的数据。</p>
<h3 id="在事务中混合使用存储引擎"><a href="#在事务中混合使用存储引擎" class="headerlink" title="在事务中混合使用存储引擎"></a>在事务中混合使用存储引擎</h3><p>MySQL服务器层不管理事务，事务是由下层的存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的。</p>
<p>如果在事务中混合使用了事务型和非事务型的表，在正常提交的情况下不会有什么问题。但如果该事务需要回滚，非事务型的表上的变更就无法撤销，这会导致数据库处于不一致的状态，这种情况很难修复，事务的最终结果将无法确定。</p>
<p>在非事务型的表上执行事务相关操作的时候，MySQL通常不会发出提醒，也不会报错。有时候只有回滚的时候才会发出一个警告：“某些非事务型的表上的变更不能被回滚”。但大多数情况下，对非事务型的操作都不会有提示。</p>
<h3 id="隐式和显式锁定"><a href="#隐式和显式锁定" class="headerlink" title="隐式和显式锁定"></a>隐式和显式锁定</h3><p>InnoBD采用的是两阶段锁定协议（two-phase locking protocol）。在事务执行过程中，随时都可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁是在同一时刻被释放。InnoDB会根据隔离级别在需要的时候自动加锁。</p>
<p>另外，InnoDB也支持通过特定的语句进行显式锁定，这些语句不属于SQL规范（这些锁定提示经常被滥用，实际上应当尽量避免使用）：</p>
<ul>
<li>SELECT … LOCK IN SHARE MODE</li>
<li>SELECT … FOR UPDATE</li>
</ul>
<p>MySQL也支持LOCK TABLES 和UNLOCK TABLES语句，这是在服务器层实现的，和存储引擎无关。</p>
<p>经常可以发现，应用已经将表从MyISAM转换到InnoDB，但还是显式地使用LOCK TABLES语句的。这不但没有必要，还会严重影响性能，实际上InnoDB的行级锁工作得更好。</p>
<p><strong>建议：除了事务中禁用了AUTOCOMMIT，可以使用LOCK TABLES之外，其他任何时候都不要显式地执行LOCK TABLES，不管使用的是什么存储引擎</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/数据库相关/mysql/事务/" data-id="cjfvvphph00fom9fygz60f2he" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Eclipse/">Eclipse</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Github/">Github</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Cookie/">Cookie</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JAXB/">JAXB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JavaMail/">JavaMail</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/基础/">基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/数据类型/">数据类型</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/日记/">日记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/时间日期/">时间日期</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/线程/">线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/网络NIO/">网络NIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/队列/">队列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/集合/">集合</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Application-Event/">Application Event</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/JPA/">JPA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Security/">Security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Spring-Boot/">Spring Boot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Spring-Session/">Spring Session</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Task/">Task</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-MVC/">spring MVC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-data-redis/">spring data redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/基础/">基础</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/">前端技术相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/forever/">forever</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/javascript/">javascript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库相关/">数据库相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据库相关/mysql/">mysql</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/">服务器相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hessian/">Hessian</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hudson-Jenkins/">Hudson & Jenkins</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Memcached/">Memcached</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Nginx/">Nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Tomcat/">Tomcat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/red5/">red5</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/resin/">resin</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/正则表达式/">正则表达式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/12/服务器相关/Tomcat/TOMCAT原理详解及请求过程/">TOMCAT原理详解及请求过程</a>
          </li>
        
          <li>
            <a href="/2018/04/12/网络/HTTPS工作原理/">HTTPS工作原理</a>
          </li>
        
          <li>
            <a href="/2018/04/12/网络/三次握手和四次挥手/">三次握手和四次挥手</a>
          </li>
        
          <li>
            <a href="/2018/04/12/服务器相关/Tomcat/内存分配/">内存分配</a>
          </li>
        
          <li>
            <a href="/2018/04/12/服务器相关/Tomcat/Tomcat整体架构浅析/">Tomcat整体架构浅析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 LeoChan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>