<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LeoChan&#39;s 个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="描述啊">
<meta property="og:type" content="website">
<meta property="og:title" content="LeoChan&#39;s 个人博客">
<meta property="og:url" content="https://clq2owesome.github.io/page/2/index.html">
<meta property="og:site_name" content="LeoChan&#39;s 个人博客">
<meta property="og:description" content="描述啊">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeoChan&#39;s 个人博客">
<meta name="twitter:description" content="描述啊">
  
    <link rel="alternate" href="/atom.xml" title="LeoChan&#39;s 个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LeoChan&#39;s 个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术都是通用的，重要的是是否具有自主解决问题的能力！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://clq2owesome.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Java/基础/序列化和反序列化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/基础/序列化和反序列化/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/基础/序列化和反序列化/">序列化和反序列化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>将 Java 对象序列化为二进制文件的 Java 序列化技术是 Java 系列技术中一个较为重要的技术点，在大部分情况下，开发人员只需要了解被序列化的类需要实现Serializable接口，使用 ObjectInputStream和ObjectOutputStream 进行对象的读写。然而在有些情况下，光知道这些还远远不够</p>
</blockquote>
<h2 id="java序列化简介"><a href="#java序列化简介" class="headerlink" title="java序列化简介"></a>java序列化简介</h2><p>序列化就是指对象通过写出描述自己状态的数值来记录自己的过程，即将对象表示成一系列有序字节，java提供了将对象写入流和从流中恢复对象的方法。对象能包含其它的对象，而其它的对象又可以包含另外的对象。JAVA序列化能够自动的处理嵌套的对象。对于一个对象的简单域，writeObject()直接将其值写入流中。当遇到一个对象域时，writeObject()被再次调用，如果这个对象内嵌另一个对象，那么，writeObject()又被调用，直到对象能被直接写入流为止。程序员所需要做的是将对象传入ObjectOutputStream的writeObject()方法，剩下的将有系统自动完成。    </p>
<p>要实现序列化的类必须实现的java.io.Serializable或java.io.Externalizable接口，否则将产生一个NotSerializableException。该接口内部并没有任何方法，它只是一个”tagging interface”，仅仅”tags”它自己的对象是一个特殊的类型。类通过实现 java.io.Serializable接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或字段，仅用于标识可序列化的语义。Java的”对象序列化”能让你将一个实现了Serializable接口的对象转换成一组byte，这样日后要用这个对象时候，你就能把这些byte数据恢复出来，并据此重新构建那个对象了。</p>
<h2 id="序列化的必要性及目的"><a href="#序列化的必要性及目的" class="headerlink" title="序列化的必要性及目的"></a>序列化的必要性及目的</h2><p>Java中，一切都是对象，在分布式环境中经常需要将Object从这一端网络或设备传递到另一端。这就需要有一种可以在两端传输数据的协议。Java序列化机制就是为了解决这个问题而产生。</p>
<p>Java序列化支持的两种主要特性：</p>
<ul>
<li>Java 的RMI使本来存在于其他机器的对象可以表现出就象本地机器上的行为。</li>
<li>将消息发给远程对象时，需要通过对象序列化来传输参数和返回值.</li>
</ul>
<p>Java序列化的目的：</p>
<ul>
<li>支持运行在不同虚拟机上不同版本类之间的双向通讯；</li>
<li>定义允许JAVA类读取用相同类较老版本写入的数据流的机制；</li>
<li>定义允许JAVA类写用相同类较老版本读取的数据流的机制；</li>
<li>提供对持久性和RMI的序列化；</li>
<li>产生压缩流且运行良好以使RMI能序列化；</li>
<li>辨别写入的是否是本地流；</li>
<li>保持非版本化类的低负载；</li>
</ul>
<h2 id="序列化异常"><a href="#序列化异常" class="headerlink" title="序列化异常"></a>序列化异常</h2><p>序列化对象期间可能抛出6种异常：</p>
<ul>
<li>InvalidClassException 通常在重序列化流无法确定类型时或返回的类无法在取得对象的系统中表示时抛出此异常。异常也在恢复的类不声明为public时或没有public缺省（无变元）构造器时抛出。</li>
<li>NotSerializableException 通常由具体化对象（负责自身的重序列化）探测到输入流错误时抛出。错误通常由意外不变量值指示，或者表示要序列化的对象不可序列化。</li>
<li>StreamCorruptedException 在存放对象的头或控制数据无效时抛出。</li>
<li>OptionalDataException 流中应包含对象但实际只包含原型数据时抛出。</li>
<li>ClassNotFoundException 流的读取端找不到反序列化对象的类时抛出。</li>
<li>IOException  要读取或写入的对象发生与流有关的错误时抛出。</li>
</ul>
<h2 id="序列化一个对象"><a href="#序列化一个对象" class="headerlink" title="序列化一个对象"></a>序列化一个对象</h2><p>序列化一个对象，以及对序列化后的对象进行操作，需要遵循以下3点：</p>
<ol>
<li>一个对象能够序列化的前提是实现Serializable接口或Externalizable接口，Serializable接口没有方法，更像是个标记。有了这个标记的Class就能被序列化机制处理。</li>
<li>写个程序将对象序列化并输出。ObjectOutputStream能把Object输出成Byte流。</li>
<li>要从持久的文件中读取Bytes重建对象，我们可以使用ObjectInputStream。</li>
</ol>
<p>在序列化时，有几点要注意的：</p>
<ul>
<li>当一个对象被序列化时，只序列化对象的非静态成员变量，不能序列化任何成员方法和静态成员变量。</li>
<li>如果一个对象的成员变量是一个对象，那么这个对象的数据成员也会被保存。</li>
<li>如果一个可序列化的对象包含对某个不可序列化的对象的引用，那么整个序列化操作将会失败，并且会抛出一个NotSerializableException。可以通过将这个引用标记为transient，那么对象仍然可以序列化。对于一些比较敏感的不想序列化的数据，也可以采用该标识进行修饰。</li>
</ul>
<h2 id="Java的序列化算法"><a href="#Java的序列化算法" class="headerlink" title="Java的序列化算法"></a>Java的序列化算法</h2><p>序列化算法一般会按步骤做如下事情：</p>
<ul>
<li>将对象实例相关的类元数据输出。</li>
<li>递归地输出类的超类描述直到不再有超类。</li>
<li>类元数据完了以后，开始从最顶层的超类开始输出对象实例的实际数据值。</li>
<li>从上至下递归输出实例的数据</li>
</ul>
<h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><h3 id="序列化-ID-问题"><a href="#序列化-ID-问题" class="headerlink" title="序列化 ID 问题"></a>序列化 ID 问题</h3><p>情境：两个客户端 A 和 B 试图通过网络传递对象数据，A 端将对象 C 序列化为二进制数据再传给 B，B 反序列化得到 C。    </p>
<p>问题：C 对象的全类路径假设为 com.inout.Test，在 A 和 B 端都有这么一个类文件，功能代码完全一致。也都实现了 Serializable 接口，但是反序列化时总是提示不成功。</p>
<p>解决：虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID = 1L）。清单1中，虽然两个类的功能代码完全一致，但是序列化 ID 不同，他们无法相互序列化和反序列化。</p>
<p>简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。</p>
<p>当实现java.io.Serializable接口的实体（类）没有显式地定义一个名为serialVersionUID，类型为long的变量时，Java序列化机制会根据编译的class自动生成一个serialVersionUID作序列化版本比较用，这种情况下，只有同一次编译生成的class才会生成相同的serialVersionUID 。  </p>
<p>如果我们不希望通过编译来强制划分软件版本，即实现序列化接口的实体能够兼容先前版本，未作更改的类，就需要显式地定义一个名为serialVersionUID，类型为long的变量，不修改这个变量值的序列化实体都可以相互进行串行化和反串行化。</p>
<p>清单 1. 相同功能代码不同序列化 ID 的类对比<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">package com.inout; </div><div class="line"></div><div class="line"> import java.io.Serializable; </div><div class="line"></div><div class="line"> public class A implements Serializable &#123; </div><div class="line"></div><div class="line">	 private static final long serialVersionUID = 1L; </div><div class="line"></div><div class="line">	 private String name; </div><div class="line">	</div><div class="line">	 public String getName() </div><div class="line">	 &#123; </div><div class="line">		 return name; </div><div class="line">	 &#125; </div><div class="line">	</div><div class="line">	 public void setName(String name) </div><div class="line">	 &#123; </div><div class="line">		 this.name = name; </div><div class="line">	 &#125; </div><div class="line"> &#125; </div><div class="line"></div><div class="line"> package com.inout; </div><div class="line"></div><div class="line"> import java.io.Serializable; </div><div class="line"></div><div class="line"> public class A implements Serializable &#123; </div><div class="line"></div><div class="line">	 private static final long serialVersionUID = 2L; </div><div class="line">	</div><div class="line">	 private String name; </div><div class="line">	</div><div class="line">	 public String getName() </div><div class="line">	 &#123; </div><div class="line">		 return name; </div><div class="line">	 &#125; </div><div class="line">	</div><div class="line">	 public void setName(String name) </div><div class="line">	 &#123; </div><div class="line">		 this.name = name; </div><div class="line">	 &#125; </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>序列化 ID 在 Eclipse 下提供了两种生成策略，一个是固定的 1L，一个是随机生成一个不重复的 long 类型数据（实际上是使用 JDK 工具生成），在这里有一个建议，如果没有特殊需求，就是用默认的 1L 就可以，这样可以确保代码一致时反序列化成功。那么随机生成的序列化 ID 有什么作用呢，有些时候，通过改变序列化 ID 可以用来限制某些用户的使用。  </p>
<h4 id="特性使用案例"><a href="#特性使用案例" class="headerlink" title="特性使用案例"></a>特性使用案例</h4><p>读者应该听过 Façade 模式，它是为应用程序提供统一的访问接口，案例程序中的 Client 客户端使用了该模式，案例程序结构图如图 1 所示。<br><img src="http://www.ibm.com/developerworks/cn/java/j-lo-serial/image003.gif" alt="image"><br>Client 端通过 Façade Object 才可以与业务逻辑对象进行交互。而客户端的 Façade Object 不能直接由 Client 生成，而是需要 Server 端生成，然后序列化后通过网络将二进制对象数据传给 Client，Client 负责反序列化得到 Façade 对象。该模式可以使得 Client 端程序的使用需要服务器端的许可，同时 Client 端和服务器端的 Façade Object 类需要保持一致。当服务器端想要进行版本更新时，只要将服务器端的 Façade Object 类的序列化 ID 再次生成，当 Client 端反序列化 Façade Object 就会失败，也就是强制 Client 端从服务器端获取最新程序。</p>
<h3 id="静态变量序列化"><a href="#静态变量序列化" class="headerlink" title="静态变量序列化"></a>静态变量序列化</h3><p>清单 2. 静态变量序列化问题代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class Test implements Serializable &#123;</div><div class="line"></div><div class="line">	private static final long serialVersionUID = 1L;</div><div class="line"></div><div class="line">	public static int staticVar = 5;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		try &#123;</div><div class="line">			//初始时staticVar为5</div><div class="line">			ObjectOutputStream out = new ObjectOutputStream(</div><div class="line">					new FileOutputStream(&quot;result.obj&quot;));</div><div class="line">			out.writeObject(new Test());</div><div class="line">			out.close();</div><div class="line"></div><div class="line">			//序列化后修改为10</div><div class="line">			Test.staticVar = 10;</div><div class="line"></div><div class="line">			ObjectInputStream oin = new ObjectInputStream(new FileInputStream(</div><div class="line">					&quot;result.obj&quot;));</div><div class="line">			Test t = (Test) oin.readObject();</div><div class="line">			oin.close();</div><div class="line">			</div><div class="line">			//再读取，通过t.staticVar打印新的值</div><div class="line">			System.out.println(t.staticVar);</div><div class="line">			</div><div class="line">		&#125; catch (FileNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; catch (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; catch (ClassNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>清单 2 中的 main 方法，将对象序列化后，修改静态变量的数值，再将序列化对象读取出来，然后通过读取出来的对象获得静态变量的数值并打印出来。依照清单 2，这个 System.out.println(t.staticVar) 语句输出的是 10 还是 5 呢？</p>
<p>最后的输出是 10，对于无法理解的读者认为，打印的 staticVar 是从读取的对象里获得的，应该是保存时的状态才对。之所以打印 10 的原因在于序列化时，并不保存静态变量，这其实比较容易理解，<strong>序列化保存的是对象的状态，静态变量属于类的状态</strong>，因此 序列化并不保存静态变量。</p>
<h3 id="父类的序列化与-Transient-关键字"><a href="#父类的序列化与-Transient-关键字" class="headerlink" title="父类的序列化与 Transient 关键字"></a>父类的序列化与 Transient 关键字</h3><p>情境：一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable 接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。  </p>
<p>解决：要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就 需要有默认的无参的构造函数。在父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都是默认声明的值，如 int 型的默认是 0，string 型的默认是 null。  </p>
<p>Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。 </p>
<h4 id="特性使用案例-1"><a href="#特性使用案例-1" class="headerlink" title="特性使用案例"></a>特性使用案例</h4><p>我们熟悉使用 Transient 关键字可以使得字段不被序列化，那么还有别的方法吗？根据父类对象序列化的规则，我们可以将不需要被序列化的字段抽取出来放到父类中，子类实现 Serializable 接口，父类不实现，根据父类序列化规则，父类的字段数据将不被序列化，形成类图如图 2 所示。<br><img src="http://www.ibm.com/developerworks/cn/java/j-lo-serial/image005.gif" alt="image"><br>上图中可以看出，attr1、attr2、attr3、attr5 都不会被序列化，放在父类中的好处在于当有另外一个 Child 类时，attr1、attr2、attr3 依然不会被序列化，不用重复抒写 transient，代码简洁。   </p>
<h3 id="对敏感字段加密"><a href="#对敏感字段加密" class="headerlink" title="对敏感字段加密"></a>对敏感字段加密</h3><p>情境：服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。    </p>
<p>解决：在序列化过程中，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。基于这个原理，可以在实际应用中得到使用，用于敏感字段的加密工作，清单 3 展示了这个过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">private static final long serialVersionUID = 1L;</div><div class="line"></div><div class="line">	private String password = &quot;pass&quot;;</div><div class="line"></div><div class="line">	public String getPassword() &#123;</div><div class="line">		return password;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setPassword(String password) &#123;</div><div class="line">		this.password = password;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private void writeObject(ObjectOutputStream out) &#123;</div><div class="line">		try &#123;</div><div class="line">			PutField putFields = out.putFields();</div><div class="line">			System.out.println(&quot;原密码:&quot; + password);</div><div class="line">			password = &quot;encryption&quot;;//模拟加密</div><div class="line">			putFields.put(&quot;password&quot;, password);</div><div class="line">			System.out.println(&quot;加密后的密码&quot; + password);</div><div class="line">			out.writeFields();</div><div class="line">		&#125; catch (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private void readObject(ObjectInputStream in) &#123;</div><div class="line">		try &#123;</div><div class="line">			GetField readFields = in.readFields();</div><div class="line">			Object object = readFields.get(&quot;password&quot;, &quot;&quot;);</div><div class="line">			System.out.println(&quot;要解密的字符串:&quot; + object.toString());</div><div class="line">			password = &quot;pass&quot;;//模拟解密,需要获得本地的密钥</div><div class="line">		&#125; catch (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; catch (ClassNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		try &#123;</div><div class="line">			ObjectOutputStream out = new ObjectOutputStream(</div><div class="line">					new FileOutputStream(&quot;result.obj&quot;));</div><div class="line">			out.writeObject(new Test());</div><div class="line">			out.close();</div><div class="line"></div><div class="line">			ObjectInputStream oin = new ObjectInputStream(new FileInputStream(</div><div class="line">					&quot;result.obj&quot;));</div><div class="line">			Test t = (Test) oin.readObject();</div><div class="line">			System.out.println(&quot;解密后的字符串:&quot; + t.getPassword());</div><div class="line">			oin.close();</div><div class="line">		&#125; catch (FileNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; catch (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; catch (ClassNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在清单 3 的 writeObject 方法中，对密码进行了加密，在 readObject 中则对 password 进行解密，只有拥有密钥的客户端，才可以正确的解析出密码，确保了数据的安全。执行清单 3 后控制台输出如图 3 所示。<br><img src="http://www.ibm.com/developerworks/cn/java/j-lo-serial/image007.jpg" alt="image">    </p>
<h4 id="特性使用案例-2"><a href="#特性使用案例-2" class="headerlink" title="特性使用案例"></a>特性使用案例</h4><p>RMI 技术是完全基于 Java 序列化技术的，服务器端接口调用所需要的参数对象来至于客户端，它们通过网络相互传输。这就涉及 RMI 的安全传输的问题。一些敏感的字段，如用户名密码（用户登录时需要对密码进行传输），我们希望对其进行加密，这时，就可以采用本节介绍的方法在客户端对密码进行加密，服务器端进行解密，确保数据传输的安全性。</p>
<h3 id="序列化存储规则"><a href="#序列化存储规则" class="headerlink" title="序列化存储规则"></a>序列化存储规则</h3><p>清单 4. 存储规则问题代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">ObjectOutputStream out = new ObjectOutputStream(</div><div class="line">					new FileOutputStream(&quot;result.obj&quot;));</div><div class="line">Test test = new Test();</div><div class="line">//试图将对象两次写入文件</div><div class="line">out.writeObject(test);</div><div class="line">out.flush();</div><div class="line">System.out.println(new File(&quot;result.obj&quot;).length());</div><div class="line">out.writeObject(test);</div><div class="line">out.close();</div><div class="line">System.out.println(new File(&quot;result.obj&quot;).length());</div><div class="line"></div><div class="line">ObjectInputStream oin = new ObjectInputStream(new FileInputStream(</div><div class="line">		&quot;result.obj&quot;));</div><div class="line">//从文件依次读出两个文件</div><div class="line">Test t1 = (Test) oin.readObject();</div><div class="line">Test t2 = (Test) oin.readObject();</div><div class="line">oin.close();</div><div class="line">		</div><div class="line">//判断两个引用是否指向同一个对象</div><div class="line">System.out.println(t1 == t2);</div></pre></td></tr></table></figure></p>
<p>清单 4 中对同一对象两次写入文件，打印出写入一次对象后的存储大小和写入两次后的存储大小，然后从文件中反序列化出两个对象，比较这两个对象是否为同一对象。一般的思维是，两次写入对象，文件大小会变为两倍的大小，反序列化时，由于从文件读取，生成了两个对象，判断相等时应该是输入 false 才对，但是最后结果输出如图 4 所示。<br><img src="http://www.ibm.com/developerworks/cn/java/j-lo-serial/image009.jpg" alt="image"><br>我们看到，第二次写入对象时文件只增加了 5 字节，并且两个对象是相等的，这是为什么呢？    </p>
<p>解答：Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用，上面增加的 5 字节的存储空间就是新增引用和一些控制信息的空间。反序列化时，恢复引用关系，使得清单 3 中的 t1 和 t2 指向唯一的对象，二者相等，输出 true。该存储规则极大的节省了存储空间。</p>
<h4 id="特性案例分析"><a href="#特性案例分析" class="headerlink" title="特性案例分析"></a>特性案例分析</h4><p>清单 5. 案例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;result.obj&quot;));</div><div class="line">Test test = new Test();</div><div class="line">test.i = 1;</div><div class="line">out.writeObject(test);</div><div class="line">out.flush();</div><div class="line">test.i = 2;</div><div class="line">out.writeObject(test);</div><div class="line">out.close();</div><div class="line">ObjectInputStream oin = new ObjectInputStream(new FileInputStream(</div><div class="line">					&quot;result.obj&quot;));</div><div class="line">Test t1 = (Test) oin.readObject();</div><div class="line">Test t2 = (Test) oin.readObject();</div><div class="line">System.out.println(t1.i);</div><div class="line">System.out.println(t2.i);</div></pre></td></tr></table></figure></p>
<p>清单 5 的目的是希望将 test 对象两次保存到 result.obj 文件中，写入一次以后修改对象属性值再次保存第二次，然后从 result.obj 中再依次读出两个对象，输出这两个对象的 i 属性值。案例代码的目的原本是希望一次性传输对象修改前后的状态。<br>结果两个输出的都是 1， 原因就是第一次写入对象以后，第二次再试图写的时候，虚拟机根据引用关系知道已经有一个相同对象已经写入文件，因此只保存第二次写的引用，所以读取时，都是第一次保存的对象。读者在使用一个文件多次 writeObject 需要特别注意这个问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/基础/序列化和反序列化/" data-id="cjei8ydg7004d7obl3gfyepco" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/基础/java8新特性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/基础/java8新特性/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/基础/java8新特性/">java8新特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="函数式接口（Functional-Interfaces）"><a href="#函数式接口（Functional-Interfaces）" class="headerlink" title="函数式接口（Functional Interfaces）"></a>函数式接口（Functional Interfaces）</h2><p>Java 8 引入的一个核心概念是函数式接口（<strong>Functional Interfaces</strong>）。通过在接口里面添加一个抽象方法，这些方法可以直接从接口中运行。如果一个接口定义个唯一一个抽象方法，那么这个接口就成为<strong>函数式接口</strong>。</p>
<p>同时，引入了一个新的注解：<code>@FunctionalInterface</code>。可以把他它放在一个接口前，表示这个接口是一个函数式接口。这个注解是非必须的，只要接口只包含一个方法的接口，虚拟机会自动判断，不过最好在接口上使用注解 @FunctionalInterface 进行声明。在接口中添加了 @FunctionalInterface 的接口，只允许有一个抽象方法，否则编译器也会报错。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">interface Converter&lt;F, T&gt; &#123;</div><div class="line">    T convert(F from);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</div><div class="line">Integer converted = converter.convert(&quot;123&quot;);</div><div class="line">System.out.println(converted);    // 123</div></pre></td></tr></table></figure></p>
<p>java.lang.Runnable 就是一个函数式接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface Runnable &#123;</div><div class="line">    public abstract void run();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们要记住默认的方法和静态方法不会违反函数接口的约定，例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface FunctionalDefaultMethods &#123;</div><div class="line">    void method();</div><div class="line"> </div><div class="line">    default void defaultMethod() &#123;</div><div class="line">        //相关代码</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    static void staticMethod() &#123;</div><div class="line">        //相关代码</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="方法和构造函数引用"><a href="#方法和构造函数引用" class="headerlink" title="方法和构造函数引用"></a>方法和构造函数引用</h2><p>上面的示例代码可以通过使用静态方法引用进一步简化:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</div><div class="line">Integer converted = converter.convert(&quot;123&quot;);</div><div class="line">System.out.println(converted);   // 123</div></pre></td></tr></table></figure></p>
<p>Java 8允许您通过<code>::</code>关键字来传递方法或构造函数的引用。上面的示例展示了如何引用静态方法。但是我们也可以引用对象方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Something &#123;</div><div class="line">    String startsWith(String s) &#123;</div><div class="line">        return String.valueOf(s.charAt(0));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Something something = new Something();</div><div class="line">Converter&lt;String, String&gt; converter = something::startsWith;</div><div class="line">String converted = converter.convert(&quot;Java&quot;);</div><div class="line">System.out.println(converted);    // &quot;J&quot;</div></pre></td></tr></table></figure></p>
<p>让我们看看<code>::</code>关键字如何对构造函数有效。首先，我们定义了一个不同构造函数的示例bean:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">    String firstName;</div><div class="line">    String lastName;</div><div class="line"></div><div class="line">    Person() &#123;&#125;</div><div class="line"></div><div class="line">    Person(String firstName, String lastName) &#123;</div><div class="line">        this.firstName = firstName;</div><div class="line">        this.lastName = lastName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来，我们指定一个人工厂接口用于创建新人员:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">interface PersonFactory&lt;P extends Person&gt; &#123;</div><div class="line">    P create(String firstName, String lastName);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们没有手工地实现工厂，而是通过构造函数引用将所有内容粘在一起:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PersonFactory&lt;Person&gt; personFactory = Person::new;</div><div class="line">Person person = personFactory.create(&quot;Peter&quot;, &quot;Parker&quot;);</div></pre></td></tr></table></figure></p>
<p>我们通过<code>Person::new</code>创建一个Person构造函数的引用。Java编译器会通过匹配PersonFactory.create的签名来自动选择正确的构造函数。</p>
<p>方法引用提供了一个很有用的语义来直接访问类或者实例的已经存在的方法或者构造方法。结合Lambda表达式，方法引用使语法结构紧凑简明。不需要复杂的引用。</p>
<p>下面我们用Car 这个类来做示例，Car这个类有不同的方法定义。让我们来看看java 8支持的4种方法引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public static class Car &#123;</div><div class="line">    public static Car create( final Supplier&lt; Car &gt; supplier ) &#123;</div><div class="line">        return supplier.get();</div><div class="line">    &#125;              </div><div class="line"> </div><div class="line">    public static void collide( final Car car ) &#123;</div><div class="line">        System.out.println( &quot;Collided &quot; + car.toString() );</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void follow( final Car another ) &#123;</div><div class="line">        System.out.println( &quot;Following the &quot; + another.toString() );</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void repair() &#123;</div><div class="line">        System.out.println( &quot;Repaired &quot; + this.toString() );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li><p>第一种方法引用是构造方法引用，语法是：<code>Class::new</code> ，对于泛型来说语法是：<code>Class&lt;T &gt;::new</code>，请注意构造方法没有参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">final Car car = Car.create( Car::new );</div><div class="line">final List&lt; Car &gt; cars = Arrays.asList( car );</div></pre></td></tr></table></figure>
</li>
<li><p>第二种方法引用是静态方法引用，语法是：<code>Class::static_method</code>请注意这个静态方法只支持一个类型为Car的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cars.forEach( Car::collide );</div></pre></td></tr></table></figure>
</li>
<li><p>第三种方法引用是类实例的方法引用，语法是：<code>Class::method</code>请注意方法没有参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cars.forEach( Car::repair );</div></pre></td></tr></table></figure>
</li>
<li><p>最后一种方法引用是引用特殊类的方法，语法是：<code>instance::method</code>，请注意只接受Car类型的一个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">final Car police = Car.create( Car::new );</div><div class="line">cars.forEach( police::follow );</div></pre></td></tr></table></figure>
</li>
</ol>
<p>运行这些例子我们将会在控制台得到如下信息（Car的实例可能会不一样）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Collided com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d</div><div class="line">Repaired com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d</div><div class="line">Following the com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d</div></pre></td></tr></table></figure></p>
<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>从lambda表达式访问外部范围变量非常类似于匿名对象。您可以从本地外部范围访问最终变量，以及实例字段和静态变量。</p>
<h3 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h3><p>我们可以从lambda表达式的外部范围读取最终的局部变量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">final int num = 1;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line"></div><div class="line">stringConverter.convert(2);     // 3</div></pre></td></tr></table></figure></p>
<p>但与匿名对象不同的是，变量num不必被声明为final。这段代码也是有效的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int num = 1;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line"></div><div class="line">stringConverter.convert(2);     // 3</div></pre></td></tr></table></figure></p>
<p>但是，对于要编译的代码，num必须是隐式的final。以下代码不编译:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int num = 1;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line">num = 3;</div></pre></td></tr></table></figure></p>
<p>也禁止在lambda表达式中写入num。</p>
<h3 id="访问字段和静态变量"><a href="#访问字段和静态变量" class="headerlink" title="访问字段和静态变量"></a>访问字段和静态变量</h3><p>在对局部变量的限制中，我们可以从lambda表达式中读取和写入对实例字段和静态变量的访问。这种行为在匿名对象中很常见。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Lambda4 &#123;</div><div class="line">    static int outerStaticNum;</div><div class="line">    int outerNum;</div><div class="line"></div><div class="line">    void testScopes() &#123;</div><div class="line">        Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;</div><div class="line">            outerNum = 23;</div><div class="line">            return String.valueOf(from);</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;</div><div class="line">            outerStaticNum = 72;</div><div class="line">            return String.valueOf(from);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="访问默认接口方法"><a href="#访问默认接口方法" class="headerlink" title="访问默认接口方法"></a>访问默认接口方法</h3><p>还记得第一部分的公式例子吗?接口公式定义了一个默认的方法sqrt，它可以从每个公式实例(包括匿名对象)访问。这不适用于lambda表达式。</p>
<p>无法从lambda表达式中访问默认方法。以下代码不编译:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Formula formula = (a) -&gt; sqrt( a * 100);</div></pre></td></tr></table></figure></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>函数式接口的重要属性是：我们能够使用 Lambda 实例化它们，Lambda 表达式让你能够将函数作为方法参数，或者将代码作为数据对待</strong>。Lambda 表达式的引入给开发者带来了不少优点：在 Java 8 之前，匿名内部类，监听器和事件处理器的使用都显得很冗长，代码可读性很差，Lambda 表达式的应用则使代码变得更加紧凑，可读性增强；Lambda 表达式使并行操作大集合变得很方便，可以充分发挥多核 CPU 的优势，更易于为多核处理器编写代码；</p>
<p>Lambda 表达式由三个部分组成：</p>
<ul>
<li>第一部分为一个括号内用逗号分隔的形式参数，参数是函数式接口里面方法的参数；</li>
<li>第二部分为一个箭头符号：-&gt;；</li>
<li>第三部分为方法体，可以是表达式和代码块。</li>
</ul>
<p>语法如下：</p>
<ol>
<li><p>方法体为表达式，该表达式的值作为返回值返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(parameters) -&gt; expression</div></pre></td></tr></table></figure>
</li>
<li><p>方法体为代码块，必须用 {} 来包裹起来，且需要一个 return 返回值，但若函数式接口里面方法返回值是 void，则无需返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(parameters) -&gt; &#123; statements; &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>例如，下面是使用匿名内部类和 Lambda 表达式的代码比较。<br>下面是用匿名内部类的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">button.addActionListener(new ActionListener() &#123;</div><div class="line">    @Override</div><div class="line">    public void actionPerformed(ActionEvent e) &#123;</div><div class="line">        System.out.print(&quot;Helllo Lambda in actionPerformed&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>下面是使用 Lambda 表达式后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">button.addActionListener(</div><div class="line">    //actionPerformed 有一个参数 e 传入，所以用 (ActionEvent e)</div><div class="line">    (ActionEvent e)-&gt; </div><div class="line">    System.out.print(&quot;Helllo Lambda in actionPerformed&quot;);</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>上面是方法体包含了参数传入 (ActionEvent e)，如果没有参数则只需 ( )，例如 Thread 中的 run 方法就没有参数传入，当它使用 Lambda 表达式后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Thread t = new Thread(</div><div class="line">    //run 没有参数传入，所以用 (), 后面用 &#123;&#125; 包起方法体</div><div class="line">    () -&gt; &#123;</div><div class="line">     System.out.println(&quot;Hello from a thread in run&quot;);</div><div class="line">    &#125;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>通过上面两个代码的比较可以发现使用 Lambda 表达式可以简化代码，并提高代码的可读性。<br>为了进一步简化 Lambda 表达式，可以使用方法引用。例如，下面三种分别是使用内部类，使用 Lambda 表示式和使用方法引用方式的比较：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//1. 使用内部类</div><div class="line">Function&lt;Integer, String&gt; f = new Function&lt;Integer,String&gt;()&#123;</div><div class="line">    @Override</div><div class="line">    public String apply(Integer t) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//2. 使用 Lambda 表达式</div><div class="line">Function&lt;Integer, String&gt; f2 = (t)-&gt;String.valueOf(t); </div><div class="line"></div><div class="line">//3. 使用方法引用的方式</div><div class="line">Function&lt;Integer, String&gt; f1 = String::valueOf;</div></pre></td></tr></table></figure></p>
<p>要使用 Lambda 表达式，需要定义一个函数式接口，这样往往会让程序充斥着过量的仅为 Lambda 表达式服务的函数式接口。为了减少这样过量的函数式接口，Java 8 在 java.util.function 中增加了不少新的函数式通用接口。例如：</p>
<ul>
<li><p><code>Function&lt;T, R&gt;</code>：将 T 作为输入，返回 R 作为输出，他还包含了和其他函数组合的默认方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</div><div class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</div><div class="line"></div><div class="line">backToString.apply(&quot;123&quot;);     // &quot;123&quot;</div></pre></td></tr></table></figure>
</li>
<li><p><code>Predicate&lt;T&gt;</code> ：将 T 作为输入，返回一个布尔值作为输出，该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（与、或、非）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">   Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;</div><div class="line">System.out.println(predicate.test(&quot;foo&quot;));// true   </div><div class="line">System.out.println(predicate.negate().test(&quot;foo&quot;));// false</div><div class="line"></div><div class="line">Predicate&lt;String&gt; nonNull = Objects::nonNull;</div><div class="line">Predicate&lt;String&gt; isNull = Objects::isNull;</div><div class="line">System.out.println(nonNull.test(&quot;aa&quot;));//true</div><div class="line">System.out.println(isNull.test(&quot;aa&quot;));//false</div><div class="line"></div><div class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</div><div class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</div></pre></td></tr></table></figure>
</li>
<li><p><code>Suppliers</code>：生成给定泛型类型的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Supplier&lt;Person&gt; personSupplier = Person::new;</div><div class="line">personSupplier.get();   // new Person</div></pre></td></tr></table></figure>
</li>
<li><p><code>Consumer&lt;T&gt;</code> ：将 T 作为输入，不返回任何内容，表示在单个参数上的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(&quot;Hello, &quot; + p.firstName);</div><div class="line">greeter.accept(new Person(&quot;Luke&quot;, &quot;Skywalker&quot;));</div></pre></td></tr></table></figure>
</li>
<li><p><code>Comparators</code>：比较器是较老版本的Java所熟悉的。Java 8向接口添加了各种默认方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</div><div class="line"></div><div class="line">Person p1 = new Person(&quot;John&quot;, &quot;Doe&quot;);</div><div class="line">Person p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;);</div><div class="line"></div><div class="line">comparator.compare(p1, p2);             // &gt; 0</div><div class="line">comparator.reversed().compare(p1, p2);  // &lt; 0</div></pre></td></tr></table></figure>
</li>
<li><p><code>Optionals</code>：Optionals不是功能性接口，相反，它是一个防止NullPointerException的漂亮工具</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Optional&lt;String&gt; optional = Optional.of(&quot;bam&quot;);</div><div class="line"></div><div class="line">optional.isPresent();           // true</div><div class="line">optional.get();                 // &quot;bam&quot;</div><div class="line">optional.orElse(&quot;fallback&quot;);    // &quot;bam&quot;</div><div class="line"></div><div class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(0)));     // &quot;b&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>著名的NullPointerException 是引起系统失败最常见的原因。很久以前Google Guava项目引入了Optional作为解决空指针异常的一种方式，不赞成代码被null检查的代码污染，期望程序员写整洁的代码。受Google Guava的鼓励，Optional 现在是Java 8库的一部分。</p>
<p>Optional 只是一个容器，它可以保存一些类型的值或者null。它提供很多有用的方法，所以没有理由不显式地检查null。请参照java 8的<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" target="_blank" rel="external">文档</a>查看详细信息。</p>
<p>让我们看看两个Optional 用法的小例子：一个是允许为空的值，另外一个是不允许为空的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Optional&lt; String &gt; fullName = Optional.ofNullable( null );</div><div class="line">System.out.println( &quot;Full Name is set? &quot; + fullName.isPresent() );        </div><div class="line">System.out.println( &quot;Full Name: &quot; + fullName.orElseGet( () -&gt; &quot;[none]&quot; ) ); </div><div class="line">System.out.println( fullName.map( s -&gt; &quot;Hey &quot; + s + &quot;!&quot; ).orElse( &quot;Hey Stranger!&quot; ) );</div></pre></td></tr></table></figure></p>
<p>如果Optional实例有非空的值，方法 isPresent() 返回true否则返回false。方法orElseGet提供了回退机制，当Optional的值为空时接受一个方法返回默认值。map()方法转化Optional当前的值并且返回一个新的Optional实例。orElse方法和orElseGet类似，但是它不接受一个方法，而是接受一个默认值。上面代码运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Full Name is set? false</div><div class="line">Full Name: [none]</div><div class="line">Hey Stranger!</div></pre></td></tr></table></figure></p>
<p>例如，People 类中有一个方法 getMaleList 需要获取男性的列表，这里需要定义一个函数式接口 PersonInterface：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">interface PersonInterface &#123;</div><div class="line">    public boolean test(Person person);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class People &#123;</div><div class="line">    private List&lt;Person&gt; persons= new ArrayList&lt;Person&gt;();</div><div class="line">    public List&lt;Person&gt; getMaleList(PersonInterface filter) &#123;</div><div class="line">        List&lt;Person&gt; res = new ArrayList&lt;Person&gt;();</div><div class="line">        persons.forEach(</div><div class="line">            (Person person) -&gt; </div><div class="line">                &#123;</div><div class="line">                    if (filter.test(person)) &#123;//调用 PersonInterface 的方法</div><div class="line">                        res.add(person);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">        );</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了去除 PersonInterface 这个函数式接口，可以用通用函数式接口 Predicate 替代如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class People&#123;</div><div class="line">    private List&lt;Person&gt; persons= new ArrayList&lt;Person&gt;();</div><div class="line">    public List&lt;Person&gt; getMaleList(Predicate&lt;Person&gt; predicate) &#123;</div><div class="line">        List&lt;Person&gt; res = new ArrayList&lt;Person&gt;();</div><div class="line">        persons.forEach(</div><div class="line">            person -&gt; &#123;</div><div class="line">                if (predicate.test(person)) &#123;//调用 Predicate 的抽象方法 test</div><div class="line">                    res.add(person);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( e -&gt; System.out.println( e ) );</div></pre></td></tr></table></figure></p>
<p>请注意到编译器会根据上下文来推测参数的类型，或者你也可以显示地指定参数类型，只需要将类型包在括号里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( ( String e ) -&gt; System.out.println( e ) );</div></pre></td></tr></table></figure></p>
<p>如果Lambda的功能语句块太复杂，我们可以用大括号包起来，跟普通的Java方法一样，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String separator = &quot;,&quot;;</div><div class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach(</div><div class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</div></pre></td></tr></table></figure></p>
<p>Lambda表达式可能会引用类的成员或者局部变量（会被隐式地转变成final类型），下面两种写法的效果是一样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">String separator = &quot;,&quot;;</div><div class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach(</div><div class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</div><div class="line">    </div><div class="line">final String separator = &quot;,&quot;;</div><div class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach(</div><div class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</div></pre></td></tr></table></figure></p>
<p>Lambda表达式可能会有返回值，编译器会根据上下文推断返回值的类型。如果lambda的语句块只有一行，不需要return关键字。下面两个写法是等价的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).sort( ( e1, e2 ) -&gt; e1.compareTo( e2 ) );</div><div class="line"></div><div class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).sort( ( e1, e2 ) -&gt; &#123;</div><div class="line">    int result = e1.compareTo( e2 );</div><div class="line">    return result;</div><div class="line">&#125; );</div></pre></td></tr></table></figure></p>
<h2 id="接口的增强"><a href="#接口的增强" class="headerlink" title="接口的增强"></a>接口的增强</h2><p>Java 8 对接口做了进一步的增强。在接口中可以添加使用 <code>default</code> 关键字修饰的非抽象方法。还可以在接口中定义静态方法。如今，接口看上去与抽象类的功能越来越类似了。</p>
<h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>Java 8 还允许我们给接口添加一个非抽象的方法实现，只需要使用 default 关键字即可，这个特征又叫做<strong>扩展方法</strong>。在实现该接口时，该默认扩展方法在子类上可以直接使用，它的使用方式类似于抽象类中非抽象成员方法。但扩展方法不能够重载 Object 中的方法。例如：toString、equals、 hashCode 不能在接口中被重载。</p>
<p><strong>一个接口可以包含多个默认方法和静态方法</strong>。</p>
<p>例如，下面接口中定义了一个默认方法 count()，该方法可以在子类中直接使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public interface DefaultFunInterface &#123;</div><div class="line">    //定义默认方法 count</div><div class="line">    default int count()&#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class SubDefaultFunClass implements DefaultFunInterface &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        //实例化一个子类对象，改子类对象可以直接调用父接口中的默认方法 count</div><div class="line">        SubDefaultFunClass sub = new SubDefaultFunClass();</div><div class="line">        sub.count();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>默认方法和抽象方法的区别是抽象方法必须要被实现，默认方法不是。作为替代方式，接口可以提供一个默认的方法实现，所有这个接口的实现类都会通过继承得倒这个方法（如果有需要也可以重写这个方法），让我们来看看下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private interface Defaulable &#123;</div><div class="line">    // Interfaces now allow default methods, the implementer may or</div><div class="line">    // may not implement (override) them.</div><div class="line">    default String notRequired() &#123;</div><div class="line">        return &quot;Default implementation&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">private static class DefaultableImpl implements Defaulable &#123;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">private static class OverridableImpl implements Defaulable &#123;</div><div class="line">    @Override</div><div class="line">    public String notRequired() &#123;</div><div class="line">        return &quot;Overridden implementation&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接口Defaulable使用default关键字声明了一个默认方法notRequired()，类DefaultableImpl实现了Defaulable接口，没有对默认方法做任何修改。另外一个类OverridableImpl重写类默认实现，提供了自己的实现方法。</p>
<p>JVM平台的接口的默认方法实现是很高效的，并且方法调用的字节码指令支持默认方法。默认方法使已经存在的接口可以修改而不会影响编译的过程。java.util.Collection中添加的额外方法就是最好的例子：stream(), parallelStream(), forEach(), removeIf()</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>在接口中，还允许定义静态的方法。接口中的静态方法可以直接用接口来调用。</p>
<p>例如，下面接口中定义了一个静态方法 find，该方法可以直接用 StaticFunInterface .find() 来调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public interface StaticFunInterface &#123;</div><div class="line">    public static int find()&#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class TestStaticFun &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        //接口中定义了静态方法 find 直接被调用</div><div class="line">        StaticFunInterface.fine();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="集合之流式操作"><a href="#集合之流式操作" class="headerlink" title="集合之流式操作"></a>集合之流式操作</h2><p>Java 8 引入了流式操作（Stream），通过该操作可以实现对集合（Collection）的并行处理和函数式操作。根据操作返回的结果不同，流式操作分为中间操作和最终操作两种。最终操作返回一特定类型的结果，而中间操作返回流本身，这样就可以将多个操作依次串联起来。根据流的并发性，流又可以分为串行和并行两种。<strong>流式操作实现了集合的过滤、排序、映射等功能</strong>。</p>
<p><strong>Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算</strong>。</p>
<h3 id="串行和并行的流"><a href="#串行和并行的流" class="headerlink" title="串行和并行的流"></a>串行和并行的流</h3><p>流有串行和并行两种，串行流上的操作是在一个线程中依次完成，而并行流则是在多个线程上同时执行。并行与串行的流可以相互切换：通过 stream.sequential() 返回串行的流，通过 stream.parallel() 返回并行的流。相比较串行的流，并行的流可以很大程度上提高程序的执行效率。</p>
<p>下面是分别用串行和并行的方式对集合进行排序。</p>
<h6 id="串行排序："><a href="#串行排序：" class="headerlink" title="串行排序："></a>串行排序：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line">for(int i=0;i&lt;1000000;i++)&#123;</div><div class="line">    double d = Math.random()*1000;</div><div class="line">    list.add(d+&quot;&quot;);</div><div class="line">&#125;</div><div class="line">long start = System.nanoTime();//获取系统开始排序的时间点</div><div class="line">int count= (int) ((Stream) list.stream().sequential()).sorted().count();</div><div class="line">long end = System.nanoTime();//获取系统结束排序的时间点</div><div class="line">long ms = TimeUnit.NANOSECONDS.toMillis(end-start);//得到串行排序所用的时间</div><div class="line">System.out.println(ms+”ms”);</div></pre></td></tr></table></figure>
<h6 id="并行排序："><a href="#并行排序：" class="headerlink" title="并行排序："></a>并行排序：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line">for(int i=0;i&lt;1000000;i++)&#123;</div><div class="line">    double d = Math.random()*1000;</div><div class="line">    list.add(d+&quot;&quot;);</div><div class="line">&#125;</div><div class="line">long start = System.nanoTime();//获取系统开始排序的时间点</div><div class="line">int count = (int)((Stream) list.stream().parallel()).sorted().count();</div><div class="line">long end = System.nanoTime();//获取系统结束排序的时间点</div><div class="line">long ms = TimeUnit.NANOSECONDS.toMillis(end-start);//得到并行排序所用的时间</div><div class="line">System.out.println(ms+”ms”);</div><div class="line">//串行输出为 1200ms，并行输出为 800ms。可见，并行排序的时间相比较串行排序时间要少不少。</div></pre></td></tr></table></figure>
<h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><p>该操作会保持 stream 处于中间状态，允许做进一步的操作。它返回的还是的 Stream，允许更多的链式操作。常见的中间操作有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();</div><div class="line">stringCollection.add(&quot;ddd2&quot;);</div><div class="line">stringCollection.add(&quot;aaa2&quot;);</div><div class="line">stringCollection.add(&quot;bbb1&quot;);</div><div class="line">stringCollection.add(&quot;aaa1&quot;);</div><div class="line">stringCollection.add(&quot;bbb3&quot;);</div><div class="line">stringCollection.add(&quot;ccc&quot;);</div><div class="line">stringCollection.add(&quot;bbb2&quot;);</div><div class="line">stringCollection.add(&quot;ddd1&quot;);</div></pre></td></tr></table></figure></p>
<ul>
<li><p><code>filter()</code>：对元素进行过滤；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">stringCollection</div><div class="line">    .stream()</div><div class="line">    .filter((s) -&gt; s.startsWith(&quot;a&quot;))</div><div class="line">    .forEach(System.out::println);</div><div class="line"></div><div class="line">// &quot;aaa2&quot;, &quot;aaa1&quot;</div></pre></td></tr></table></figure>
</li>
<li><p><code>sorted()</code>：对元素排序,排序只创建流的排序视图，原来集合顺序不变；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">stringCollection</div><div class="line">    .stream()</div><div class="line">    .sorted()</div><div class="line">    .filter((s) -&gt; s.startsWith(&quot;a&quot;))</div><div class="line">    .forEach(System.out::println);</div><div class="line"></div><div class="line">// &quot;aaa1&quot;, &quot;aaa2&quot;</div><div class="line"></div><div class="line">System.out.println(stringCollection);</div><div class="line">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</div></pre></td></tr></table></figure>
</li>
<li><p><code>map()</code>：元素的映射,中间操作映射通过给定的函数将每个元素转换成另一个对象。下面的示例将每个字符串转换为一个大写字符串。但是您也可以使用map将每个对象转换成另一个类型。生成的流的泛型类型取决于您传递给映射的函数的泛型类型。原来的集合不受影响；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">stringCollection</div><div class="line">    .stream()</div><div class="line">    .map(String::toUpperCase)</div><div class="line">    .sorted((a, b) -&gt; b.compareTo(a))</div><div class="line">    .forEach(System.out::println);</div><div class="line"></div><div class="line">// &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;AAA2&quot;, &quot;AAA1&quot;</div></pre></td></tr></table></figure>
</li>
<li><p><code>distinct()</code>：去除重复元素；</p>
</li>
<li><code>subStream()</code>：获取子 Stream 等。</li>
</ul>
<p>例如，下面是对一个字符串集合进行过滤，返回以“s”开头的字符串集合，并将该集合依次打印出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">list.stream()</div><div class="line">    .filter((s) -&gt; s.startsWith(&quot;s&quot;))</div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<p>这里的 filter(…) 就是一个中间操作，该中间操作可以链式地应用其他 Stream 操作。</p>
<h3 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h3><p>该操作必须是流的最后一个操作，一旦被调用，Stream 就到了一个终止状态，而且不能再使用了。常见的终止操作有：</p>
<ul>
<li><code>forEach()</code>：对每个元素做处理；</li>
<li><code>toArray()</code>：把元素导出到数组；</li>
<li><code>findFirst()</code>：返回第一个匹配的元素；</li>
<li><p><code>Match</code>：可以使用各种匹配操作检查某个谓词是否与流匹配。所有这些操作都是终端，并返回一个布尔结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">boolean anyStartsWithA =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .anyMatch((s) -&gt; s.startsWith(&quot;a&quot;));</div><div class="line"></div><div class="line">System.out.println(anyStartsWithA);      // true</div><div class="line"></div><div class="line">boolean allStartsWithA =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .allMatch((s) -&gt; s.startsWith(&quot;a&quot;));</div><div class="line"></div><div class="line">System.out.println(allStartsWithA);      // false</div><div class="line"></div><div class="line">boolean noneStartsWithZ =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .noneMatch((s) -&gt; s.startsWith(&quot;z&quot;));</div><div class="line"></div><div class="line">System.out.println(noneStartsWithZ);      // true</div></pre></td></tr></table></figure>
</li>
<li><p><code>Count</code>：返回流中元素的数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">long startsWithB =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .filter((s) -&gt; s.startsWith(&quot;b&quot;))</div><div class="line">        .count();</div><div class="line"></div><div class="line">System.out.println(startsWithB);    // 3</div></pre></td></tr></table></figure>
</li>
<li><p><code>Reduce</code>：通过给定的函数对流的元素进行还原。结果是存于Optional中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Optional&lt;String&gt; reduced =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .sorted()</div><div class="line">        .reduce((s1, s2) -&gt; s1 + &quot;#&quot; + s2);</div><div class="line"></div><div class="line">reduced.ifPresent(System.out::println);</div><div class="line">// &quot;aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>例如，下面是对一个字符串集合进行过滤，返回以“s”开头的字符串集合，并将该集合依次打印出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">list.stream() //获取列表的 stream 操作对象</div><div class="line">    .filter((s) -&gt; s.startsWith(&quot;s&quot;))//对这个流做过滤操作</div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<p>这里的 forEach(…) 就是一个终止操作，该操作之后不能再链式的添加其他操作了。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>现在Map支持用于执行常见任务的各种新的和有用的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</div><div class="line"></div><div class="line">for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">    map.putIfAbsent(i, &quot;val&quot; + i);</div><div class="line">&#125;</div><div class="line"></div><div class="line">map.forEach((id, val) -&gt; System.out.println(val));</div></pre></td></tr></table></figure></p>
<p>map的计算:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">map.computeIfPresent(3, (num, val) -&gt; val + num);</div><div class="line">map.get(3);             // val33</div><div class="line"></div><div class="line">map.computeIfPresent(9, (num, val) -&gt; null);</div><div class="line">map.containsKey(9);     // false</div><div class="line"></div><div class="line">map.computeIfAbsent(23, num -&gt; &quot;val&quot; + num);</div><div class="line">map.containsKey(23);    // true</div><div class="line"></div><div class="line">map.computeIfAbsent(3, num -&gt; &quot;bam&quot;);</div><div class="line">map.get(3);             // val33</div></pre></td></tr></table></figure></p>
<p>通过给定的key来删除元素，只有value值匹配才会删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">map.remove(3, &quot;val3&quot;);</div><div class="line">map.get(3);             // val33</div><div class="line"></div><div class="line">map.remove(3, &quot;val33&quot;);</div><div class="line">map.get(3);             // null</div></pre></td></tr></table></figure></p>
<p>其他有用的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">map.getOrDefault(42, &quot;not found&quot;);  // not found</div></pre></td></tr></table></figure></p>
<p>合并：如果不存在则插入，存在则合并<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">map.merge(9, &quot;val9&quot;, (value, newValue) -&gt; value.concat(newValue));</div><div class="line">map.get(9);             // val9</div><div class="line"></div><div class="line">map.merge(9, &quot;concat&quot;, (value, newValue) -&gt; value.concat(newValue));</div><div class="line">map.get(9);             // val9concat</div></pre></td></tr></table></figure></p>
<h2 id="注解的更新"><a href="#注解的更新" class="headerlink" title="注解的更新"></a>注解的更新</h2><p>对于注解，Java 8 主要有两点改进：<strong>类型注解</strong>和<strong>重复注解</strong>。</p>
<p>Java 8 的类型注解扩展了注解使用的范围。在该版本之前，注解只能是在声明的地方使用。现在几乎可以为任何东西添加注解：局部变量、类与接口，就连方法的异常也能添加注解。</p>
<p>新增的两个注释的程序元素类型： <code>ElementType.TYPE_USE</code> 和 <code>ElementType.TYPE_PARAMETER</code> 用来描述注解的新场合。ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中。而 ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中（例如声明语句、泛型和强制转换语句中的类型）。</p>
<p>对类型注解的支持，增强了通过静态分析工具发现错误的能力。原先只能在运行时发现的问题可以提前在编译的时候被排查出来。Java 8 本身虽然没有自带类型检测的框架，但可以通过使用 Checker Framework 这样的第三方工具，自动检查和确认软件的缺陷，提高生产效率。</p>
<p>例如，下面的代码可以通过编译，但是运行时会报 NullPointerException 的异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class TestAnno &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Object obj = null;</div><div class="line">        obj.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了能在编译期间就自动检查出这类异常，可以通过类型注解结合 Checker Framework 提前排查出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import org.checkerframework.checker.nullness.qual.NonNull;</div><div class="line">public class TestAnno &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        @NonNull Object obj = null;</div><div class="line">        obj.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译时自动检测结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">C:\workspace\TestJava8\src\TestAnno.java:4: Warning:</div><div class="line">  (assignment.type.incompatible) $$ 2 $$ null $$ @UnknownInitialization @NonNull Object $$ ( 152, 156 )</div><div class="line">  $$ incompatible types in assignment.</div><div class="line">@NonNull Object obj = null;</div><div class="line"> ^</div><div class="line"> found : null</div><div class="line"> required: @UnknownInitialization @NonNull Object</div></pre></td></tr></table></figure></p>
<p>另外，在该版本之前使用注解的一个限制是相同的注解在同一位置只能声明一次，不能声明多次。Java 8 引入了重复注解机制，这样相同的注解可以在同一地方声明多次。重复注解机制本身必须用 <code>@Repeatable</code> 注解。</p>
<p>例如，下面就是用 @Repeatable 重复注解的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@Retention(RetentionPolicy.RUNTIME) \\该注解存在于类文件中并在运行时可以通过反射获取</div><div class="line">@interface Annots &#123;</div><div class="line">    Annot[] value();</div><div class="line">&#125; </div><div class="line"></div><div class="line">@Retention(RetentionPolicy.RUNTIME) \\该注解存在于类文件中并在运行时可以通过反射获取</div><div class="line">@Repeatable(Annots.class)</div><div class="line">@interface Annot &#123;</div><div class="line">    String value();</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Annot(&quot;a1&quot;)</div><div class="line">@Annot(&quot;a2&quot;)</div><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Annots annots1 = Test.class.getAnnotation(Annots.class);</div><div class="line">        System.out.println(annots1.value()[0]+&quot;,&quot;+annots1.value()[1]); </div><div class="line">        // 输出: @Annot(value=a1),@Annot(value=a2)</div><div class="line">        Annot[] annots2 = Test.class.getAnnotationsByType(Annot.class);</div><div class="line">        System.out.println(annots2[0]+&quot;,&quot;+annots2[1]); </div><div class="line">        // 输出: @Annot(value=a1),@Annot(value=a2)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注释 Annot 被 @Repeatable( Annots.class ) 注解。Annots 只是一个容器，它包含 Annot 数组, 编译器尽力向程序员隐藏它的存在。通过这样的方式，Test 类可以被 Annot 注解两次。重复注释的类型可以通过 getAnnotationsByType() 方法来返回。</p>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>现今，互联网环境中存在各种各种潜在的威胁，对于 Java 平台来说，安全显得特别重要。为了保证新版本具有更高的安全性，Java 8 在安全性上对许多方面进行了增强，也为此推迟了它的发布日期。下面例举其中几个关于安全性的更新：</p>
<p>支持更强的基于密码的加密算法。基于 AES 的加密算法，例如 PBEWithSHA256AndAES_128 和 PBEWithSHA512AndAES_256，已经被加入进来。</p>
<p>在客户端，TLS1.1 和 TLS1.2 被设为默认启动。并且可以通过新的系统属性包 jdk.tls.client.protocols 来对它进行配置。</p>
<p>Keystore 的增强，包含新的 Keystore 类型 java.security.DomainLoadStoreParameter 和为 Keytool 这个安全钥匙和证书的管理工具添加新的命令行选项-importpassword。同时，添加和更新了一些关于安全性的 API 来支持 KeyStore 的更新。</p>
<p>支持安全的随机数发生器。如果随机数来源于随机性不高的种子，那么那些用随机数来产生密钥或者散列敏感信息的系统就更易受攻击。SecureRandom 这个类的 getInstanceStrong 方法如今可以获取各个平台最强的随机数对象实例，通过这个实例生成像 RSA 私钥和公钥这样具有较高熵的随机数。</p>
<p>JSSE（Java(TM) Secure Socket Extension）服务器端开始支持 SSL/TLS 服务器名字识别 SNI（Server Name Indication）扩展。SNI 扩展目的是 SSL/TLS 协议可以通过 SNI 扩展来识别客户端试图通过握手协议连接的服务器名字。在 Java 7 中只在客户端默认启动 SNI 扩展。如今，在 JSSE 服务器端也开始支持 SNI 扩展了。</p>
<p>安全性比较差的加密方法被默认禁用。默认不支持 DES 相关的 Kerberos 5 加密方法。如果一定要使用这类弱加密方法需要在 krb5.conf 文件中添加 allow_weak_crypto=true。考虑到这类加密方法安全性极差，开发者应该尽量避免使用它。</p>
<h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><p>对Base64的支持最终成了Java 8标准库的一部分，非常简单易用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package com.javacodegeeks.java8.base64;</div><div class="line"> </div><div class="line">import java.nio.charset.StandardCharsets;</div><div class="line">import java.util.Base64;</div><div class="line"> </div><div class="line">public class Base64s &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        final String text = &quot;Base64 finally in Java 8!&quot;;</div><div class="line">         </div><div class="line">        final String encoded = Base64</div><div class="line">        .getEncoder()</div><div class="line">        .encodeToString( text.getBytes( StandardCharsets.UTF_8 ) );</div><div class="line">        System.out.println( encoded );</div><div class="line">         </div><div class="line">        final String decoded = new String(</div><div class="line">        Base64.getDecoder().decode( encoded ),</div><div class="line">        StandardCharsets.UTF_8 );</div><div class="line">        System.out.println( decoded );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>控制台输出的编码和解码的字符串:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">QmFzZTY0IGZpbmFsbHkgaW4gSmF2YSA4IQ==</div><div class="line">Base64 finally in Java 8!</div></pre></td></tr></table></figure></p>
<p>新的Base64API也支持URL和MINE的编码解码。</p>
<p><strong>(Base64.getUrlEncoder() / Base64.getUrlDecoder(), Base64.getMimeEncoder() / Base64.getMimeDecoder())</strong></p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>在新增Stream机制与lambda的基础之上，在java.util.concurrent.ConcurrentHashMap中加入了一些新方法来支持聚集操作。同时也在java.util.concurrent.ForkJoinPool类中加入了一些新方法来支持共有资源池（common pool）。</p>
<p>新增的java.util.concurrent.locks.StampedLock类提供一直基于容量的锁，这种锁有三个模型来控制读写操作（它被认为是不太有名的java.util.concurrent.locks.ReadWriteLock类的替代者）。</p>
<p>在java.util.concurrent.atomic包中还增加了下面这些类：</p>
<ul>
<li>DoubleAccumulator</li>
<li>DoubleAdder</li>
<li>LongAccumulator</li>
<li>LongAdder</li>
</ul>
<h2 id="IO-NIO-的改进"><a href="#IO-NIO-的改进" class="headerlink" title="IO/NIO 的改进"></a>IO/NIO 的改进</h2><p>Java 8 对 IO/NIO 也做了一些改进。主要包括：改进了 java.nio.charset.Charset 的实现，使编码和解码的效率得以提升，也精简了 jre/lib/charsets.jar 包；优化了 String(byte[],*) 构造方法和 String.getBytes() 方法的性能；还增加了一些新的 IO/NIO 方法，使用这些方法可以从文件或者输入流中获取流（java.util.stream.Stream），通过对流的操作，可以简化文本行处理、目录遍历和文件查找。</p>
<p>新增的 API 如下：</p>
<ul>
<li>BufferedReader.line(): 返回文本行的流 Stream<string></string></li>
<li>File.lines(Path, Charset):返回文本行的流 Stream<string></string></li>
<li>File.list(Path): 遍历当前目录下的文件和目录</li>
<li>File.walk(Path, int, FileVisitOption): 遍历某一个目录下的所有文件和指定深度的子目录</li>
<li>File.find(Path, int, BiPredicate, FileVisitOption… ): 查找相应的文件</li>
</ul>
<p>下面就是用流式操作列出当前目录下的所有文件和目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Files.list(new File(&quot;.&quot;).toPath())</div><div class="line">     .forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<h2 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h2><p>Java 8 版本还完善了全球化功能：支持新的 Unicode 6.2.0 标准，新增了日历和本地化的 API，改进了日期时间的管理等。</p>
<p>Java 的日期与时间 API 问题由来已久，Java 8 之前的版本中关于时间、日期及其他时间日期格式化类由于线程安全、重量级、序列化成本高等问题而饱受批评。Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。</p>
<p>新的 java.time 中包含了所有关于<code>时钟（Clock）</code>，<code>本地日期（LocalDate）</code>、<code>本地时间（LocalTime）</code>、<code>本地日期时间（LocalDateTime）</code>、<code>时区（ZonedDateTime）</code>和<code>持续时间（Duration）</code>的类。历史悠久的 Date 类新增了 toInstant() 方法，用于把 Date 转换成新的表示形式。这些新增的本地化时间日期 API 大大简化了了日期时间和本地化的管理。</p>
<h3 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h3><p>时钟提供对当前日期和时间的访问。时钟知道一个时区，可以代替System.currentTimeMillis()来检索当前的毫秒。时间线上的瞬时点也由类Instants表示。Instants可以用来创建遗留java.util.Date对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Clock clock = Clock.systemDefaultZone();</div><div class="line">long millis = clock.millis();</div><div class="line"></div><div class="line">Instant instant = clock.instant();</div><div class="line">Date legacyDate = Date.from(instant);</div></pre></td></tr></table></figure></p>
<h3 id="Timezones"><a href="#Timezones" class="headerlink" title="Timezones"></a>Timezones</h3><p>时区由ZoneId表示。可以通过静态工厂方法轻松地访问它们。时区定义了在instant和本地日期和时间之间转换重要的偏移量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">System.out.println(ZoneId.getAvailableZoneIds());</div><div class="line">// prints all available timezone ids</div><div class="line"></div><div class="line">ZoneId zone1 = ZoneId.of(&quot;Europe/Berlin&quot;);</div><div class="line">ZoneId zone2 = ZoneId.of(&quot;Brazil/East&quot;);</div><div class="line">System.out.println(zone1.getRules());</div><div class="line">System.out.println(zone2.getRules());</div><div class="line"></div><div class="line">// ZoneRules[currentStandardOffset=+01:00]</div><div class="line">// ZoneRules[currentStandardOffset=-03:00]</div></pre></td></tr></table></figure></p>
<h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><p>LocalTime表示没有时区的时间，例如:10pm或17:30:15。下面的示例为上面定义的时区创建了两个本地时间。然后我们比较两种情况，并计算两种时间之间的小时数和分钟数的差值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LocalTime now1 = LocalTime.now(zone1);</div><div class="line">LocalTime now2 = LocalTime.now(zone2);</div><div class="line"></div><div class="line">System.out.println(now1.isBefore(now2));  // false</div><div class="line"></div><div class="line">long hoursBetween = ChronoUnit.HOURS.between(now1, now2);</div><div class="line">long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</div><div class="line"></div><div class="line">System.out.println(hoursBetween);       // -3</div><div class="line">System.out.println(minutesBetween);     // -239</div></pre></td></tr></table></figure></p>
<p>LocalTime提供了各种工厂方法来简化新实例的创建，包括对时间字符串的解析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LocalTime late = LocalTime.of(23, 59, 59);</div><div class="line">System.out.println(late);       // 23:59:59</div><div class="line"></div><div class="line">DateTimeFormatter germanFormatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofLocalizedTime(FormatStyle.SHORT)</div><div class="line">        .withLocale(Locale.GERMAN);</div><div class="line"></div><div class="line">LocalTime leetTime = LocalTime.parse(&quot;13:37&quot;, germanFormatter);</div><div class="line">System.out.println(leetTime);   // 13:37</div></pre></td></tr></table></figure></p>
<h3 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h3><p>LocalDate表示一个不同的日期，如2014-03-11。它是不可变的，和LocalTime完全一样。该示例演示了如何通过添加或减少日、月或年来计算新的日期。请记住，每个操作都返回一个新实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">LocalDate today = LocalDate.now();</div><div class="line">LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);</div><div class="line">LocalDate yesterday = tomorrow.minusDays(2);</div><div class="line"></div><div class="line">LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);</div><div class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</div><div class="line">System.out.println(dayOfWeek);    // FRIDAY</div></pre></td></tr></table></figure></p>
<p>从字符串解析LocalDate就像解析LocalTime一样简单:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">DateTimeFormatter germanFormatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofLocalizedDate(FormatStyle.MEDIUM)</div><div class="line">        .withLocale(Locale.GERMAN);</div><div class="line"></div><div class="line">LocalDate xmas = LocalDate.parse(&quot;24.12.2014&quot;, germanFormatter);</div><div class="line">System.out.println(xmas);   // 2014-12-24</div></pre></td></tr></table></figure></p>
<h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p>LocalDateTime代表日期时间。它将上面几节中所看到的日期和时间合并为一个实例。LocalDateTime是不可变的，与LocalTime和LocalDate类似。我们可以利用方法来从数据时间检索某些字段:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);</div><div class="line"></div><div class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</div><div class="line">System.out.println(dayOfWeek);      // WEDNESDAY</div><div class="line"></div><div class="line">Month month = sylvester.getMonth();</div><div class="line">System.out.println(month);          // DECEMBER</div><div class="line"></div><div class="line">long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</div><div class="line">System.out.println(minuteOfDay);    // 1439</div></pre></td></tr></table></figure></p>
<p>有了一个时区的额外信息，它可以转换为实例。可以很容易地将Instants转换为java.util.Date类型的遗留日期。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Instant instant = sylvester</div><div class="line">        .atZone(ZoneId.systemDefault())</div><div class="line">        .toInstant();</div><div class="line"></div><div class="line">Date legacyDate = Date.from(instant);</div><div class="line">System.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014</div></pre></td></tr></table></figure></p>
<p>格式化日期时间就像格式化日期或时间一样。我们可以创建自定义模式的格式化程序，而不是使用预定义的格式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">DateTimeFormatter formatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofPattern(&quot;MMM dd, yyyy - HH:mm&quot;);</div><div class="line"></div><div class="line">LocalDateTime parsed = LocalDateTime.parse(&quot;Nov 03, 2014 - 07:13&quot;, formatter);</div><div class="line">String string = formatter.format(parsed);</div><div class="line">System.out.println(string);     // Nov 03, 2014 - 07:13</div></pre></td></tr></table></figure></p>
<p>不像java.text.NumberFormat新的DateTimeFormatter是不可变的和线程安全的。</p>
<p>例如，下面是对 Clock, LocalDate，LocalTime, LocalDateTime 的简单应用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">//Clock 时钟</div><div class="line">Clock clock = Clock.systemDefaultZone();//获取系统默认时区 (当前瞬时时间 )</div><div class="line">System.out.println( clock.instant() );//2014-04-12T15:19:29.282Z</div><div class="line">System.out.println( clock.millis() );//1397315969360</div><div class="line"></div><div class="line">// LocalDate: Get the local date and local time</div><div class="line">final LocalDate date = LocalDate.now();</div><div class="line">final LocalDate dateFromClock = LocalDate.now( clock );</div><div class="line">System.out.println( date );//2014-04-12</div><div class="line">System.out.println( dateFromClock );//2014-04-12</div><div class="line"> </div><div class="line">// LocalTime: Get the local date and local time</div><div class="line">final LocalTime time = LocalTime.now();</div><div class="line">final LocalTime timeFromClock = LocalTime.now( clock );</div><div class="line">System.out.println( time );//</div><div class="line">System.out.println( timeFromClock );//11:25:54.568</div><div class="line"></div><div class="line">// LocalDateTime: Get the local date/time</div><div class="line">final LocalDateTime datetime = LocalDateTime.now();</div><div class="line">final LocalDateTime datetimeFromClock = LocalDateTime.now( clock );</div><div class="line">System.out.println( datetime );//2014-04-12T11:37:52.309</div><div class="line">System.out.println( datetimeFromClock );//2014-04-12T15:37:52.309</div><div class="line"></div><div class="line">// 日期格式化：DateTimeFormatter是不可变的，是线程安全的</div><div class="line">DateTimeFormatter formatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofPattern(&quot;MMM dd, yyyy - HH:mm&quot;);</div><div class="line"></div><div class="line">LocalDateTime parsed = LocalDateTime.parse(&quot;Nov 03, 2014 - 07:13&quot;, formatter);</div><div class="line">String string = formatter.format(parsed);</div><div class="line">System.out.println(string);     // Nov 03, 2014 - 07:13</div></pre></td></tr></table></figure></p>
<p>如果您需要一个类持有日期时间和时区信息，可以使用ZonedDateTime，它保存有ISO-8601日期系统的日期和时间，而且有时区信息。让我们看一些例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// Get the zoned date/time</div><div class="line">final ZonedDateTime zonedDatetime = ZonedDateTime.now();</div><div class="line">final ZonedDateTime zonedDatetimeFromClock = ZonedDateTime.now( clock );</div><div class="line">final ZonedDateTime zonedDatetimeFromZone = ZonedDateTime.now( ZoneId.of( &quot;America/Los_Angeles&quot; ) );</div><div class="line"> </div><div class="line">System.out.println( zonedDatetime );</div><div class="line">System.out.println( zonedDatetimeFromClock );</div><div class="line">System.out.println( zonedDatetimeFromZone );</div></pre></td></tr></table></figure></p>
<p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2014-04-12T11:47:01.017-04:00[America/New_York]</div><div class="line">2014-04-12T15:47:01.017Z</div><div class="line">2014-04-12T08:47:01.017-07:00[America/Los_Angeles]</div></pre></td></tr></table></figure></p>
<p>最后让我们看看Duration类，Duration持有的时间精确到纳秒。它让我们很容易计算两个日期中间的差异。让我们来看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// Get duration between two dates</div><div class="line">final LocalDateTime from = LocalDateTime.of( 2014, Month.APRIL, 16, 0, 0, 0 );</div><div class="line">final LocalDateTime to = LocalDateTime.of( 2015, Month.APRIL, 16, 23, 59, 59 );</div><div class="line"> </div><div class="line">final Duration duration = Duration.between( from, to );</div><div class="line">System.out.println( &quot;Duration in days: &quot; + duration.toDays() );</div><div class="line">System.out.println( &quot;Duration in hours: &quot; + duration.toHours() );</div></pre></td></tr></table></figure></p>
<p>上面的例子计算了两个日期（2014年4月16日和2014年5月16日）之间的持续时间（基于天数和小时）输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Duration in days: 365</div><div class="line">Duration in hours: 8783</div></pre></td></tr></table></figure></p>
<h2 id="Nashorn-javascript引擎"><a href="#Nashorn-javascript引擎" class="headerlink" title="Nashorn javascript引擎"></a>Nashorn javascript引擎</h2><p>Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。Nashorn javascript引擎只是javax.script.ScriptEngine另一个实现，而且规则也一样，允许Java和JavaScript互相操作。这里有个小例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ScriptEngineManager manager = new ScriptEngineManager();</div><div class="line">ScriptEngine engine = manager.getEngineByName( &quot;JavaScript&quot; );</div><div class="line"> </div><div class="line">System.out.println( engine.getClass().getName() );//jdk.nashorn.api.scripting.NashornScriptEngine</div><div class="line">System.out.println( &quot;Result:&quot; + engine.eval( &quot;function f() &#123; return 1; &#125;; f() + 1;&quot; ) );//Result: 2</div></pre></td></tr></table></figure></p>
<h2 id="并行数组"><a href="#并行数组" class="headerlink" title="并行数组"></a>并行数组</h2><p>Java 8新增加了很多方法支持并行的数组处理。最重要的大概是parallelSort()这个方法显著地使排序在多核计算机上速度加快。下面的小例子演示了这个新的方法（parallelXXX）的行为。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.javacodegeeks.java8.parallel.arrays;</div><div class="line"> </div><div class="line">import java.util.Arrays;</div><div class="line">import java.util.concurrent.ThreadLocalRandom;</div><div class="line"> </div><div class="line">public class ParallelArrays &#123;</div><div class="line">    public static void main( String[] args ) &#123;</div><div class="line">        long[] arrayOfLong = new long [ 20000 ];        </div><div class="line"> </div><div class="line">        Arrays.parallelSetAll( arrayOfLong,</div><div class="line">            index -&gt; ThreadLocalRandom.current().nextInt( 1000000 ) );</div><div class="line">        Arrays.stream( arrayOfLong ).limit( 10 ).forEach(</div><div class="line">            i -&gt; System.out.print( i + &quot; &quot; ) );</div><div class="line">        System.out.println();</div><div class="line"> </div><div class="line">        Arrays.parallelSort( arrayOfLong );</div><div class="line">        Arrays.stream( arrayOfLong ).limit( 10 ).forEach(</div><div class="line">            i -&gt; System.out.print( i + &quot; &quot; ) );</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这一小段代码使用parallelSetAll() t方法填充这个长度是2000的数组，然后使用parallelSort() 排序。这个程序输出了排序前和排序后的10个数字来验证数组真的已经被排序了。示例可能的输出如下（请注意这些数字是随机产生的）</p>
<p>Unsorted: 591217 891976 443951 424479 766825 351964 242997 642839 119108 552378<br>Sorted: 39 220 263 268 325 607 655 678 723 793</p>
<h2 id="新的工具"><a href="#新的工具" class="headerlink" title="新的工具"></a>新的工具</h2><h3 id="Nashorn引擎：jjs"><a href="#Nashorn引擎：jjs" class="headerlink" title="Nashorn引擎：jjs"></a>Nashorn引擎：jjs</h3><p>jjs是个基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。例如，我们创建一个具有如下内容的func.js文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function f() &#123;</div><div class="line">    return 1;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">print( f() + 1 );</div></pre></td></tr></table></figure></p>
<p>我们可以把这个文件作为参数传递给jjs使得这个文件可以在命令行中执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jjs func.js   //结果输出：2</div></pre></td></tr></table></figure></p>
<h3 id="类依赖分析工具：jdeps"><a href="#类依赖分析工具：jdeps" class="headerlink" title="类依赖分析工具：jdeps"></a>类依赖分析工具：jdeps</h3><p>Jdeps是一个功能强大的命令行工具，它可以帮我们显示出包层级或者类层级java类文件的依赖关系。它接受class文件、目录、jar文件作为输入，默认情况下，jdeps会输出到控制台。</p>
<p>例如分析Notepad.jar：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">$ jdeps demo/jfc/Notepad/Notepad.jar</div><div class="line"> </div><div class="line">demo/jfc/Notepad/Notepad.jar -&gt; /usr/java/jre/lib/rt.jar</div><div class="line">   &lt;unnamed&gt; (Notepad.jar)</div><div class="line">      -&gt; java.awt                                           </div><div class="line">      -&gt; java.awt.event                                     </div><div class="line">      -&gt; java.beans                                         </div><div class="line">      -&gt; java.io                                            </div><div class="line">      -&gt; java.lang                                          </div><div class="line">      -&gt; java.net                                           </div><div class="line">      -&gt; java.util                                          </div><div class="line">      -&gt; java.util.logging                                  </div><div class="line">      -&gt; javax.swing                                        </div><div class="line">      -&gt; javax.swing.border                                 </div><div class="line">      -&gt; javax.swing.event                                  </div><div class="line">      -&gt; javax.swing.text                                   </div><div class="line">      -&gt; javax.swing.tree                                   </div><div class="line">      -&gt; javax.swing.undo</div></pre></td></tr></table></figure></p>
<p>更多的详细信息请参考<a href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/jdeps.html" target="_blank" rel="external">官方文档</a>。</p>
<h2 id="JVM的新特性"><a href="#JVM的新特性" class="headerlink" title="JVM的新特性"></a>JVM的新特性</h2><p>JVM内存永久区已经被metaspace替换（JEP 122）。JVM参数 -XX:PermSize 和 –XX:MaxPermSize被XX:MetaSpaceSize 和 -XX:MaxMetaspaceSize代替。</p>
<h2 id="Java-8-开发环境"><a href="#Java-8-开发环境" class="headerlink" title="Java 8 开发环境"></a>Java 8 开发环境</h2><p>随着 Java 8 正式发布，许多 IDE 也开始提供对 Java 8 的支持。Eclipse 是 Java 开发人员最为常用集成开发环境，在最新的 Eclipse Kepler 4.3.2 版本中已经默认增加了对 Java 8 的支持。要想在 Eclipse Kepler 的前期版本中添加对 Java 8 的支持，可以通过下面步骤来完成：</p>
<ol>
<li><p>选择 “Help &gt; Eclipse Marketplace…”。</p>
</li>
<li><p>在搜索框中输入 “Java 8 Kepler”。</p>
</li>
<li><p>点击安装 Java 8 support for Eclipse Kepler SR2。</p>
</li>
</ol>
<p>图 1. 安装 Java 8 support for Eclipse Kepler SR2<br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-jdk8newfeature/img001.png" alt="image"><br>接下来，就可以开启 Java 8 编程之旅。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>Java 8 正式版是一个有重大改变的版本，该版本对 Java 做了重大改进。本文通过文字描述及代码实例对新版本中主要新特性做了介绍：函数式接口、Lambda 表达式、集合的流式操作、注解、安全性、IO/NIO、全球化功能。除了文中介绍的这些重要的新功能之外，Java 8 还对 java 工具包 JDBC、Java DB、JavaFX 等方面都有许多改进和增强。这些新增功能简化了开发，提升了代码可读性，增强了代码的安全性，提高了代码的执行效率，为开发者带来了全新的 Java 开发体验，从而推动了 Java 这个平台的前进。</p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="http://winterbe.com/posts/2014/03/16/java-8-tutorial/" target="_blank" rel="external">Java 8 Tutorial</a></p>
<p>Part 1: <a href="http://winterbe.com/posts/2015/04/07/java8-concurrency-tutorial-thread-executor-examples/" target="_blank" rel="external">Threads and Executors</a><br>Part 2: <a href="http://winterbe.com/posts/2015/04/30/java8-concurrency-tutorial-synchronized-locks-examples/" target="_blank" rel="external">Synchronization and Locks</a><br>Part 3: <a href="http://winterbe.com/posts/2015/05/22/java8-concurrency-tutorial-atomic-concurrent-map-examples/" target="_blank" rel="external">Atomic Variables and ConcurrentMap</a>  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/基础/java8新特性/" data-id="cjei8ydg8004g7oblukk0cvpk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/基础/类加载机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/基础/类加载机制/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/基础/类加载机制/">类加载机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被直接使用的java类型，这就是虚拟机的类加载机制。<br>类的生命周期包括<strong>加载（Loading）</strong>、<strong>验证（Verification）</strong>、<strong>准备（Preparation）</strong>、<strong>解析（Resolution）</strong>、<strong>初始化（Initialization）</strong>、<strong>使用（Using）</strong>、<strong>卸载（Unloading）</strong>等七个阶段，其中<strong>验证、准备和解析三个部分统称为连接（Linking）</strong>。而<strong>类的加载指的就是从加载到初始化这五个阶段</strong>。    </p>
<p>虚拟机规范对于何时进行加载这一阶段并没有强制约束，但对于初始化阶段，虚拟机规范是严格规定了有且只有四种情况必须立即对类进行初始化：</p>
<ol>
<li>遇到new,getstatic,putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指定的场景是：使用new关键字实例化对象，读取或设置一个类的静态字段以及调用一个类的静态方法的时候。当然，被final修饰并在编译期就把结果放入常量池的静态字段不属于这些场景，这类静态字段的值在编译期时就会被编译器优化而直接放入常量池，其引用直接指向其在常量池的入口。</li>
<li>使用java.lang.reflect包的方法对类进行反射调用时，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的类），虚拟机会先初始化这个主类。</li>
<li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic，REF_putStatic，REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ol>
<p>以上四种场景中的行为称为对一个类进行主动引用，除此之外所有引用类的方式都不会触发初始化，称为被动引用。<br>接口的加载过程与类加载过程最主要的区别在于第三点，即当一个类在初始化时，要求其父类全部都已经初始化过了，但是当初始化一个接口时，并不需要先初始化其父接口，而是只有真正使用到父接口中的字段的时候才会初始化。</p>
<h3 id="类加载的各个阶段"><a href="#类加载的各个阶段" class="headerlink" title="类加载的各个阶段"></a>类加载的各个阶段</h3><h5 id="一个简单的类加载过程："><a href="#一个简单的类加载过程：" class="headerlink" title="一个简单的类加载过程："></a>一个简单的类加载过程：</h5><ol>
<li>寻找jre目录，寻找jvm.dll，并初始化JVM；</li>
<li>产生一个Bootstrap Loader（启动类加载器）；</li>
<li>Bootstrap Loader自动加载Extended Loader（标准扩展类加载器），并将其父Loader设为Bootstrap Loader。</li>
<li>Bootstrap Loader自动加载AppClassLoader（系统类加载器），并将其父Loader设为Extended Loader。</li>
<li>最后由AppClassLoader加载HelloWorld类。</li>
</ol>
<h5 id="类记载目录："><a href="#类记载目录：" class="headerlink" title="类记载目录："></a>类记载目录：</h5><ol>
<li>Bootstrap ClassLoader : 将存放于<java_home>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar 名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用</java_home></li>
<li>Extension ClassLoader : 将<java_home>\lib\ext目录下的，或者被java.ext.dirs系统变量所指定的路径中的所有类库加载。开发者可以直接使用扩展类加载器。</java_home></li>
<li>Application ClassLoader : 负责加载用户类路径(ClassPath)上所指定的类库,开发者可直接使用。</li>
</ol>
<p>ExtClassLoader和AppClassLoader在JVM启动后，会在JVM中保存一份，并且在程序运行中无法改变其搜索路径。如果想在运行时从其他搜索路径加载类，就要产生新的类加载器。</p>
<h5 id="类记载器特点："><a href="#类记载器特点：" class="headerlink" title="类记载器特点："></a>类记载器特点：</h5><ol>
<li>运行一个程序时，总是由AppClassLoader（系统类加载器）开始加载指定的类。</li>
<li>在加载类时，每个类加载器会将加载任务上交给其父，如果其父找不到，再由自己去加载。</li>
<li>Bootstrap Loader（启动类加载器）是最顶级的类加载器了，其父加载器为null.</li>
</ol>
<h5 id="类加载有三种方式："><a href="#类加载有三种方式：" class="headerlink" title="类加载有三种方式："></a>类加载有三种方式：</h5><ol>
<li>命令行启动应用时候由JVM初始化加载</li>
<li>通过Class.forName()方法动态加载</li>
<li>通过ClassLoader.loadClass()方法动态加载</li>
</ol>
<p>三种方式区别比较大，看个例子就明白了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class HelloWorld &#123; </div><div class="line">        public static void main(String[] args) throws ClassNotFoundException &#123; </div><div class="line">                ClassLoader loader = HelloWorld.class.getClassLoader(); </div><div class="line">                System.out.println(loader); </div><div class="line">                //使用ClassLoader.loadClass()来加载类，不会执行初始化块 </div><div class="line">                loader.loadClass(&quot;Test2&quot;); </div><div class="line">                //使用Class.forName()来加载类，默认会执行初始化块 </div><div class="line">                //Class.forName(&quot;Test2&quot;); </div><div class="line">                //使用Class.forName()来加载类，并指定ClassLoader，参数2设置为false时初始化时不执行静态块，设置为true时初始化时执行静态块</div><div class="line">                //Class.forName(&quot;Test2&quot;, false, loader); </div><div class="line">        &#125; </div><div class="line">&#125;</div><div class="line"> </div><div class="line">public class Test2 &#123; </div><div class="line">        static &#123; </div><div class="line">                System.out.println(&quot;静态初始化块执行了！&quot;); </div><div class="line">        &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有关ClassLoader还有很重要一点：<br><strong>同一个ClassLoader加载的类文件，只有一个Class实例。但是，如果同一个类文件被不同的ClassLoader载入，则会有两份不同的Class实例</strong>（前提是着两个类加载器不能用相同的父类加载器）。</p>
<p>以下对类加载的各个阶段进行简单的说明。  </p>
<ul>
<li><strong>加载阶段</strong>，虚拟机需要完成三件事：<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li><strong>在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口</strong>。</li>
</ol>
</li>
<li><strong>验证阶段</strong>，不同虚拟机会进行不同类验证的实现，但大致都会完成以下四个阶段的检验过程：文件格式验证（验证字节流是否符合Class文件格式的规范，并能被当前版本的虚拟机处理），元数据验证（对字节码描述信息进行语义分析，保证其描述信息符合java语言规范），字节码验证（对类方法体进行数据流和控制流分析，保证类的方法在运行时不会做出危害虚拟机的行为）和符号引用验证（发生在将符号引用转化为直接引用的时候，在解析阶段中发生）。</li>
<li><strong>准备阶段</strong>，正式为类成员变量（被static修饰的变量）（注意，不是实例成员变量，实例变量会在对象实例化时随着对象一起分配在java堆上）分配内存并设置类变量初始值（通常情况下是数据类型的零值，不进行赋值操作）的阶段，这些内存都将在方法区中进行分配。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例：public static int value=123;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>则在准备阶段过后，value的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<client>()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。</client></p>
<ul>
<li><strong>解析阶段</strong>，虚拟机将常量池内的符号引用替换为直接引用的过程。符号引用与内存布局无关，而直接引用的目标必定已经在内存中存在。<strong>解析动作主要针对类或接口、字段、类方法、接口方法，方法类型，方法句柄和调用限定符号期类符号引用进行</strong>。</li>
<li><strong>初始化阶段</strong>，真正开始执行类中定义的java程序代码（字节码），是执行类构造器<clinit>()方法的过程。</clinit></li>
</ul>
<p><clinit>()方法的一些特点：</clinit></p>
<ol>
<li><p><clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static｛｝）中的语句合并产生的，编译器收集顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</clinit></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public Class test &#123;</div><div class="line">    static &#123;</div><div class="line">        i = 0; //给变量赋值可以正常编译通过</div><div class="line">        System.out.println(i); //这句编译器会提示“非法向前引用”</div><div class="line">    &#125;</div><div class="line">    static int i = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><clinit>()方法与类的构造函数（或者说实例构造器<init>()方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前完成父类<clinit>()方法的执行。因此在虚拟机中第一个被执行的<client>()方法的类肯定是java.lang.Object。   </client></clinit></clinit></init></clinit></p>
</li>
<li>由于父类的<clinit>() 方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作</clinit></li>
<li><p><clinit>()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，则编译器可以不为这个类生成<clinit>()方法。   </clinit></clinit></p>
</li>
<li><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法，不同于类的地方是执行接口的<clinit>()方法时不需要先执行父类的<clinit>()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<client>()方法。</client></clinit></clinit></clinit></p>
</li>
<li><p>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，则只有一个线程去执行这个类的<clinit>()方法，其它线程阻塞等待，直到活动线程执行<clinit>()方法完毕。 如果在一个类的<client>()方法中有耗时很长的操作，就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</client></clinit></clinit></clinit></p>
<p> 需要注意的是，其他线程虽然会被阻塞，但如果执行<client>()方法的那条线程退出<client>()方法后，其他线程唤醒之后不会再次进入<client>()方法。同一个类加载器下，一个类型只会初始化一次。</client></client></client></p>
</li>
</ol>
<p>了解完各个类加载机制的阶段后，我们需要进一步了解类加载器这个概念。类加载器只用于实现类的加载动作，即实现通过一个类的全限定名来获取描述此类的二进制字节流。<strong>但对于类来说，要判断两个类是否相等（instanceof，equal），其前提是两个类是由同一个类加载器所加载，否则，无论两个类是否来源于同一个Class文件，这两个类都必定不等，亦即是说，对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在java虚拟机的唯一性。</strong>  </p>
<p>在Java开发人员看来，类加载器可划分为以下三类系统提供的类加载器：启动类加载器（Boostrap ClassLoader，负责将存放在<java_home>\lib目录中的类库加载到虚拟机内存中，其无法被Java程序直接引用），扩展类加载器（Extension ClassLoader，由sun.misc.Launcher$ExtClassLoader实现，负责加载<java_home>\lib\ext目录中的类库，可被开发者直接使用），应用程序类加载器（由sun.misc.Launcher$AppClassLoader来实现，负责加载用户类路径（ClassPath）上指定的类库，可被开发者直接使用，且为默认的类加载器）。  </java_home></java_home></p>
<p>java中采用<strong>双亲委派模型</strong>（Parents Delegation Model）来实现类的加载模式。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，此处的父子关系不以继承来实现，而是采用组合来利用父加载器。    </p>
<p>双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会自己去加载。</p>
<p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个成为java.lang.Object的类，并放在程序的ClassPath之中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证。</p>
<p>其模型如下图所示：<br><img src="http://note.youdao.com/yws/public/resource/ee75e4361b58214a36b4d854bbd3faf1/xmlnote/EEE7B3274550464AB506A63343F42905/7749" alt="image">    </p>
<h3 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h3><p>了解了以上类文件结构和类加载机制后，我们最后再来看看字节码在虚拟机中是如何被执行的。  </p>
<p>不同的虚拟机实现时硕，执行引擎在执行Java执行的时候可能有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备，甚至可能包含几个不同级别的编译器执行引擎。  </p>
<p>在具体了解虚拟机是如何执行字节码之前，我们先来从概念上理解虚拟机是如何执行程序的。程序的执行可以直接解释为是对方法的递归调用，通过一连串的方法链来最终得出执行结果，亦即是说虚拟机对程序的执行，根本上是对方法的调用和执行。</p>
<p>栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表（最小单位为变量槽Variable Slot）、操作数栈、动态连接和方法返回地址等信息，每一个方法从调用开始到执行完成的过程，就对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。栈帧的内容在编译时就已经完成确定，不受程序运行期变量数据的影响，仅取决于具体的虚拟机实现。    </p>
<p>前面说了，对程序的执行就是对方法链的调用和执行，即可能会出现很多方法同时处于执行状态，此时对于执行引擎来说，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，其关联的方法称为当前方法，执行引擎所运行的所有字节码指令只针对当前栈帧进行操作。    </p>
<p>方法调用包含两种方法：<strong>解析和分派</strong>。解析调用一定是个静态过程，在编译期间完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。而分派调用则可能是动态的也可能是静态的，根据分派依据的宗量数可分为单分派和多分派。（具体情形请参考《深入理解java虚拟机》这本书第8章）</p>
<p>方法执行即是指字节码解释执行引擎，包括解释执行和编译执行。而java编译器输出的指令流，基本上是一种基于栈的指令集架构。即Java虚拟机采用的是基于栈的字节码执行引擎。（具体情形请参考《深入理解java虚拟机》这本书第8章）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/基础/类加载机制/" data-id="cjei8ydga004l7oblnks4jj3m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器相关/redis/redis快速的几个原因" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/服务器相关/redis/redis快速的几个原因/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/服务器相关/redis/redis快速的几个原因/">redis快速的几个原因</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>总体来说快速的原因如下：        </p>
<ol>
<li>绝大部分请求是纯粹的内存操作（非常快速）   </li>
<li>采用单线程,避免了不必要的上下文切换和竞争条件   </li>
<li>非阻塞IO  </li>
</ol>
<p>内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间</p>
<p>这3个条件不是相互独立的，特别是第一条，如果请求都是耗时的，采用单线程吞吐量及性能可想而知了。应该说redis为特殊的场景选择了合适的技术方案。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/服务器相关/redis/redis快速的几个原因/" data-id="cjei8ydl300ez7oblyio4vhzb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器相关/redis/高性能IO模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/服务器相关/redis/高性能IO模型/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/服务器相关/redis/高性能IO模型/">高性能IO模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>服务器端编程经常需要构造高性能的IO模型，常见的IO模型有四种：    </p>
<ol>
<li>同步阻塞IO（Blocking IO）：即传统的IO模型。</li>
<li>同步非阻塞IO（Non-blocking IO）：默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。注意这里所说的NIO并非Java的NIO（New IO）库。</li>
<li>IO多路复用（IO Multiplexing）：即经典的Reactor设计模式，有时也称为异步阻塞IO，Java中的Selector和Linux中的epoll都是这种模型。</li>
<li>异步IO（Asynchronous IO）：即经典的Proactor设计模式，也称为异步非阻塞IO。    </li>
</ol>
<p><strong>同步和异步</strong>的概念描述的是用户线程与内核的交互方式：同步是指用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行；而异步是指用户线程发起IO请求后仍继续执行，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数。    </p>
<p><strong>阻塞和非阻塞</strong>的概念描述的是用户线程调用内核IO操作的方式：阻塞是指IO操作需要彻底完成后才返回到用户空间；而非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。    </p>
<h2 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h2><p>同步阻塞IO模型是最简单的IO模型，用户线程在内核进行IO操作时被阻塞。<br><img src="http://images.cnitblog.com/blog/405877/201411/142330286789443.png" alt="image"> </p>
<p>如上图所示，用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作。  </p>
<p>用户线程使用同步阻塞IO模型的伪代码描述为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    read(socket, buffer);</div><div class="line">    process(buffer);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>即用户需要等待read将socket中的数据读取到buffer后，才继续处理接收的数据。整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够。</p>
<h2 id="同步非阻塞IO"><a href="#同步非阻塞IO" class="headerlink" title="同步非阻塞IO"></a>同步非阻塞IO</h2><p>同步非阻塞IO是在同步阻塞IO的基础上，将socket设置为NONBLOCK。这样做用户线程可以在发起IO请求后可以立即返回。<br><img src="http://images.cnitblog.com/blog/405877/201411/142332004602984.png" alt="image"></p>
<p>如上图所示，由于socket是非阻塞的方式，因此用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。<br>用户线程使用同步非阻塞IO模型的伪代码描述为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    while(read(socket, buffer) != SUCCESS)</div><div class="line">        ;</div><div class="line">    process(buffer);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>即用户需要不断地调用read，尝试读取socket中的数据，直到读取成功后，才继续处理接收的数据。整个IO请求的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。  </p>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。<br><img src="http://images.cnitblog.com/blog/405877/201411/142332187256396.png" alt="image"><br>如上图所示，用户首先将需要进行IO操作的socket添加到select中，然后阻塞等待select系统调用返回。当数据到达时，socket被激活，select函数返回。用户线程正式发起read请求，读取数据并继续执行。    </p>
<p>从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在<strong>同一个线程内同时处理多个IO请求</strong>的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p>
<p>用户线程使用select函数的伪代码描述为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    select(socket);</div><div class="line">    while(1) &#123;</div><div class="line">        sockets = select();</div><div class="line">        for(socket in sockets) &#123;</div><div class="line">            if(can_read(socket)) &#123;</div><div class="line">                read(socket, buffer);</div><div class="line">                process(buffer);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中while循环前将socket添加到select监视中，然后在while内一直调用select获取被激活的socket，一旦socket可读，便调用read函数将socket中的数据读取出来。  </p>
<p>然而，使用select函数的优点并不仅限于此。虽然上述方式允许单线程内处理多个IO请求，但是每个IO请求的过程还是阻塞的（在select函数上阻塞），平均时间甚至比同步阻塞IO模型还要长。如果用户线程只注册自己感兴趣的socket或者IO请求，然后去做自己的事情，等到数据到来时再进行处理，则可以提高CPU的利用率。 </p>
<p>IO多路复用模型使用了Reactor设计模式实现了这一机制。<br><img src="http://images.cnitblog.com/blog/405877/201411/142332350853195.png" alt="image"><br>如上图所示，EventHandler抽象类表示IO事件处理器，它拥有IO文件句柄Handle（通过get_handle获取），以及对Handle的操作handle_event（读/写等）。继承于EventHandler的子类可以对事件处理器的行为进行定制。Reactor类用于管理EventHandler（注册、删除等），并使用handle_events实现事件循环，不断调用同步事件多路分离器（一般是内核）的多路分离函数select，只要某个文件句柄被激活（可读/写等），select就返回（阻塞），handle_events就会调用与文件句柄关联的事件处理器的handle_event进行相关操作。    </p>
<p><img src="http://images.cnitblog.com/blog/405877/201411/142333254136604.png" alt="image"><br>如上图所示，通过Reactor的方式，可以将用户线程轮询IO操作状态的工作统一交给handle_events事件循环进行处理。用户线程注册事件处理器之后可以继续执行做其他的工作（异步），而Reactor线程负责调用内核的select函数检查socket状态。当有socket被激活时，则通知相应的用户线程（或执行用户线程的回调函数），执行handle_event进行数据读取、处理的工作。由于select函数是阻塞的，因此<strong>多路IO复用模型也被称为异步阻塞IO模型</strong>。注意，这里的所说的阻塞是指select函数执行时线程被阻塞，而不是指socket。一般在使用IO多路复用模型时，socket都是设置为NONBLOCK的，不过这并不会产生影响，因为用户发起IO请求时，数据已经到达了，用户线程一定不会被阻塞。</p>
<p>用户线程使用IO多路复用模型的伪代码描述为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void UserEventHandler::handle_event() &#123;</div><div class="line">    if(can_read(socket)) &#123;</div><div class="line">        read(socket, buffer);</div><div class="line">        process(buffer);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">    Reactor.register(new UserEventHandler(socket));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用户需要重写EventHandler的handle_event函数进行读取数据、处理数据的工作，用户线程只需要将自己的EventHandler注册到Reactor即可。Reactor中handle_events事件循环的伪代码大致如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Reactor::handle_events() &#123;</div><div class="line">    while(1) &#123;</div><div class="line">        sockets = select();</div><div class="line">        for(socket in sockets) &#123;</div><div class="line">            get_event_handler(socket).handle_event();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>事件循环不断地调用select获取被激活的socket，然后根据获取socket对应的EventHandler，执行器handle_event函数即可。  </p>
<p>IO多路复用是最常使用的IO模型，但是其异步程度还不够“彻底”，因为它使用了会阻塞线程的select系统调用。因此IO多路复用只能称为异步阻塞IO，而非真正的异步IO。  </p>
<h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p>“真正”的异步IO需要操作系统更强的支持。在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。    </p>
<p>异步IO模型使用了Proactor设计模式实现了这一机制。<br><img src="http://images.cnitblog.com/blog/405877/201411/151608309061672.jpg" alt="image"> </p>
<p>如上图，Proactor模式和Reactor模式在结构上比较相似，不过在用户（Client）使用方式上差别较大。Reactor模式中，用户线程通过向Reactor对象注册感兴趣的事件监听，然后事件触发时调用事件处理函数。而Proactor模式中，用户线程将AsynchronousOperation（读/写等）、Proactor以及操作完成时的CompletionHandler注册到AsynchronousOperationProcessor。AsynchronousOperationProcessor使用Facade模式提供了一组异步操作API（读/写等）供用户使用，当用户线程调用异步API后，便继续执行自己的任务。AsynchronousOperationProcessor 会开启独立的内核线程执行异步操作，实现真正的异步。当异步IO操作完成时，AsynchronousOperationProcessor将用户线程与AsynchronousOperation一起注册的Proactor和CompletionHandler取出，然后将CompletionHandler与IO操作的结果数据一起转发给Proactor，Proactor负责回调每一个异步操作的事件完成处理函数handle_event。虽然Proactor模式中每个异步操作都可以绑定一个Proactor对象，但是一般在操作系统中，Proactor被实现为Singleton模式，以便于集中化分发操作完成事件。 </p>
<p><img src="http://images.cnitblog.com/blog/405877/201411/142333511475767.png" alt="image"><br>如上图所示，异步IO模型中，用户线程直接使用内核提供的异步IO API发起read请求，且发起后立即返回，继续执行用户线程代码。不过此时用户线程已经将调用的AsynchronousOperation和CompletionHandler注册到内核，然后操作系统开启独立的内核线程去处理IO操作。当read请求的数据到达时，由内核负责读取socket中的数据，并写入用户指定的缓冲区中。最后内核将read的数据和用户线程注册的CompletionHandler分发给内部Proactor，Proactor将IO完成的信息通知给用户线程（一般通过调用用户线程注册的完成事件处理函数），完成异步IO。    </p>
<p>用户线程使用异步IO模型的伪代码描述为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void UserCompletionHandler::handle_event(buffer) &#123;</div><div class="line">    process(buffer);</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">    aio_read(socket, new UserCompletionHandler);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用户需要重写CompletionHandler的handle_event函数进行处理数据的工作，参数buffer表示Proactor已经准备好的数据，用户线程直接调用内核提供的异步IO API，并将重写的CompletionHandler注册即可。  </p>
<p>相比于IO多路复用模型，异步IO并不十分常用，不少高性能并发服务程序使用IO多路复用模型+多线程任务处理的架构基本可以满足需求。况且目前操作系统对异步IO的支持并非特别完善，更多的是采用IO多路复用模型模拟异步IO的方式（IO事件触发时不直接通知用户线程，而是将数据读写完毕后放到用户指定的缓冲区中）。Java7之后已经支持了异步IO，感兴趣的读者可以尝试使用。  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/服务器相关/redis/高性能IO模型/" data-id="cjei8ydld00fd7oblbwm9de5v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器相关/redis/Redis集群" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/服务器相关/redis/Redis集群/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/服务器相关/redis/Redis集群/">Redis集群</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Redis集群介绍"><a href="#Redis集群介绍" class="headerlink" title="Redis集群介绍"></a>Redis集群介绍</h3><p>Redis 集群是一个提供在<strong>多个Redis间节点间共享数据</strong>的程序集。 </p>
<p>Redis集群并不支持处理多个keys的命令,因为这需要在不同的节点间移动数据,从而达不到像Redis那样的性能,在高负载的情况下可能会导致不可预料的错误.  </p>
<p>Redis 集群通过分区来提供<strong>一定程度的可用性</strong>,在实际环境中当某个节点宕机或者不可达的情况下继续处理命令. Redis 集群的优势:</p>
<ul>
<li>自动分割数据到不同的节点上。</li>
<li>整个集群的部分节点失败或者不可达的情况下能够继续处理命令。</li>
</ul>
<h3 id="Redis-集群的数据分片"><a href="#Redis-集群的数据分片" class="headerlink" title="Redis 集群的数据分片"></a>Redis 集群的数据分片</h3><p>Redis 集群没有使用一致性hash, 而是引入了 <strong>哈希槽</strong>的概念.</p>
<p>Redis 集群有<strong>16384</strong>个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽,举个例子,比如当前集群有3个节点,那么:</p>
<ul>
<li>节点 A 包含 0 到 5500号哈希槽.</li>
<li>节点 B 包含5501 到 11000 号哈希槽.</li>
<li>节点 C 包含11001 到 16384号哈希槽.</li>
</ul>
<p>这种结构很容易添加或者删除节点. 比如如果我想新添加个节点D, 我需要从节点 A, B, C中得部分槽到D上. 如果我像移除节点A,需要将A中得槽移到B和C节点上,然后将没有任何槽的A节点从集群中移除即可. 由于从一个节点将哈希槽移动到另一个节点并不会停止服务,所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态.</p>
<h3 id="Redis-集群的主从复制模型"><a href="#Redis-集群的主从复制模型" class="headerlink" title="Redis 集群的主从复制模型"></a>Redis 集群的主从复制模型</h3><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品.</p>
<p>在我们例子中具有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用.</p>
<p>然而如果在集群创建的时候（或者过一段时间）我们为每个节点添加一个从节点A1，B1，C1,那么整个集群便有三个master节点和三个slave节点组成，这样在节点B失败后，集群便会选举B1为新的主节点继续服务，整个集群便不会因为槽找不到而不可用了</p>
<p>不过当B和B1 都失败后，集群是不可用的.</p>
<h3 id="Redis-一致性保证"><a href="#Redis-一致性保证" class="headerlink" title="Redis 一致性保证"></a>Redis 一致性保证</h3><p>Redis 并不能保证数据的<strong>强一致性</strong>. 这意味这在实际中集群在特定的条件下可能会丢失写操作.</p>
<p>第一个原因是因为集群是用了异步复制. 写操作过程:</p>
<ol>
<li>客户端向主节点B写入一条命令.</li>
<li>主节点B向客户端回复命令状态.</li>
<li>主节点将写操作复制给他得从节点 B1, B2 和 B3.</li>
</ol>
<p>主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。 注意：Redis 集群可能会在将来提供同步写的方法。 Redis 集群另外一种可能会丢失命令的情况是集群出现了网络分区， 并且一个客户端与至少包括一个主节点在内的少数实例被孤立。</p>
<p>举个例子 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点， 其中 A 、B 、C 为主节点， A1 、B1 、C1 为A，B，C的从节点， 还有一个客户端 Z1 假设集群中发生网络分区，那么集群可能会分为两方，大部分的一方包含节点 A 、C 、A1 、B1 和 C1 ，小部分的一方则包含节点 B 和客户端 Z1 .</p>
<p>Z1仍然能够向主节点B中写入, 如果网络分区发生时间较短,那么集群将会继续正常运作,如果分区的时间足够让大部分的一方将B1选举为新的master，那么Z1写入B中得数据便丢失了.</p>
<p>注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项</p>
<h3 id="搭建并使用Redis集群"><a href="#搭建并使用Redis集群" class="headerlink" title="搭建并使用Redis集群"></a>搭建并使用Redis集群</h3><p>搭建集群的第一件事情我们需要一些运行在 集群模式的Redis实例. 这意味这集群并不是由一些普通的Redis实例组成的，集群模式需要通过配置启用，开启集群模式后的Redis实例便可以使用集群特有的命令和特性了.<br>下面是一个最少选项的集群的配置文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">port 7000</div><div class="line">cluster-enabled yes</div><div class="line">cluster-config-file nodes.conf</div><div class="line">cluster-node-timeout 5000</div><div class="line">appendonly yes</div></pre></td></tr></table></figure></p>
<p>文件中的 cluster-enabled 选项用于开实例的集群模式， 而 cluster-conf-file 选项则设定了保存节点配置文件的路径， 默认值为 nodes.conf.节点配置文件无须人为修改， 它由 Redis 集群在启动时创建， 并在有需要时自动进行更新。 </p>
<p>要让集群正常运作至少需要三个主节点，不过在刚开始试用集群功能时， 强烈建议使用六个节点： 其中三个为主节点， 而其余三个则是各个主节点的从节点。</p>
<p>首先， 让我们进入一个新目录， 并创建六个以端口号为名字的子目录， 稍后我们在将每个目录中运行一个 Redis 实例：  命令如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir cluster-test</div><div class="line">cd cluster-test</div><div class="line">mkdir 7000 7001 7002 7003 7004 7005</div></pre></td></tr></table></figure></p>
<p>在文件夹 7000 至 7005 中， 各创建一个 redis.conf 文件， 文件的内容可以使用上面的示例配置文件， 但记得将配置中的端口号从 7000 改为与文件夹名字相同的号码,并且nodes.conf的文件名也要相应调整，如nodes-7000.conf。</p>
<p>启动6个集群示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/Cellar/redis/3.2.8/bin</div><div class="line">1./usr/local/Cellar/redis/3.2.8/cluster-test/7000/redis.conf</div><div class="line">2./usr/local/Cellar/redis/3.2.8/cluster-test/70010/redis.conf</div><div class="line">3./usr/local/Cellar/redis/3.2.8/cluster-test/7002/redis.conf</div><div class="line">4./usr/local/Cellar/redis/3.2.8/cluster-test/7003/redis.conf</div><div class="line">5./usr/local/Cellar/redis/3.2.8/cluster-test/7004/redis.conf</div><div class="line">6./usr/local/Cellar/redis/3.2.8/cluster-test/7005/redis.conf</div></pre></td></tr></table></figure></p>
<p>实例打印的日志显示， 因为 nodes.conf 文件不存在， 所以每个节点都为它自身指定了一个新的 ID ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[82462] 26 Nov 11:56:55.329 * No cluster configuration found, I&apos;m 97a3a64667477371c4479320d683e4c8db5858b1</div></pre></td></tr></table></figure></p>
<p>实例会一直使用同一个 ID ， 从而在集群中保持一个独一无二（unique）的名字。</p>
<h3 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h3><p>现在我们已经有了六个正在运行中的 Redis 实例， 接下来我们需要使用这些实例来创建集群， 并为每个节点编写配置文件。<br>通过使用 Redis 集群命令行工具 redis-trib ， 编写节点配置文件的工作可以非常容易地完成： redis-trib 位于 Redis 源码的 src 文件夹中， 它是一个 Ruby 程序， 这个程序通过向实例发送特殊命令来完成创建新集群， 检查集群， 或者对集群进行重新分片（reshared）等工作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 \</div><div class="line">127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</div></pre></td></tr></table></figure></p>
<p>这个命令在这里用于创建一个新的集群, 选项–replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。<br>之后跟着的其他参数则是这个集群实例的地址列表,3个master3个slave redis-trib 会打印出一份预想中的配置给你看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</div><div class="line">&gt;&gt;&gt; Creating cluster</div><div class="line">&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...</div><div class="line">Using 3 masters:</div><div class="line">127.0.0.1:7000</div><div class="line">127.0.0.1:7001</div><div class="line">127.0.0.1:7002</div><div class="line">Adding replica 127.0.0.1:7003 to 127.0.0.1:7000</div><div class="line">Adding replica 127.0.0.1:7004 to 127.0.0.1:7001</div><div class="line">Adding replica 127.0.0.1:7005 to 127.0.0.1:7002</div><div class="line">M: 83976d23ea61befbacc383aa03bd2da9f08fa7fa 127.0.0.1:7000</div><div class="line">   slots:0-5460 (5461 slots) master</div><div class="line">M: c2f4de6b29648599ade1d596b96838cdf559f397 127.0.0.1:7001</div><div class="line">   slots:5461-10922 (5462 slots) master</div><div class="line">M: 3e9798d73cc0685745c18cb15cf68c75c746e0a5 127.0.0.1:7002</div><div class="line">   slots:10923-16383 (5461 slots) master</div><div class="line">S: dfcad7da198267663734490dc876a7c072d186f1 127.0.0.1:7003</div><div class="line">   replicates 83976d23ea61befbacc383aa03bd2da9f08fa7fa</div><div class="line">S: d415630bb73d2df4ddbe8032ac3034756dff838c 127.0.0.1:7004</div><div class="line">   replicates c2f4de6b29648599ade1d596b96838cdf559f397</div><div class="line">S: ccda46a376b2a473ac596c80050b464ca9ba30d4 127.0.0.1:7005</div><div class="line">   replicates 3e9798d73cc0685745c18cb15cf68c75c746e0a5</div><div class="line">Can I set the above configuration? (type &apos;yes&apos; to accept):</div></pre></td></tr></table></figure></p>
<p>如果你觉得没问题的话， 就可以输入 yes ， redis-trib 就会将这份配置应用到集群当中,让各个节点开始互相通讯,最后可以得到如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">Can I set the above configuration? (type &apos;yes&apos; to accept): yes</div><div class="line">&gt;&gt;&gt; Nodes configuration updated</div><div class="line">&gt;&gt;&gt; Assign a different config epoch to each node</div><div class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</div><div class="line">Waiting for the cluster to join...</div><div class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)</div><div class="line">M: 83976d23ea61befbacc383aa03bd2da9f08fa7fa 127.0.0.1:7000</div><div class="line">   slots:0-5460 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: d415630bb73d2df4ddbe8032ac3034756dff838c 127.0.0.1:7004</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates c2f4de6b29648599ade1d596b96838cdf559f397</div><div class="line">M: c2f4de6b29648599ade1d596b96838cdf559f397 127.0.0.1:7001</div><div class="line">   slots:5461-10922 (5462 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: ccda46a376b2a473ac596c80050b464ca9ba30d4 127.0.0.1:7005</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates 3e9798d73cc0685745c18cb15cf68c75c746e0a5</div><div class="line">M: 3e9798d73cc0685745c18cb15cf68c75c746e0a5 127.0.0.1:7002</div><div class="line">   slots:10923-16383 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: dfcad7da198267663734490dc876a7c072d186f1 127.0.0.1:7003</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates 83976d23ea61befbacc383aa03bd2da9f08fa7fa</div><div class="line">[OK] All nodes agree about slots configuration.</div><div class="line">&gt;&gt;&gt; Check for open slots...</div><div class="line">&gt;&gt;&gt; Check slots coverage...</div><div class="line">[OK] All 16384 slots covered.</div></pre></td></tr></table></figure></p>
<p>这表示集群中的 16384 个槽都有至少一个主节点在处理， 集群运作正常。</p>
<p><strong>注意</strong>：如果脚本报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">custom_require.rb:36:in `require&apos;: cannot load such file -- redis (LoadError)</div><div class="line">from /usr/lib/ruby/1.9.1/rubygems/custom_require.rb:36:in `require&apos;</div><div class="line">from ./redis-trib.rb:25:in `&lt;main&gt;&apos;</div></pre></td></tr></table></figure></p>
<p>那么说明Ruby的redis接口没有安装，可以通过<code>sudo gem install redis</code>进行安装。</p>
<h3 id="Creating-a-Redis-Cluster-using-the-create-cluster-script"><a href="#Creating-a-Redis-Cluster-using-the-create-cluster-script" class="headerlink" title="Creating a Redis Cluster using the create-cluster script"></a>Creating a Redis Cluster using the create-cluster script</h3><p>If you don’t want to create a Redis Cluster by configuring and executing individual instances manually as explained above, there is a much simpler system (but you’ll not learn the same amount of operational details).</p>
<p>Just check utils/create-cluster directory in the Redis distribution. There is a script called create-cluster inside (same name as the directory it is contained into), it’s a simple bash script. In order to start a 6 nodes cluster with 3 masters and 3 slaves just type the following commands:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1. create-cluster start</div><div class="line">2. create-cluster create</div></pre></td></tr></table></figure></p>
<p>Reply to yes in step 2 when the redis-trib utility wants you to accept the cluster layout.<br>You can now interact with the cluster, the first node will start at port 30001 by default. When you are done, stop the cluster with:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">create-cluster stop</div></pre></td></tr></table></figure></p>
<p>Please read the README inside this directory for more information on how to run the script.</p>
<h3 id="使用集群"><a href="#使用集群" class="headerlink" title="使用集群"></a>使用集群</h3><p>Redis 集群现阶段的一个问题是客户端实现很少。<br>以下是一些我知道的实现：</p>
<ul>
<li><a href="https://github.com/antirez/redis-rb-cluster" target="_blank" rel="external">redis-rb-cluster</a> 是我（@antirez）编写的 Ruby 实现， 用于作为其他实现的参考。 该实现是对 redis-rb 的一个简单包装， 高效地实现了与集群进行通讯所需的最少语义（semantic）.</li>
<li><a href="https://github.com/Grokzen/redis-py-cluster" target="_blank" rel="external">redis-py-cluster</a> 看上去是 redis-rb-cluster 的一个 Python 版本， 这个项目有一段时间没有更新了（最后一次提交是在六个月之前）， 不过可以将这个项目用作学习集群的起点。</li>
<li>流行的 <a href="https://github.com/nrk/predis" target="_blank" rel="external">Predis</a> 曾经对早期的 Redis 集群有过一定的支持， 但我不确定它对集群的支持是否完整， 也不清楚它是否和最新版本的 Redis 集群兼容 （因为新版的 Redis 集群将槽的数量从 4k 改为 16k 了）.</li>
<li>使用最多的时java客户端, <a href="https://github.com/xetorthio/jedis" target="_blank" rel="external">Jedis</a> 最近添加了对集群的支持, 详细请查看项目README中Jedis Cluster部分.</li>
<li><a href="https://github.com/StackExchange/StackExchange.Redis" target="_blank" rel="external">StackExchange.Redis</a> 提供对 C# 的支持(并且包括大部分 .NET 下面的语言，比如： VB, F#等等)</li>
<li><a href="https://github.com/thunks/thunk-redis" target="_blank" rel="external">thunk-redis</a> 提供对 Node.js 和 io.js的支持。</li>
<li>Redis unstable 分支中的 redis-cli 程序实现了非常基本的集群支持， 可以使用命令 redis-cli -c 来启动。</li>
</ul>
<p>测试 Redis 集群比较简单的办法就是使用 redis-rb-cluster 或者 redis-cli ， 接下来我们将使用 redis-cli 为例来进行演示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -c -p 7000</div><div class="line">redis 127.0.0.1:7000&gt; set foo bar</div><div class="line">-&gt; Redirected to slot [12182] located at 127.0.0.1:7002</div><div class="line">OK</div><div class="line">redis 127.0.0.1:7002&gt; set hello world</div><div class="line">-&gt; Redirected to slot [866] located at 127.0.0.1:7000</div><div class="line">OK</div><div class="line">redis 127.0.0.1:7000&gt; get foo</div><div class="line">-&gt; Redirected to slot [12182] located at 127.0.0.1:7002</div><div class="line">&quot;bar&quot;</div><div class="line">redis 127.0.0.1:7000&gt; get hello</div><div class="line">-&gt; Redirected to slot [866] located at 127.0.0.1:7000</div><div class="line">&quot;world&quot;</div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>: 如果你是使用脚本创建的集群节点，那么默认端口可能是从30001开始。</p>
<p>redis-cli 对集群的支持是非常基本的， 所以它总是依靠 Redis 集群节点来将它转向（redirect）至正确的节点。一个真正的（serious）集群客户端应该做得比这更好： 它应该用缓存记录起哈希槽与节点地址之间的映射（map）， 从而直接将命令发送到正确的节点上面。这种映射只会在集群的配置出现某些修改时变化， 比如说， 在一次故障转移（failover）之后， 或者系统管理员通过添加节点或移除节点来修改了集群的布局（layout）之后， 诸如此类。</p>
<h3 id="使用redis-rb-cluster写一个例子"><a href="#使用redis-rb-cluster写一个例子" class="headerlink" title="使用redis-rb-cluster写一个例子"></a>使用redis-rb-cluster写一个例子</h3><p>在展示如何使用集群进行故障转移、重新分片等操作之前， 我们需要创建一个示例应用， 了解一些与 Redis 集群客户端进行交互的基本方法。  </p>
<p>在运行示例应用的过程中， 我们会尝试让节点进入失效状态， 又或者开始一次重新分片， 以此来观察 Redis 集群在真实世界运行时的表现， 并且为了让这个示例尽可能地有用， 我们会让这个应用向集群进行写操作。<br>本节将通过两个示例应用来展示 redis-rb-cluster 的基本用法， 以下是本节的第一个示例应用， 它是一个名为 example.rb 的文件， 包含在redis-rb-cluster 项目里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"> 1  require &apos;./cluster&apos;</div><div class="line"> 2</div><div class="line"> 3  startup_nodes = [</div><div class="line"> 4      &#123;:host =&gt; &quot;127.0.0.1&quot;, :port =&gt; 7000&#125;,</div><div class="line"> 5      &#123;:host =&gt; &quot;127.0.0.1&quot;, :port =&gt; 7001&#125;</div><div class="line"> 6  ]</div><div class="line"> 7  rc = RedisCluster.new(startup_nodes,32,:timeout =&gt; 0.1)</div><div class="line"> 8</div><div class="line"> 9  last = false</div><div class="line">10</div><div class="line">11  while not last</div><div class="line">12      begin</div><div class="line">13          last = rc.get(&quot;__last__&quot;)</div><div class="line">14          last = 0 if !last</div><div class="line">15      rescue =&gt; e</div><div class="line">16          puts &quot;error #&#123;e.to_s&#125;&quot;</div><div class="line">17          sleep 1</div><div class="line">18      end</div><div class="line">19  end</div><div class="line">20</div><div class="line">21  ((last.to_i+1)..1000000000).each&#123;|x|</div><div class="line">22      begin</div><div class="line">23          rc.set(&quot;foo#&#123;x&#125;&quot;,x)</div><div class="line">24          puts rc.get(&quot;foo#&#123;x&#125;&quot;)</div><div class="line">25          rc.set(&quot;__last__&quot;,x)</div><div class="line">26      rescue =&gt; e</div><div class="line">27          puts &quot;error #&#123;e.to_s&#125;&quot;</div><div class="line">28      end</div><div class="line">29      sleep 0.1</div><div class="line">30  &#125;</div></pre></td></tr></table></figure></p>
<p>这个应用所做的工作非常简单： 它不断地以 foo<number> 为键， number 为值， 使用 SET 命令向数据库设置键值对:</number></p>
<ul>
<li>SET foo0 0</li>
<li>SET foo1 1</li>
<li>SET foo2 2</li>
<li>And so forth…</li>
</ul>
<p>代码中的每个集群操作都使用一个 begin 和 rescue 代码块（block）包裹着， 因为我们希望在代码出错时， 将错误打印到终端上面， 而不希望应用因为异常（exception）而退出。</p>
<p>代码的第七行是代码中第一个有趣的地方， 它创建了一个 Redis 集群对象， 其中创建对象所使用的参数及其意义如下：第一个参数是记录了启动节点的 startup_nodes 列表， 列表中包含了两个集群节点的地址。第二个参数指定了对于集群中的各个不同的节点， Redis 集群对象可以获得的最大连接数 ，第三个参数 timeout 指定了一个命令在执行多久之后， 才会被看作是执行失败。</p>
<p>启动列表中并不需要包含所有集群节点的地址， 但这些地址中至少要有一个是有效的： 一旦 redis-rb-cluster 成功连接上集群中的某个节点时， 集群节点列表就会被自动更新， 任何真正的的集群客户端都应该这样做。</p>
<p>现在， 程序创建的 Redis 集群对象实例被保存到 rc 变量里面， 我们可以将这个对象当作普通 Redis 对象实例来使用。<br>在十一至十九行， 我们先尝试阅读计数器中的值， 如果计数器不存在的话， 我们才将计数器初始化为 0 ： 通过将计数值保存到 Redis 的计数器里面， 我们可以在示例重启之后， 仍然继续之前的执行过程， 而不必每次重启之后都从 foo0 开始重新设置键值对。为了让程序在集群下线的情况下， 仍然不断地尝试读取计数器的值， 我们将读取操作包含在了一个 while 循环里面， 一般的应用程序并不需要如此小心。</p>
<p>二十一至三十行是程序的主循环， 这个循环负责设置键值对， 并在设置出错时打印错误信息。程序在主循环的末尾添加了一个 sleep 调用， 让写操作的执行速度变慢， 帮助执行示例的人更容易看清程序的输出。执行 example.rb 程序将产生以下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ruby ./example.rb</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">^C (I stopped the program here)</div></pre></td></tr></table></figure></p>
<p>这个程序并不是十分有趣， 稍后我们就会看到一个更有趣的集群应用示例， 不过在此之前， 让我们先使用这个示例来演示集群的重新分片操作。</p>
<h3 id="集群重新分片"><a href="#集群重新分片" class="headerlink" title="集群重新分片"></a>集群重新分片</h3><p>现在， 让我们来试试对集群进行重新分片操作。在执行重新分片的过程中， 请让你的 example.rb 程序处于运行状态， 这样你就会看到， 重新分片并不会对正在运行的集群程序产生任何影响， 你也可以考虑将 example.rb 中的 sleep 调用删掉， 从而让重新分片操作在近乎真实的写负载下执行 重新分片操作基本上就是将某些节点上的哈希槽移动到另外一些节点上面， 和创建集群一样， 重新分片也可以使用 redis-trib 程序来执行 执行以下命令可以开始一次重新分片操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb reshard 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<p>你只需要指定集群中其中一个节点的地址， redis-trib 就会自动找到集群中的其他节点。<br>目前 redis-trib 只能在管理员的协助下完成重新分片的工作， 要让 redis-trib 自动将哈希槽从一个节点移动到另一个节点， 目前来说还做不到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">你想移动多少个槽( 从1 到 16384)?</div></pre></td></tr></table></figure></p>
<p>我们尝试从将100个槽重新分片， 如果 example.rb 程序一直运行着的话， 现在 1000 个槽里面应该有不少键了。<br>除了移动的哈希槽数量之外， redis-trib 还需要知道重新分片的目标， 也即是， 负责接收这 1000 个哈希槽的节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -p 7000 cluster nodes | grep myself</div><div class="line">97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5460</div></pre></td></tr></table></figure></p>
<p>我的目标节点是 97a3a64667477371c4479320d683e4c8db5858b1.<br>现在需要指定从哪些节点来移动keys到目标节点 我输入的是all ，这样就会从其他每个master上取一些哈希槽。<br>最后确认后你将会看到每个redis-trib移动的槽的信息，每个key的移动的信息也会打印出来        在重新分片的过程中，你的例子程序是不会受到影响的,你可以停止或者重新启动多次。<br>在重新分片结束后你可以通过如下命令检查集群状态:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb check 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<h3 id="一个更有趣的程序"><a href="#一个更有趣的程序" class="headerlink" title="一个更有趣的程序"></a>一个更有趣的程序</h3><p>我们在前面使用的示例程序 example.rb 并不是十分有趣， 因为它只是不断地对集群进行写入， 但并不检查写入结果是否正确。 比如说， 集群可能会错误地将 example.rb 发送的所有 SET 命令都改成了 SET foo 42 ， 但因为 example.rb 并不检查写入后的值， 所以它不会意识到集群实际上写入的值是错误的 因为这个原因， redis-rb-cluster 项目包含了一个名为 consistency-test.rb 的示例应用， 这个应用比起 example.rb 有趣得多： 它创建了多个计数器（默认为 1000 个）， 并通过发送 INCR 命令来增加这些计数器的值。</p>
<p>在增加计数器值的同时， consistency-test.rb 还执行以下操作： 每次使用 INCR 命令更新一个计数器时， 应用会记录下计数器执行 INCR 命令之后应该有的值。 举个例子， 如果计数器的起始值为 0 ， 而这次是程序第 50 次向它发送 INCR 命令， 那么计数器的值应该是 50 。</p>
<p>在每次发送 INCR 命令之前， 程序会随机从集群中读取一个计数器的值， 并将它与自己记录的值进行对比， 看两个值是否相同。</p>
<p>换句话说， 这个程序是一个一致性检查器（consistency checker）： 如果集群在执行 INCR 命令的过程中， 丢失了某条 INCR 命令， 又或者多执行了某条客户端没有确认到的 INCR 命令， 那么检查器将察觉到这一点 —— 在前一种情况中， consistency-test.rb 记录的计数器值将比集群记录的计数器值要大； 而在后一种情况中， consistency-test.rb 记录的计数器值将比集群记录的计数器值要小。</p>
<p>运行 consistency-test 程序将产生类似以下的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ ruby consistency-test.rb</div><div class="line">925 R (0 err) | 925 W (0 err) |</div><div class="line">5030 R (0 err) | 5030 W (0 err) |</div><div class="line">9261 R (0 err) | 9261 W (0 err) |</div><div class="line">13517 R (0 err) | 13517 W (0 err) |</div><div class="line">17780 R (0 err) | 17780 W (0 err) |</div><div class="line">22025 R (0 err) | 22025 W (0 err) |</div><div class="line">25818 R (0 err) | 25818 W (0 err) |</div></pre></td></tr></table></figure></p>
<p>结果展示了执行的读和 写,和错误(由于系统不可用而没有接受的查询发生的错误）的数量.<br>如果程序察觉了不一致的情况出现， 它将在输出行的末尾显式不一致的详细情况。比如说， 如果我们在 consistency-test.rb 运行的过程中， 手动修改某个计数器的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ redis 127.0.0.1:7000&gt; set key_217 0</div><div class="line">OK</div><div class="line"></div><div class="line">(in the other tab I see...)</div><div class="line"></div><div class="line">94774 R (0 err) | 94774 W (0 err) |</div><div class="line">98821 R (0 err) | 98821 W (0 err) |</div><div class="line">102886 R (0 err) | 102886 W (0 err) | 114 lost |</div><div class="line">107046 R (0 err) | 107046 W (0 err) | 114 lost |</div></pre></td></tr></table></figure></p>
<p>在我们修改计数器值的时候， 计数器的正确值是 114 （执行了 114 次 INCR 命令）， 因为我们将计数器的值设成了 0 ， 所以 consistency-test.rb 会向我们报告说丢失了 114 个 INCR 命令。<br>这个程序作为测试程序很有意思，所以我们用这个程序来测试故障恢复.</p>
<h3 id="测试故障转移"><a href="#测试故障转移" class="headerlink" title="测试故障转移"></a>测试故障转移</h3><p>在执行本节操作的过程中， 请一直运行 consistency-test 程序。 要触发一次故障转移， 最简单的办法就是令集群中的某个主节点进入下线状态。首先用以下命令列出集群中的所有主节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -p 7000 cluster nodes | grep master</div><div class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385482984082 0 connected 5960-10921</div><div class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 master - 0 1385482983582 0 connected 11423-16383</div><div class="line">97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422</div></pre></td></tr></table></figure></p>
<p>通过命令输出得知端口号为 7000 、 7001 和 7002 的节点都是主节点， 然后我们可以通过向端口号为7002 的主节点发送 <strong>DEBUG SEGFAULT</strong> 命令， 让这个主节点崩溃：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -p 7002 debug segfault</div><div class="line">Error: Server closed the connection</div></pre></td></tr></table></figure></p>
<p>现在，切换到运行着 consistency-test 的标签页， 可以看到， consistency-test 在 7002 下线之后的一段时间里将产生大量的错误警告信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">18849 R (0 err) | 18849 W (0 err) |</div><div class="line">23151 R (0 err) | 23151 W (0 err) |</div><div class="line">27302 R (0 err) | 27302 W (0 err) |</div><div class="line"></div><div class="line">... many error warnings here ...</div><div class="line"></div><div class="line">29659 R (578 err) | 29660 W (577 err) |</div><div class="line">33749 R (578 err) | 33750 W (577 err) |</div><div class="line">37918 R (578 err) | 37919 W (577 err) |</div><div class="line">42077 R (578 err) | 42078 W (577 err) |</div></pre></td></tr></table></figure></p>
<p>从 consistency-test 的这段输出可以看到， 集群在执行故障转移期间， 总共丢失了 578 个读命令和 577 个写命令， 但是并没有产生任何数据不一致。这听上去可能有点奇怪， 因为在教程的开头我们提到过， Redis 使用的是异步复制， 在执行故障转移期间， 集群可能会丢失写命令。但是在实际上， 丢失命令的情况并不常见， 因为 Redis 几乎是同时执行将命令回复发送给客户端， 以及将命令复制给从节点这两个操作， 所以实际上造成命令丢失的时间窗口是非常小的。不过， 尽管出现的几率不高， 但丢失命令的情况还是有可能会出现的， 所以我们对 Redis 集群不能提供强一致性的这一描述仍然是正确的。现在， 让我们使用 cluster nodes 命令,查看集群在执行故障转移操作之后， 主从节点的布局情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -p 7000 cluster nodes</div><div class="line">3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385503418521 0 connected</div><div class="line">a211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385503419023 0 connected</div><div class="line">97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422</div><div class="line">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385503419023 3 connected 11423-16383</div><div class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385503417005 0 connected 5960-10921</div><div class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385503418016 3 connected</div></pre></td></tr></table></figure></p>
<p>现在masters运行在 7000, 7001 和 7005端口上. 原来的master 7002现在变成了一个7005的一个从节点.<br>CLUSTER NODES 命令的输出看起来有点复杂,其实他非常的简单，含义如下:</p>
<ul>
<li>节点ID</li>
<li>IP:端口</li>
<li>标志: master, slave, myself, fail, …</li>
<li>如果是个从节点, 这里是它的主节点的NODE ID</li>
<li>集群最近一次向节点发送 PING 命令之后， 过去了多长时间还没接到回复。.</li>
<li>节点最近一次返回 PONG 回复的时间。</li>
<li>节点的配置纪元（configuration epoch）：详细信息请参考 Redis 集群规范 。</li>
<li>本节点的网络连接情况：例如 connected 。</li>
<li>节点目前包含的槽：例如 127.0.0.1:7001 目前包含号码为 5960 至 10921 的哈希槽。</li>
</ul>
<h3 id="手动故障转移"><a href="#手动故障转移" class="headerlink" title="手动故障转移"></a>手动故障转移</h3><p>有的时候在主节点没有任何问题的情况下强制手动故障转移也是很有必要的，比如想要升级主节点的Redis进程，我们可以通过故障转移将其转为slave再进行升级操作来避免对集群的可用性造成很大的影响。</p>
<p>Redis集群使用 <code>CLUSTER FAILOVER</code>命令来进行故障转移，不过要被转移的主节点的从节点上执行该命令 手动故障转移比主节点失败自动故障转移更加安全，因为手动故障转移时客户端的切换是在确保新的主节点完全复制了失败的旧的主节点数据的前提下下发生的，所以避免了数据的丢失。<br>执行手动故障转移时从节点日志如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># Manual failover user request accepted.</div><div class="line"># Received replication offset for paused master manual failover: 347540</div><div class="line"># All master replication stream processed, manual failover can start.</div><div class="line"># Start of election delayed for 0 milliseconds (rank #0, offset 347540).</div><div class="line"># Starting a failover election for epoch 7545.</div><div class="line"># Failover election won: I&apos;m the new master.</div></pre></td></tr></table></figure></p>
<p>其基本过程如下：客户端不再链接我们淘汰的主节点，同时主节点向从节点发送复制偏移量,从节点得到复制偏移量后故障转移开始,接着通知主节点进行配置切换,当客户端在旧的master上解锁后重新连接到新的主节点上。</p>
<h3 id="添加一个新节点"><a href="#添加一个新节点" class="headerlink" title="添加一个新节点"></a>添加一个新节点</h3><p>添加新的节点的基本过程就是添加一个空的节点然后移动一些数据给它，有两种情况，添加一个主节点和添加一个从节点（添加从节点时需要将这个新的节点设置为集群中某个节点的复制）<br>针对这两种情况，本节都会介绍，先从添加主节点开始.</p>
<p>两种情况第一步都是要添加 一个空的节点.<br>启动新的7006节点,使用的配置文件和以前的一样,只要把端口号改一下即可，过程如下:   </p>
<ul>
<li>在终端打开一个新的标签页.</li>
<li>进入cluster-test 目录.</li>
<li>创建并进入 7006文件夹.</li>
<li>和其他节点一样，创建redis.conf文件,需要将端口号改成7006.</li>
<li>最后启动节点 ../redis-server ./redis.conf</li>
<li>如果正常的话，节点会正确的启动.</li>
</ul>
<p>接下来使用redis-trib 来添加这个节点到现有的集群中去.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb add-node 127.0.0.1:7006 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<p>可以看到.使用<strong>addnode</strong>命令来添加节点，第一个参数是新节点的地址，第二个参数是任意一个已经存在的节点的IP和端口. 我们可以看到新的节点已经添加到集群中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:7006&gt; cluster nodes</div><div class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385543178575 0 connected 5960-10921</div><div class="line">3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385543179583 0 connected</div><div class="line">f093c80dde814da99c5cf72a7dd01590792b783b :0 myself,master - 0 0 0 connected</div><div class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543178072 3 connected</div><div class="line">a211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385543178575 0 connected</div><div class="line">97a3a64667477371c4479320d683e4c8db5858b1 127.0.0.1:7000 master - 0 1385543179080 0 connected 0-5959 10922-11422</div><div class="line">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385543177568 3 connected 11423-16383</div></pre></td></tr></table></figure></p>
<p>新节点现在已经连接上了集群， 成为集群的一份子， 并且可以对客户端的命令请求进行转向了， 但是和其他主节点相比， 新节点还有两点区别： </p>
<ul>
<li>新节点没有包含任何数据， 因为它没有包含任何哈希槽.</li>
<li>尽管新节点没有包含任何哈希槽， 但它仍然是一个主节点， 所以在集群需要将某个从节点升级为新的主节点时， 这个新节点不会被选中。</li>
</ul>
<p>接下来， 只要使用 redis-trib 程序， 将集群中的某些哈希桶移动到新节点里面， 新节点就会成为真正的主节点了。</p>
<h3 id="添加一个从节点"><a href="#添加一个从节点" class="headerlink" title="添加一个从节点"></a>添加一个从节点</h3><p>有两种方法添加从节点，可以像添加主节点一样使用redis-trib 命令，也可以像下面的例子一样使用 –slave选项:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb add-node --slave 127.0.0.1:7006 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<p>此处的命令和添加一个主节点命令类似，此处并没有指定添加的这个从节点的主节点，这种情况下系统会在其他的复制集中的主节点中随机选取一个作为这个从节点的主节点。<br>你可以通过下面的命令指定主节点:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb add-node --slave --master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7006 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<p>也可以使用CLUSTER REPLICATE 命令添加.这个命令也可以改变一个从节点的主节点。<br>例如，要给主节点 127.0.0.1:7005添加一个从节点，该节点哈希槽的范围1423-16383, 节点 ID 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e,我们需要链接新的节点（已经是空的主节点）并执行命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:7006&gt; cluster replicate 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</div></pre></td></tr></table></figure></p>
<p>我们新的从节点有了一些哈希槽，其他的节点也知道（过几秒后会更新他们自己的配置），可以使用如下命令确认:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -p 7000 cluster nodes | grep slave | grep 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</div><div class="line">f093c80dde814da99c5cf72a7dd01590792b783b 127.0.0.1:7006 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617702 3 connected</div><div class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617198 3 connected</div></pre></td></tr></table></figure></p>
<p>节点 3c3a0c… 有两个从节点， 7002 (已经存在的) 和 7006 (新添加的).</p>
<h3 id="移除一个节点"><a href="#移除一个节点" class="headerlink" title="移除一个节点"></a>移除一个节点</h3><p>只要使用 del-node 命令即可:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb del-node 127.0.0.1:7000 `&lt;node-id&gt;`</div></pre></td></tr></table></figure></p>
<p>第一个参数是任意一个节点的地址,第二个节点是你想要移除的节点地址。<br>使用同样的方法移除主节点,不过在移除主节点前，<strong>需要确保这个主节点是空的</strong>. 如果不是空的,需要将这个节点的数据重新分片到其他主节点上.</p>
<p>替代移除主节点的方法是手动执行故障恢复，被移除的主节点会作为一个从节点存在，不过这种情况下不会减少集群节点的数量，也需要重新分片数据.</p>
<h3 id="从节点的迁移"><a href="#从节点的迁移" class="headerlink" title="从节点的迁移"></a>从节点的迁移</h3><p>在Redis集群中会存在改变一个从节点的主节点的情况，需要执行如下命令 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CLUSTER REPLICATE &lt;master-node-id&gt;</div></pre></td></tr></table></figure></p>
<p>在特定的场景下，不需要系统管理员的协助下，自动将一个从节点从当前的主节点切换到另一个主节 的自动重新配置的过程叫做复制迁移（从节点迁移），从节点的迁移能够提高整个Redis集群的可用性.</p>
<p>你可以阅读（Redis集群规范）<a href="http://www.redis.cn/topics/cluster-spec.html" target="_blank" rel="external">/topics/cluster-spec</a>了解细节.</p>
<p>简短的概况一下从节点迁移</p>
<ul>
<li>集群会在有从节点数量最多的主节点上进行从节点的迁移.</li>
<li>要在一个主节点上添加多个从节点.</li>
<li>参数来控制从节点迁移 replica-migration-barrier:你可以仔细阅读redis.conf 。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/服务器相关/redis/Redis集群/" data-id="cjei8ydl200ex7oblqdosjdsc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器相关/redis/5种数据结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/服务器相关/redis/5种数据结构/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/服务器相关/redis/5种数据结构/">5种数据结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <table>
<thead>
<tr>
<th>结构类型</th>
<th>存储结构的值</th>
<th>结构的读写能力</th>
</tr>
</thead>
<tbody>
<tr>
<td>STRING</td>
<td>可以是字符串，整数，或者浮点数</td>
<td>对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增（increment）或者自减（decrement）操作</td>
</tr>
<tr>
<td>LIST</td>
<td>一个链表，链表上的每个节点都包含了一个字符串</td>
<td>从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪（trim）；读取单个或者多个元素；根据值查找或者移除元素</td>
</tr>
<tr>
<td>SET</td>
<td>包含字符串的无序收集器（unordered collection），并且被包含的每个字符串都是独一无二，各不相同的</td>
<td>添加，获取，移除元素；检查一个元素是否存在于集合中；计算交集，并集，差集；从集合里面随机获取元素</td>
</tr>
<tr>
<td>HASH</td>
<td>包含键值对的无序散列表</td>
<td>添加，获取，移除单个键值对；获取所有的键值对</td>
</tr>
<tr>
<td>ZSET（有序集合）</td>
<td>字符串成员（member）与浮点数分值（score）之间的有序映射，元素的排列顺序由分值的大小决定</td>
<td>添加，获取，删除单个元素；根据分值范围（range）或者成员来获取元素</td>
</tr>
</tbody>
</table>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h5 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>get</td>
<td>get key-name 获取存储在给定键中的值</td>
</tr>
<tr>
<td>set</td>
<td>set key-name value 设置存储在给定键中的值</td>
</tr>
<tr>
<td>del</td>
<td>del  key-name 删除存储在给定键中的值</td>
</tr>
</tbody>
</table>
<h5 id="自增命令和自减命令"><a href="#自增命令和自减命令" class="headerlink" title="自增命令和自减命令"></a>自增命令和自减命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>incr</td>
<td>incr key-name 将键存储的值加上1</td>
</tr>
<tr>
<td>decr</td>
<td>decr key-name 将键存储的值减去1</td>
</tr>
<tr>
<td>incrby</td>
<td>incrby key-name amount 将键存储的值加上整数amount</td>
</tr>
<tr>
<td>decrby</td>
<td>将键存储的值减去整数amount</td>
</tr>
<tr>
<td>incrbyfloat</td>
<td>incrbyfloat key-name amount 将键存储的值加上浮点数amount，这个命令在Redis 2.6 或以上的版本可用</td>
</tr>
</tbody>
</table>
<h5 id="处理子串和二进制位的命令"><a href="#处理子串和二进制位的命令" class="headerlink" title="处理子串和二进制位的命令"></a>处理子串和二进制位的命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>append</td>
<td>append key-name value 将值value追加到给定键key-name当前存储的值的末尾</td>
</tr>
<tr>
<td>getrange</td>
<td>getrange key-name start end 获取一个由偏移量start至偏移量end范围内所有字符组成的子串，包括start和end在内</td>
</tr>
<tr>
<td>setrange</td>
<td>setrange ke-name offset value 将从offset偏移量开始的字串设置为给定值</td>
</tr>
<tr>
<td>getbit</td>
<td>getbit key-name offset 将字符串看作是二进制位串（bit string），并返回位串中偏移量位offset的二进制位的值</td>
</tr>
<tr>
<td>setbit</td>
<td>setbit key-name offset value 将字节串看作是二进制位串，并将位串中的偏移量为offset的二进制位的值设置为value</td>
</tr>
<tr>
<td>bitcount</td>
<td>bitcount key-name [start end] 将统计二进制位串里面值为1的二进制位的数量，如果给定了可选的start偏移量和end偏移量，那么只对偏移量指定范围内的二进制位进行统计</td>
</tr>
<tr>
<td>bitof</td>
<td>bitof operation dest-key key-name [key-name …] 对一个或多个二进制位串执行包括并（and），或（or），异或（xor），非（not）在内的任意一种位运算操作（bitwise operation），并将计算得出的结果保存在dest-key键里面</td>
</tr>
</tbody>
</table>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h5 id="基础命令-1"><a href="#基础命令-1" class="headerlink" title="基础命令"></a>基础命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>rpush</td>
<td>rpush key-name value [value .. .] 将一个或者多个推入列表的右端</td>
</tr>
<tr>
<td>lpush</td>
<td>lpush key-name value [value…] 将一个或者多个值推入列表的左端</td>
</tr>
<tr>
<td>lrange</td>
<td>lrange key-name start end 返回列表从start偏移量到end偏移量范围内的所有元素，其中偏移量为start和end的元素也会包含在被返回的元素之内</td>
</tr>
<tr>
<td>lindex</td>
<td>lindex key-name offset 返回列表中偏移量为offset的元素</td>
</tr>
<tr>
<td>lpop</td>
<td>lpop key-name 移除并返回列表最左端的元素</td>
</tr>
<tr>
<td>rpop</td>
<td>rpop key-name 移除并返回列表最右端的元素</td>
</tr>
<tr>
<td>ltrim</td>
<td>ltrim key-name start end 对列表进行修剪，只保留从start偏移量到end偏移量范围内的元素，其中偏移量为start和end的元素也会被保留</td>
</tr>
</tbody>
</table>
<h5 id="阻塞式的列表弹出命令以及在列表之间移动元素的命令"><a href="#阻塞式的列表弹出命令以及在列表之间移动元素的命令" class="headerlink" title="阻塞式的列表弹出命令以及在列表之间移动元素的命令"></a>阻塞式的列表弹出命令以及在列表之间移动元素的命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>blpop</td>
<td>blpop key-name [key-name …] timeout 从第一个非空列表中弹出位于最左端的元素，或者在timeout秒之内阻塞并等待可弹出的元素出现</td>
</tr>
<tr>
<td>brpop</td>
<td>brpop key-name [key-name …] timeout 从第一个非空列表中弹出位于最右端的元素，或者在timeout秒之内阻塞并等待可弹出的元素出现</td>
</tr>
<tr>
<td>rpoplpush</td>
<td>rpoplrush source-key dest-key 从source-key列表中弹出位于最右端的元素，然后将这个元素推入dest-key列表的最左端，并向用户返回这个元素</td>
</tr>
<tr>
<td>brpoplpush</td>
<td>brpoplrush source-key dest-key timeout 从source-key列表中弹出位于最右端的元素，然后将这个元素推入dest-key列表的最左端，并向用户返回这个元素；如果source-key为空，那么在timeout秒之内阻塞并等待可弹出的元素出现</td>
</tr>
</tbody>
</table>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h5 id="基础命令-2"><a href="#基础命令-2" class="headerlink" title="基础命令"></a>基础命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>sadd</td>
<td>sadd key-name item [item …] 将一个或者多个元素添加到集合里面，并返回被添加元素当中原本并不存在于集合里面的元素数量</td>
</tr>
<tr>
<td>srem</td>
<td>srem key-name item [item …] 从集合里面移除一个或者多个元素，并返回被移除元素的数量</td>
</tr>
<tr>
<td>sismember</td>
<td>sismember key-name item 检查元素item是否存在于集合key-name里</td>
</tr>
<tr>
<td>scard</td>
<td>scard key-name 返回集合包含的元素的数量</td>
</tr>
<tr>
<td>smembers</td>
<td>smembers key-name 返回集合包含的所有元素</td>
</tr>
<tr>
<td>srandmember</td>
<td>srandmember key-name [count] 从集合里面随机地返回一个或者多个元素。当count为正数时，命令返回的随机元素不会重复；当count为负数时，命令返回的随机元素可能会出现重复</td>
</tr>
<tr>
<td>spop</td>
<td>spop key-name 随机地移除集合中的一个元素，并返回被移除的元素</td>
</tr>
<tr>
<td>smove</td>
<td>smove source-key dest-key item 如果集合source-key包含元素item，那么从集合source-key里面移除元素item，并将元素item添加到集合dest-key中；如果item被成功移除，那么命令返回1，否则返回0</td>
</tr>
</tbody>
</table>
<h5 id="用于组合和处理多个集合的命令"><a href="#用于组合和处理多个集合的命令" class="headerlink" title="用于组合和处理多个集合的命令"></a>用于组合和处理多个集合的命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>sdiff</td>
<td>sdiff key-name [key-name …] 返回那些存在于第一集合，但不存在于其他集合中的元素（数学上的差集运算）</td>
</tr>
<tr>
<td>sdiffstore</td>
<td>sdiffstore dest-key key-name [key-name…] 将那些存在于第一个集合但并不存在于其他集合中的元素存储到dest-key键里面</td>
</tr>
<tr>
<td>sinter</td>
<td>sinter key-name [key-name…] 返回那些同时存在于所有集合中的元素（数学上的交集运算）</td>
</tr>
<tr>
<td>sinterstore</td>
<td>sinterstore dest-key key-name [key-name …] 返回那些同时存在于所有集合中的元素并存储到dest-key键里面</td>
</tr>
<tr>
<td>sunion</td>
<td>sunion key-name [key-name…] 返回那些至少存在于一个集合中的元素（数学上的并集计算）</td>
</tr>
<tr>
<td>sunionstore</td>
<td>sunionstore dest-key key-name [key-name…] 返回那些至少存在于一个集合中的元素并存储到dest-key键里面</td>
</tr>
</tbody>
</table>
<h3 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h3><h5 id="基础命令-3"><a href="#基础命令-3" class="headerlink" title="基础命令"></a>基础命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>hset</td>
<td>hset key-name key 为散列里面设置一个值</td>
</tr>
<tr>
<td>hget</td>
<td>hget key-name 为散列里面获取一个键的值</td>
</tr>
<tr>
<td>hgetall</td>
<td>获取散列包含的所有键值对</td>
</tr>
<tr>
<td>hmget</td>
<td>hmget key-name key [key …] 从散列里面获取一个或多个键的值</td>
</tr>
<tr>
<td>hmset</td>
<td>hmset key-name key value [key value …] 为散列里面的一个或多个键设置值</td>
</tr>
<tr>
<td>hdel</td>
<td>hdel key-name key [key …] 删除散列里面的一个或多个键值对，返回成功找到并删除的键值对数量</td>
</tr>
<tr>
<td>hlen</td>
<td>hlen key-name 返回散列表包含的键值对数量</td>
</tr>
</tbody>
</table>
<h5 id="散列的更高级特性"><a href="#散列的更高级特性" class="headerlink" title="散列的更高级特性"></a>散列的更高级特性</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>hexists</td>
<td>hexists key-name key 检查给定键是否存在于散列中</td>
</tr>
<tr>
<td>hkeys</td>
<td>hkeys key-name 获取散列包含的所有键</td>
</tr>
<tr>
<td>hvals</td>
<td>获取散列包含的所有值</td>
</tr>
<tr>
<td>hgetall</td>
<td>hgetall key-name 获取散列包含的所有键值对</td>
</tr>
<tr>
<td>hincrby</td>
<td>hincrby key-name key increment 将键key存储的值加上整数increment</td>
</tr>
<tr>
<td>hincrbyfloat</td>
<td>hincrbyfloat key-name key increment 将键key存储的值加上浮点数increment</td>
</tr>
</tbody>
</table>
<h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>zadd</td>
<td>zadd key-name score member [score member …] 将带有给定分值的成员添加到有序集合里面</td>
</tr>
<tr>
<td>zrem</td>
<td>zrem key-name member [member …] 从有序集合里面移除给定的成员，并返回被移除成员的数量</td>
</tr>
<tr>
<td>zcard</td>
<td>zcard key-name 返回有序集合包含的成员数量</td>
</tr>
<tr>
<td>zincrby</td>
<td>zincrby key-name increment member 将member成员的分值加上</td>
</tr>
<tr>
<td>zcount</td>
<td>zcount key-name min max 返回分值介于min和max之间的成员数量</td>
</tr>
<tr>
<td>zrank</td>
<td>zrank key-name member 返回成员member在有序集合中的排名</td>
</tr>
<tr>
<td>zscore</td>
<td>zscore key-name member 返回成员member的分值</td>
</tr>
<tr>
<td>zrange</td>
<td>zrange key-name start stop [withscores] 返回有序集合中排名介于start和stop之间的成员，如果给定了可选的withscores选项，那么命令会将成员的分值也一并返回</td>
</tr>
</tbody>
</table>
<h5 id="范围型数据获取命令和范围型数据删除命令，以及并集和交集命令"><a href="#范围型数据获取命令和范围型数据删除命令，以及并集和交集命令" class="headerlink" title="范围型数据获取命令和范围型数据删除命令，以及并集和交集命令"></a>范围型数据获取命令和范围型数据删除命令，以及并集和交集命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>zrevrank</td>
<td>zrevrank key-name member 返回有序集合成员member的排名，成员按照分值从大到小排列</td>
</tr>
<tr>
<td>zrevrange</td>
<td>zrevrange key-name start stop [withscores] 返回有序集合给定排名范围内的成员，成员按照分值从大到小排列</td>
</tr>
<tr>
<td>zrangebyscore</td>
<td>zrangebyscore key min max [withscores] [limit offset count] 返回有序集合中，分值介于min和max之间的所有成员</td>
</tr>
<tr>
<td>zrevrangebyscore</td>
<td>zrevrangebyscore key min max [withscores] [limit offset count] 获取有序集合中分值介于min和max之间所有成员，并按照分值从大到小的顺序来返回它们</td>
</tr>
<tr>
<td>zremrangebyrank</td>
<td>zremrangebyrank key-name start stop 移除有序集合中排名介于start和stop之间的所有成员</td>
</tr>
<tr>
<td>zremrangebyscore</td>
<td>zremrangebyscore key-name min max 移除有序集合中分值介于min和max之间的所有成员</td>
</tr>
<tr>
<td>zinterstore</td>
<td>zinterstore dest-key key-count key [key …] [withscores weight [weight …]] [aggregate sum\</td>
<td>min\</td>
<td>max] 对给定的有序集合执行类似于集合的交集运算</td>
</tr>
<tr>
<td>zunionstore</td>
<td>zunionstore dest-key key-count key [key …] [withscores weight [weight …]] [aggregate sum\</td>
<td>min\</td>
<td>max] 对给定的有序集合执行类似于集合的并集运算</td>
</tr>
</tbody>
</table>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>sort</td>
<td>sort source-key [by pattern] [limit offset count] [get pattern [get pattern …]] [asc\</td>
<td>desc] [alpha] [store dest-key] 根据给定的选项，对输入列表，集合或者有序集合进行排序，然后返回或者存储排序的结果</td>
</tr>
</tbody>
</table>
<h5 id="用于处理过期时间的命令"><a href="#用于处理过期时间的命令" class="headerlink" title="用于处理过期时间的命令"></a>用于处理过期时间的命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>persist</td>
<td>persist key-name 移除键的过期时间</td>
</tr>
<tr>
<td>ttl</td>
<td>ttl key-name 查看给定键距离过期还有多少秒</td>
</tr>
<tr>
<td>expire</td>
<td>expire key-name seconds 让给定键在指定的秒数之后过期</td>
</tr>
<tr>
<td>expireat</td>
<td>expireat key-name timestamp 将给定键的过期时间设置为给定的unix时间戳</td>
</tr>
<tr>
<td>pttl</td>
<td>pttl key-name 查看给定键距离过期时间还有多少毫秒，这个命令在Redis 2.6 或以上版本可用</td>
</tr>
<tr>
<td>pexpire</td>
<td>pexpire key-name milliseconds 让给定键在指定的毫秒数之后过期，这个命令在Redis 2.6 或以上版本可用</td>
</tr>
<tr>
<td>pexpireat</td>
<td>pexpireat key-name timestamp-milliseconds 将一个毫秒级精度的unix时间戳设置为给定键的过期时间，这个命令在Redis 2.6 或以上版本可用</td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/服务器相关/redis/5种数据结构/" data-id="cjei8ydl000es7oblpf00cey7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据库相关/mysql/索引的类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/数据库相关/mysql/索引的类型/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库相关/">数据库相关</a>►<a class="article-category-link" href="/categories/数据库相关/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/数据库相关/mysql/索引的类型/">索引的类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>这是最基本的索引，它没有任何限制。它有以下几种创建方式：</p>
<h5 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CREATE INDEX indexName ON mytable(username(length));</div></pre></td></tr></table></figure>
<p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length，下同。</p>
<h5 id="修改表结构的方式"><a href="#修改表结构的方式" class="headerlink" title="修改表结构的方式"></a>修改表结构的方式</h5><p>创建表后，修改表的结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER mytable ADD INDEX [indexName] ON (username(length))</div></pre></td></tr></table></figure></p>
<p>创建表的时候直接指定:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE mytable(  </div><div class="line"> </div><div class="line">    ID INT NOT NULL,   </div><div class="line">     </div><div class="line">    username VARCHAR(16) NOT NULL,  </div><div class="line">     </div><div class="line">    INDEX [indexName] (username(length))  </div><div class="line"> </div><div class="line">);</div></pre></td></tr></table></figure></p>
<h5 id="删除索引的语法："><a href="#删除索引的语法：" class="headerlink" title="删除索引的语法："></a>删除索引的语法：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DROP INDEX [indexName] ON mytable;</div></pre></td></tr></table></figure>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：</p>
<h5 id="创建索引-1"><a href="#创建索引-1" class="headerlink" title="创建索引"></a>创建索引</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CREATE UNIQUE INDEX indexName ON mytable(username(length))</div></pre></td></tr></table></figure>
<h5 id="修改表结构的方式-1"><a href="#修改表结构的方式-1" class="headerlink" title="修改表结构的方式"></a>修改表结构的方式</h5><p>创建表后，修改表的结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER mytable ADD UNIQUE [indexName] ON (username(length))</div></pre></td></tr></table></figure></p>
<p>创建表的时候直接指定:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE mytable(  </div><div class="line"> </div><div class="line">    ID INT NOT NULL,   </div><div class="line">     </div><div class="line">    username VARCHAR(16) NOT NULL,  </div><div class="line">     </div><div class="line">    UNIQUE [indexName] (username(length))  </div><div class="line"> </div><div class="line">);</div></pre></td></tr></table></figure></p>
<h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE mytable(  </div><div class="line"> </div><div class="line">    ID INT NOT NULL,   </div><div class="line">     </div><div class="line">    username VARCHAR(16) NOT NULL,  </div><div class="line">     </div><div class="line">    PRIMARY KEY(ID)  </div><div class="line"> </div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>当然也可以用 ALTER 命令。记住：一个表只能有一个主键。</p>
<h3 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h3><p>为了形象地对比单列索引和组合索引，为表添加多个字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE mytable(  </div><div class="line"> </div><div class="line">    ID INT NOT NULL,   </div><div class="line">     </div><div class="line">    username VARCHAR(16) NOT NULL,  </div><div class="line">     </div><div class="line">    city VARCHAR(50) NOT NULL,  </div><div class="line">     </div><div class="line">    age INT NOT NULL </div><div class="line"> </div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>为了进一步榨取MySQL的效率，就要考虑建立组合索引。就是将 name, city, age建到一个索引里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE mytable ADD INDEX name_city_age (name(10),city,age);</div></pre></td></tr></table></figure></p>
<p>建表时，usernname长度为 16，这里用 10。这是因为一般情况下名字的长度不会超过10，这样会加速索引查询速度，还会减少索引文件的大小，提高INSERT的更新速度。    </p>
<p>如果分别在usernname，city，age上建立单列索引，让该表有3个单列索引，查询时和上述的组合索引效率也会大不一样，远远低于我们的组合索引。虽然此时有了三个索引，但MySQL只能用到其中的那个它认为似乎是最有效率的单列索引。</p>
<p>建立这样的组合索引，其实是相当于分别建立了下面三组组合索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">usernname,city,age  </div><div class="line"> </div><div class="line">usernname,city  </div><div class="line"> </div><div class="line">usernname</div></pre></td></tr></table></figure></p>
<p>为什么没有city，age这样的组合索引呢？这是因为MySQL组合索引“<strong>最左前缀</strong>”的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这三列的查询都会用到该组合索引，下面的几个SQL就会用到这个组合索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM mytable WHREE username=&quot;admin&quot; AND city=&quot;郑州&quot; </div><div class="line"> </div><div class="line">SELECT * FROM mytable WHREE username=&quot;admin&quot;</div></pre></td></tr></table></figure></p>
<p>而下面几个则不会用到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM mytable WHREE age=20 AND city=&quot;郑州&quot; </div><div class="line"> </div><div class="line">SELECT * FROM mytable WHREE city=&quot;郑州&quot;</div></pre></td></tr></table></figure></p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>全文索引(也称全文检索)是目前搜索引擎使用的一种关键技术。它能够利用“分词技术”等多种算法智能分析出文本文字中关键字词的频率及重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。</p>
<h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><p>建表的时候确定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE article ( </div><div class="line">      id INT AUTO_INCREMENT NOT NULL PRIMARY KEY, </div><div class="line">      title VARCHAR(200), </div><div class="line">      body TEXT, </div><div class="line">      FULLTEXT(title, body) </div><div class="line">) TYPE=MYISAM;</div></pre></td></tr></table></figure></p>
<p>通过 alter table 的方式来添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> ALTER TABLE `student` ADD FULLTEXT INDEX INDEX_NAME  (`name`) </div><div class="line"></div><div class="line">或者：ALTER TABLE `student` ADD FULLTEXT INDEX_NAME  (`name`)</div></pre></td></tr></table></figure></p>
<p>直接通过create index的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CREATE FULLTEXT INDEX INDEX_NAME ON `student` (`name`)</div><div class="line"></div><div class="line">也可以在创建索引的时候指定索引的长度：</div><div class="line">CREATE FULLTEXT INDEX INDEX_NAME ON `student` (`name`(20))</div></pre></td></tr></table></figure></p>
<h5 id="删除全文索引"><a href="#删除全文索引" class="headerlink" title="删除全文索引"></a>删除全文索引</h5><p>直接使用 drop index(注意：没有 drop fulltext index 这种用法)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DROP INDEX INDEX_NAME ON TABLENAME ;</div></pre></td></tr></table></figure></p>
<p>使用 alter table的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE TABLENAME DROP INDEX INDEX_NAME;</div></pre></td></tr></table></figure></p>
<h5 id="使用全文索引"><a href="#使用全文索引" class="headerlink" title="使用全文索引"></a>使用全文索引</h5><p>跟普通索引稍有不同,使用全文索引的格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MATCH (columnName) AGAINST (&apos;string&apos;)</div></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM `student` WHERE MATCH(`name`) AGAINST(&apos;聪&apos;)</div></pre></td></tr></table></figure></p>
<h5 id="设置条件"><a href="#设置条件" class="headerlink" title="设置条件"></a>设置条件</h5><ol>
<li>表的存储引擎是MyISAM，默认存储引擎InnoDB不支持全文索引（新版本MYSQL5.6的InnoDB支持全文索引）    </li>
<li>字段类型：char、varchar和text</li>
</ol>
<p>MySQL自带的全文索引只能对英文进行全文检索，目前无法对中文进行全文检索。如果需要对包含中文在内的文本数据进行全文检索，我们需要采用Sphinx(斯芬克斯)/Coreseek技术来处理中文</p>
<h5 id="全文索引应用流程："><a href="#全文索引应用流程：" class="headerlink" title="全文索引应用流程："></a>全文索引应用流程：</h5><ol>
<li>接收数据-数据分词-入库</li>
<li>接收数据-数据分词-查询</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/数据库相关/mysql/索引的类型/" data-id="cjei8ydki00dp7obl4r64ruqz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网络/HTTP完整请求过程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/网络/HTTP完整请求过程/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络/">网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/网络/HTTP完整请求过程/">HTTP完整请求过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：</p>
<ol>
<li><p>建立TCP连接：</p>
<p> 在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，</p>
<p> 即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能进行更高层协议的连接，</p>
<p> 因此，首先要建立TCP连接，一般TCP连接的端口号是80。</p>
</li>
<li><p>Web浏览器向Web服务器发送请求命令： </p>
<p> 一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。</p>
</li>
</ol>
<ol>
<li><p>Web浏览器发送请求头信息 ：</p>
<p> 浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。</p>
</li>
</ol>
<ol>
<li><p>Web服务器应答 ：</p>
<p> 客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。</p>
</li>
</ol>
<ol>
<li><p>Web服务器发送应答头信息： </p>
<p> 正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。</p>
</li>
</ol>
<ol>
<li><p>Web服务器向浏览器发送数据： </p>
<p> Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。</p>
</li>
<li><p>Web服务器关闭TCP连接 ：</p>
<p> 一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive；</p>
<p> TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>
<p> ​</p>
</li>
</ol>
<p>下面以Chrome浏览器为例，分析一下整个过程：</p>
<ol>
<li><strong>域名解析</strong></li>
</ol>
<p>首先Chrome浏览器会解析 www.baidu.com 这个域名（准确的叫法应该是主机名）对应的IP地址。怎么解析到对应的IP地址？</p>
<p>① Chrome浏览器 会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有www.baidu.com 对应的条目，而且没有过期，如果有且没有过期则解析到此结束。</p>
<pre><code>注：我们怎么查看Chrome自身的缓存？可以使用 chrome://net-internals/#dns 来进行查看
</code></pre><p>② 如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索解析到此结束.</p>
<pre><code>注：怎么查看操作系统自身的DNS缓存，以Windows系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看  
</code></pre><p>③ 如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于C:\Windows\System32\drivers\etc），看看这里面有没有该域名对应的IP地址，如果有则解析成功。</p>
<p>④ 如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找打根域的DNS地址，就会向其发起请求（请问www.baidu.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.baidu.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.baidu.com这个域名的IP地址，但是我知道www.baidu.com这个域的DNS地址，你去找它去，于是运营商的DNS又向www.baidu.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.baidu.com这个域名的IP地址是多少？），这个时候www.baidu.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.baidu.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.baidu.com 对应的IP地址，该进行一步的动作了。</p>
<ol>
<li><strong>发起TCP的3次握手</strong>     </li>
</ol>
<p>拿到域名对应的IP地址之后，User-Agent（一般是指浏览器）会以一个随机端口（1024 &lt; 端口 &lt; 65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求（原始的http请求经过TCP/IP4层模型的层层封包）到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。</p>
<p>如下图：<br><img src="http://s3.51cto.com/wyfs02/M01/11/7C/wKioL1LSW6rjI1nhAAE63Uv8ZRY731.jpg?_=5959335" alt="image"><br>1） Client首先发送一个连接试探，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示Client自己的初始序号（seq = 0 就代表这是第0号包），这时候Client进入syn_sent状态，表示客户端等待服务器的回复</p>
<p>2） Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN 和 ACK都置1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server 自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待client的确认。</p>
<p>3） Client收到确认后还需再次发送确认，同时携带要发送给Server的数据。ACK 置1 表示确认号ack= y + 1 有效（代表期望收到服务器的第1个包），Client自己的序号seq= x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到Client的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。</p>
<ol>
<li><strong>建立TCP连接后发起http请求</strong>    </li>
</ol>
<p>HTTP请求信息由3部分组成：   </p>
<ul>
<li>请求行（请求方法（GET/POST）、URI、协议/版本）</li>
<li>请求头(Request Header)</li>
<li>请求正文</li>
</ul>
<p>http响应消息由3部分组成：</p>
<ul>
<li>状态行</li>
<li>响应头(Response Header)</li>
<li>响应正文</li>
</ul>
<ol>
<li><strong>服务器端响应http请求，浏览器得到html代码</strong></li>
<li><strong>浏览器解析html代码，并请求html代码中的资源</strong></li>
<li><strong>浏览器对页面进行渲染呈现给用户</strong></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/网络/HTTP完整请求过程/" data-id="cjei8yde000257oblafks902h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据库相关/mysql/查询性能优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/数据库相关/mysql/查询性能优化/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库相关/">数据库相关</a>►<a class="article-category-link" href="/categories/数据库相关/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/数据库相关/mysql/查询性能优化/">查询性能优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="慢查询基础：优化数据访问"><a href="#慢查询基础：优化数据访问" class="headerlink" title="慢查询基础：优化数据访问"></a>慢查询基础：优化数据访问</h2><p>对于低效的查询，我们发现通过下面两个步骤来分析总是很有效的：</p>
<ul>
<li>确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多列。</li>
<li>确认MySQL服务器层是否在分析大量超过需要的数据行。</li>
</ul>
<p>对于MySQL，最简单的衡量查询开销的三个指标如下：</p>
<ul>
<li>响应时间</li>
<li>扫描的行数</li>
<li>返回的行数</li>
</ul>
<p>一般MySQL能够使用如下三种方式应用WHERE条件，从好到坏依次为：</p>
<ul>
<li>在索引中使用WHERE条件来过滤不匹配的记录。这是在存储引擎层完成的。</li>
<li>使用索引覆盖扫描（在Extra列中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无须再回表查询记录。</li>
<li>从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using Where）。这是在MySQL服务器层完成，MySQL需要先从数据表读出记录然后过滤。</li>
</ul>
<p>如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试下面的技巧去优化它：</p>
<ul>
<li>使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果了</li>
<li>改变库表结构</li>
<li>重写这个复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询</li>
</ul>
<h2 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h2><h6 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h6><p>有时候对于一个大查询我们需要“分而治之”，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果</p>
<h6 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h6><p>很多高性能的应用都会对关联查询进行分解。简单地，可以对每一个表进行一次单表查询，然后将结果在应用程序中进行关联。例如，下面这个查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT * FROM tag</div><div class="line">    -&gt;   JOIN tag_post ON tag_post.tag_id=tag.id</div><div class="line">    -&gt;   JOIN post on tag_post.post_id=post.id</div><div class="line">    -&gt; WHERE tag.tag=&apos;mysql&apos;;</div></pre></td></tr></table></figure></p>
<p>可以分解成下面这些查询来代替：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT * FROM tag WHERE tag=&apos;mysql&apos;;</div><div class="line">mysql&gt; SELECT * FROM tag_post WHERE tag_id=1234;</div><div class="line">mysql&gt; SELECT * FROM post WHERE post.id in(123, 456, 789);</div></pre></td></tr></table></figure></p>
<p>用分解关联查询的方式重构查询有如下的优势：</p>
<ul>
<li>让缓存更高效。许多应用程序可以方便地缓存单表查询对应的结果对象。</li>
<li>将查询分解后，执行单个查询可以减少锁的竞争</li>
<li>在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展</li>
<li>查询本身效率也可能会有所提升。在这个例子中，使用IN()代替关联查询，可以染MySQL按照ID顺序进行查询，这可能比随机的关联要更高效。</li>
<li>可以减少冗余记录的查询。在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复地访问一部分数据。从这点看，这样的重构还可能会减少网络和内存的消耗。</li>
<li>更进一步，这样做相当于在应用中实现了哈希关联，而不是使用MySQL的嵌套循环查询。</li>
</ul>
<h2 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h2><p>MySQL执行一个查询的过程：<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/MySQL8.jpeg" alt="image"></p>
<ol>
<li>客户端发送一条查询给服务器</li>
<li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段</li>
<li>服务器进行SQL解析，预处理，再由优化器生成对应的执行计划</li>
<li>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询</li>
<li>将结果返回给客户端</li>
</ol>
<h6 id="MySQL客户端-服务器通信协议"><a href="#MySQL客户端-服务器通信协议" class="headerlink" title="MySQL客户端/服务器通信协议"></a>MySQL客户端/服务器通信协议</h6><p>MySQL客户端和服务器之间的通信协议是“半双工”的，这意味着，在任何一个时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生。所以，我们无法也无须将一个消息切成小块独立来发送。</p>
<p>这种协议让MySQL通信简单快速，但是也从很多地方限制了MySQL。一个明显的限制是，这意味着无法进行流量控制。一旦一端开始发送消息，另一端要接收完整个消息才能响应它。</p>
<p>客户端用一个单独的数据包将查询传给服务器。这也是为什么当查询的语句很长的时候，参数<code>max_allowed_packet</code>就特别重要了。一旦客户端发送了请求，它能做的事情就只是等待结果了。</p>
<p>相反的，一般服务器响应给用户的数据通常很多，由多个数据包组成。当服务器开始响应客户端请求时，客户端必须完整地接收整个返回结果，而不能简单地只取前面几条结果，然后让服务器停止发送数据。</p>
<p>换一种方式解释这种行为：当客户端从服务器取数据时，看起来是一个拉数据的过程，但实际上是MySQL在向客户端推送数据的过程。客户端不断地接收从服务器推送的数据，客户端也无法让服务器停下来。</p>
<p>多数连接MySQL的库函数都可以获得全部结果集并缓存到内存里，还可以逐行获取需要的数据。默认一般是获得全部结果集并缓存到内存中。MySQL通常需要等所有的数据都已经发送给客户端才能释放这条查询所占用的资源，所以接收全部结果并缓存通常可以减少服务器的压力，让查询能够早点结束，早点释放相应的资源。</p>
<h6 id="查询状态"><a href="#查询状态" class="headerlink" title="查询状态"></a>查询状态</h6><p>对于一个MySQL连接，或者说一个线程，任何时刻都由一个状态，该状态表示了MySQL当前正在做什么。由很多中方式能够查看当前的状态，最简单的是使用<code>SHOW FULL PROCESSLIST</code>命令（该命令返回结果中的Command列就表示当前的状态）</p>
<h6 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h6><p>当不能使用索引生成排序结果的时候，MySQL需要自己进行排序，如果数据量小则在内存中进行，如果数据量大则需要使用磁盘，不过MySQL将这个过程统一称为文件排序（filesort），即使完全是内存排序不需要任何磁盘文件时也是如此。</p>
<p>如果需要排序的数据量小于“排序缓冲区”，MySQL使用内存进行“快速排序”操作。如果内存不够排序，那么MySQL会先将数据分块，对每个独立的块使用“快速排序”进行排序，并将各个块的排序结果存放在磁盘上，然后将各个拍好序的块进行合并（merge），最后返回排序结果。</p>
<p>MySQL有两种排序算法，新版本使用的是<strong>单次传输排序</strong>：<br>先读取查询所需要的所有列，然后再根据给定列进行排序，最后直接返回排序结果。这个算法只在MySQL4.1及后续更新的版本引入。因为不再需要从数据表读取两次数据，对于I/O密集型的应用，这样做的效率高了很多。另外，相比两次传输排序，这个算法只需要一次顺序I/O读取所有的数据，而无须任何的随机I/O。缺点是，如果需要返回的列非常多，非常大，会额外占用大量的空间，而这些列对排序操作本身来说是没有任何作用的。因为单条排序记录很大，所以可能会有更多的排序块需要合并。</p>
<p><strong>在关联查询的时候如果需要排序，MySQL会分两种情况来处理这样的文件排序。如果ORDER BY 子句中的所有列都来自关联的第一个表。那么MySQL在关联处理第一个表的时候就进行文件排序。如果是这样，那么在MySQL的EXPLAIN结果中可以看到Extra字段会有“Using filesort”。除此之外的所有情况，MySQL都会先将关联的结果存放到一个临时表中，然后再所有的关联都结束后，再进行文件排序。这种情况下，在MySQL的EXPLAIN结果的Extra字段可以看到“Using temporary；Using filesort”。如果查询中有LIMIT的话，LIMIT也会在排序之后应用，所以即使需要返回较少的数据，临时表和需要排序的数据量仍然会非常大</strong>。</p>
<h2 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h2><h6 id="优化count-查询"><a href="#优化count-查询" class="headerlink" title="优化count()查询"></a>优化count()查询</h6><p>count()是一个特殊的函数，有两种非常不同的作用：它可以统计某个列值的数量，也可以统计行数。</p>
<p>在统计列值时要求列值是非空的（不统计NULL）。如果在count()的括号中指定了列或者列的表达式，则统计的就是这个表达式有值的结果数。</p>
<p>在统计结果集的行数时，当MySQL确认括号内的表达式值不可能为空时，实际上就是在统计行数。最简单的就是当我们使用count(*)的时候，它会忽略所有的列而直接统计所有的行数。</p>
<h6 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h6><ul>
<li>确保ON 或者 USING 子句中的列上有索引。一般来说，除非有其他理由，否则只需要在关联顺序中的第二个表的相应列上创建索引。</li>
<li>确保任何的 GROUP BY 和 ORDER BY 中的表达式只涉及到一个表中的列。这样MySQL才有可能使用索引来优化这个过程。</li>
<li>当升级MySQL的时候需要注意：关联语法，运算符优先级等其他可能会发生变化的地方。</li>
</ul>
<h6 id="优化GROUP-BY-和-DISTINCT"><a href="#优化GROUP-BY-和-DISTINCT" class="headerlink" title="优化GROUP BY 和 DISTINCT"></a>优化GROUP BY 和 DISTINCT</h6><p>MySQL优化器会在内部处理的时候相互转化这两类查询。它们都可以使用索引来优化，这也是最有效的优化办法。</p>
<p>在MySQL中，当无法使用索引的时候，GROUP BY使用两种策略来完成：<strong>使用临时表或者文件排序来做分组</strong>。</p>
<p><strong>如果没有通过ORDER BY子句显式地指定排序列，当查询使用GROUP BY子句的时候，结果集会自动按照分组的字段进行排序。如果不关心结果集的顺序，而这种默认排序又导致了需要文件排序，则可以使用ORDER BY NULL，让MySQL不再进行文件排序。也可以在GROUP BY子句中直接使用DESC 或ASC关键字，使分组的结果集按需要的方向排序</strong>。</p>
<h6 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h6><p>优化此类分页查询的一个最简单的办法就是尽可能地使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候，这样做的效率会提升非常大。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/数据库相关/mysql/查询性能优化/" data-id="cjei8ydkh00dm7oblutzgzyn9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Eclipse/">Eclipse</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Github/">Github</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Cookie/">Cookie</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JAXB/">JAXB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JavaMail/">JavaMail</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/基础/">基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/数据类型/">数据类型</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/日记/">日记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/时间日期/">时间日期</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/线程/">线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/网络NIO/">网络NIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/队列/">队列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/集合/">集合</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Application-Event/">Application Event</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/JPA/">JPA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Security/">Security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Spring-Boot/">Spring Boot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Spring-Session/">Spring Session</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Task/">Task</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-MVC/">spring MVC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-data-redis/">spring data redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/基础/">基础</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/">前端技术相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/forever/">forever</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/javascript/">javascript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库相关/">数据库相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据库相关/mysql/">mysql</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/">服务器相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hessian/">Hessian</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hudson-Jenkins/">Hudson & Jenkins</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Memcached/">Memcached</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Nginx/">Nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Tomcat/">Tomcat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/red5/">red5</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/resin/">resin</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/正则表达式/">正则表达式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/08/正则表达式/正则表达式/">正则表达式</a>
          </li>
        
          <li>
            <a href="/2018/02/25/Java/集合/Hashtable与ConcurrentHashMap区别/">Hashtable与ConcurrentHashMap区别</a>
          </li>
        
          <li>
            <a href="/2018/02/25/Java/分布式/分布式事务/">分布式事务</a>
          </li>
        
          <li>
            <a href="/2018/02/25/Java/分布式/分布式锁/">分布式锁</a>
          </li>
        
          <li>
            <a href="/2018/02/25/Java/集合/在List循环中删除元素/">在List循环中删除元素</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 LeoChan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>