<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LeoChan&#39;s 个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="描述啊">
<meta property="og:type" content="website">
<meta property="og:title" content="LeoChan&#39;s 个人博客">
<meta property="og:url" content="https://clq2owesome.github.io/page/2/index.html">
<meta property="og:site_name" content="LeoChan&#39;s 个人博客">
<meta property="og:description" content="描述啊">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeoChan&#39;s 个人博客">
<meta name="twitter:description" content="描述啊">
  
    <link rel="alternate" href="/atom.xml" title="LeoChan&#39;s 个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LeoChan&#39;s 个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术都是通用的，重要的是是否具有自主解决问题的能力！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://clq2owesome.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Java/基础/java8新特性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/基础/java8新特性/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/基础/java8新特性/">java8新特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="函数式接口（Functional-Interfaces）"><a href="#函数式接口（Functional-Interfaces）" class="headerlink" title="函数式接口（Functional Interfaces）"></a>函数式接口（Functional Interfaces）</h2><p>Java 8 引入的一个核心概念是函数式接口（<strong>Functional Interfaces</strong>）。通过在接口里面添加一个抽象方法，这些方法可以直接从接口中运行。如果一个接口定义个唯一一个抽象方法，那么这个接口就成为<strong>函数式接口</strong>。</p>
<p>同时，引入了一个新的注解：<code>@FunctionalInterface</code>。可以把他它放在一个接口前，表示这个接口是一个函数式接口。这个注解是非必须的，只要接口只包含一个方法的接口，虚拟机会自动判断，不过最好在接口上使用注解 @FunctionalInterface 进行声明。在接口中添加了 @FunctionalInterface 的接口，只允许有一个抽象方法，否则编译器也会报错。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">interface Converter&lt;F, T&gt; &#123;</div><div class="line">    T convert(F from);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</div><div class="line">Integer converted = converter.convert(&quot;123&quot;);</div><div class="line">System.out.println(converted);    // 123</div></pre></td></tr></table></figure></p>
<p>java.lang.Runnable 就是一个函数式接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface Runnable &#123;</div><div class="line">    public abstract void run();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们要记住默认的方法和静态方法不会违反函数接口的约定，例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface FunctionalDefaultMethods &#123;</div><div class="line">    void method();</div><div class="line"> </div><div class="line">    default void defaultMethod() &#123;</div><div class="line">        //相关代码</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    static void staticMethod() &#123;</div><div class="line">        //相关代码</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="方法和构造函数引用"><a href="#方法和构造函数引用" class="headerlink" title="方法和构造函数引用"></a>方法和构造函数引用</h2><p>上面的示例代码可以通过使用静态方法引用进一步简化:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</div><div class="line">Integer converted = converter.convert(&quot;123&quot;);</div><div class="line">System.out.println(converted);   // 123</div></pre></td></tr></table></figure></p>
<p>Java 8允许您通过<code>::</code>关键字来传递方法或构造函数的引用。上面的示例展示了如何引用静态方法。但是我们也可以引用对象方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Something &#123;</div><div class="line">    String startsWith(String s) &#123;</div><div class="line">        return String.valueOf(s.charAt(0));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Something something = new Something();</div><div class="line">Converter&lt;String, String&gt; converter = something::startsWith;</div><div class="line">String converted = converter.convert(&quot;Java&quot;);</div><div class="line">System.out.println(converted);    // &quot;J&quot;</div></pre></td></tr></table></figure></p>
<p>让我们看看<code>::</code>关键字如何对构造函数有效。首先，我们定义了一个不同构造函数的示例bean:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">    String firstName;</div><div class="line">    String lastName;</div><div class="line"></div><div class="line">    Person() &#123;&#125;</div><div class="line"></div><div class="line">    Person(String firstName, String lastName) &#123;</div><div class="line">        this.firstName = firstName;</div><div class="line">        this.lastName = lastName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来，我们指定一个人工厂接口用于创建新人员:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">interface PersonFactory&lt;P extends Person&gt; &#123;</div><div class="line">    P create(String firstName, String lastName);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们没有手工地实现工厂，而是通过构造函数引用将所有内容粘在一起:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PersonFactory&lt;Person&gt; personFactory = Person::new;</div><div class="line">Person person = personFactory.create(&quot;Peter&quot;, &quot;Parker&quot;);</div></pre></td></tr></table></figure></p>
<p>我们通过<code>Person::new</code>创建一个Person构造函数的引用。Java编译器会通过匹配PersonFactory.create的签名来自动选择正确的构造函数。</p>
<p>方法引用提供了一个很有用的语义来直接访问类或者实例的已经存在的方法或者构造方法。结合Lambda表达式，方法引用使语法结构紧凑简明。不需要复杂的引用。</p>
<p>下面我们用Car 这个类来做示例，Car这个类有不同的方法定义。让我们来看看java 8支持的4种方法引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public static class Car &#123;</div><div class="line">    public static Car create( final Supplier&lt; Car &gt; supplier ) &#123;</div><div class="line">        return supplier.get();</div><div class="line">    &#125;              </div><div class="line"> </div><div class="line">    public static void collide( final Car car ) &#123;</div><div class="line">        System.out.println( &quot;Collided &quot; + car.toString() );</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void follow( final Car another ) &#123;</div><div class="line">        System.out.println( &quot;Following the &quot; + another.toString() );</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void repair() &#123;</div><div class="line">        System.out.println( &quot;Repaired &quot; + this.toString() );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li><p>第一种方法引用是构造方法引用，语法是：<code>Class::new</code> ，对于泛型来说语法是：<code>Class&lt;T &gt;::new</code>，请注意构造方法没有参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">final Car car = Car.create( Car::new );</div><div class="line">final List&lt; Car &gt; cars = Arrays.asList( car );</div></pre></td></tr></table></figure>
</li>
<li><p>第二种方法引用是静态方法引用，语法是：<code>Class::static_method</code>请注意这个静态方法只支持一个类型为Car的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cars.forEach( Car::collide );</div></pre></td></tr></table></figure>
</li>
<li><p>第三种方法引用是类实例的方法引用，语法是：<code>Class::method</code>请注意方法没有参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cars.forEach( Car::repair );</div></pre></td></tr></table></figure>
</li>
<li><p>最后一种方法引用是引用特殊类的方法，语法是：<code>instance::method</code>，请注意只接受Car类型的一个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">final Car police = Car.create( Car::new );</div><div class="line">cars.forEach( police::follow );</div></pre></td></tr></table></figure>
</li>
</ol>
<p>运行这些例子我们将会在控制台得到如下信息（Car的实例可能会不一样）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Collided com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d</div><div class="line">Repaired com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d</div><div class="line">Following the com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d</div></pre></td></tr></table></figure></p>
<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>从lambda表达式访问外部范围变量非常类似于匿名对象。您可以从本地外部范围访问最终变量，以及实例字段和静态变量。</p>
<h3 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h3><p>我们可以从lambda表达式的外部范围读取最终的局部变量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">final int num = 1;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line"></div><div class="line">stringConverter.convert(2);     // 3</div></pre></td></tr></table></figure></p>
<p>但与匿名对象不同的是，变量num不必被声明为final。这段代码也是有效的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int num = 1;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line"></div><div class="line">stringConverter.convert(2);     // 3</div></pre></td></tr></table></figure></p>
<p>但是，对于要编译的代码，num必须是隐式的final。以下代码不编译:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int num = 1;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line">num = 3;</div></pre></td></tr></table></figure></p>
<p>也禁止在lambda表达式中写入num。</p>
<h3 id="访问字段和静态变量"><a href="#访问字段和静态变量" class="headerlink" title="访问字段和静态变量"></a>访问字段和静态变量</h3><p>在对局部变量的限制中，我们可以从lambda表达式中读取和写入对实例字段和静态变量的访问。这种行为在匿名对象中很常见。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Lambda4 &#123;</div><div class="line">    static int outerStaticNum;</div><div class="line">    int outerNum;</div><div class="line"></div><div class="line">    void testScopes() &#123;</div><div class="line">        Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;</div><div class="line">            outerNum = 23;</div><div class="line">            return String.valueOf(from);</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;</div><div class="line">            outerStaticNum = 72;</div><div class="line">            return String.valueOf(from);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="访问默认接口方法"><a href="#访问默认接口方法" class="headerlink" title="访问默认接口方法"></a>访问默认接口方法</h3><p>还记得第一部分的公式例子吗?接口公式定义了一个默认的方法sqrt，它可以从每个公式实例(包括匿名对象)访问。这不适用于lambda表达式。</p>
<p>无法从lambda表达式中访问默认方法。以下代码不编译:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Formula formula = (a) -&gt; sqrt( a * 100);</div></pre></td></tr></table></figure></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>函数式接口的重要属性是：我们能够使用 Lambda 实例化它们，Lambda 表达式让你能够将函数作为方法参数，或者将代码作为数据对待</strong>。Lambda 表达式的引入给开发者带来了不少优点：在 Java 8 之前，匿名内部类，监听器和事件处理器的使用都显得很冗长，代码可读性很差，Lambda 表达式的应用则使代码变得更加紧凑，可读性增强；Lambda 表达式使并行操作大集合变得很方便，可以充分发挥多核 CPU 的优势，更易于为多核处理器编写代码；</p>
<p>Lambda 表达式由三个部分组成：</p>
<ul>
<li>第一部分为一个括号内用逗号分隔的形式参数，参数是函数式接口里面方法的参数；</li>
<li>第二部分为一个箭头符号：-&gt;；</li>
<li>第三部分为方法体，可以是表达式和代码块。</li>
</ul>
<p>语法如下：</p>
<ol>
<li><p>方法体为表达式，该表达式的值作为返回值返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(parameters) -&gt; expression</div></pre></td></tr></table></figure>
</li>
<li><p>方法体为代码块，必须用 {} 来包裹起来，且需要一个 return 返回值，但若函数式接口里面方法返回值是 void，则无需返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(parameters) -&gt; &#123; statements; &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>例如，下面是使用匿名内部类和 Lambda 表达式的代码比较。<br>下面是用匿名内部类的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">button.addActionListener(new ActionListener() &#123;</div><div class="line">    @Override</div><div class="line">    public void actionPerformed(ActionEvent e) &#123;</div><div class="line">        System.out.print(&quot;Helllo Lambda in actionPerformed&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>下面是使用 Lambda 表达式后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">button.addActionListener(</div><div class="line">    //actionPerformed 有一个参数 e 传入，所以用 (ActionEvent e)</div><div class="line">    (ActionEvent e)-&gt; </div><div class="line">    System.out.print(&quot;Helllo Lambda in actionPerformed&quot;);</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>上面是方法体包含了参数传入 (ActionEvent e)，如果没有参数则只需 ( )，例如 Thread 中的 run 方法就没有参数传入，当它使用 Lambda 表达式后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Thread t = new Thread(</div><div class="line">    //run 没有参数传入，所以用 (), 后面用 &#123;&#125; 包起方法体</div><div class="line">    () -&gt; &#123;</div><div class="line">     System.out.println(&quot;Hello from a thread in run&quot;);</div><div class="line">    &#125;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>通过上面两个代码的比较可以发现使用 Lambda 表达式可以简化代码，并提高代码的可读性。<br>为了进一步简化 Lambda 表达式，可以使用方法引用。例如，下面三种分别是使用内部类，使用 Lambda 表示式和使用方法引用方式的比较：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//1. 使用内部类</div><div class="line">Function&lt;Integer, String&gt; f = new Function&lt;Integer,String&gt;()&#123;</div><div class="line">    @Override</div><div class="line">    public String apply(Integer t) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//2. 使用 Lambda 表达式</div><div class="line">Function&lt;Integer, String&gt; f2 = (t)-&gt;String.valueOf(t); </div><div class="line"></div><div class="line">//3. 使用方法引用的方式</div><div class="line">Function&lt;Integer, String&gt; f1 = String::valueOf;</div></pre></td></tr></table></figure></p>
<p>要使用 Lambda 表达式，需要定义一个函数式接口，这样往往会让程序充斥着过量的仅为 Lambda 表达式服务的函数式接口。为了减少这样过量的函数式接口，Java 8 在 java.util.function 中增加了不少新的函数式通用接口。例如：</p>
<ul>
<li><p><code>Function&lt;T, R&gt;</code>：将 T 作为输入，返回 R 作为输出，他还包含了和其他函数组合的默认方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</div><div class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</div><div class="line"></div><div class="line">backToString.apply(&quot;123&quot;);     // &quot;123&quot;</div></pre></td></tr></table></figure>
</li>
<li><p><code>Predicate&lt;T&gt;</code> ：将 T 作为输入，返回一个布尔值作为输出，该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（与、或、非）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">   Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;</div><div class="line">System.out.println(predicate.test(&quot;foo&quot;));// true   </div><div class="line">System.out.println(predicate.negate().test(&quot;foo&quot;));// false</div><div class="line"></div><div class="line">Predicate&lt;String&gt; nonNull = Objects::nonNull;</div><div class="line">Predicate&lt;String&gt; isNull = Objects::isNull;</div><div class="line">System.out.println(nonNull.test(&quot;aa&quot;));//true</div><div class="line">System.out.println(isNull.test(&quot;aa&quot;));//false</div><div class="line"></div><div class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</div><div class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</div></pre></td></tr></table></figure>
</li>
<li><p><code>Suppliers</code>：生成给定泛型类型的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Supplier&lt;Person&gt; personSupplier = Person::new;</div><div class="line">personSupplier.get();   // new Person</div></pre></td></tr></table></figure>
</li>
<li><p><code>Consumer&lt;T&gt;</code> ：将 T 作为输入，不返回任何内容，表示在单个参数上的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(&quot;Hello, &quot; + p.firstName);</div><div class="line">greeter.accept(new Person(&quot;Luke&quot;, &quot;Skywalker&quot;));</div></pre></td></tr></table></figure>
</li>
<li><p><code>Comparators</code>：比较器是较老版本的Java所熟悉的。Java 8向接口添加了各种默认方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</div><div class="line"></div><div class="line">Person p1 = new Person(&quot;John&quot;, &quot;Doe&quot;);</div><div class="line">Person p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;);</div><div class="line"></div><div class="line">comparator.compare(p1, p2);             // &gt; 0</div><div class="line">comparator.reversed().compare(p1, p2);  // &lt; 0</div></pre></td></tr></table></figure>
</li>
<li><p><code>Optionals</code>：Optionals不是功能性接口，相反，它是一个防止NullPointerException的漂亮工具</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Optional&lt;String&gt; optional = Optional.of(&quot;bam&quot;);</div><div class="line"></div><div class="line">optional.isPresent();           // true</div><div class="line">optional.get();                 // &quot;bam&quot;</div><div class="line">optional.orElse(&quot;fallback&quot;);    // &quot;bam&quot;</div><div class="line"></div><div class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(0)));     // &quot;b&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>著名的NullPointerException 是引起系统失败最常见的原因。很久以前Google Guava项目引入了Optional作为解决空指针异常的一种方式，不赞成代码被null检查的代码污染，期望程序员写整洁的代码。受Google Guava的鼓励，Optional 现在是Java 8库的一部分。</p>
<p>Optional 只是一个容器，它可以保存一些类型的值或者null。它提供很多有用的方法，所以没有理由不显式地检查null。请参照java 8的<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" target="_blank" rel="external">文档</a>查看详细信息。</p>
<p>让我们看看两个Optional 用法的小例子：一个是允许为空的值，另外一个是不允许为空的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Optional&lt; String &gt; fullName = Optional.ofNullable( null );</div><div class="line">System.out.println( &quot;Full Name is set? &quot; + fullName.isPresent() );        </div><div class="line">System.out.println( &quot;Full Name: &quot; + fullName.orElseGet( () -&gt; &quot;[none]&quot; ) ); </div><div class="line">System.out.println( fullName.map( s -&gt; &quot;Hey &quot; + s + &quot;!&quot; ).orElse( &quot;Hey Stranger!&quot; ) );</div></pre></td></tr></table></figure></p>
<p>如果Optional实例有非空的值，方法 isPresent() 返回true否则返回false。方法orElseGet提供了回退机制，当Optional的值为空时接受一个方法返回默认值。map()方法转化Optional当前的值并且返回一个新的Optional实例。orElse方法和orElseGet类似，但是它不接受一个方法，而是接受一个默认值。上面代码运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Full Name is set? false</div><div class="line">Full Name: [none]</div><div class="line">Hey Stranger!</div></pre></td></tr></table></figure></p>
<p>例如，People 类中有一个方法 getMaleList 需要获取男性的列表，这里需要定义一个函数式接口 PersonInterface：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">interface PersonInterface &#123;</div><div class="line">    public boolean test(Person person);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class People &#123;</div><div class="line">    private List&lt;Person&gt; persons= new ArrayList&lt;Person&gt;();</div><div class="line">    public List&lt;Person&gt; getMaleList(PersonInterface filter) &#123;</div><div class="line">        List&lt;Person&gt; res = new ArrayList&lt;Person&gt;();</div><div class="line">        persons.forEach(</div><div class="line">            (Person person) -&gt; </div><div class="line">                &#123;</div><div class="line">                    if (filter.test(person)) &#123;//调用 PersonInterface 的方法</div><div class="line">                        res.add(person);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">        );</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了去除 PersonInterface 这个函数式接口，可以用通用函数式接口 Predicate 替代如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class People&#123;</div><div class="line">    private List&lt;Person&gt; persons= new ArrayList&lt;Person&gt;();</div><div class="line">    public List&lt;Person&gt; getMaleList(Predicate&lt;Person&gt; predicate) &#123;</div><div class="line">        List&lt;Person&gt; res = new ArrayList&lt;Person&gt;();</div><div class="line">        persons.forEach(</div><div class="line">            person -&gt; &#123;</div><div class="line">                if (predicate.test(person)) &#123;//调用 Predicate 的抽象方法 test</div><div class="line">                    res.add(person);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( e -&gt; System.out.println( e ) );</div></pre></td></tr></table></figure></p>
<p>请注意到编译器会根据上下文来推测参数的类型，或者你也可以显示地指定参数类型，只需要将类型包在括号里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( ( String e ) -&gt; System.out.println( e ) );</div></pre></td></tr></table></figure></p>
<p>如果Lambda的功能语句块太复杂，我们可以用大括号包起来，跟普通的Java方法一样，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String separator = &quot;,&quot;;</div><div class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach(</div><div class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</div></pre></td></tr></table></figure></p>
<p>Lambda表达式可能会引用类的成员或者局部变量（会被隐式地转变成final类型），下面两种写法的效果是一样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">String separator = &quot;,&quot;;</div><div class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach(</div><div class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</div><div class="line">    </div><div class="line">final String separator = &quot;,&quot;;</div><div class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach(</div><div class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</div></pre></td></tr></table></figure></p>
<p>Lambda表达式可能会有返回值，编译器会根据上下文推断返回值的类型。如果lambda的语句块只有一行，不需要return关键字。下面两个写法是等价的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).sort( ( e1, e2 ) -&gt; e1.compareTo( e2 ) );</div><div class="line"></div><div class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).sort( ( e1, e2 ) -&gt; &#123;</div><div class="line">    int result = e1.compareTo( e2 );</div><div class="line">    return result;</div><div class="line">&#125; );</div></pre></td></tr></table></figure></p>
<h2 id="接口的增强"><a href="#接口的增强" class="headerlink" title="接口的增强"></a>接口的增强</h2><p>Java 8 对接口做了进一步的增强。在接口中可以添加使用 <code>default</code> 关键字修饰的非抽象方法。还可以在接口中定义静态方法。如今，接口看上去与抽象类的功能越来越类似了。</p>
<h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>Java 8 还允许我们给接口添加一个非抽象的方法实现，只需要使用 default 关键字即可，这个特征又叫做<strong>扩展方法</strong>。在实现该接口时，该默认扩展方法在子类上可以直接使用，它的使用方式类似于抽象类中非抽象成员方法。但扩展方法不能够重载 Object 中的方法。例如：toString、equals、 hashCode 不能在接口中被重载。</p>
<p><strong>一个接口可以包含多个默认方法和静态方法</strong>。</p>
<p>例如，下面接口中定义了一个默认方法 count()，该方法可以在子类中直接使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public interface DefaultFunInterface &#123;</div><div class="line">    //定义默认方法 count</div><div class="line">    default int count()&#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class SubDefaultFunClass implements DefaultFunInterface &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        //实例化一个子类对象，改子类对象可以直接调用父接口中的默认方法 count</div><div class="line">        SubDefaultFunClass sub = new SubDefaultFunClass();</div><div class="line">        sub.count();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>默认方法和抽象方法的区别是抽象方法必须要被实现，默认方法不是。作为替代方式，接口可以提供一个默认的方法实现，所有这个接口的实现类都会通过继承得倒这个方法（如果有需要也可以重写这个方法），让我们来看看下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private interface Defaulable &#123;</div><div class="line">    // Interfaces now allow default methods, the implementer may or</div><div class="line">    // may not implement (override) them.</div><div class="line">    default String notRequired() &#123;</div><div class="line">        return &quot;Default implementation&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">private static class DefaultableImpl implements Defaulable &#123;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">private static class OverridableImpl implements Defaulable &#123;</div><div class="line">    @Override</div><div class="line">    public String notRequired() &#123;</div><div class="line">        return &quot;Overridden implementation&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接口Defaulable使用default关键字声明了一个默认方法notRequired()，类DefaultableImpl实现了Defaulable接口，没有对默认方法做任何修改。另外一个类OverridableImpl重写类默认实现，提供了自己的实现方法。</p>
<p>JVM平台的接口的默认方法实现是很高效的，并且方法调用的字节码指令支持默认方法。默认方法使已经存在的接口可以修改而不会影响编译的过程。java.util.Collection中添加的额外方法就是最好的例子：stream(), parallelStream(), forEach(), removeIf()</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>在接口中，还允许定义静态的方法。接口中的静态方法可以直接用接口来调用。</p>
<p>例如，下面接口中定义了一个静态方法 find，该方法可以直接用 StaticFunInterface .find() 来调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public interface StaticFunInterface &#123;</div><div class="line">    public static int find()&#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class TestStaticFun &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        //接口中定义了静态方法 find 直接被调用</div><div class="line">        StaticFunInterface.fine();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="集合之流式操作"><a href="#集合之流式操作" class="headerlink" title="集合之流式操作"></a>集合之流式操作</h2><p>Java 8 引入了流式操作（Stream），通过该操作可以实现对集合（Collection）的并行处理和函数式操作。根据操作返回的结果不同，流式操作分为中间操作和最终操作两种。最终操作返回一特定类型的结果，而中间操作返回流本身，这样就可以将多个操作依次串联起来。根据流的并发性，流又可以分为串行和并行两种。<strong>流式操作实现了集合的过滤、排序、映射等功能</strong>。</p>
<p><strong>Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算</strong>。</p>
<h3 id="串行和并行的流"><a href="#串行和并行的流" class="headerlink" title="串行和并行的流"></a>串行和并行的流</h3><p>流有串行和并行两种，串行流上的操作是在一个线程中依次完成，而并行流则是在多个线程上同时执行。并行与串行的流可以相互切换：通过 stream.sequential() 返回串行的流，通过 stream.parallel() 返回并行的流。相比较串行的流，并行的流可以很大程度上提高程序的执行效率。</p>
<p>下面是分别用串行和并行的方式对集合进行排序。</p>
<h6 id="串行排序："><a href="#串行排序：" class="headerlink" title="串行排序："></a>串行排序：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line">for(int i=0;i&lt;1000000;i++)&#123;</div><div class="line">    double d = Math.random()*1000;</div><div class="line">    list.add(d+&quot;&quot;);</div><div class="line">&#125;</div><div class="line">long start = System.nanoTime();//获取系统开始排序的时间点</div><div class="line">int count= (int) ((Stream) list.stream().sequential()).sorted().count();</div><div class="line">long end = System.nanoTime();//获取系统结束排序的时间点</div><div class="line">long ms = TimeUnit.NANOSECONDS.toMillis(end-start);//得到串行排序所用的时间</div><div class="line">System.out.println(ms+”ms”);</div></pre></td></tr></table></figure>
<h6 id="并行排序："><a href="#并行排序：" class="headerlink" title="并行排序："></a>并行排序：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line">for(int i=0;i&lt;1000000;i++)&#123;</div><div class="line">    double d = Math.random()*1000;</div><div class="line">    list.add(d+&quot;&quot;);</div><div class="line">&#125;</div><div class="line">long start = System.nanoTime();//获取系统开始排序的时间点</div><div class="line">int count = (int)((Stream) list.stream().parallel()).sorted().count();</div><div class="line">long end = System.nanoTime();//获取系统结束排序的时间点</div><div class="line">long ms = TimeUnit.NANOSECONDS.toMillis(end-start);//得到并行排序所用的时间</div><div class="line">System.out.println(ms+”ms”);</div><div class="line">//串行输出为 1200ms，并行输出为 800ms。可见，并行排序的时间相比较串行排序时间要少不少。</div></pre></td></tr></table></figure>
<h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><p>该操作会保持 stream 处于中间状态，允许做进一步的操作。它返回的还是的 Stream，允许更多的链式操作。常见的中间操作有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();</div><div class="line">stringCollection.add(&quot;ddd2&quot;);</div><div class="line">stringCollection.add(&quot;aaa2&quot;);</div><div class="line">stringCollection.add(&quot;bbb1&quot;);</div><div class="line">stringCollection.add(&quot;aaa1&quot;);</div><div class="line">stringCollection.add(&quot;bbb3&quot;);</div><div class="line">stringCollection.add(&quot;ccc&quot;);</div><div class="line">stringCollection.add(&quot;bbb2&quot;);</div><div class="line">stringCollection.add(&quot;ddd1&quot;);</div></pre></td></tr></table></figure></p>
<ul>
<li><p><code>filter()</code>：对元素进行过滤；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">stringCollection</div><div class="line">    .stream()</div><div class="line">    .filter((s) -&gt; s.startsWith(&quot;a&quot;))</div><div class="line">    .forEach(System.out::println);</div><div class="line"></div><div class="line">// &quot;aaa2&quot;, &quot;aaa1&quot;</div></pre></td></tr></table></figure>
</li>
<li><p><code>sorted()</code>：对元素排序,排序只创建流的排序视图，原来集合顺序不变；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">stringCollection</div><div class="line">    .stream()</div><div class="line">    .sorted()</div><div class="line">    .filter((s) -&gt; s.startsWith(&quot;a&quot;))</div><div class="line">    .forEach(System.out::println);</div><div class="line"></div><div class="line">// &quot;aaa1&quot;, &quot;aaa2&quot;</div><div class="line"></div><div class="line">System.out.println(stringCollection);</div><div class="line">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</div></pre></td></tr></table></figure>
</li>
<li><p><code>map()</code>：元素的映射,中间操作映射通过给定的函数将每个元素转换成另一个对象。下面的示例将每个字符串转换为一个大写字符串。但是您也可以使用map将每个对象转换成另一个类型。生成的流的泛型类型取决于您传递给映射的函数的泛型类型。原来的集合不受影响；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">stringCollection</div><div class="line">    .stream()</div><div class="line">    .map(String::toUpperCase)</div><div class="line">    .sorted((a, b) -&gt; b.compareTo(a))</div><div class="line">    .forEach(System.out::println);</div><div class="line"></div><div class="line">// &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;AAA2&quot;, &quot;AAA1&quot;</div></pre></td></tr></table></figure>
</li>
<li><p><code>distinct()</code>：去除重复元素；</p>
</li>
<li><code>subStream()</code>：获取子 Stream 等。</li>
</ul>
<p>例如，下面是对一个字符串集合进行过滤，返回以“s”开头的字符串集合，并将该集合依次打印出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">list.stream()</div><div class="line">    .filter((s) -&gt; s.startsWith(&quot;s&quot;))</div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<p>这里的 filter(…) 就是一个中间操作，该中间操作可以链式地应用其他 Stream 操作。</p>
<h3 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h3><p>该操作必须是流的最后一个操作，一旦被调用，Stream 就到了一个终止状态，而且不能再使用了。常见的终止操作有：</p>
<ul>
<li><code>forEach()</code>：对每个元素做处理；</li>
<li><code>toArray()</code>：把元素导出到数组；</li>
<li><code>findFirst()</code>：返回第一个匹配的元素；</li>
<li><p><code>Match</code>：可以使用各种匹配操作检查某个谓词是否与流匹配。所有这些操作都是终端，并返回一个布尔结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">boolean anyStartsWithA =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .anyMatch((s) -&gt; s.startsWith(&quot;a&quot;));</div><div class="line"></div><div class="line">System.out.println(anyStartsWithA);      // true</div><div class="line"></div><div class="line">boolean allStartsWithA =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .allMatch((s) -&gt; s.startsWith(&quot;a&quot;));</div><div class="line"></div><div class="line">System.out.println(allStartsWithA);      // false</div><div class="line"></div><div class="line">boolean noneStartsWithZ =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .noneMatch((s) -&gt; s.startsWith(&quot;z&quot;));</div><div class="line"></div><div class="line">System.out.println(noneStartsWithZ);      // true</div></pre></td></tr></table></figure>
</li>
<li><p><code>Count</code>：返回流中元素的数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">long startsWithB =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .filter((s) -&gt; s.startsWith(&quot;b&quot;))</div><div class="line">        .count();</div><div class="line"></div><div class="line">System.out.println(startsWithB);    // 3</div></pre></td></tr></table></figure>
</li>
<li><p><code>Reduce</code>：通过给定的函数对流的元素进行还原。结果是存于Optional中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Optional&lt;String&gt; reduced =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .sorted()</div><div class="line">        .reduce((s1, s2) -&gt; s1 + &quot;#&quot; + s2);</div><div class="line"></div><div class="line">reduced.ifPresent(System.out::println);</div><div class="line">// &quot;aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>例如，下面是对一个字符串集合进行过滤，返回以“s”开头的字符串集合，并将该集合依次打印出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">list.stream() //获取列表的 stream 操作对象</div><div class="line">    .filter((s) -&gt; s.startsWith(&quot;s&quot;))//对这个流做过滤操作</div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<p>这里的 forEach(…) 就是一个终止操作，该操作之后不能再链式的添加其他操作了。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>现在Map支持用于执行常见任务的各种新的和有用的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</div><div class="line"></div><div class="line">for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">    map.putIfAbsent(i, &quot;val&quot; + i);</div><div class="line">&#125;</div><div class="line"></div><div class="line">map.forEach((id, val) -&gt; System.out.println(val));</div></pre></td></tr></table></figure></p>
<p>map的计算:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">map.computeIfPresent(3, (num, val) -&gt; val + num);</div><div class="line">map.get(3);             // val33</div><div class="line"></div><div class="line">map.computeIfPresent(9, (num, val) -&gt; null);</div><div class="line">map.containsKey(9);     // false</div><div class="line"></div><div class="line">map.computeIfAbsent(23, num -&gt; &quot;val&quot; + num);</div><div class="line">map.containsKey(23);    // true</div><div class="line"></div><div class="line">map.computeIfAbsent(3, num -&gt; &quot;bam&quot;);</div><div class="line">map.get(3);             // val33</div></pre></td></tr></table></figure></p>
<p>通过给定的key来删除元素，只有value值匹配才会删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">map.remove(3, &quot;val3&quot;);</div><div class="line">map.get(3);             // val33</div><div class="line"></div><div class="line">map.remove(3, &quot;val33&quot;);</div><div class="line">map.get(3);             // null</div></pre></td></tr></table></figure></p>
<p>其他有用的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">map.getOrDefault(42, &quot;not found&quot;);  // not found</div></pre></td></tr></table></figure></p>
<p>合并：如果不存在则插入，存在则合并<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">map.merge(9, &quot;val9&quot;, (value, newValue) -&gt; value.concat(newValue));</div><div class="line">map.get(9);             // val9</div><div class="line"></div><div class="line">map.merge(9, &quot;concat&quot;, (value, newValue) -&gt; value.concat(newValue));</div><div class="line">map.get(9);             // val9concat</div></pre></td></tr></table></figure></p>
<h2 id="注解的更新"><a href="#注解的更新" class="headerlink" title="注解的更新"></a>注解的更新</h2><p>对于注解，Java 8 主要有两点改进：<strong>类型注解</strong>和<strong>重复注解</strong>。</p>
<p>Java 8 的类型注解扩展了注解使用的范围。在该版本之前，注解只能是在声明的地方使用。现在几乎可以为任何东西添加注解：局部变量、类与接口，就连方法的异常也能添加注解。</p>
<p>新增的两个注释的程序元素类型： <code>ElementType.TYPE_USE</code> 和 <code>ElementType.TYPE_PARAMETER</code> 用来描述注解的新场合。ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中。而 ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中（例如声明语句、泛型和强制转换语句中的类型）。</p>
<p>对类型注解的支持，增强了通过静态分析工具发现错误的能力。原先只能在运行时发现的问题可以提前在编译的时候被排查出来。Java 8 本身虽然没有自带类型检测的框架，但可以通过使用 Checker Framework 这样的第三方工具，自动检查和确认软件的缺陷，提高生产效率。</p>
<p>例如，下面的代码可以通过编译，但是运行时会报 NullPointerException 的异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class TestAnno &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Object obj = null;</div><div class="line">        obj.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了能在编译期间就自动检查出这类异常，可以通过类型注解结合 Checker Framework 提前排查出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import org.checkerframework.checker.nullness.qual.NonNull;</div><div class="line">public class TestAnno &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        @NonNull Object obj = null;</div><div class="line">        obj.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译时自动检测结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">C:\workspace\TestJava8\src\TestAnno.java:4: Warning:</div><div class="line">  (assignment.type.incompatible) $$ 2 $$ null $$ @UnknownInitialization @NonNull Object $$ ( 152, 156 )</div><div class="line">  $$ incompatible types in assignment.</div><div class="line">@NonNull Object obj = null;</div><div class="line"> ^</div><div class="line"> found : null</div><div class="line"> required: @UnknownInitialization @NonNull Object</div></pre></td></tr></table></figure></p>
<p>另外，在该版本之前使用注解的一个限制是相同的注解在同一位置只能声明一次，不能声明多次。Java 8 引入了重复注解机制，这样相同的注解可以在同一地方声明多次。重复注解机制本身必须用 <code>@Repeatable</code> 注解。</p>
<p>例如，下面就是用 @Repeatable 重复注解的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@Retention(RetentionPolicy.RUNTIME) \\该注解存在于类文件中并在运行时可以通过反射获取</div><div class="line">@interface Annots &#123;</div><div class="line">    Annot[] value();</div><div class="line">&#125; </div><div class="line"></div><div class="line">@Retention(RetentionPolicy.RUNTIME) \\该注解存在于类文件中并在运行时可以通过反射获取</div><div class="line">@Repeatable(Annots.class)</div><div class="line">@interface Annot &#123;</div><div class="line">    String value();</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Annot(&quot;a1&quot;)</div><div class="line">@Annot(&quot;a2&quot;)</div><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Annots annots1 = Test.class.getAnnotation(Annots.class);</div><div class="line">        System.out.println(annots1.value()[0]+&quot;,&quot;+annots1.value()[1]); </div><div class="line">        // 输出: @Annot(value=a1),@Annot(value=a2)</div><div class="line">        Annot[] annots2 = Test.class.getAnnotationsByType(Annot.class);</div><div class="line">        System.out.println(annots2[0]+&quot;,&quot;+annots2[1]); </div><div class="line">        // 输出: @Annot(value=a1),@Annot(value=a2)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注释 Annot 被 @Repeatable( Annots.class ) 注解。Annots 只是一个容器，它包含 Annot 数组, 编译器尽力向程序员隐藏它的存在。通过这样的方式，Test 类可以被 Annot 注解两次。重复注释的类型可以通过 getAnnotationsByType() 方法来返回。</p>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>现今，互联网环境中存在各种各种潜在的威胁，对于 Java 平台来说，安全显得特别重要。为了保证新版本具有更高的安全性，Java 8 在安全性上对许多方面进行了增强，也为此推迟了它的发布日期。下面例举其中几个关于安全性的更新：</p>
<p>支持更强的基于密码的加密算法。基于 AES 的加密算法，例如 PBEWithSHA256AndAES_128 和 PBEWithSHA512AndAES_256，已经被加入进来。</p>
<p>在客户端，TLS1.1 和 TLS1.2 被设为默认启动。并且可以通过新的系统属性包 jdk.tls.client.protocols 来对它进行配置。</p>
<p>Keystore 的增强，包含新的 Keystore 类型 java.security.DomainLoadStoreParameter 和为 Keytool 这个安全钥匙和证书的管理工具添加新的命令行选项-importpassword。同时，添加和更新了一些关于安全性的 API 来支持 KeyStore 的更新。</p>
<p>支持安全的随机数发生器。如果随机数来源于随机性不高的种子，那么那些用随机数来产生密钥或者散列敏感信息的系统就更易受攻击。SecureRandom 这个类的 getInstanceStrong 方法如今可以获取各个平台最强的随机数对象实例，通过这个实例生成像 RSA 私钥和公钥这样具有较高熵的随机数。</p>
<p>JSSE（Java(TM) Secure Socket Extension）服务器端开始支持 SSL/TLS 服务器名字识别 SNI（Server Name Indication）扩展。SNI 扩展目的是 SSL/TLS 协议可以通过 SNI 扩展来识别客户端试图通过握手协议连接的服务器名字。在 Java 7 中只在客户端默认启动 SNI 扩展。如今，在 JSSE 服务器端也开始支持 SNI 扩展了。</p>
<p>安全性比较差的加密方法被默认禁用。默认不支持 DES 相关的 Kerberos 5 加密方法。如果一定要使用这类弱加密方法需要在 krb5.conf 文件中添加 allow_weak_crypto=true。考虑到这类加密方法安全性极差，开发者应该尽量避免使用它。</p>
<h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><p>对Base64的支持最终成了Java 8标准库的一部分，非常简单易用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package com.javacodegeeks.java8.base64;</div><div class="line"> </div><div class="line">import java.nio.charset.StandardCharsets;</div><div class="line">import java.util.Base64;</div><div class="line"> </div><div class="line">public class Base64s &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        final String text = &quot;Base64 finally in Java 8!&quot;;</div><div class="line">         </div><div class="line">        final String encoded = Base64</div><div class="line">        .getEncoder()</div><div class="line">        .encodeToString( text.getBytes( StandardCharsets.UTF_8 ) );</div><div class="line">        System.out.println( encoded );</div><div class="line">         </div><div class="line">        final String decoded = new String(</div><div class="line">        Base64.getDecoder().decode( encoded ),</div><div class="line">        StandardCharsets.UTF_8 );</div><div class="line">        System.out.println( decoded );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>控制台输出的编码和解码的字符串:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">QmFzZTY0IGZpbmFsbHkgaW4gSmF2YSA4IQ==</div><div class="line">Base64 finally in Java 8!</div></pre></td></tr></table></figure></p>
<p>新的Base64API也支持URL和MINE的编码解码。</p>
<p><strong>(Base64.getUrlEncoder() / Base64.getUrlDecoder(), Base64.getMimeEncoder() / Base64.getMimeDecoder())</strong></p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>在新增Stream机制与lambda的基础之上，在java.util.concurrent.ConcurrentHashMap中加入了一些新方法来支持聚集操作。同时也在java.util.concurrent.ForkJoinPool类中加入了一些新方法来支持共有资源池（common pool）。</p>
<p>新增的java.util.concurrent.locks.StampedLock类提供一直基于容量的锁，这种锁有三个模型来控制读写操作（它被认为是不太有名的java.util.concurrent.locks.ReadWriteLock类的替代者）。</p>
<p>在java.util.concurrent.atomic包中还增加了下面这些类：</p>
<ul>
<li>DoubleAccumulator</li>
<li>DoubleAdder</li>
<li>LongAccumulator</li>
<li>LongAdder</li>
</ul>
<h2 id="IO-NIO-的改进"><a href="#IO-NIO-的改进" class="headerlink" title="IO/NIO 的改进"></a>IO/NIO 的改进</h2><p>Java 8 对 IO/NIO 也做了一些改进。主要包括：改进了 java.nio.charset.Charset 的实现，使编码和解码的效率得以提升，也精简了 jre/lib/charsets.jar 包；优化了 String(byte[],*) 构造方法和 String.getBytes() 方法的性能；还增加了一些新的 IO/NIO 方法，使用这些方法可以从文件或者输入流中获取流（java.util.stream.Stream），通过对流的操作，可以简化文本行处理、目录遍历和文件查找。</p>
<p>新增的 API 如下：</p>
<ul>
<li>BufferedReader.line(): 返回文本行的流 Stream<string></string></li>
<li>File.lines(Path, Charset):返回文本行的流 Stream<string></string></li>
<li>File.list(Path): 遍历当前目录下的文件和目录</li>
<li>File.walk(Path, int, FileVisitOption): 遍历某一个目录下的所有文件和指定深度的子目录</li>
<li>File.find(Path, int, BiPredicate, FileVisitOption… ): 查找相应的文件</li>
</ul>
<p>下面就是用流式操作列出当前目录下的所有文件和目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Files.list(new File(&quot;.&quot;).toPath())</div><div class="line">     .forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<h2 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h2><p>Java 8 版本还完善了全球化功能：支持新的 Unicode 6.2.0 标准，新增了日历和本地化的 API，改进了日期时间的管理等。</p>
<p>Java 的日期与时间 API 问题由来已久，Java 8 之前的版本中关于时间、日期及其他时间日期格式化类由于线程安全、重量级、序列化成本高等问题而饱受批评。Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。</p>
<p>新的 java.time 中包含了所有关于<code>时钟（Clock）</code>，<code>本地日期（LocalDate）</code>、<code>本地时间（LocalTime）</code>、<code>本地日期时间（LocalDateTime）</code>、<code>时区（ZonedDateTime）</code>和<code>持续时间（Duration）</code>的类。历史悠久的 Date 类新增了 toInstant() 方法，用于把 Date 转换成新的表示形式。这些新增的本地化时间日期 API 大大简化了了日期时间和本地化的管理。</p>
<h3 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h3><p>时钟提供对当前日期和时间的访问。时钟知道一个时区，可以代替System.currentTimeMillis()来检索当前的毫秒。时间线上的瞬时点也由类Instants表示。Instants可以用来创建遗留java.util.Date对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Clock clock = Clock.systemDefaultZone();</div><div class="line">long millis = clock.millis();</div><div class="line"></div><div class="line">Instant instant = clock.instant();</div><div class="line">Date legacyDate = Date.from(instant);</div></pre></td></tr></table></figure></p>
<h3 id="Timezones"><a href="#Timezones" class="headerlink" title="Timezones"></a>Timezones</h3><p>时区由ZoneId表示。可以通过静态工厂方法轻松地访问它们。时区定义了在instant和本地日期和时间之间转换重要的偏移量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">System.out.println(ZoneId.getAvailableZoneIds());</div><div class="line">// prints all available timezone ids</div><div class="line"></div><div class="line">ZoneId zone1 = ZoneId.of(&quot;Europe/Berlin&quot;);</div><div class="line">ZoneId zone2 = ZoneId.of(&quot;Brazil/East&quot;);</div><div class="line">System.out.println(zone1.getRules());</div><div class="line">System.out.println(zone2.getRules());</div><div class="line"></div><div class="line">// ZoneRules[currentStandardOffset=+01:00]</div><div class="line">// ZoneRules[currentStandardOffset=-03:00]</div></pre></td></tr></table></figure></p>
<h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><p>LocalTime表示没有时区的时间，例如:10pm或17:30:15。下面的示例为上面定义的时区创建了两个本地时间。然后我们比较两种情况，并计算两种时间之间的小时数和分钟数的差值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LocalTime now1 = LocalTime.now(zone1);</div><div class="line">LocalTime now2 = LocalTime.now(zone2);</div><div class="line"></div><div class="line">System.out.println(now1.isBefore(now2));  // false</div><div class="line"></div><div class="line">long hoursBetween = ChronoUnit.HOURS.between(now1, now2);</div><div class="line">long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</div><div class="line"></div><div class="line">System.out.println(hoursBetween);       // -3</div><div class="line">System.out.println(minutesBetween);     // -239</div></pre></td></tr></table></figure></p>
<p>LocalTime提供了各种工厂方法来简化新实例的创建，包括对时间字符串的解析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LocalTime late = LocalTime.of(23, 59, 59);</div><div class="line">System.out.println(late);       // 23:59:59</div><div class="line"></div><div class="line">DateTimeFormatter germanFormatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofLocalizedTime(FormatStyle.SHORT)</div><div class="line">        .withLocale(Locale.GERMAN);</div><div class="line"></div><div class="line">LocalTime leetTime = LocalTime.parse(&quot;13:37&quot;, germanFormatter);</div><div class="line">System.out.println(leetTime);   // 13:37</div></pre></td></tr></table></figure></p>
<h3 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h3><p>LocalDate表示一个不同的日期，如2014-03-11。它是不可变的，和LocalTime完全一样。该示例演示了如何通过添加或减少日、月或年来计算新的日期。请记住，每个操作都返回一个新实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">LocalDate today = LocalDate.now();</div><div class="line">LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);</div><div class="line">LocalDate yesterday = tomorrow.minusDays(2);</div><div class="line"></div><div class="line">LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);</div><div class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</div><div class="line">System.out.println(dayOfWeek);    // FRIDAY</div></pre></td></tr></table></figure></p>
<p>从字符串解析LocalDate就像解析LocalTime一样简单:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">DateTimeFormatter germanFormatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofLocalizedDate(FormatStyle.MEDIUM)</div><div class="line">        .withLocale(Locale.GERMAN);</div><div class="line"></div><div class="line">LocalDate xmas = LocalDate.parse(&quot;24.12.2014&quot;, germanFormatter);</div><div class="line">System.out.println(xmas);   // 2014-12-24</div></pre></td></tr></table></figure></p>
<h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p>LocalDateTime代表日期时间。它将上面几节中所看到的日期和时间合并为一个实例。LocalDateTime是不可变的，与LocalTime和LocalDate类似。我们可以利用方法来从数据时间检索某些字段:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);</div><div class="line"></div><div class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</div><div class="line">System.out.println(dayOfWeek);      // WEDNESDAY</div><div class="line"></div><div class="line">Month month = sylvester.getMonth();</div><div class="line">System.out.println(month);          // DECEMBER</div><div class="line"></div><div class="line">long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</div><div class="line">System.out.println(minuteOfDay);    // 1439</div></pre></td></tr></table></figure></p>
<p>有了一个时区的额外信息，它可以转换为实例。可以很容易地将Instants转换为java.util.Date类型的遗留日期。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Instant instant = sylvester</div><div class="line">        .atZone(ZoneId.systemDefault())</div><div class="line">        .toInstant();</div><div class="line"></div><div class="line">Date legacyDate = Date.from(instant);</div><div class="line">System.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014</div></pre></td></tr></table></figure></p>
<p>格式化日期时间就像格式化日期或时间一样。我们可以创建自定义模式的格式化程序，而不是使用预定义的格式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">DateTimeFormatter formatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofPattern(&quot;MMM dd, yyyy - HH:mm&quot;);</div><div class="line"></div><div class="line">LocalDateTime parsed = LocalDateTime.parse(&quot;Nov 03, 2014 - 07:13&quot;, formatter);</div><div class="line">String string = formatter.format(parsed);</div><div class="line">System.out.println(string);     // Nov 03, 2014 - 07:13</div></pre></td></tr></table></figure></p>
<p>不像java.text.NumberFormat新的DateTimeFormatter是不可变的和线程安全的。</p>
<p>例如，下面是对 Clock, LocalDate，LocalTime, LocalDateTime 的简单应用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">//Clock 时钟</div><div class="line">Clock clock = Clock.systemDefaultZone();//获取系统默认时区 (当前瞬时时间 )</div><div class="line">System.out.println( clock.instant() );//2014-04-12T15:19:29.282Z</div><div class="line">System.out.println( clock.millis() );//1397315969360</div><div class="line"></div><div class="line">// LocalDate: Get the local date and local time</div><div class="line">final LocalDate date = LocalDate.now();</div><div class="line">final LocalDate dateFromClock = LocalDate.now( clock );</div><div class="line">System.out.println( date );//2014-04-12</div><div class="line">System.out.println( dateFromClock );//2014-04-12</div><div class="line"> </div><div class="line">// LocalTime: Get the local date and local time</div><div class="line">final LocalTime time = LocalTime.now();</div><div class="line">final LocalTime timeFromClock = LocalTime.now( clock );</div><div class="line">System.out.println( time );//</div><div class="line">System.out.println( timeFromClock );//11:25:54.568</div><div class="line"></div><div class="line">// LocalDateTime: Get the local date/time</div><div class="line">final LocalDateTime datetime = LocalDateTime.now();</div><div class="line">final LocalDateTime datetimeFromClock = LocalDateTime.now( clock );</div><div class="line">System.out.println( datetime );//2014-04-12T11:37:52.309</div><div class="line">System.out.println( datetimeFromClock );//2014-04-12T15:37:52.309</div><div class="line"></div><div class="line">// 日期格式化：DateTimeFormatter是不可变的，是线程安全的</div><div class="line">DateTimeFormatter formatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofPattern(&quot;MMM dd, yyyy - HH:mm&quot;);</div><div class="line"></div><div class="line">LocalDateTime parsed = LocalDateTime.parse(&quot;Nov 03, 2014 - 07:13&quot;, formatter);</div><div class="line">String string = formatter.format(parsed);</div><div class="line">System.out.println(string);     // Nov 03, 2014 - 07:13</div></pre></td></tr></table></figure></p>
<p>如果您需要一个类持有日期时间和时区信息，可以使用ZonedDateTime，它保存有ISO-8601日期系统的日期和时间，而且有时区信息。让我们看一些例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// Get the zoned date/time</div><div class="line">final ZonedDateTime zonedDatetime = ZonedDateTime.now();</div><div class="line">final ZonedDateTime zonedDatetimeFromClock = ZonedDateTime.now( clock );</div><div class="line">final ZonedDateTime zonedDatetimeFromZone = ZonedDateTime.now( ZoneId.of( &quot;America/Los_Angeles&quot; ) );</div><div class="line"> </div><div class="line">System.out.println( zonedDatetime );</div><div class="line">System.out.println( zonedDatetimeFromClock );</div><div class="line">System.out.println( zonedDatetimeFromZone );</div></pre></td></tr></table></figure></p>
<p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2014-04-12T11:47:01.017-04:00[America/New_York]</div><div class="line">2014-04-12T15:47:01.017Z</div><div class="line">2014-04-12T08:47:01.017-07:00[America/Los_Angeles]</div></pre></td></tr></table></figure></p>
<p>最后让我们看看Duration类，Duration持有的时间精确到纳秒。它让我们很容易计算两个日期中间的差异。让我们来看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// Get duration between two dates</div><div class="line">final LocalDateTime from = LocalDateTime.of( 2014, Month.APRIL, 16, 0, 0, 0 );</div><div class="line">final LocalDateTime to = LocalDateTime.of( 2015, Month.APRIL, 16, 23, 59, 59 );</div><div class="line"> </div><div class="line">final Duration duration = Duration.between( from, to );</div><div class="line">System.out.println( &quot;Duration in days: &quot; + duration.toDays() );</div><div class="line">System.out.println( &quot;Duration in hours: &quot; + duration.toHours() );</div></pre></td></tr></table></figure></p>
<p>上面的例子计算了两个日期（2014年4月16日和2014年5月16日）之间的持续时间（基于天数和小时）输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Duration in days: 365</div><div class="line">Duration in hours: 8783</div></pre></td></tr></table></figure></p>
<h2 id="Nashorn-javascript引擎"><a href="#Nashorn-javascript引擎" class="headerlink" title="Nashorn javascript引擎"></a>Nashorn javascript引擎</h2><p>Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。Nashorn javascript引擎只是javax.script.ScriptEngine另一个实现，而且规则也一样，允许Java和JavaScript互相操作。这里有个小例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ScriptEngineManager manager = new ScriptEngineManager();</div><div class="line">ScriptEngine engine = manager.getEngineByName( &quot;JavaScript&quot; );</div><div class="line"> </div><div class="line">System.out.println( engine.getClass().getName() );//jdk.nashorn.api.scripting.NashornScriptEngine</div><div class="line">System.out.println( &quot;Result:&quot; + engine.eval( &quot;function f() &#123; return 1; &#125;; f() + 1;&quot; ) );//Result: 2</div></pre></td></tr></table></figure></p>
<h2 id="并行数组"><a href="#并行数组" class="headerlink" title="并行数组"></a>并行数组</h2><p>Java 8新增加了很多方法支持并行的数组处理。最重要的大概是parallelSort()这个方法显著地使排序在多核计算机上速度加快。下面的小例子演示了这个新的方法（parallelXXX）的行为。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.javacodegeeks.java8.parallel.arrays;</div><div class="line"> </div><div class="line">import java.util.Arrays;</div><div class="line">import java.util.concurrent.ThreadLocalRandom;</div><div class="line"> </div><div class="line">public class ParallelArrays &#123;</div><div class="line">    public static void main( String[] args ) &#123;</div><div class="line">        long[] arrayOfLong = new long [ 20000 ];        </div><div class="line"> </div><div class="line">        Arrays.parallelSetAll( arrayOfLong,</div><div class="line">            index -&gt; ThreadLocalRandom.current().nextInt( 1000000 ) );</div><div class="line">        Arrays.stream( arrayOfLong ).limit( 10 ).forEach(</div><div class="line">            i -&gt; System.out.print( i + &quot; &quot; ) );</div><div class="line">        System.out.println();</div><div class="line"> </div><div class="line">        Arrays.parallelSort( arrayOfLong );</div><div class="line">        Arrays.stream( arrayOfLong ).limit( 10 ).forEach(</div><div class="line">            i -&gt; System.out.print( i + &quot; &quot; ) );</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这一小段代码使用parallelSetAll() t方法填充这个长度是2000的数组，然后使用parallelSort() 排序。这个程序输出了排序前和排序后的10个数字来验证数组真的已经被排序了。示例可能的输出如下（请注意这些数字是随机产生的）</p>
<p>Unsorted: 591217 891976 443951 424479 766825 351964 242997 642839 119108 552378<br>Sorted: 39 220 263 268 325 607 655 678 723 793</p>
<h2 id="新的工具"><a href="#新的工具" class="headerlink" title="新的工具"></a>新的工具</h2><h3 id="Nashorn引擎：jjs"><a href="#Nashorn引擎：jjs" class="headerlink" title="Nashorn引擎：jjs"></a>Nashorn引擎：jjs</h3><p>jjs是个基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。例如，我们创建一个具有如下内容的func.js文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function f() &#123;</div><div class="line">    return 1;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">print( f() + 1 );</div></pre></td></tr></table></figure></p>
<p>我们可以把这个文件作为参数传递给jjs使得这个文件可以在命令行中执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jjs func.js   //结果输出：2</div></pre></td></tr></table></figure></p>
<h3 id="类依赖分析工具：jdeps"><a href="#类依赖分析工具：jdeps" class="headerlink" title="类依赖分析工具：jdeps"></a>类依赖分析工具：jdeps</h3><p>Jdeps是一个功能强大的命令行工具，它可以帮我们显示出包层级或者类层级java类文件的依赖关系。它接受class文件、目录、jar文件作为输入，默认情况下，jdeps会输出到控制台。</p>
<p>例如分析Notepad.jar：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">$ jdeps demo/jfc/Notepad/Notepad.jar</div><div class="line"> </div><div class="line">demo/jfc/Notepad/Notepad.jar -&gt; /usr/java/jre/lib/rt.jar</div><div class="line">   &lt;unnamed&gt; (Notepad.jar)</div><div class="line">      -&gt; java.awt                                           </div><div class="line">      -&gt; java.awt.event                                     </div><div class="line">      -&gt; java.beans                                         </div><div class="line">      -&gt; java.io                                            </div><div class="line">      -&gt; java.lang                                          </div><div class="line">      -&gt; java.net                                           </div><div class="line">      -&gt; java.util                                          </div><div class="line">      -&gt; java.util.logging                                  </div><div class="line">      -&gt; javax.swing                                        </div><div class="line">      -&gt; javax.swing.border                                 </div><div class="line">      -&gt; javax.swing.event                                  </div><div class="line">      -&gt; javax.swing.text                                   </div><div class="line">      -&gt; javax.swing.tree                                   </div><div class="line">      -&gt; javax.swing.undo</div></pre></td></tr></table></figure></p>
<p>更多的详细信息请参考<a href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/jdeps.html" target="_blank" rel="external">官方文档</a>。</p>
<h2 id="JVM的新特性"><a href="#JVM的新特性" class="headerlink" title="JVM的新特性"></a>JVM的新特性</h2><p>JVM内存永久区已经被metaspace替换（JEP 122）。JVM参数 -XX:PermSize 和 –XX:MaxPermSize被XX:MetaSpaceSize 和 -XX:MaxMetaspaceSize代替。</p>
<h2 id="Java-8-开发环境"><a href="#Java-8-开发环境" class="headerlink" title="Java 8 开发环境"></a>Java 8 开发环境</h2><p>随着 Java 8 正式发布，许多 IDE 也开始提供对 Java 8 的支持。Eclipse 是 Java 开发人员最为常用集成开发环境，在最新的 Eclipse Kepler 4.3.2 版本中已经默认增加了对 Java 8 的支持。要想在 Eclipse Kepler 的前期版本中添加对 Java 8 的支持，可以通过下面步骤来完成：</p>
<ol>
<li><p>选择 “Help &gt; Eclipse Marketplace…”。</p>
</li>
<li><p>在搜索框中输入 “Java 8 Kepler”。</p>
</li>
<li><p>点击安装 Java 8 support for Eclipse Kepler SR2。</p>
</li>
</ol>
<p>图 1. 安装 Java 8 support for Eclipse Kepler SR2<br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-jdk8newfeature/img001.png" alt="image"><br>接下来，就可以开启 Java 8 编程之旅。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>Java 8 正式版是一个有重大改变的版本，该版本对 Java 做了重大改进。本文通过文字描述及代码实例对新版本中主要新特性做了介绍：函数式接口、Lambda 表达式、集合的流式操作、注解、安全性、IO/NIO、全球化功能。除了文中介绍的这些重要的新功能之外，Java 8 还对 java 工具包 JDBC、Java DB、JavaFX 等方面都有许多改进和增强。这些新增功能简化了开发，提升了代码可读性，增强了代码的安全性，提高了代码的执行效率，为开发者带来了全新的 Java 开发体验，从而推动了 Java 这个平台的前进。</p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="http://winterbe.com/posts/2014/03/16/java-8-tutorial/" target="_blank" rel="external">Java 8 Tutorial</a></p>
<p>Part 1: <a href="http://winterbe.com/posts/2015/04/07/java8-concurrency-tutorial-thread-executor-examples/" target="_blank" rel="external">Threads and Executors</a><br>Part 2: <a href="http://winterbe.com/posts/2015/04/30/java8-concurrency-tutorial-synchronized-locks-examples/" target="_blank" rel="external">Synchronization and Locks</a><br>Part 3: <a href="http://winterbe.com/posts/2015/05/22/java8-concurrency-tutorial-atomic-concurrent-map-examples/" target="_blank" rel="external">Atomic Variables and ConcurrentMap</a>  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/基础/java8新特性/" data-id="cjei97edq004689blgt9r9rhk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/分布式/分布式锁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/分布式/分布式锁/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/分布式/">分布式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/分布式/分布式锁/">分布式锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。</p>
<p>分布式的<code>CAP理论</code>告诉我们“任何一个分布式系统都无法同时满足<code>一致性（Consistency）</code>、<code>可用性（Availability）</code>和<code>分区容错性（Partition tolerance）</code>，最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。</p>
<p>在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行。在单机环境中，Java中其实提供了很多并发处理相关的API，但是这些API在分布式场景中就无能为力了。也就是说单纯的Java Api并不能提供分布式锁的能力。所以针对分布式锁的实现目前有多种方案：</p>
<ul>
<li>基于数据库实现分布式锁</li>
<li>基于缓存（redis，memcached）实现分布式锁</li>
<li>基于Zookeeper实现分布式锁</li>
</ul>
<h3 id="分布式情况"><a href="#分布式情况" class="headerlink" title="分布式情况"></a>分布式情况</h3><ul>
<li>分布式与单机情况下最大的不同在于其不是多线程而是多进程。</li>
<li>多线程由于可以共享堆内存，因此可以简单的采取内存作为标记存储位置。而进程之间甚至可能都不在同一台物理机上，因此需要将标记存储在一个所有进程都能看到的地方。</li>
</ul>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><ul>
<li>当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。</li>
<li>与单机模式下的锁不仅需要保证进程可见，还需要考虑进程与锁之间的网络问题。（我觉得分布式情况下之所以问题变得复杂，主要就是需要考虑到网络的延时和不可靠）</li>
<li>分布式锁还是可以将标记存在内存，只是该内存不是某个进程分配的内存而是公共内存如Redis、Memcache。至于利用数据库、文件等做锁与单机的实现是一样的，只要保证标记能互斥就行。</li>
</ul>
<h3 id="单机Redis锁"><a href="#单机Redis锁" class="headerlink" title="单机Redis锁"></a>单机Redis锁</h3><h5 id="基本锁"><a href="#基本锁" class="headerlink" title="基本锁"></a>基本锁</h5><p><strong>原理</strong>：利用Redis的setnx如果不存在某个key则设置值，设置成功则表示取得锁成功。<br><strong>缺点</strong>：如果获取锁后的进程，在还没执行完的时候挂调了，则锁永远不会释放。</p>
<h5 id="改进型"><a href="#改进型" class="headerlink" title="改进型"></a>改进型</h5><p><strong>改进</strong>：在基本型是锁上的setnx后设置expire，保证即使获取锁的进程不主动释放锁，过一段时间后也能自动释放。<br><strong>缺点</strong>：setnx与expire不是一个原子操作，可能执行完setnx该进程就挂了。<br>当锁过期后，该进程还没执行完，可能造成同时多个进程取得锁。（貌似这个问题目前还没有很优雅的解决方案）</p>
<h5 id="再改进"><a href="#再改进" class="headerlink" title="再改进"></a>再改进</h5><p><strong>改进</strong>：利用Lua脚本，将setnx与expire变成一个原子操作，可解决一部分问题。<br><strong>缺点</strong>：还是锁过期的问题。</p>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ol>
<li>直接调用Lua脚本原子setnx同时expire，设置一个随机值。</li>
<li>获取到锁则执行同步代码块，没获取则根据业务场景可以选择自旋、休眠、或做一个等待队列等拥有锁进程来唤醒（类似Synchronize的同步队列）。</li>
<li>当同步代码块执行完成，先判断锁的key是否是自己设置的，如果是则删除key（可利用Lua做成原子操作），不是则表明自己的锁已经过期，不需要删除。（这时候就出现了多进程同时有锁的问题了）</li>
</ol>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>一般情况下直接用setnx加expire就够了，但从安全性的角度看还是存在一下几个问题：</p>
<ol>
<li>单点问题。单机Redis只在单机上，如果单机down了，那么所有需要用分布式锁的地方均获取不到锁，全部阻塞。需要做好降级的处理。</li>
<li>可能出现多进程同时拥有锁。</li>
</ol>
<h3 id="集群Rides锁"><a href="#集群Rides锁" class="headerlink" title="集群Rides锁"></a>集群Rides锁</h3><h4 id="Redlock"><a href="#Redlock" class="headerlink" title="Redlock"></a>Redlock</h4><p>Redlock是Redis的作者antirez给出的集群模式的Redis分布式锁，它基于N个完全独立的Redis节点（通常情况下N可以设置成5）。</p>
<h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h5><ol>
<li>获取当前时间（毫秒数）。</li>
<li>按顺序依次向N个Redis节点执行获取锁的操作。获取锁的操作与单机锁一样。</li>
<li>如果获取锁成功的节点数&gt;=N/2+1，则再计算获取锁的时间有没有超过锁过期时间（可考虑设置一个必须留多长的时间给代码块执行），如果超过了则认为取锁失败。</li>
<li>如果取锁失败则应该对所有节点进行释放锁的操作。<h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5></li>
</ol>
<p>当有5个节点，某次上锁对a,b,c三个节点上锁成功，而后c马上down了，此时还没通过AOF或RDB写入磁盘。而后c又马上恢复，此时c没有上锁数据，因此此时可能出现c,d,e三个节点被别的进程上锁。所以在节点恢复时应该延时起码一个锁的过期时间。</p>
<h3 id="Zookeeper锁"><a href="#Zookeeper锁" class="headerlink" title="Zookeeper锁"></a>Zookeeper锁</h3><h5 id="zookeeper锁相关基础知识"><a href="#zookeeper锁相关基础知识" class="headerlink" title="zookeeper锁相关基础知识"></a>zookeeper锁相关基础知识</h5><ul>
<li>zk一般由多个节点构成（单数），采用zab一致性协议。因此可以将zk看成一个单点结构，对其修改数据其内部自动将所有节点数据进行修改而后才提供查询服务。</li>
<li>zk的数据以目录树的形式，每个目录称为 znode， znode中可存储数据（一般不超过1M），还可以在其中增加子节点。</li>
<li>子节点有三种类型。序列化节点，每在该节点下增加一个节点自动给该节点的名称上自增。临时节点，一旦创建这个 znode 的客户端与服务器失去联系，这个 znode 也将自动删除。最后就是普通节点。</li>
<li>Watch机制，client可以监控每个节点的变化，当产生变化会给client产生一个事件。</li>
</ul>
<h5 id="zk基本锁"><a href="#zk基本锁" class="headerlink" title="zk基本锁"></a>zk基本锁</h5><p><strong>原理</strong>：利用临时节点与watch机制。每个锁占用一个普通节点/lock，当需要获取锁时在/lock下创建一个临时节点，创建成功则表示获取锁成功，失败则watch/lock节点，有删除操作后再去争锁。临时节点好处在于当进程挂掉后能自动上锁的节点自动删除即取消锁。</p>
<p><strong>缺点</strong>：所有取锁失败的进程都监听父节点，很容易发生羊群效应，即当释放锁后所有等待进程一起来创建节点，并发量很大。</p>
<h5 id="zk锁优化"><a href="#zk锁优化" class="headerlink" title="zk锁优化"></a>zk锁优化</h5><p><strong>原理</strong>：上锁改为创建临时有序节点，每个上锁的节点均能创建节点成功，知识其序号不同。只有序号最小的可以拥有锁，当需要不是最小的则watch序号排在前面的一个节点(公平锁)。</p>
<p><strong>步骤</strong>：</p>
<ol>
<li>在/lock节点下创建一个有序临时节点(EPHEMERAL_SEQUENTIAL)。</li>
<li>判断创建的节点序号是否最小，如果是最小则获取锁成功。不是则取锁失败，然后watch序号比本身小的前一个节点。</li>
<li>当取锁失败，设置watch后则等待watch事件到来后，再次判断是否序号最小。</li>
<li>取锁成功则执行代码，最后删除本身节点，释放了锁。</li>
</ol>
<h3 id="分布式锁总结"><a href="#分布式锁总结" class="headerlink" title="分布式锁总结"></a>分布式锁总结</h3><h5 id="分布式锁存在的问题"><a href="#分布式锁存在的问题" class="headerlink" title="分布式锁存在的问题"></a>分布式锁存在的问题</h5><ol>
<li>均可能存在多进程拥有锁的情况。redis锁主要是expire时间与代码执行时间的问题，zk锁的问题在于zk是通过心跳监控进程存活状态，如果进程进行GC pause或者因为网络原因导致很长时间没与zk联系，则将导致zk认为进程已挂，而后锁自动释放，而此时进程并未挂任然在执行。</li>
<li>Redlock锁的时间问题。由于redis的expire的实现是通过pexpireat，如果某个节点发生时钟跳跃，则该节点可能过早释放锁导致一系列问题。</li>
</ol>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><ol>
<li>获取锁时提供一个fencing token(两种说法，一种说需要有序，一种说随机值就可以，我觉得随机值就可以)，在进程获取锁后对数据进行操作时，数据所在的资源服务器需要去锁中查看当前token，如果token对的才执行，不对则放弃执行。</li>
<li>我觉得对于放弃执行的应该在我们的代码块中增加类似事物的rollback的操作。因此如果资源服务器拒绝了我们的操作则表明此时起码已经存在了另外一个进程拥有锁了，为了保证数据安全性不能继续执行，因此需要回滚到执行代码块之前而继续去竞争锁。</li>
<li>至于Redis锁的时间问题，Antirez说在运维层面是可以控制时钟跳跃的区间的，只要能控制跳跃区间与expire的比例就没问题，详细可看《基于Redis的分布式锁真的安全吗？》</li>
</ol>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><ol>
<li>大多数时候采用zk锁就好了，没必要再考虑安全性的问题。其实也可以通过zk锁+幂等校验来达到双层保障。</li>
<li>fencing 机制需要对数据服务进行修改适配，个人觉得没这个必要吧。。。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/分布式/分布式锁/" data-id="cjei97edd003689bl987jmxn5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/分布式/分布式事务" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Java/分布式/分布式事务/" class="article-date">
  <time datetime="2018-02-25T07:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/分布式/">分布式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Java/分布式/分布式事务/">分布式事务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="分布式事务概述"><a href="#分布式事务概述" class="headerlink" title="分布式事务概述"></a>分布式事务概述</h3><p>分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。以上是百度百科的解释，简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。</p>
<h3 id="分布式事务的产生的原因"><a href="#分布式事务的产生的原因" class="headerlink" title="分布式事务的产生的原因"></a>分布式事务的产生的原因</h3><h5 id="1-数据库分库分表"><a href="#1-数据库分库分表" class="headerlink" title="1.数据库分库分表"></a>1.数据库分库分表</h5><p>当数据库单表一年产生的数据超过1000W，那么就要考虑分库分表，具体分库分表的原理在此不做解释，以后有空详细说，简单的说就是原来的一个数据库变成了多个数据库。这时候，如果一个操作既访问01库，又访问02库，而且要保证数据的一致性，那么就要用到分布式事务。<br><img src="http://img.blog.csdn.net/20170320083203650?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZV9zb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image">    </p>
<h5 id="2-应用SOA化"><a href="#2-应用SOA化" class="headerlink" title="2.应用SOA化"></a>2.应用SOA化</h5><p>所谓的SOA化，就是业务的服务化。比如原来单机支撑了整个电商网站，现在对整个网站进行拆解，分离出了订单中心、用户中心、库存中心。对于订单中心，有专门的数据库存储订单信息，用户中心也有专门的数据库存储用户信息，库存中心也会有专门的数据库存储库存信息。这时候如果要同时对订单和库存进行操作，那么就会涉及到订单数据库和库存数据库，为了保证数据一致性，就需要用到分布式事务。<br><img src="http://img.blog.csdn.net/20170320083209525?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZV9zb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"><br>以上两种情况表象不同，但是本质相同，都是因为要操作的数据库变多了！    </p>
<h3 id="分布式事务的应用场景"><a href="#分布式事务的应用场景" class="headerlink" title="分布式事务的应用场景"></a>分布式事务的应用场景</h3><h5 id="1-支付"><a href="#1-支付" class="headerlink" title="1.支付"></a>1.支付</h5><p>最经典的场景就是支付了，一笔支付，是对买家账户进行扣款，同时对卖家账户进行加钱，这些操作必须在一个事务里执行，要么全部成功，要么全部失败。而对于买家账户属于买家中心，对应的是买家数据库，而卖家账户属于卖家中心，对应的是卖家数据库，对不同数据库的操作必然需要引入分布式事务。</p>
<h5 id="2-在线下单"><a href="#2-在线下单" class="headerlink" title="2.在线下单"></a>2.在线下单</h5><p>买家在电商平台下单，往往会涉及到两个动作，一个是扣库存，第二个是更新订单状态，库存和订单一般属于不同的数据库，需要使用分布式事务保证数据一致性。</p>
<h3 id="常见的分布式事务解决方案"><a href="#常见的分布式事务解决方案" class="headerlink" title="常见的分布式事务解决方案"></a>常见的分布式事务解决方案</h3><h4 id="基于XA协议的两阶段提交"><a href="#基于XA协议的两阶段提交" class="headerlink" title="基于XA协议的两阶段提交"></a>基于XA协议的两阶段提交</h4><p>XA是一个分布式事务协议，由Tuxedo提出。XA中大致分为两部分：事务管理器和本地资源管理器。其中本地资源管理器往往由数据库实现，比如Oracle、DB2这些商业数据库都实现了XA接口，而事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。XA实现分布式事务的原理如下：<br><img src="http://img.blog.csdn.net/20170320083214850?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZV9zb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image">    </p>
<p>总的来说，XA协议比较简单，而且一旦商业数据库实现了XA协议，使用分布式事务的成本也比较低。但是，XA也有致命的缺点，那就是性能不理想，特别是在交易下单链路，往往并发量很高，XA无法满足高并发场景。XA目前在商业数据库支持的比较理想，在mysql数据库中支持的不太理想，mysql的XA实现，没有记录prepare阶段日志，主备切换回导致主库与备库数据不一致。许多nosql也没有支持XA，这让XA的应用场景变得非常狭隘。  </p>
<p>两阶段提交协议（Two-phase Commit，2PC）经常被用来实现分布式事务。一般分为协调器C和若干事务执行者Si两种角色，这里的事务执行者就是具体的数据库，协调器可以和事务执行器在一台机器上。<br><img src="http://ww2.sinaimg.cn/large/7cc829d3gw1eux5nfbny7j20l908xta6.jpg" alt="image">  </p>
<ol>
<li><p>我们的应用程序（client）发起一个开始请求到TC；</p>
</li>
<li><p>TC先将<prepare>消息写到本地日志，之后向所有的Si发起<prepare>消息。以支付宝转账到余额宝为例，TC给A的prepare消息是通知支付宝数据库相应账目扣款1万，TC给B的prepare消息是通知余额宝数据库相应账目增加1w。为什么在执行任务前需要先写本地日志，主要是为了故障后恢复用，本地日志起到现实生活中凭证 的效果，如果没有本地日志（凭证），出问题容易死无对证；</prepare></prepare></p>
</li>
<li><p>Si收到<prepare>消息后，执行具体本机事务，但不会进行commit，如果成功返回<yes>，不成功返回<no>。同理，返回前都应把要返回的消息写到日志里，当作凭证。</no></yes></prepare></p>
</li>
<li><p>TC收集所有执行器返回的消息，如果所有执行器都返回yes，那么给所有执行器发生送commit消息，执行器收到commit后执行本地事务的commit操作；如果有任一个执行器返回no，那么给所有执行器发送abort消息，执行器收到abort消息后执行事务abort操作。</p>
</li>
</ol>
<p>注：TC或Si把发送或接收到的消息先写到日志里，主要是为了故障后恢复用。如某一Si从故障中恢复后，先检查本机的日志，如果已收到<commit>，则提交，如果<abort>则回滚。如果是<yes>，则再向TC询问一下，确定下一步。如果什么都没有，则很可能在<prepare>阶段Si就崩溃了，因此需要回滚。</prepare></yes></abort></commit></p>
<p>现如今实现基于两阶段提交的分布式事务也没那么困难了，如果使用java，那么可以使用开源软件atomikos(<a href="http://www.atomikos.com/)来快速实现。" target="_blank" rel="external">http://www.atomikos.com/)来快速实现。</a><br>​<br>不过但凡使用过的上述两阶段提交的同学都可以发现性能实在是太差，根本不适合高并发的系统。为什么？</p>
<ol>
<li>两阶段提交涉及多次节点间的网络通信，通信时间太长！</li>
<li>事务时间相对于变长了，锁定的资源的时间也变长了，造成资源等待时间也增加好多！</li>
</ol>
<p>正是由于分布式事务存在很严重的性能问题，大部分高并发服务都在避免使用，往往通过其他途径来解决数据一致性问题。</p>
<h4 id="消息事务-最终一致性"><a href="#消息事务-最终一致性" class="headerlink" title="消息事务+最终一致性"></a>消息事务+最终一致性</h4><p>如果仔细观察生活的话，生活的很多场景已经给了我们提示。</p>
<p>比如在北京很有名的姚记炒肝点了炒肝并付了钱后，他们并不会直接把你点的炒肝给你，而是给你一张小票，然后让你拿着小票到出货区排队去取。为什么他们要将付钱和取货两个动作分开呢？原因很多，其中一个很重要的原因是为了使他们接待能力增强（并发量更高）。</p>
<p>所谓的消息事务就是基于消息中间件的两阶段提交，本质上是对消息中间件的一种特殊利用，它是将本地事务和发消息放在了一个分布式事务里，保证要么本地操作成功成功并且对外发消息成功，要么两者都失败，开源的RocketMQ就支持这一特性，具体原理如下： </p>
<p><img src="http://img.blog.csdn.net/20170320083222287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZV9zb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image">    </p>
<ol>
<li>A系统向消息中间件发送一条预备消息</li>
<li>消息中间件保存预备消息并返回成功</li>
<li>A执行本地事务</li>
<li>A发送提交消息给消息中间件</li>
</ol>
<p>通过以上4步完成了一个消息事务。对于以上的4个步骤，每个步骤都可能产生错误，下面一一分析：</p>
<ul>
<li>步骤一出错，则整个事务失败，不会执行A的本地操作</li>
<li>步骤二出错，则整个事务失败，不会执行A的本地操作</li>
<li>步骤三出错，这时候需要回滚预备消息，怎么回滚？答案是A系统实现一个消息中间件的回调接口，消息中间件会去不断执行回调接口，检查A事务执行是否执行成功，如果失败则回滚预备消息</li>
<li>步骤四出错，这时候A的本地事务是成功的，那么消息中间件要回滚A吗？答案是不需要，其实通过回调接口，消息中间件能够检查到A执行成功了，这时候其实不需要A发提交消息了，消息中间件可以自己对消息进行提交，从而完成整个消息事务</li>
</ul>
<p>基于消息中间件的两阶段提交往往用在高并发场景下，将一个分布式事务拆成一个消息事务（A系统的本地操作+发消息）+B系统的本地操作，其中B系统的操作由消息驱动，只要消息事务成功，那么A操作一定成功，消息也一定发出来了，这时候B会收到消息去执行本地操作，如果本地操作失败，消息会重投，直到B操作成功，这样就变相地实现了A与B的分布式事务。原理如下：<br><img src="http://img.blog.csdn.net/20170320083228100?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZV9zb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"><br>虽然上面的方案能够完成A和B的操作，但是A和B并不是严格一致的，而是最终一致的，我们在这里牺牲了一致性，换来了性能的大幅度提升。当然，这种玩法也是有风险的，如果B一直执行不成功，那么一致性会被破坏，具体要不要玩，还是得看业务能够承担多少风险。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Java/分布式/分布式事务/" data-id="cjei97eda003389bll30z1uwl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux/shell script" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Linux/shell script/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Linux/shell script/">shell script</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="编写shell-script的需要注意以下事项："><a href="#编写shell-script的需要注意以下事项：" class="headerlink" title="编写shell script的需要注意以下事项："></a>编写shell script的需要注意以下事项：</h3><ol>
<li>命令的执行是从上而下，从左而右地分析与执行</li>
<li>命令，参数间的多个空白都会被忽略掉</li>
<li>空白行也将被忽略掉，并且[tab]按键所得的空白同样视为空格键</li>
<li>如果读取到一个Enter符号（CR），就尝试开始执行该行（或该串）命令</li>
<li>至于如果一行的内容太多，则可以使用“\Enter”来扩展至下一行</li>
<li>“#”可以作为批注。任何加在#后面的数据将全部被视为批注文字而被忽略</li>
</ol>
<h3 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h3><ol>
<li><p><strong>直接命令执行</strong>：shell.sh文件必须具备可读与可执行（rx）的权限，然后：</p>
<ol>
<li>绝对路径：使用<code>/home/dmtsai/shell.sh</code>来执行命令</li>
<li>相对命令：假设工作目录在/home/dmtsai/,则使用<code>./shell.sh</code>来执行</li>
<li>变量“PATH”功能：将shell.sh放在PATH指定的目录内，例如：~/bin/</li>
</ol>
</li>
<li><p><strong>以bash进程来执行</strong>：通过<code>bash shell.sh</code> 或 <code>sh shell.sh</code>来执行</p>
</li>
</ol>
<h3 id="脚本规范"><a href="#脚本规范" class="headerlink" title="脚本规范"></a>脚本规范</h3><ol>
<li><p>第一行<code>#!/bin/bash</code>声明这个script使用的shell名称</p>
<p> 因为我们使用的是bash，所以必须要以<code>#!/bin/bash</code>来声明这个内的语法使用bash的语法。那么当这个程序被执行时，它就能够加载bash的相关环境配置文件（一般来说就是non-login shell的~/.bashrc），并且执行bash来执行bash使我们下面的命令能够执行。这很重要的（在很多情况中，如果没有设置好这一行，那么该程序很可能会无法执行，因为系统可能无法判断该程序需要使用什么shell来执行）</p>
</li>
<li><p>程序内容的说明</p>
<p> 整个script当中，除了第一行的<code>#!</code>是用来声明shell的之外，其他的#都是“批注”用途。一般来说，建议你一定要养成说明该script的内容和功能，版本信息，作者与联系方式，建立日期，历史记录等习惯，这将有助于将来程序的改写与调试</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"># 功能：</div><div class="line">#   这里是功能描述</div><div class="line"># 历史：</div><div class="line">#   时间 作者 版本号</div></pre></td></tr></table></figure>
</li>
<li><p>主要环境变量的声明</p>
<p> 建议务必要将一些重要的环境变量设置好，PATH与LANG（如果有使用到输出相关的信息时）是当中最重要的！如此一来，则可让我们这个程序在进行时可以直接执行一些外部命令，而不必写绝对路径</p>
</li>
<li><p>主要程序部分</p>
<p> 就将主要的程序写好即可</p>
</li>
<li><p>告知执行结果</p>
<p> 可以利用exit这个命令来让程序中断，并且回传一个数值给系统。例如使用exit 0，这代表离开script并且回传一个0给系统。进一步，可以利用exit n（n为数字）的功能，自定义错误信息，让程序变得更加聪明</p>
</li>
</ol>
<p>注意：<strong>使用上述的方式执行script时，该script都会使用一个新的bash环境来执行脚本内的命令</strong>.</p>
<p>也就是说，<strong>使用这种执行方式时，其实script是在子进程的bash内执行的。当子进程完成后，子进程内的各项变量或操作将会结束而不会传回到父进程中</strong></p>
<p>如下图：<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/WechatIMG2436.jpeg" alt="image"><br>​    </p>
<h5 id="使用source来执行脚本：在父进程中执行"><a href="#使用source来执行脚本：在父进程中执行" class="headerlink" title="使用source来执行脚本：在父进程中执行"></a>使用source来执行脚本：在父进程中执行</h5><p><img src="https://raw.githubusercontent.com/clq2owesome/image/master/WechatIMG2438.jpeg" alt="image"></p>
<h3 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var=$((运算内容))</div></pre></td></tr></table></figure>
<h3 id="自定义变量转成环境变量（export）"><a href="#自定义变量转成环境变量（export）" class="headerlink" title="自定义变量转成环境变量（export）"></a>自定义变量转成环境变量（export）</h3><p><strong>子进程仅会继承父进程的环境变量，子进程不会继承父进程的自定义变量</strong>，所以你原本bash中的自定义变量在进入了子进程后就会消失不见，一直到你离开子进程并回到原本的父进程后，这个变量才会又出现</p>
<p>换个角度来说，如果我能将自定义变量变成环境变量的话，那不就可以让该变量值继续存在于子进程了？如果想要让该变量内容继续在子进程中使用，那么就请执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export 变量名称</div></pre></td></tr></table></figure></p>
<p>为什么环境变量的数据可以被子进程所引用呢？这是因为内存配置的关系。理论上是这样的：</p>
<ul>
<li>当启动一个shell，操作系统会分配一记忆块给shell使用，此内存内的变量可让子进程取用</li>
<li>若在父进程利用export功能，可以让自定义变量的内容写到上述的记忆块当中（环境变量）</li>
<li>当加载另一个shell时（即启动子进程，而离开原本的父进程了），子shell可以将父shell的环境变量所在的记忆块导入自己的环境变量块当中</li>
</ul>
<h3 id="关于本shell的PID"><a href="#关于本shell的PID" class="headerlink" title="$(关于本shell的PID)"></a>$(关于本shell的PID)</h3><p>“$”本身也是个变量，这个代表的是目前这个shell的线程代号，即是所谓的PID（Process ID）</p>
<h3 id="（关于上个执行命令的回传码）"><a href="#（关于上个执行命令的回传码）" class="headerlink" title="?（关于上个执行命令的回传码）"></a>?（关于上个执行命令的回传码）</h3><p>问号也是一个特殊的变量，在bash里面这个变量很重要。<strong>这个变量是上一个执行的命令所回传的值</strong>。当我们执行某些命令时，这些命令都会回传一个执行后的代码。一般来说，<strong>如果成功执行该命令，则会回传一个0值，如果执行过程中发生错误，就会回传“错误代码”才对。一般就是以非0的数值来替代</strong></p>
<h3 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h3><h6 id="关于某个文件名的“文件类型”判断"><a href="#关于某个文件名的“文件类型”判断" class="headerlink" title="关于某个文件名的“文件类型”判断"></a>关于某个文件名的“文件类型”判断</h6><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-e</td>
<td>该文件名是否存在（常用）</td>
</tr>
<tr>
<td>-f</td>
<td>该文件名是否存在且为文件（file）（常用）</td>
</tr>
<tr>
<td>-d</td>
<td>是否存在且为目录（常用）</td>
</tr>
<tr>
<td>-b</td>
<td>是否存在且为一个block device设备</td>
</tr>
<tr>
<td>-c</td>
<td>是否存在且为一个character device设备</td>
</tr>
<tr>
<td>-S</td>
<td>是否存在且为一个Socket文件</td>
</tr>
<tr>
<td>-p</td>
<td>是否存在且为一个FIFO（pipe）文件</td>
</tr>
<tr>
<td>-L</td>
<td>是否存在且为一个连接文件</td>
</tr>
</tbody>
</table>
<h6 id="关于文件的权限检测"><a href="#关于文件的权限检测" class="headerlink" title="关于文件的权限检测"></a>关于文件的权限检测</h6><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-r</td>
<td>检测该文件是否存在且具有“可读”的权限</td>
</tr>
<tr>
<td>-w</td>
<td>检测该文件是否存在且具有“可写”的权限</td>
</tr>
<tr>
<td>-x</td>
<td>检测该文件是否存在且具有“可执行”的权限</td>
</tr>
<tr>
<td>-u</td>
<td>检测该文件是否存在且具有“SUID”的属性</td>
</tr>
<tr>
<td>-g</td>
<td>检测该文件是否存在且具有“SGID”的属性</td>
</tr>
<tr>
<td>-k</td>
<td>检测该文件是否存在且具有“Sticky bit”的属性</td>
</tr>
<tr>
<td>-s</td>
<td>检测该文件是否存在且为“非空白文件”</td>
</tr>
</tbody>
</table>
<h6 id="关于文件的权限检测-1"><a href="#关于文件的权限检测-1" class="headerlink" title="关于文件的权限检测"></a>关于文件的权限检测</h6><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-nt</td>
<td>判断file1是否比file2新</td>
</tr>
<tr>
<td>-ot</td>
<td>判断file1是否比file2旧</td>
</tr>
<tr>
<td>-ef</td>
<td>判断file1与file2是否为同一文件，可用在判断hard link的判定上。主要意义在于判定两个文件是否均指向同一个node</td>
</tr>
</tbody>
</table>
<h6 id="关于两个整数之间的判定"><a href="#关于两个整数之间的判定" class="headerlink" title="关于两个整数之间的判定"></a>关于两个整数之间的判定</h6><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-eq</td>
<td>两数值相等</td>
</tr>
<tr>
<td>-ne</td>
<td>两数值不等</td>
</tr>
<tr>
<td>-gt</td>
<td>n1大于n2</td>
</tr>
<tr>
<td>-lt</td>
<td>n1小于n2</td>
</tr>
<tr>
<td>-ge</td>
<td>n1大于等于n2</td>
</tr>
<tr>
<td>-le</td>
<td>n1小于等于n2</td>
</tr>
</tbody>
</table>
<h6 id="判定字符串的数据"><a href="#判定字符串的数据" class="headerlink" title="判定字符串的数据"></a>判定字符串的数据</h6><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Test -Z string</td>
<td>判定字符串是否为0，若string为空字符串，则为true</td>
</tr>
<tr>
<td>Test -n string</td>
<td>判定字符串是否为非0，若string为空字符串，则为false<br>注：-n也可以省略</td>
</tr>
<tr>
<td>test str1 = str2</td>
<td>判定str1是否等于str2，若相等，则回传true</td>
</tr>
<tr>
<td>test str1 != str2</td>
<td>判定str1是否不等于str2，若相等，则返回false</td>
</tr>
</tbody>
</table>
<h6 id="多重条件判定"><a href="#多重条件判定" class="headerlink" title="多重条件判定"></a>多重条件判定</h6><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>两个条件同时成立！例如test -r file -a -x file，则file同时具有r与x的权限时，才返回true</td>
</tr>
<tr>
<td>-o</td>
<td>任何一个条件成立！例如test -r file -o -x file，则file具有r或x权限时，就会返回true</td>
</tr>
<tr>
<td>!</td>
<td>反向状态！例如 test ! -x file，当file不具有x时，就会回传true</td>
</tr>
</tbody>
</table>
<h3 id="利用判断符号"><a href="#利用判断符号" class="headerlink" title="利用判断符号[]"></a>利用判断符号[]</h3><p>中括号的用法与test几乎一模一样，只是中括号比较常用在条件判断式 if…then…fi 的情况</p>
<p>例如：如果想要知道$HOME这个变量是否为空的，可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># [ -z &quot;$HOME&quot; ];echo $?</div><div class="line">1</div></pre></td></tr></table></figure></p>
<p>必须要注意：</p>
<ol>
<li>在中括号[]内的每个组件的两端都需要有空格符来分隔</li>
<li>中中括号内的变量，最好都以双引号括起来</li>
<li>在中括号内的常量，最好都以单或双引号括起来</li>
</ol>
<h3 id="shell-script-的默认变量"><a href="#shell-script-的默认变量" class="headerlink" title="shell script 的默认变量"></a>shell script 的默认变量</h3><p>script针对参数已经有设置好一些变量名称了，对应如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/path/to/scriptname opt1 opt2 opt3 opt4</div><div class="line">     $0              $1   $2   $3   $4</div></pre></td></tr></table></figure></p>
<p>除了这些数字的变量之外，我们还有一些较为特殊的变量可以在script内使用来调用这些参数</p>
<ul>
<li>$#:代表后接的参数的个数</li>
<li>$@:代表“$1”，“$2”，“$3”，“$4”之意，每个变量是独立的（用双引号括起来）</li>
<li>$*:代表“”$1c$2c$3c$4””，其中c为分隔字符，默认为空格键，所以本例中代表“”$1 $2 $3 $4””之意</li>
</ul>
<h3 id="判断式"><a href="#判断式" class="headerlink" title="判断式"></a>判断式</h3><h6 id="单层，简单条件判断式"><a href="#单层，简单条件判断式" class="headerlink" title="单层，简单条件判断式"></a>单层，简单条件判断式</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if [条件];then</div><div class="line">    当条件成立时，可以进行的命令工作内容</div><div class="line">fi &lt;---结束之意</div></pre></td></tr></table></figure>
<h6 id="多重，复杂条件判断式"><a href="#多重，复杂条件判断式" class="headerlink" title="多重，复杂条件判断式"></a>多重，复杂条件判断式</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">if [条件]; then</div><div class="line">    当条件成立时，可以进行的命令工作内容</div><div class="line">elif [条件]; then</div><div class="line">    当条件成立时，可以进行的命令工作内容</div><div class="line">fi &lt;---结束之意</div><div class="line"></div><div class="line">或者</div><div class="line"></div><div class="line">if [条件]; then</div><div class="line">    当条件成立时，可以进行的命令工作内容</div><div class="line">elif [条件]; then</div><div class="line">    当条件成立时，可以进行的命令工作内容</div><div class="line">else </div><div class="line">    当条件成立时，可以进行的命令工作内容</div><div class="line">fi &lt;---结束之意</div><div class="line"></div><div class="line">例如：</div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">if [ &quot;$1&quot; == &quot;hello&quot; ]; then</div><div class="line">	echo &quot;Hello, how are you?&quot;</div><div class="line">elif [ &quot;$1&quot; == &quot;&quot; ]; then</div><div class="line">	echo &quot;you must input params, ex&gt; &#123;$0 someword&#125;&quot;</div><div class="line">else </div><div class="line">	echo &quot;the only params is &apos;hello&apos;, ex&gt; &#123;$0 hello&#125;&quot;</div><div class="line">fi</div></pre></td></tr></table></figure>
<h3 id="netstat-简单使用"><a href="#netstat-简单使用" class="headerlink" title="netstat 简单使用"></a>netstat 简单使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">~# netstat -tuln</div><div class="line">Active Internet connections (only servers)</div><div class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </div><div class="line">tcp        0      0 127.0.0.1:8005          0.0.0.0:*               LISTEN     </div><div class="line">tcp        0      0 0.0.0.0:8009            0.0.0.0:*               LISTEN     </div><div class="line">tcp        0      0 127.0.0.1:6379          0.0.0.0:*               LISTEN     </div><div class="line">tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN     </div><div class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN     </div><div class="line">tcp        0      0 0.0.0.0:8081            0.0.0.0:*               LISTEN     </div><div class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     </div><div class="line">tcp6       0      0 :::3306                 :::*                    LISTEN     </div><div class="line">tcp6       0      0 :::3000                 :::*                    LISTEN     </div><div class="line">tcp6       0      0 :::88                   :::*                    LISTEN     </div><div class="line">udp        0      0 0.0.0.0:33848           0.0.0.0:*                          </div><div class="line">udp        0      0 0.0.0.0:5353            0.0.0.0:*                          </div><div class="line">udp        0      0 172.18.79.196:123       0.0.0.0:*                          </div><div class="line">udp        0      0 127.0.0.1:123           0.0.0.0:*                          </div><div class="line">udp        0      0 0.0.0.0:123             0.0.0.0:*                          </div><div class="line">udp6       0      0 :::123                  :::*</div></pre></td></tr></table></figure>
<p>上面的重点是Local Address（本地主机的IP与端口对应）那个字段，它代表的是本机所启动的网络服务。IP的部分说明的是该服务位于哪个接口上，若为127.0.0.1则是针对本机开放，若是0.0.0.0 或 ::: 则代表对整个Internet开发。每个端口都有其特定的网络服务，几个常见与相关网络服务的关系是：</p>
<ul>
<li>80:www</li>
<li>22:ssh</li>
<li>21:ftp</li>
<li>25:mail</li>
<li>111:RPC（远程过程调用）</li>
<li>631:CUPS（打印服务功能）</li>
</ul>
<h3 id="利用case…esac判断"><a href="#利用case…esac判断" class="headerlink" title="利用case…esac判断"></a>利用case…esac判断</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">case $变量名称 in </div><div class="line">    &quot;第一个变量内容&quot;) &lt;==每个变量内容建议用双引号括起来，关键字则为小括号</div><div class="line">    程序段</div><div class="line">    ;;</div><div class="line">    </div><div class="line">    &quot;第二个变量内容&quot;)</div><div class="line">    程序段</div><div class="line">    ;;</div><div class="line">    </div><div class="line">    *) &lt;==最后一个变量内容都会用*来代表所有其他值，不包含第一个变量内容与第二个变量内容的其他程序执行段</div><div class="line">    ;;</div><div class="line">esac  &lt;== case反过来写，表示结尾</div><div class="line"></div><div class="line">例如：</div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">case $1 in </div><div class="line">	&quot;hello&quot;)</div><div class="line">		echo &quot;你好&quot;</div><div class="line">		;;</div><div class="line">	</div><div class="line">	&quot;&quot;)</div><div class="line">		echo &quot;请输入参数：ex&gt; &#123;$0 someword&#125;&quot;</div><div class="line">		;;</div><div class="line">	</div><div class="line">	*)</div><div class="line">		echo &quot;usage $0 &#123;hello&#125;&quot;</div><div class="line">		;;</div><div class="line">esac</div></pre></td></tr></table></figure>
<p>每一个变量内容的程序段最后都需要两个分号（;;）来代表该程序段落的结束，这很重要</p>
<p>使用“case $变量 in”这个语法中，当中的那个“$变量”大致有两种取得的方式：</p>
<ul>
<li>直接执行式：例如上面提到的，利用“script.sh variable”的方式来直接给予$1这个变量的内容，这也是在/etc/init.d目录下大多数程序的设计方式</li>
<li>交互式：通过read这个命令来让用户输入变量的内容</li>
</ul>
<h6 id="交互式"><a href="#交互式" class="headerlink" title="交互式"></a>交互式</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">echo &quot;this program will print your selection&quot;</div><div class="line"># 交互式</div><div class="line">read -p &quot;input your choice:&quot; choice</div><div class="line">case $choice in</div><div class="line">	&quot;one&quot;)</div><div class="line">		echo &quot;your choice is one&quot;</div><div class="line">		;;</div><div class="line">	</div><div class="line">	&quot;two&quot;)</div><div class="line">		echo &quot;your choice is two&quot;</div><div class="line">		;;</div><div class="line">		</div><div class="line">	&quot;three&quot;)</div><div class="line">	echo &quot;your choice is three&quot;</div><div class="line">	;;</div><div class="line">	</div><div class="line">	*)</div><div class="line">		echo &quot;usage $0 &#123;one|two|three&#125;&quot;</div><div class="line">		;;</div><div class="line">esac</div></pre></td></tr></table></figure>
<h6 id="直接执行式"><a href="#直接执行式" class="headerlink" title="直接执行式"></a>直接执行式</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">echo &quot;this program will print your selection&quot;</div><div class="line"></div><div class="line">case $1 in </div><div class="line">	&quot;one&quot;)</div><div class="line">		echo &quot;your choice is one&quot;</div><div class="line">		;;</div><div class="line">	</div><div class="line">	&quot;two&quot;)</div><div class="line">		echo &quot;your choice is two&quot;</div><div class="line">		;;</div><div class="line">		</div><div class="line">	&quot;three&quot;)</div><div class="line">	echo &quot;your choice is three&quot;</div><div class="line">	;;</div><div class="line">	</div><div class="line">	*)</div><div class="line">		echo &quot;usage $0 &#123;one|two|three&#125;&quot;</div><div class="line">		;;</div><div class="line">esac</div></pre></td></tr></table></figure>
<h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function fname() &#123;</div><div class="line">    程序段</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为shell script 的执行方式是由上而下，由左而右，因此在shell script当中的function的设置一定要在程序最前面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">echo &quot;this program will print your selection&quot;</div><div class="line">function printit() &#123;</div><div class="line">	echo -n &quot;your choice is &quot;  # 加上-n可以不断行继续在同一行显示</div><div class="line">&#125;</div><div class="line"># 直接执行式</div><div class="line">case $1 in </div><div class="line">	&quot;one&quot;)</div><div class="line">		printit; echo $1 | tr &apos;a-z&apos; &apos;A-Z&apos; # 将参数大小写转换</div><div class="line">		;;</div><div class="line">	</div><div class="line">	&quot;two&quot;)</div><div class="line">		printit; echo $1 | tr &apos;a-z&apos; &apos;A-Z&apos;</div><div class="line">		;;</div><div class="line">		</div><div class="line">	&quot;three&quot;)</div><div class="line">		printit; echo $1 | tr &apos;a-z&apos; &apos;A-Z&apos;</div><div class="line">		;;</div><div class="line">	</div><div class="line">	*)</div><div class="line">		echo &quot;usage $0 &#123;one|two|three&#125;&quot;</div><div class="line">		;;</div><div class="line">esac</div></pre></td></tr></table></figure></p>
<p>function 也是拥有内置变量的，它的内置变量与shell script很类似，函数名称代表$0,而后续的变量也是以$1,$2…来替代的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">echo &quot;this program will print your selection&quot;</div><div class="line">function printit() &#123;</div><div class="line">	echo -n &quot;your choice is $1 &quot;  # 加上-n可以不断行继续在同一行显示</div><div class="line">&#125;</div><div class="line"># 直接执行式</div><div class="line">case $1 in </div><div class="line">	&quot;one&quot;)</div><div class="line">		printit 1; echo $1 | tr &apos;a-z&apos; &apos;A-Z&apos; # 将参数大小写转换</div><div class="line">		;;</div><div class="line">	</div><div class="line">	&quot;two&quot;)</div><div class="line">		printit 2; echo $1 | tr &apos;a-z&apos; &apos;A-Z&apos;</div><div class="line">		;;</div><div class="line">		</div><div class="line">	&quot;three&quot;)</div><div class="line">		printit 3; echo $1 | tr &apos;a-z&apos; &apos;A-Z&apos;</div><div class="line">		;;</div><div class="line">	</div><div class="line">	*)</div><div class="line">		echo &quot;usage $0 &#123;one|two|three&#125;&quot;</div><div class="line">		;;</div><div class="line">esac</div></pre></td></tr></table></figure></p>
<h3 id="循环（loop）"><a href="#循环（loop）" class="headerlink" title="循环（loop）"></a>循环（loop）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># 当condition成立时开始循环</div><div class="line">while [condition]</div><div class="line">do  &lt;== do是循环的开始</div><div class="line">    程序段</div><div class="line">done  &lt;== done 是循环的结束</div><div class="line"></div><div class="line"></div><div class="line"># 当condition 成立时结束循环</div><div class="line">until [condition]</div><div class="line">do  </div><div class="line">    程序段</div><div class="line">done</div></pre></td></tr></table></figure>
<h3 id="for…do…done（固定循环）"><a href="#for…do…done（固定循环）" class="headerlink" title="for…do…done（固定循环）"></a>for…do…done（固定循环）</h3><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for var in con1 con2 con3 ...</div><div class="line">do </div><div class="line">    程序段</div><div class="line">done</div></pre></td></tr></table></figure></p>
<p>以上来的语法来说，这个$var 的变量内容在循环工作时：</p>
<ol>
<li>第一次循环时，$var的内容为con1</li>
<li>第二次循环时，$var的内容为con2</li>
<li>第三次循环时，$var的内容为con3</li>
</ol>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for animal in dog cat elepant</div><div class="line">do </div><div class="line">	echo &quot;there are $&#123;animal&#125;s...&quot;</div><div class="line">done</div></pre></td></tr></table></figure></p>
<h3 id="for…do…done数值处理"><a href="#for…do…done数值处理" class="headerlink" title="for…do…done数值处理"></a>for…do…done数值处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(( 初始值; 限制值; 执行步长))</div><div class="line">do</div><div class="line">    程序段</div><div class="line">done</div></pre></td></tr></table></figure>
<p>这种语法适合于数值方式的运算当中，在for后面的括号内的三串内容意义为：</p>
<ol>
<li>初始值：某个变量在循环当中的初始值，直接以类似i=1设置好</li>
<li>限制值：当变量的值在这个限制值的范围内，就继续进行循环，例如i&lt;=100</li>
<li>执行步长：每做一次循环时变量的变化值，例如i=i+1</li>
</ol>
<h3 id="shell-script的追踪与调试"><a href="#shell-script的追踪与调试" class="headerlink" title="shell script的追踪与调试"></a>shell script的追踪与调试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sh [-nvx] scripts.sh</div><div class="line">参数：</div><div class="line">-n：不要执行script，仅查询语法的问题</div><div class="line">-v：在执行script前，先将script的内容输出到屏幕上</div><div class="line">-x：将使用到的script内容显示到屏幕上，这是很有用的参数</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Linux/shell script/" data-id="cjei97eat000n89blb8cldgfx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux/shell 变量" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Linux/shell 变量/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Linux/shell 变量/">shell 变量</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是变量"><a href="#什么是变量" class="headerlink" title="什么是变量"></a>什么是变量</h3><p>变量就是以一组文件或符号等，来替代一些设置或者是一串保留的数据</p>
<p>可以使用<code>echo</code>这个命令来显示变量，但是变量在被显示时，前面必须要加上字符<code>$</code>或者以<code>${变量}</code>的方式来显示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">echo $PATH</div><div class="line">echo $&#123;PATH&#125;</div></pre></td></tr></table></figure></p>
<h3 id="变量的设置规则"><a href="#变量的设置规则" class="headerlink" title="变量的设置规则"></a>变量的设置规则</h3><p>在bash当中，当一个变量名称尚未被设置时，默认的内容是“空”的，另外变量在设置时，还是需要符合某些规定的，否则会设置失败</p>
<ol>
<li><p>变量与变量内容以一个等号“=”来连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myname=VBird</div></pre></td></tr></table></figure>
</li>
<li><p>等号两边不能直接接空格符，如下显示是错误的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myname= VBird</div><div class="line">myname=VBird Tsai</div></pre></td></tr></table></figure>
</li>
<li><p>变量的名称只能是英文字母与数字，但是开头字符不能是数字，如下为错误的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2myname=VBird</div></pre></td></tr></table></figure>
</li>
<li><p>变量的内容若有空格符号可使用双引号””或者单引号’’将变量内容结合起来，但是</p>
<ul>
<li><p>双引号内的特殊字符如$等，可以保持原本的特性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var=&quot;lang is $LANG&quot;</div><div class="line">echo $var 输出为:lang is zh_CN.UTF-8</div></pre></td></tr></table></figure>
</li>
<li><p>单引号内的特殊字符则仅为一般字符（纯文本）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var=&apos;lang is $LANG&apos;</div><div class="line">echo $var 输出为:lang is $LANG</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>可用转义字符“\”将特殊符号（如[Enter],$,空格符,! 等）变为一般字符</p>
</li>
<li><p>在一串命令中，还需要通过其他的命令提供信息，可以使用反单引号“`命令`”或“$(命令)”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">test=$(echo $PATH)</div><div class="line">echo $test 输出PATH的内容</div></pre></td></tr></table></figure>
</li>
<li><p>若该变量为了增加变量内容时，则可使用“$变量名称”或“${变量}”累加内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PATH=&quot;$PATH&quot;:/home/bin</div></pre></td></tr></table></figure>
</li>
<li><p>若该变量需要在其他子进程执行，则需要以<code>export</code>来使变量变成环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PATH</div></pre></td></tr></table></figure>
</li>
<li><p>通常大写字符为系统默认变量，自行设置变量可以使用小写字符，方便判断</p>
</li>
<li>取消变量的方法为使用“unset变量名称”<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unset myname</div></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：在一串命令中，在反单引号（`）之内的命令将会被先执行，而其执行出来的结果将作为外部的输入信息</p>
<h3 id="环境变量的功能"><a href="#环境变量的功能" class="headerlink" title="环境变量的功能"></a>环境变量的功能</h3><h4 id="用env查看环境变量与常见环境变量说明"><a href="#用env查看环境变量与常见环境变量说明" class="headerlink" title="用env查看环境变量与常见环境变量说明"></a>用env查看环境变量与常见环境变量说明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">env</div><div class="line">-------------------------------</div><div class="line">TERM_PROGRAM=Apple_Terminal</div><div class="line">SHELL=/bin/bash</div><div class="line">TERM=xterm-256color</div><div class="line">CATALINA_HOME=/Users/chenliqiang/software/apache-tomcat-test</div><div class="line">TMPDIR=/var/folders/mx/gn0s9skj0jzgxdzn68wtj8_h0000gn/T/</div><div class="line">Apple_PubSub_Socket_Render=/private/tmp/com.apple.launchd.ElGvcw57Yf/Render</div><div class="line">TERM_PROGRAM_VERSION=400</div><div class="line">TERM_SESSION_ID=60C62703-2490-444F-86A8-3C0827EC0DF0</div><div class="line">USER=chenliqiang</div><div class="line">SSH_AUTH_SOCK=/private/tmp/com.apple.launchd.jD69alTKH6/Listeners</div><div class="line">MAVEN_HOME=/usr/local/Cellar/maven/3.5.2</div><div class="line">PATH=/Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Home/bin:/usr/local/Cellar/maven/3.5.2/bin:/Users/chenliqiang/software/apache-tomcat-test/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</div><div class="line">PWD=/Users/chenliqiang</div><div class="line">JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Home</div><div class="line">LANG=zh_CN.UTF-8</div><div class="line">XPC_FLAGS=0x0</div><div class="line">XPC_SERVICE_NAME=0</div><div class="line">SHLVL=1</div><div class="line">HOME=/Users/chenliqiang</div><div class="line">LOGNAME=chenliqiang</div><div class="line">CLASSPATH=.:/Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Home/lib/tools.jar:/Users/chenliqiang/software/apache-tomcat-test/lib</div><div class="line">_=/usr/bin/env</div></pre></td></tr></table></figure>
<h4 id="查看所有变量（含环境变量和自定义变量）（set）"><a href="#查看所有变量（含环境变量和自定义变量）（set）" class="headerlink" title="查看所有变量（含环境变量和自定义变量）（set）"></a>查看所有变量（含环境变量和自定义变量）（set）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set</div></pre></td></tr></table></figure>
<h3 id="变量键盘的读取，数组与声明（read，array，declare）"><a href="#变量键盘的读取，数组与声明（read，array，declare）" class="headerlink" title="变量键盘的读取，数组与声明（read，array，declare）"></a>变量键盘的读取，数组与声明（read，array，declare）</h3><h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><p>要读取来自键盘输入的变量，就需要用read命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">read [-pt] variable</div><div class="line">参数：</div><div class="line">-p：后面可以接提示符</div><div class="line">-t：后面可以接等待的“秒数”，这个比较有趣，不会一直等待用户</div><div class="line"></div><div class="line">chenliqiangdeMacBook-Pro:~ chenliqiang$ read -p &quot;Please keyin your name:&quot; -t 30 atest</div><div class="line">Please keyin your name:test</div><div class="line">chenliqiangdeMacBook-Pro:~ chenliqiang$ echo $atest</div><div class="line">test</div></pre></td></tr></table></figure></p>
<h4 id="声明变量类型（declare）"><a href="#声明变量类型（declare）" class="headerlink" title="声明变量类型（declare）"></a>声明变量类型（declare）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">declare [-aixr] variable</div><div class="line">参数：</div><div class="line">-a：将后面名为variable的变量定义成为数组类型</div><div class="line">-i：将后面名为variable的变量定义成为整数数字类型</div><div class="line">-x：用法与export一样，就是将variable变成环境变量，把-改为+可以将variable变为非环境变量</div><div class="line">-r：将变量设置为readonly类型，该变量不可被更改内容，也不能重设</div></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>变量类型默认为“字符串”，所以若不指定变量类型，则1+2为一个“字符串”而不是“计算式”</li>
<li>bash环境中的数值运算，默认最多仅能达到整数类型，所以1/3的结果是0</li>
</ul>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组的设置方式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var[index]=content</div></pre></td></tr></table></figure></p>
<p>一般来说，建议直接以<code>${数组}</code>的方式来读取，会比较正确无误</p>
<h3 id="变量的测试与内容替换"><a href="#变量的测试与内容替换" class="headerlink" title="变量的测试与内容替换"></a>变量的测试与内容替换</h3><table>
<thead>
<tr>
<th>变量设置方式</th>
<th>str没有设置</th>
<th>str为空字符串</th>
<th>str已设置为非空字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>var=${str-expr}</td>
<td>var=expr</td>
<td>var=</td>
<td>var=$str</td>
</tr>
<tr>
<td>var=${str:-expr}</td>
<td>var=expr</td>
<td>var=expr</td>
<td>var=$str</td>
</tr>
<tr>
<td>var=${str+expr}</td>
<td>var=</td>
<td>var=expr</td>
<td>var=expr</td>
</tr>
<tr>
<td>var=${str:+expr}</td>
<td>var=</td>
<td>var=</td>
<td>var=expr</td>
</tr>
<tr>
<td>var=${str=expr}</td>
<td>str=expr<br>var=expr</td>
<td>str不变<br>var=</td>
<td>str不变<br>var=$str</td>
</tr>
<tr>
<td>var=${str:=expr}</td>
<td>str=expr<br>var=expr</td>
<td>str=expr<br>var=expr</td>
<td>str不变<br>var=$str</td>
</tr>
<tr>
<td>var=${str?expr}</td>
<td>expr输出至stderr</td>
<td>var=</td>
<td>var=str</td>
</tr>
<tr>
<td>var=${str:?expr}</td>
<td>expr输出至stderr</td>
<td>expr输出至stderr</td>
<td>var=str</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">例一：测试一下是否存在username这个变量，若不存在则给予username内容为root</div><div class="line">username=$&#123;username-root&#125;</div><div class="line">echo $username 输出：root</div><div class="line">username=&quot;vbird tsai&quot;</div><div class="line">username=$&#123;username-root&#125;</div><div class="line">echo $username 输出：vbird tsai</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Linux/shell 变量/" data-id="cjei97eau000p89bl1r4p4578" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据库相关/mysql/建立索引的原则" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/数据库相关/mysql/建立索引的原则/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库相关/">数据库相关</a>►<a class="article-category-link" href="/categories/数据库相关/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/数据库相关/mysql/建立索引的原则/">建立索引的原则</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><strong>最左前缀匹配原则</strong>，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li>
<li>尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录</li>
<li>索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);</li>
<li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</li>
</ol>
<h3 id="实际中的一些通用的原则："><a href="#实际中的一些通用的原则：" class="headerlink" title="实际中的一些通用的原则："></a>实际中的一些通用的原则：</h3><ol>
<li><p>在经常用作过滤器的字段上建立索引；</p>
</li>
<li><p>在SQL语句中经常进行GROUP BY、ORDER BY的字段上建立索引；MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</p>
</li>
<li><p>在不同值较少的字段上不必要建立索引，如性别字段；</p>
</li>
<li><p>对于经常存取的列避免建立索引；</p>
</li>
<li><p>用于联接的列（主健/外健）上建立索引；</p>
</li>
<li><p>在经常查询的多个列上建立复合索引，但要注意复合索引的建立顺序要按照使用的频率来确定；</p>
</li>
<li><p>缺省情况下建立的是非簇集索引，但在以下情况下最好考虑簇集索引，如：含有有限数目（不是很少）唯一的列；进行大范围的查询；充分的利用索引可以减少表扫描I/0的次数，有效的避免对整表的搜索。当然合理的索引要建立在对各种查询的分析和预测中，也取决于DBA的所设计的数据库结构。</p>
</li>
<li><p>MySQL只对以下操作符才使用索引：&lt;,&lt;=,=,&gt;,&gt;=,between,in,以及某些时候的like(不以通配符%或_开头的情形)</p>
</li>
<li><p>索引不会包含有NULL值的列。只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。</p>
</li>
<li><p>使用短索引。<br>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引,只需要针对特定的前缀进行索引即可。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</p>
</li>
</ol>
<h3 id="索引的不足之处"><a href="#索引的不足之处" class="headerlink" title="索引的不足之处"></a>索引的不足之处</h3><p>过多的使用索引将会造成滥用。因此索引也会有它的缺点：  </p>
<ol>
<li><p>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。</p>
</li>
<li><p>建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/数据库相关/mysql/建立索引的原则/" data-id="cjei97ehu00dc89blvvxlymu8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据库相关/mysql/创建高性能的索引" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/数据库相关/mysql/创建高性能的索引/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库相关/">数据库相关</a>►<a class="article-category-link" href="/categories/数据库相关/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/数据库相关/mysql/创建高性能的索引/">创建高性能的索引</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>索引（在MySQL中也叫做“键（key）”）是存储引擎用于快速找到记录的一种数据结构。索引优化应该是对查询性能优化最有效的手段了。</p>
<h2 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h2><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><p>在MySQL中，索引是在存储引擎层而不是服务器层实现的。所以，并没有统一的索引标准：不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。</p>
<h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h4><p>存储引擎以不同的方式使用B-Tree索引，性能也各有不同，各有优劣。例如，MyISAM使用前缀压缩计数使得索引更小，但InnoDB则按照原数据格式进行存储。再如MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。</p>
<p>B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。如下图展示了B-Tree索引的抽象表示：<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/mysql1.jpeg" alt="image"><br>B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点（图示并未画出）开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么是找到对应的值，要么该记录不存在。</p>
<p>叶子节点比较特别，它们的指针指向的是被索引的数据，而不是其他节点页。上图仅绘制了一个节点和其对应的叶子节点，其实在根节点和叶子节点之间可能有很多层节点页。树的深度和表的大小直接相关。</p>
<p><strong>索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序。</strong></p>
<p><strong>B-Tree索引适用于全键值，键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找</strong>。</p>
<ul>
<li><strong>全值匹配</strong><br>  全值匹配指的是和索引中的所有列进行匹配</li>
<li><strong>匹配最左前缀</strong><br>  即按定义好的索引顺序，只使用索引的第一列或几列（按顺序）</li>
<li><strong>匹配列前缀</strong><br>  也可以只匹配某一列的值的开头部分</li>
<li><strong>匹配范围值</strong><br>  匹配某一范围内的值</li>
<li><strong>精确匹配某一列并范围匹配另外一列</strong><br>  即第一列或几列是全值匹配，跟着一列是范围匹配，往后的列不能用于索引查询</li>
<li><strong>只访问索引的查询</strong><br>  B-Tree通常可以支持“只访问索引的查询”，即查询只需要访问索引，而无须访问数据行</li>
</ul>
<p>B-Tree索引的限制：</p>
<ul>
<li>如果不是按照索引的最左列开始查找，则无法使用索引。</li>
<li>不能跳过索引中的列</li>
<li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查询。</li>
</ul>
<p>索引列的顺序很重要：这些限制都和索引列的顺序有关。在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。</p>
<h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p>
<p>在Mysql中，只有Memory引擎显式支持哈希索引。这也是Memory引擎表的默认索引类型，Memory引擎同时也支持B-Tree索引。值得一提的是，Memory引擎是支持非唯一哈希索引的，这在数据库世界里面是比较与众不同的。如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中。</p>
<p>例如：<br>创建一个测试表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `testhash` (</div><div class="line">  `fname` varchar(50) COLLATE utf8_unicode_ci NOT NULL,</div><div class="line">  `lanme` varchar(50) COLLATE utf8_unicode_ci NOT NULL,</div><div class="line">  KEY `fname` (`fname`) USING HASH</div><div class="line">) ENGINE=MEMORY DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci</div></pre></td></tr></table></figure></p>
<p>表中数据如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select * from testhash;</div><div class="line">+-------+-----------+</div><div class="line">| fname | lanme     |</div><div class="line">+-------+-----------+</div><div class="line">| Arjen | Lentz     |</div><div class="line">| Baron | Schwartz  |</div><div class="line">| Peter | Zaitsev   |</div><div class="line">| Vadim | Tkachenko |</div><div class="line">+-------+-----------+</div><div class="line">4 行于数据集 (0.05 秒)</div></pre></td></tr></table></figure></p>
<p>假设索引使用假想的哈希函数f(),它返回下面的值（都是示例数据，非真实数据）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">f(&apos;Arjen&apos;)=2323</div><div class="line">f(&apos;Baron&apos;)=7437</div><div class="line">f(&apos;Peter&apos;)=8784</div><div class="line">f(&apos;Vadim&apos;)=2458</div></pre></td></tr></table></figure></p>
<p>则哈希索引的数据结构如下：</p>
<table>
<thead>
<tr>
<th>槽（Slot）</th>
<th>值（Value）</th>
</tr>
</thead>
<tbody>
<tr>
<td>2323</td>
<td>指向第1行的指针</td>
</tr>
<tr>
<td>2458</td>
<td>指向第4行的指针</td>
</tr>
<tr>
<td>7437</td>
<td>指向第2行的指针</td>
</tr>
<tr>
<td>8784</td>
<td>指向第3行的指针</td>
</tr>
</tbody>
</table>
<p>注意每个槽的编号是顺序的，但是数据行不是，现在来看如下查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT lanme FROM testhash WHERE fname = &apos;Peter&apos;;</div></pre></td></tr></table></figure></p>
<p>MySQL先计算’Peter’的哈希值，并使用该值寻找对应的记录指针。因为f(‘Peter’)=8784，索引MySQL在索引中查找8784，可以找到指向第3行的指针，最后一步是比较第3行的值是否为’Peter’，以确保就是要查找的行。</p>
<p>因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引查找的速度非常快。然而，哈希索引也有它的限制：</p>
<ul>
<li><strong>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行</strong>。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显。</li>
<li><strong>哈希索引数据并不是按照索引值顺序存储的，而是按照索引值的哈希值大小存储的，原数据的大小跟索引值的哈希值大小并不一致，所以也就无法用于排序</strong>。</li>
<li><strong>哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的</strong>。例如，在数据列（A，B）上建立哈希索引，如果查询只有数据列A，则无法使用该索引。</li>
<li><p><strong>哈希索引只支持等值比较查询，包括=，IN()，&lt;=&gt;（注意，&lt;&gt;和&lt;=&gt;是不同的操作），也不支持任何范围查询</strong>。例如WHERE price &gt; 100。<br>  注：&lt;=&gt;用于比较可能含有NULL的值，如</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">... WHERE col_a &lt;=&gt; ? ...</div></pre></td></tr></table></figure>
<p>  这里的占位符有可能是常量也有可能是NULL，当使用&lt;=&gt;运算符时，你没有必要对查询语句做任何修改。</p>
</li>
<li><strong>访问哈希索引的数据非常快，除非有很多哈希冲突（不同的索引列值却有相同的哈希值）</strong>。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。</li>
<li><strong>如果哈希冲突很多的话，一些索引维护操作的代价也会很高</strong>。例如，如果在某个选择性很低 （哈希冲突很多）的列上建立哈希索引，那么当从表中删除一行时，存储引擎需要遍历对应哈希值的链表中的每一行，找到并删除对应行的引用，冲突越多，代价越大。</li>
</ul>
<h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><p>最常见的B-Tree索引，按照顺序存储数据，所以MySQL可以用来做ORDER BY和GROUP BY操作。因为数据是有序的，所以B-Tree也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询。据此特性，总结下来索引有如下三个优点：</p>
<ul>
<li>索引大大减少了服务器需要扫描的数据量</li>
<li>索引可以帮助服务器避免排序和临时表</li>
<li>索引可以将随机I/O变为顺序I/O</li>
</ul>
<h2 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h2><h3 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h3><p>如果查询中的列不是独立的，则MySQL就不会使用索引。“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。<br>例如，下面这个查询无法使用actor_id列的索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT actor_id FORM sakila.actor WHERE actor_id + 1 = 5</div></pre></td></tr></table></figure></p>
<h3 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h3><p>通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。<strong>索引的选择性是指，不重复的索引值（也称为基数，cardinality）和数据表的记录总数（#T）的比值，范围从1/#T到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的</strong>。</p>
<p>一般情况下某个列前缀的选择性也是足够高的，足以满足查询性能。对于OLOB，TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。</p>
<p>诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间）。前缀应该足够长，以使得前缀索引的选择性接近于索引整个列。换句话说，前缀的“基数”因该接近于完整列的“<strong>基数</strong>”。</p>
<p>选择合适的前缀需要反复进行实验：比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT COUNT(*) AS cnt, LEFT(city, 7) AS pref FROM sakila.city_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10;</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>cnt</th>
<th>pref</th>
</tr>
</thead>
<tbody>
<tr>
<td>70</td>
<td>Santing</td>
</tr>
<tr>
<td>68</td>
<td>San Fel</td>
</tr>
<tr>
<td>65</td>
<td>London</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>不断改变前缀的长度，发现长度为7时最合适。</p>
<p>计算合适的前缀长度的另外一个办法就是计算完整列的选择性，并使前缀的选择性接近于完整列的选择性。下面显示如何计算完整列的选择性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT COUNT(DISTINCT city) / COUNT(*) FROM sakila.city_demo;</div><div class="line"></div><div class="line">+---------------------------------+</div><div class="line">| COUNT(DISTINCT city) / COUNT(*) | </div><div class="line">+---------------------------------+</div><div class="line">|  0.0312                         |</div><div class="line">+---------------------------------+</div></pre></td></tr></table></figure></p>
<p>下面演示一下如何创建前缀索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; ALTER TABLE sakila.city_demo ADD KEY (city(7));</div></pre></td></tr></table></figure></p>
<p><strong>前缀索引是一种能使索引更小，更快的有效办法，但另一方面也有其缺点：MySQL无法使用前缀索引做ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描</strong>。</p>
<h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p>在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。MySQL5.0和更新版本引入了一种叫“<strong>索引合并</strong>”（index merge）策略，一定程度上可以使用表上的多个单列索引来定位指定的行。</p>
<p>在MySQL5.0和更新的版本中，查询能够同时使用这两个单列索引进行扫描，并将扫描结果进行合并。这种算法有三个变种：</p>
<ul>
<li>OR条件的联合（union）</li>
<li>AND条件的相交（intersection）</li>
<li>组合前两种情况的联合及相交</li>
</ul>
<p>例如有单索引列actor_id和film_id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT film_id, actor_id FROM sakila.film_actor WHERE actor_id = 1 OR film_id = 1;</div></pre></td></tr></table></figure></p>
<p>索引合并策略有时候是一种优化的结果，但实际上更多时候说明了表上的索引建得很糟糕：</p>
<ul>
<li>当出现服务器对多个索引做相交操作时（通常有多个AND条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。</li>
<li>当服务器需要对多个索引做联合操作时（通常有多个OR条件），通常需要耗费大量CPU和内存资源在算法的缓存，排序和合并操作上。特别是当其中有些索引的选择性不高，需要合并并扫描返回的大量数据的时候。</li>
<li>更重要的是，优化器不会把这些计算到“查询成本”（cost）中，优化器只关心随机页面读取。这会使得查询的成本被“低估”，导致该执行计划还不如直接走全表扫描。这样做不但会消耗更多的CPU和内存资源，还可能会影响查询的并发性，但如果是单独运行这样的查询则往往会忽略对并发性的影响。</li>
</ul>
<h3 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h3><p>在一个多列B-Tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。所以，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的ORDER BY 和 GROUP BY 和 DISTINCT 等子句的查询需求。</p>
<p>多列索引的列顺序至关重要。<strong>对于如何选择索引的列顺序有一个经验法则：将选择性最高的列放到索引最前列</strong>。</p>
<p>当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的。</p>
<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。当表有聚簇索引时，它的数据行实际上存放在索引的叶子页（leaf page）中。术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<p>因为是存储引擎负责实现索引，因此不是所有的存储引擎都支持聚簇索引。</p>
<p>InnoDB将通过主键聚集数据。如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引。InnoDB会隐式定义一个主键来作为聚簇索引。InnoDB只聚集在同一个页面中的记录。包含相邻键值的页面可能会相距甚远。</p>
<p>聚集数据的一些重要的优点：</p>
<ul>
<li>可以把相关数据保存到一起。</li>
<li>数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找更快。</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值</li>
</ul>
<p>聚簇索引的一些缺点：</p>
<ul>
<li>聚簇数据最大限度地提高了I/O密集型应用的性能。但如果数据全部都放在内存中，则访问的顺序就没那么重要了，聚簇索引也就没什么优势了。</li>
<li>插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用<code>OPTIMIZE TABLE</code>命令重新组织一下表。</li>
<li>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。</li>
<li>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂（page split）”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳改行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间。</li>
<li>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。</li>
<li>二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。</li>
<li>二级索引访问需要两次索引查找，而不是一次。要记住，二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。</li>
</ul>
<h3 id="InnoDB和MyISAM的数据分布对比"><a href="#InnoDB和MyISAM的数据分布对比" class="headerlink" title="InnoDB和MyISAM的数据分布对比"></a>InnoDB和MyISAM的数据分布对比</h3><p>来看看InnoDB和MyISAM是如何存储下面这个表的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE layout_test (</div><div class="line"> col1 int not null,</div><div class="line"> col2 int not null,</div><div class="line"> PRIMARY KEY(col1),</div><div class="line"> KEY(col2)</div><div class="line">);</div></pre></td></tr></table></figure></p>
<h6 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h6><p>MyISAM按照数据插入的顺序存储在磁盘上，如下图：<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/MyISAM1.jpeg" alt="image"><br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/MyISAM2.jpeg" alt="image"><br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/MyISAM3.jpeg" alt="image"></p>
<h6 id="InnoDB的数据分布"><a href="#InnoDB的数据分布" class="headerlink" title="InnoDB的数据分布"></a>InnoDB的数据分布</h6><p><img src="https://raw.githubusercontent.com/clq2owesome/image/master/MyISAM4.jpeg" alt="image"><br>该图显示了整个表，而不是只有索引。因为在InnoDB中，聚簇索引“就是”表，所以不像MyISAM那样需要独立的行存储。</p>
<p><strong>聚簇所以的每一个叶子节点都包含了主键值，事务ID，用于事务和MVCC的回滚指针以及所有的剩余列。如果主键是一个列前缀索引，InnoDB也会包含完整的主键列和剩下的其他列</strong>。</p>
<p>还有一点和MyISAM的不同是，InnoDB的二级索引和聚簇索引很不同。InnoDB二级索引的叶子节点中存储的不是“行指针”，而是主键值，并以此作为指向行的“指针”。这样的策略减少了当出现行一定或者数据页分裂时二级索引的维护工作。使用主键值当作指针会让二级索引占用更多的空间，换来的好处是，InnoDB在移动行时无须更新二级索引中的这个“指针”。</p>
<p>下面是二级索引分布图：<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/MyISAM5.jpeg" alt="image"></p>
<p>下图是描述InnoDB和MyISAM如何存放表的抽象图：<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/MyISAM6.jpeg" alt="image"></p>
<h3 id="在InnoDB表中按主键顺序插入行"><a href="#在InnoDB表中按主键顺序插入行" class="headerlink" title="在InnoDB表中按主键顺序插入行"></a>在InnoDB表中按主键顺序插入行</h3><p>如果正在使用InnoDB表并且没有什么数据需要聚集，那么可以定义一个代理键（surrogate key）作为主键，这种主键的数据应该和应用无关，最简单的方法是使用<code>AUTO_INCREMENT</code>自增列。这样可以保证数据行是按顺序写入，对于根据主键做关联操作的性能会更好。</p>
<p>向聚簇索引中顺序插入数据：<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/MyISAM7.jpeg" alt="image"><br>因为主键的值是顺序的，所以InnoDB把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时（InnoDB默认最大填充因子是页大小的15/16，流出部分空间用于以后修改），下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满，这页正是所期望的结果（然而，二级索引页可能是不一样的）。</p>
<p>最好避免随机的（不连续且值的分布范围非常大）聚簇索引，特别是对于I/O密集型的应用。例如，从性能的角度考虑，使用UUID来作为聚簇索引则会很糟糕：它使得聚簇索引的插入变得完全随机，这是最坏的情况，使得数据没有任何聚集特性。</p>
<p>随机聚簇索引的缺点：</p>
<ul>
<li>写入的目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，InnoDB在插入之前不得不先找到并从磁盘读取目标页到内存中。这将导致大量的随机I/O</li>
<li>因为写入是乱序的，InnoDB不得不频繁地做页分裂操作，以便为新的行分配空间，页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个页。</li>
<li>由于频繁的页分裂，页会变得稀疏并被不规则填充，所以最终数据会有碎片。</li>
</ul>
<p>在把这些随机值载入到聚簇索引以后，也行需要做一次<code>OPTIMIZE TABLE</code>来重建表并优化页的填充。</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。</p>
<p>覆盖索引是非常有用的工具，能够极大地提高性能。考虑一下如果查询只需要扫描索引而无须回表，会带来多少好处：</p>
<ul>
<li><strong>索引条目通常远小于数据行大小，所以如果只需要读取索引，那MySQL机会极大地减少数据访问量</strong>。这对缓存负载非常重要，因为这种情况下响应时间大部分花费在数据拷贝上。覆盖索引对于I/O密集型的应用也有帮助，因为索引比数据更小，更容易全部放入内存中（这对于MyISAM尤其正确，因为MyISAM能压缩索引以变的更小）。</li>
<li><strong>因为索引是按照列值顺序存储的（至少在单个页内是如此），所以对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少的多</strong>。</li>
<li><strong>一些存储引擎如MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存</strong>，因此要访问数据需要一次系统调用。这可能会导致严重的性能问题，尤其是那些系统调用占了数据访问中的最大开销的场景。</li>
<li>由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。</li>
</ul>
<p><strong>不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引列的值，而哈希索引，空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引</strong>。另外，不同的存储引擎实现覆盖索引的方式也不同，而且不是所有的引擎都支持覆盖索引。</p>
<p>比如，表inventory有一个多列索引（store_id, film_id）。MySQL如果只需访问这两列，就可以使用这个索引做覆盖索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT store_id, film_id FROM inventory;</div></pre></td></tr></table></figure></p>
<p>下面的查询不会使用覆盖查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT * FROM products WHERE actor=&apos;SEAN CARREY&apos; AND title like &apos;%APOLLO%&apos;</div></pre></td></tr></table></figure></p>
<p>这里的索引无法覆盖该查询，有两个原因：</p>
<ul>
<li>没有任何索引能够覆盖这个查询。因为查询从表中选择了所有的列，而没有任何索引覆盖了所有的列。不过，理论上MySQL还有一个捷径可以利用：WHERE条件中的列是由索引可以覆盖的，因此MySQL可以使用该索引找到对应的actor并检查title是否匹配，过滤之后再读取需要的数据行。</li>
<li>MySQL不能在索引中执行LIKE操作。MySQL能在索引中做最左前缀匹配的LIKE比较，因为该操作可以转换为简单的比较操作，但是如果是通配符开头的LIKE查询，存储引擎就无法做比较匹配。这种情况下，MySQL服务器只能提取数据行的值而不是索引值来做比较。</li>
</ul>
<p>也有办法可以解决上面说的两个问题，需要重写查询并巧妙地设计索引。先将索引扩展至覆盖三个数据列（artist, title, prod_id），然后按如下方式重写查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT * FROM products JOIN (</div><div class="line">-&gt; SELECT prod_id FROM products WHERE actor=&apos;SEAN CARREY&apos; AND title LIKE &apos;%APOLLO&apos;</div><div class="line">-&gt; ) AS t1 ON (t1.prod_id = products.prod_id)</div></pre></td></tr></table></figure></p>
<p>我们把这种方式叫做“<strong>延迟关联（deferred join）</strong>”,因为延迟了对列的访问。在查询的第一阶段MySQL可以使用覆盖索引，在FROM子句的子查询中找到匹配的prod_id，然后根据这些prod_id值在外层查询匹配获取需要的所有列值。虽然无法使用索引覆盖整个查询，但总算比完全无法利用索引覆盖好。</p>
<h3 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h3><p>MySQL有两种方式可以生成有序的结果：</p>
<ul>
<li>通过排序操作</li>
<li>按索引顺序扫描</li>
</ul>
<p><strong>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一张表时，才能使用索引做排序。ORDER BY子句和查找型查询的限制是一样的：需要满足索引的最左前缀的要求，否则MySQL都需要执行排序操作，而无法利用索引排序</strong>。</p>
<p>有一种情况下ORDER BY子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。如果WHERE子句或者JOIN子句对这些列指定了常量，就可以“弥补”索引的不足。</p>
<p>例如：表rental在列（rental_data，inv_id, cust_id）上设置了索引，则以下SQL语句可以用索引排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT rental_id, staff_id FROM rental WHERE retal_data = &apos;2018-01-01&apos; ORDER BY inv_id, cust_id;</div><div class="line"></div><div class="line">mysql&gt; ... WHERE retal_data = &apos;2018-01-01&apos; ORDER BY inv_id DESC;</div><div class="line"></div><div class="line">mysql&gt; ... WHERE retal_data &gt; &apos;2018-01-01&apos; ORDER BY retal_date, inv_id;</div></pre></td></tr></table></figure></p>
<p>下面是一些不能使用索引做排序的查询：</p>
<ol>
<li><p>这个查询使用了两种不同的排序方向，但是索引列都是正序排序的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; ... WHERE retal_data = &apos;2018-01-01&apos; ORDER BY inv_id DESC, cust_id ASC;</div></pre></td></tr></table></figure>
</li>
<li><p>这个查询的ORDER BY 子句中引用了一个不在索引中的列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; ... WHERE retal_data = &apos;2018-01-01&apos; ORDER BY inv_id, staff_id</div></pre></td></tr></table></figure>
</li>
<li><p>这个查询的WHERE 和 ORDER BY中的列无法组合成索引的最左前缀：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; ... WHERE retal_data = &apos;2018-01-01&apos; ORDER BY cust_id;</div></pre></td></tr></table></figure>
</li>
<li><p>这个查询在索引列的第一列上是范围条件，所以MySQL无法使用索引的其余列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; ... WHERE retal_data &gt; &apos;2018-01-01&apos; ORDER BY inv_id, cust_id;</div></pre></td></tr></table></figure>
</li>
<li><p>这个查询在inv_id列上有多个等于条件。对于排序来说，这也是一种范围查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; ... WHERE retal_data = &apos;2018-01-01&apos; AND inv_id IN(1,2) ORDER BY cust_id;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="压缩（前缀压缩）索引"><a href="#压缩（前缀压缩）索引" class="headerlink" title="压缩（前缀压缩）索引"></a>压缩（前缀压缩）索引</h3><p>MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中，这在某些情况下能极大地提高性能。默认只压缩字符串，但通过参数设置也可以对整数做压缩。</p>
<p><strong>MyISAM压缩每个索引块的方法是，先完全保存索引块中的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分，把这部分存储起来即可。例如，索引块中第一个值是“perfform”，第二值是“performance”，那么第二个值的前缀压缩后存储的是类似“7,ance”这样的形式。MyISAM对行指针也采用类似的前缀压缩方式</strong>。</p>
<p>压缩块使用更少的空间，代价是某些操作可能更慢。因为每个值的压缩前缀都依赖前面的值，所以MyISAM查找时无法在索引块使用二分查找而只能从从头开始扫描。正序的扫描速度还不错，但是如果是倒序扫描就不是很好了。</p>
<h3 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h3><p>MySQL允许在相同列上创建多个索引。重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。应该避免这样创建重复索引，发现以后也应该立即移除。</p>
<p>冗余索引通常发生在为表添加新索引的时候。例如有人可能会添加一个新的索引（A,B）而不是扩展已有的索引（A）。还有一种情况是将一个索引扩展为（A, ID），其中ID是主键，对于InnoDB来说主键列已经包含在二级索引中了，所以这也是冗余的。</p>
<p>大多数情况下都不需要冗余索引，应该尽量扩展已有的索引而不是创建新索引。但也有时候出于性能方面的考虑需要冗余索引，因为扩展已有的索引会导致其变的太大，从而影响其他使用该索引的查询的性能。</p>
<p>表中的索引越多插入速度会越慢。一般来说，增加新索引将会导致INSERT，UPDATE，DELETE等操作的速度变慢，特别是新增索引后导致达到了内存瓶颈的时候。</p>
<p>可以使用Percona Toolkit中的<code>pt-duplicate-key-checker</code>分析表结构来找出冗余和重复的索引。</p>
<h3 id="未使用的索引"><a href="#未使用的索引" class="headerlink" title="未使用的索引"></a>未使用的索引</h3><p>可以使用Percona Toolkit中的<code>pt-index-usage</code>，该工具可以读取查询日志，并对日志中的每条查询进行EXPLAIN操作，然后打印出关于索引和查询的报告。</p>
<h3 id="索引的锁"><a href="#索引的锁" class="headerlink" title="索引的锁"></a>索引的锁</h3><p>InnoDB只有在访问行的时候才会对其加锁，而索引能够减少InnoDB访问的行数，从而减少锁的数量。但这只有当InnoDB在存储引擎层能够过滤掉所有不需要的行时才有效。如果索引无法过滤掉无效的行，那么在InnoDB检索到数据并返回给服务器层以后，MySQL服务器才能应用WHERE子句。</p>
<p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">mysql&gt; set AUTOCOMMIT=0;</div><div class="line">mysql&gt; BEGIN;</div><div class="line">mysql&gt; SELECT actor_id FROM actor WHERE actor_id &lt; 5 AND actor_id &lt;&gt; 1 FOR UPDATE;</div><div class="line"></div><div class="line">+----------+</div><div class="line">| actor_id | </div><div class="line">+----------+</div><div class="line">| 2        |</div><div class="line">| 3        |</div><div class="line">| 4        |</div><div class="line">+----------+</div></pre></td></tr></table></figure></p>
<p>这条查询仅仅会返回2～4之间的行，但是实际上获取了1～4之间的行的排他锁。InnoDB会锁住第一行。此时其他事务想获取第一行数据时不得不等待。</p>
<p>关于InnoDB，索引和锁有一些很少有人知道的细节：InnoDB在二级索引上使用共享（读）锁，但访问主键索引需要排他（写）锁。这消除了使用覆盖索引的可能性，并且使得<code>SELECT FOR UPDATE</code> 比 <code>LOCK IN SHARE MODE</code> 或 非锁定查询要慢很多。</p>
<h3 id="优化排序"><a href="#优化排序" class="headerlink" title="优化排序"></a>优化排序</h3><p>对于那些选择性非常低的列，可以增加一些特殊的索引来做排序。例如，可以创建（sex, rating）索引用于下面的查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT &lt;cols&gt; FROM profiles WHERE sex=&apos;M&apos; ORDER BY rating LIMIT 10;</div></pre></td></tr></table></figure></p>
<p>这个查询同时使用了ORDER BY 和 LIMIT，如果没有索引的话会很慢。</p>
<p>即使有索引，如果用户界面上需要翻页，并且翻页到比较靠后时查询也可能非常慢。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt;SELECT &lt;cols&gt; FROM profiles WHERE sex=&apos;M&apos; ORDER BY rating LIMIT 100000, 10;</div></pre></td></tr></table></figure></p>
<p>无论如何创建索引，这种查询都是个严重的问题，因为随着偏移量的增加，MySQL需要花费大量的时间来扫描需要丢弃的数据。一个更好的办法是限制用户能够翻页的数量，实际上这对用户体验的影响不大，因为用户很少会真正在乎搜索结果的第100000页。</p>
<p>优化这类搜索的另一个比较好的策略是使用延迟关联，通过使用覆盖索引查询返回需要的主键，再根据这些主键关联原来的表获取需要的行。这可以减少MySQL扫描那些需要丢弃的行数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT &lt;cols&gt; FROM profiles INNER JOIN (</div><div class="line">-&gt; SELECT &lt;primary key cols&gt; FROM profiles</div><div class="line">-&gt; WHERE x.sex=&apos;M&apos; ORDER BY rating LIMIT 100000, 10</div><div class="line">-&gt; ) AS x USING(&lt;primary key cols&gt;);</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/数据库相关/mysql/创建高性能的索引/" data-id="cjei97ehr00d489blisxqgz9n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux/别名，历史命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Linux/别名，历史命令/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Linux/别名，历史命令/">别名，历史命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="设置和取消别名（alias，unalias）"><a href="#设置和取消别名（alias，unalias）" class="headerlink" title="设置和取消别名（alias，unalias）"></a>设置和取消别名（alias，unalias）</h3><p>alias的定义规则和变量定义规则几乎相同，所以你只要在alias后面加上你的（”别名”=’命令参数…’）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alias lm=&apos;ls -l | more&apos;</div></pre></td></tr></table></figure></p>
<p>取消别名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unalias lm</div></pre></td></tr></table></figure></p>
<h3 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">history [n]</div><div class="line">history [-c]</div><div class="line">history [-raw] histfiles</div><div class="line">参数：</div><div class="line">n：数字，是要列出最近的n条命令行</div><div class="line">-c：将目前的shell中的所有history内容全部消除</div><div class="line">-a：将目前新增的history命令新增入histfiles中，若没有加histfiles，则默认写入~/.bash_history</div><div class="line">-r：将histfiles的内容读到目前这个shell的history记忆中</div><div class="line">-w：将目前的history记忆内容写入histfiles中</div><div class="line"></div><div class="line"></div><div class="line">!number</div><div class="line">!command</div><div class="line">!!</div><div class="line">参数：</div><div class="line">number：执行第几条命令</div><div class="line">command：由最近的命令向前搜寻命令串开头为command的那个命令，并执行</div><div class="line">!!：就是执行上一条命令（相当于按↑按键后，按[Enter]）</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Linux/别名，历史命令/" data-id="cjei97eax000x89blbkd83p2k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux/文件和目录管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Linux/文件和目录管理/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Linux/文件和目录管理/">文件和目录管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="显示目前所在的目录（pwd）"><a href="#显示目前所在的目录（pwd）" class="headerlink" title="显示目前所在的目录（pwd）"></a>显示目前所在的目录（pwd）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pwd [-P]</div><div class="line">参数：</div><div class="line">-P：显示出当前的路径，而非使用连接路径</div></pre></td></tr></table></figure>
<h3 id="新建目录（mkdir）"><a href="#新建目录（mkdir）" class="headerlink" title="新建目录（mkdir）"></a>新建目录（mkdir）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir [-mp] 目录名称</div><div class="line">参数：</div><div class="line">-m：配置目录的权限，直接设置，不需要看默认权限（umask）</div><div class="line">-p：帮助你直接将所需的目录（包含上层目录）递归创建起来</div></pre></td></tr></table></figure>
<h3 id="删除空的目录（rmdir）"><a href="#删除空的目录（rmdir）" class="headerlink" title="删除空的目录（rmdir）"></a>删除空的目录（rmdir）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rmdir [-p] 目录名称</div><div class="line">参数：</div><div class="line">-p：连同上层“空的”目录也一起删除</div></pre></td></tr></table></figure>
<h3 id="查看文件与目录（ls）"><a href="#查看文件与目录（ls）" class="headerlink" title="查看文件与目录（ls）"></a>查看文件与目录（ls）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ls [-aAdfFhilnrRSt] 目录名称</div><div class="line">参数：</div><div class="line">-a：全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用）</div><div class="line">-d：仅列出目录本身，而不是列出目录内的文件数据（常用）</div><div class="line">-l：列出长数据串，包含文件的属性与权限等数据（常用）</div></pre></td></tr></table></figure>
<h3 id="复制文件或目录（cp）"><a href="#复制文件或目录（cp）" class="headerlink" title="复制文件或目录（cp）"></a>复制文件或目录（cp）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">cp [-adfilprsu] 源文件（source） 目标文件（destination）</div><div class="line">cp [options] source1 source2 source3 ... directory</div><div class="line">参数：</div><div class="line">-a：相当于-pdr的意思（常用）</div><div class="line">-i：若目标文件已经存在时，在覆盖时会先询问操作的进行（常用）</div><div class="line">-r：递归持续复制，用于目录的复制行为（常用）</div><div class="line">-d：若源文件为连接文件的属性，则复制连接文件属性而非文件本身</div><div class="line">-p：连同文件的属性一起复制过期，而非使用默认属性（备份常用）</div></pre></td></tr></table></figure>
<p>在默认的条件中，cp的源文件与目的文件的权限是不同的，目的文件的所有者通常会是命令操作者本身</p>
<p>由于具有这个特性，因为当我们在进行备份的时候，某些需要特别注意的特殊权限文件，例如密码文件（/etc/shadow）以及一些配置文件，就不能直接以cp来复制，而必须要加上-a或者是-p等可以完整复制文件权限的参数才行。另外，如果你想要复制文件给其他的用户，也必须要注意到文件的权限（包含读，写，执行以及文件所有者等），否则，其他人还是无法针对你给予的文件进行修订的操作</p>
<h3 id="移除文件或目录（rm）"><a href="#移除文件或目录（rm）" class="headerlink" title="移除文件或目录（rm）"></a>移除文件或目录（rm）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">rm [-fir] 文件或目录</div><div class="line">参数：</div><div class="line">-f：就是force意思，忽略不存在的文件，不会出现警告信息</div><div class="line">-i：互动模式，在删除前会询问用户是否操作</div><div class="line">-r：递归删除，最常用在目录的删除了，这是个非常危险的参数！！！！</div></pre></td></tr></table></figure>
<h3 id="移动文件与目录，或更名（mv）"><a href="#移动文件与目录，或更名（mv）" class="headerlink" title="移动文件与目录，或更名（mv）"></a>移动文件与目录，或更名（mv）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mv [-fiu] source destination</div><div class="line">mv [options] source1 source2 source3 ... directory</div><div class="line">参数：</div><div class="line">-f：就是force强制的意思，如果目标文件以及存在，不会询问直接覆盖</div><div class="line">-i：若目标文件已经存在时，就会询问是否覆盖</div><div class="line">-u：若目标文件已经存在，且source比较新，才会更新</div></pre></td></tr></table></figure>
<h3 id="取得路径的文件名与目录名称（basename，dirname）"><a href="#取得路径的文件名与目录名称（basename，dirname）" class="headerlink" title="取得路径的文件名与目录名称（basename，dirname）"></a>取得路径的文件名与目录名称（basename，dirname）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">basename /etc/sysconfig/network</div><div class="line">network #取得最后的文件名</div><div class="line"></div><div class="line">dirname /etc/sysconfig/network</div><div class="line">/etc/sysconfig #取得目录名</div></pre></td></tr></table></figure>
<h3 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="文件内容查阅"></a>文件内容查阅</h3><ul>
<li>cat：由第一行开始显示文件内容</li>
<li>tac：从最后一行开始显示，可以看出tac是cat的倒写形式</li>
<li>nl：显示的时候，顺便输出行号</li>
<li>more：一页一页地显示文件内容</li>
<li>less：与more类似，但是比more更好的是，它可以往前翻页</li>
<li>head：只看头几行</li>
<li>tail：只看结尾几行</li>
<li>od：以二进制的方式读取文件内容</li>
</ul>
<h5 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cat [-AbEnTv]</div><div class="line">参数：</div><div class="line">-n：打印出行号，连同空白行也会有行号</div></pre></td></tr></table></figure>
<h5 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">nl [-bnw] 文件</div><div class="line">参数：</div><div class="line">-b：指定行号指定的方式，主要有两种：</div><div class="line">    -b a：表示不论是否为空行，也同样列出行号（类似 cat -n）</div><div class="line">    -b t：如果有空行，空的那一行不要列出行号（默认值）</div><div class="line">-n：列出行号的表示方法，主要有三种：</div><div class="line">    -n ln：行号在屏幕的最左方显示</div><div class="line">    -n rn：行号在自己字段的最右方显示，且不加0</div><div class="line">    -n rz：行号在自己字段的最右方显示，且加0</div><div class="line">-w：行号字段占用的位数</div></pre></td></tr></table></figure>
<h5 id="more"><a href="#more" class="headerlink" title="more"></a>more</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">空格键：向下翻一页</div><div class="line">Enter：向下滚一行</div><div class="line">/字符串</div><div class="line">:f：立刻显示出文件名以及目前显示的行数</div><div class="line">q：立刻离开more，不再显示该文件内容</div><div class="line">b：往回翻页，不过这操作只对文件有用，对管道无用</div></pre></td></tr></table></figure>
<h5 id="less"><a href="#less" class="headerlink" title="less"></a>less</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">空格键：向下翻一页</div><div class="line">[PageDown]：向下翻动一页</div><div class="line">[PageUp]：向上翻动一页</div><div class="line">/字符串：向下查询“字符串”的功能</div><div class="line">?字符串：向上查询“字符串”的功能</div><div class="line">n：重复前一个查询（与/或?有关）</div><div class="line">N：反向重复前一个查询（与/或?有关）</div><div class="line">q：离开</div></pre></td></tr></table></figure>
<h5 id="head"><a href="#head" class="headerlink" title="head"></a>head</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">head [-n number] 文件</div><div class="line">参数：</div><div class="line">-n：后面接数字，代表显示几行的意思（默认显示10行）</div></pre></td></tr></table></figure>
<h5 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tail [-n number] 文件</div><div class="line">参数：</div><div class="line">-n：后面接数字，代表显示几行的意思</div><div class="line">-f：表示持续输出文件内容，要等到按下[ctrl]+c才会结束tail的输出</div></pre></td></tr></table></figure>
<h3 id="修改文件时间或创建新文件（touch）"><a href="#修改文件时间或创建新文件（touch）" class="headerlink" title="修改文件时间或创建新文件（touch）"></a>修改文件时间或创建新文件（touch）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">touch [-acdmt] 文件</div><div class="line">参数：</div><div class="line">-a：仅修改访问时间</div><div class="line">-c：仅修改文件的时间，若该文件不存在则不创建新文件</div><div class="line">-d：后面可以接欲修改的日期而不用目前的日期，也可以使用 --date=&quot;日期或时间&quot;</div><div class="line">-m：仅修改mtime</div><div class="line">-t：后面可以接欲修改的时间而不用目前的时间，格式为[YYMMDDhhmm]</div></pre></td></tr></table></figure>
<h3 id="文件默认权限（umask）"><a href="#文件默认权限（umask）" class="headerlink" title="文件默认权限（umask）"></a>文件默认权限（umask）</h3><p>umask就是指定“<strong>目前用户在新建文件或目录时候的权限默认值</strong>”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">umask</div><div class="line">0022</div><div class="line"></div><div class="line">umask -S</div><div class="line">u=rwx,g=rx,o=rx</div></pre></td></tr></table></figure></p>
<p>查看的方式有两种，一种可以直接输入umask，就可以看到数字形态的权限设置分数，一种则是加入-S这个参数，就会以符号类型的方式来显示出权限</p>
<p>在默认权限的属性上，目录与文件是不一样的，默认的情况如下：</p>
<ul>
<li>若用户创建“文件”则默认没有可执行（x）权限，即只有r，w这两个选项，也就是最大为666，默认权限为：<code>-rw-rw-rw-</code></li>
<li>若用户新建“目录”，则由于x与是否可以进入此目录有关，因此默认所有权限均开放，即为777，默认权限为：<code>drwxrwxrwx</code></li>
</ul>
<p>要注意的是，umask的分数是指“<strong>该默认值需要减掉的权限</strong>”。因为r，w，x分别是4，2，1，也就是说当要拿掉能写的权限，就是输入2，而如果要拿掉能读的权限，也就是4，那么要拿掉读与写的权限，也就是6，而要拿掉执行与写入的权限，也就是3，要拿掉读与执行的权限，也就是5</p>
<p>所以在设置了umask的时候，默认新建文件和目录的权限为：</p>
<ul>
<li>新建文件时：（-rw-rw-rw-）-（—–w–w-）==&gt;-rw-r–r–(644)</li>
<li>新建目录时：（drwxrwxrwx）-（d—-w–w-）==&gt;drwxr-xr-x(755)</li>
</ul>
<h3 id="命令与文件的查询"><a href="#命令与文件的查询" class="headerlink" title="命令与文件的查询"></a>命令与文件的查询</h3><h4 id="脚本文件名的查询（which）"><a href="#脚本文件名的查询（which）" class="headerlink" title="脚本文件名的查询（which）"></a>脚本文件名的查询（which）</h4><p>which是根据用户所设置的PATH变量内的目录去查找可执行文件的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">which [-a] command</div><div class="line">参数：</div><div class="line">-a：将所有有PATH目录中可以找到的命令均列出，而不只第一个被找到的命令名称</div></pre></td></tr></table></figure></p>
<h4 id="文件名的查询（whereis，locate）"><a href="#文件名的查询（whereis，locate）" class="headerlink" title="文件名的查询（whereis，locate）"></a>文件名的查询（whereis，locate）</h4><p>whereis与locate是利用数据库来查找数据，所以速度相当快速，而且并没有实际查询硬盘，比较节省时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">whereis [-bmsu] 文件或目录名</div><div class="line">参数：</div><div class="line">-b：只找二进制格式的文件</div><div class="line">-m：只找在说明文件mamual路径下的文件</div><div class="line">-s：只找source源文件</div><div class="line">-u：查找不在上述三个选项当中的其他特殊文件</div></pre></td></tr></table></figure></p>
<p>locate的使用更简单，直接在后面输入“文件的部分名称”后就能够得到结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">locate [-ir] keyword</div><div class="line">参数：</div><div class="line">-i：忽略大小写的差异</div><div class="line">-r：后面可接正则表达式的显示方式</div></pre></td></tr></table></figure></p>
<p>locate是依据/var/lib/mlocate内的数据库记载，查出用户输入的关键字文件名</p>
<p>可以输入<code>updatedb</code>来手动更新数据库，updatedb命令回去读取<code>/etc/updatedb.conf</code>这个配置文件的设置，然后再去硬盘里面进行查找文件名的操作，最后就更新整个数据库文件（/var/lib/mlocate）</p>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">find [PATH] [option] [action]</div><div class="line">参数：</div><div class="line">1.与时间有关的参数：共有-atime，-ctime，-mtime，下面以-mtime说明</div><div class="line">-mtime n：n为数字，意义为在n天之前的“一天之内”被更改过的文件</div><div class="line">-mtime +n：列出在n天之前（不含n天本身）被更改过的文件名</div><div class="line">-mtime -n：列出n天之内（含n本身）被更改过的文件名</div><div class="line">-newer file：file为一个存在的文件，列出比file还要新的文件名</div><div class="line"></div><div class="line">2.用户或用户组名有关的参数：</div><div class="line">-uid n：n为数字，这个数字是用户的账号ID，即UID，这个UID是记录在/etc/passwd里面与账号名称对应的数字</div><div class="line">-gid n：n为数字，这个数字是用户组名的ID，即GID，这个GID记录在/etc/group中</div><div class="line">-user name：name为用户账号名称</div><div class="line">-group name：name为用户组名称</div><div class="line">-nouser：寻找文件的所有者不在/etc/passwd的人</div><div class="line">-nogroup：选找文件的所有用户组不存在于/etc/group中的文件</div><div class="line">当你自行安装软件时，很可能该软件的属性当中并没有文件所有者，这是可能的，在这个时候，就可以使用-nouser和-nogroup查找</div><div class="line"></div><div class="line">3.与文件权限及名称有关的参数：</div><div class="line">-name filename：查找文件名为filename的文件</div><div class="line">-size [+-]SIZE:查找比SIZE还要大（+）或小（-）的文件，这个SIZE的规格有：</div><div class="line">    c：代表byte k：代表1024bytes 。所以，要找比50KB还要大的文件，就是“-size +50k”</div><div class="line">-type TYPE：查找文件的类型为TYPE的，类型主要有：一般正规文件（f），设备文件（b，c），目录（d），连接文件（l），socket（s）及FIFO（p）等属性</div><div class="line">-perm mode：查找文件权限“刚好等于”mode的文件，这个mode类似chmod的属性值，举例来说，-rwsr-xr-x的属性为4755</div><div class="line">-perm -mode：查找文件权限“必须要全部包括mode的权限”的文件，举例来说，我们要查找-rwxr--r--，即0744的文件，使用-perm -0744，当一个文件的权限为-rwsr-xr-x，即4755时，也会被列出，因为-rwsr-xr-x的属性已经包括了-rwxr--r--的属性了</div><div class="line">-perm +mode：查找文件权限“包含任一mode的权限”的文件，举例来说，我们查找-rwxr-xr-x，即-perm +755时，但一个文件属性为-rw-------也会被列出来，因为它有-rw...的属性存在</div><div class="line"></div><div class="line">4.其他可进行的操作：</div><div class="line">-exec command：command为其他命令，-exec后面可再接其他的命令来处理查找到的结果</div><div class="line">-print：将结果打印到屏幕上，这个操作是默认操作</div><div class="line"></div><div class="line">例子：find / -perm +7000 -exec ls -l &#123;&#125; \;</div><div class="line">&#123;&#125;代表的是“由find找到的内容”，find的结果会被放置在&#123;&#125;位置中</div><div class="line">-exec 一直到“\;”是关键字，代表find额外命令的开始（-exec）到结束（\;）,在这个中间的就是find命令内的额外命令，在本例中就是“ls -l &#123;&#125;”</div><div class="line">因为“;”在bash环境下是有特殊意义的，因此利用反斜杠来转义</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Linux/文件和目录管理/" data-id="cjei97eay000z89blc1qs79mr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux/权限相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Linux/权限相关/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Linux/权限相关/">权限相关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="列出所有的文件详细的权限与属性"><a href="#列出所有的文件详细的权限与属性" class="headerlink" title="列出所有的文件详细的权限与属性"></a>列出所有的文件详细的权限与属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ls -al</div><div class="line">drwxr-xr-x+  42 chenliqiang  staff   1344 12  2 14:20 .</div><div class="line">drwxr-xr-x    6 root         admin    192 11 15 11:23 ..</div><div class="line">-r--------    1 chenliqiang  staff      9 11 15 15:44 .CFUserTextEncoding</div><div class="line">-rw-r--r--@   1 chenliqiang  staff  18436 12  2 15:05 .DS_Store</div><div class="line">drwxr-xr-x   11 chenliqiang  staff    352  4 24  2017 .MarkEditorData</div><div class="line">drwx------    2 chenliqiang  staff     64 12  2 15:08 .Trash</div><div class="line">-rw-------    1 chenliqiang  staff  18925 12  2 14:31 .bash_history</div><div class="line">-rw-r--r--@   1 chenliqiang  staff    354 11 30 17:27 .bash_profile</div><div class="line">drwx------  459 chenliqiang  staff  14688 12  2 14:31 .bash_sessions</div><div class="line">drwx------    6 chenliqiang  staff    192 11 28 17:46 .config</div><div class="line">[权限]      [连接]   [所有者] [用户组] [容量：B] [修改时间]   [文件名]</div></pre></td></tr></table></figure>
<h4 id="第一列代表这个文件的类型与权限"><a href="#第一列代表这个文件的类型与权限" class="headerlink" title="第一列代表这个文件的类型与权限"></a>第一列代表这个文件的类型与权限</h4><h5 id="第一个字符代表这个文件是“目录，文件或链接文件等”"><a href="#第一个字符代表这个文件是“目录，文件或链接文件等”" class="headerlink" title="第一个字符代表这个文件是“目录，文件或链接文件等”"></a>第一个字符代表这个文件是“目录，文件或链接文件等”</h5><ul>
<li>d：目录</li>
<li>-：文件</li>
<li>l：连接文件</li>
<li>b：设备文件里面的可供存储的接口设备</li>
<li>c：设备文件里面的串行端口设备</li>
</ul>
<h5 id="接下来的字符中，以3个为一组，且均为“rwx”的3个参数的组合。其中-r-代表可读（read），-w-代表可写（write），-x-代表可执行（execute）"><a href="#接下来的字符中，以3个为一组，且均为“rwx”的3个参数的组合。其中-r-代表可读（read），-w-代表可写（write），-x-代表可执行（execute）" class="headerlink" title="接下来的字符中，以3个为一组，且均为“rwx”的3个参数的组合。其中[r]代表可读（read）， [w]代表可写（write），[x]代表可执行（execute）"></a>接下来的字符中，以3个为一组，且均为“rwx”的3个参数的组合。其中[r]代表可读（read）， [w]代表可写（write），[x]代表可执行（execute）</h5><p>注意：这3个权限的位置不会改变，如果没有权限，就会出现减号[-]而已</p>
<ul>
<li>第一组为“文件所有者的权限”</li>
<li>第二组为“同用户组的权限”</li>
<li>第三组为“其他非本用户组的权限”</li>
</ul>
<h3 id="查看文件或者目录的权限"><a href="#查看文件或者目录的权限" class="headerlink" title="查看文件或者目录的权限"></a>查看文件或者目录的权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">ls -l webapps</div><div class="line">total 0</div><div class="line">drwxr-xr-x  17 chenliqiang  staff   544  9 29 20:27 ROOT</div><div class="line">drwxr-xr-x  54 chenliqiang  staff  1728  9 29 20:27 docs</div><div class="line">drwxr-xr-x   8 chenliqiang  staff   256  9 29 20:27 examples</div><div class="line">drwxr-xr-x   7 chenliqiang  staff   224  9 29 20:27 host-manager</div><div class="line">drwxr-xr-x   8 chenliqiang  staff   256  9 29 20:27 manager</div><div class="line"></div><div class="line">//包括隐藏文件</div><div class="line">ls -al webapps</div><div class="line">total 16</div><div class="line">drwxr-xr-x   8 chenliqiang  staff   256 12  1 15:35 .</div><div class="line">drwxrwxr-x  14 chenliqiang  staff   448 11 30 15:52 ..</div><div class="line">-rw-r--r--@  1 chenliqiang  staff  6148 12  2 15:49 .DS_Store</div><div class="line">drwxr-xr-x  17 chenliqiang  staff   544  9 29 20:27 ROOT</div><div class="line">drwxr-xr-x  54 chenliqiang  staff  1728  9 29 20:27 docs</div><div class="line">drwxr-xr-x   8 chenliqiang  staff   256  9 29 20:27 examples</div><div class="line">drwxr-xr-x   7 chenliqiang  staff   224  9 29 20:27 host-manager</div><div class="line">drwxr-xr-x   8 chenliqiang  staff   256  9 29 20:27 manager</div></pre></td></tr></table></figure>
<h3 id="改变文件属性与权限"><a href="#改变文件属性与权限" class="headerlink" title="改变文件属性与权限"></a>改变文件属性与权限</h3><ul>
<li><code>chgrp</code>：改变文件所属用户组</li>
<li><code>chown</code>：改变文件所属者</li>
<li><code>chmod</code>：改变文件的权限</li>
</ul>
<h4 id="改变所属用户组：chgrp"><a href="#改变所属用户组：chgrp" class="headerlink" title="改变所属用户组：chgrp"></a>改变所属用户组：chgrp</h4><p>注意：要被改变的组名必须要在<code>/etc/group</code>文件内存在才行，否则就会显示错误</p>
<p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">chgrp [-R] 用户组名 目录名/文件名</div><div class="line">选项与参数：</div><div class="line">—R:进行递归（recursive）的持续更改，也即连同子目录下的所有文件，目录</div></pre></td></tr></table></figure></p>
<h4 id="改变文件所有者：chown"><a href="#改变文件所有者：chown" class="headerlink" title="改变文件所有者：chown"></a>改变文件所有者：chown</h4><p>注意：用户必须已经存在与系统中的账号，也就是在<code>/etc/passwd</code>这个文件中有记录的用户名称才能改变</p>
<p>chown还可以直接修改用户组的名称</p>
<p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">chown [-R] 用户名 目录名/文件名</div><div class="line">chown [-R] 用户名:组名 目录名/文件名</div><div class="line">chown [-R] 用户名.组名 目录名/文件名(不建议这样的写法，因为账号中可能会有小数点，如：vbird.tsai)</div><div class="line">选项与参数：</div><div class="line">—R:进行递归（recursive）的持续更改，也即连同子目录下的所有文件，目录</div></pre></td></tr></table></figure></p>
<h4 id="改变权限：chmod"><a href="#改变权限：chmod" class="headerlink" title="改变权限：chmod"></a>改变权限：chmod</h4><p>权限的设置方法有两种，可以使用数字或者是符号来进行权限的更改</p>
<h6 id="1-数字类型改变文件权限"><a href="#1-数字类型改变文件权限" class="headerlink" title="1.数字类型改变文件权限"></a>1.数字类型改变文件权限</h6><p>Linux文件的基本权限就有9个，分别是owner，group，others三种身份各有自己的read，write，execute权限</p>
<p>我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p>
<ul>
<li>r：4</li>
<li>w：2</li>
<li>x：1</li>
</ul>
<p>每种身份（owner，group，others）各自三个权限（r，w，x）分数是需要累加的，例如当权限为[-rwxrwx—],分数则是：</p>
<ul>
<li>owner=rwx=4+2+1=7</li>
<li>group=rwx=4+2+1=7</li>
<li>others=—=0+0+0=0</li>
</ul>
<p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">chmod [-R] rwx 目录名/文件名</div><div class="line">选项与参数：</div><div class="line">—R:进行递归（recursive）的持续更改，也即连同子目录下的所有文件，目录</div></pre></td></tr></table></figure></p>
<h6 id="2-符号类型改变文件权限"><a href="#2-符号类型改变文件权限" class="headerlink" title="2.符号类型改变文件权限"></a>2.符号类型改变文件权限</h6><p>user，group，others3种身份可以通过u，g，o来代表，此外，a代表all，也即全部的身份</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>身份简写</th>
<th>权限操作</th>
<th>权限</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>chmod</td>
<td><code>u:用户身份</code><br> <code>g:组身份</code><br> <code>o:其他身份</code><br> <code>a:所有身份</code><br></td>
<td>+（加入）<br> -（除去）<br>=（设置）</td>
<td>r <br>w <br>x</td>
<td>文件或者目录</td>
</tr>
</tbody>
</table>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1.设置一个文件的权限为“-rwxr-xr-x”</div><div class="line">chmod u=rwx,go=rx .bashrc  注意：那个u=rwx,go=rx是连在一起的，中间没有任何空格</div><div class="line"></div><div class="line">2.如果只想要增加.bashrc这个文件的每个人均可写入的权限，那么可以使用</div><div class="line">chmod a+w .bashrc</div><div class="line"></div><div class="line">3.去掉全部人的可执行权限</div><div class="line">chmod a-x .bashrc</div></pre></td></tr></table></figure></p>
<p>在+与-的状态下，只要是没有指定到的选项，则该权限“不会被变动”，例如上面的例子中，由于仅以-去掉x，则其他两个权限保持当时的值不变</p>
<p>如果让一个程序可以拥有执行的权限，但你又不知道该文件原本的权限，此时利用<code>chmod a+x filename</code>就可以让该程序拥有执行的权限了</p>
<h3 id="目录与文件的权限意义"><a href="#目录与文件的权限意义" class="headerlink" title="目录与文件的权限意义"></a>目录与文件的权限意义</h3><h4 id="权限对文件的重要性"><a href="#权限对文件的重要性" class="headerlink" title="权限对文件的重要性"></a>权限对文件的重要性</h4><ul>
<li>r：可读取此文件的实际内容，如读取文本文件的文字内容等</li>
<li>w：可以编辑，新增，或者是修改该文件的内容（但不含删除该文件）</li>
<li>x：该文件具有可以被系统执行的权限</li>
</ul>
<p>对于文件的r，w，x来说，主要都是针对“文件的内容”而言，与文件名的存在与否没有关系的，因为文件记录的是实际的数据</p>
<h4 id="权限对目录的重要性"><a href="#权限对目录的重要性" class="headerlink" title="权限对目录的重要性"></a>权限对目录的重要性</h4><p>文件是存放实际数据的所在，目录主要的内容是记录文件名列表，文件名与目录有强烈的关联</p>
<ul>
<li>r：表示具有读取目录结构列表的权限，所以当你具有读取一个目录的权限时，表示你可以查询该目录下的文件名数据</li>
<li>w：表示你具有更改该目录结构列表的权限，也就是下面这些权限<ul>
<li>新建心的文件与目录</li>
<li>删除已经存在的文件与目录</li>
<li>将已存在的文件或者目录进行重命名</li>
<li>转移该目录内的文件，目录位置</li>
</ul>
</li>
<li>x：<strong>目录的x代表的是用户能否进入该目录成为工作目录</strong>的用途。所谓的工作目录（work directory）就是你目前所在的目录。工作目录对于命令的执行是非常重要的，如果你在某目录下不具有x的权限，那么你就无法切换到该目录下，也就无法执行该目录下的任何命令，即使你具有该目录的r权限</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Linux/权限相关/" data-id="cjei97eaz001289blw82g7b9l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Eclipse/">Eclipse</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Github/">Github</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Cookie/">Cookie</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JAXB/">JAXB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JavaMail/">JavaMail</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/基础/">基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/数据类型/">数据类型</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/日记/">日记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/时间日期/">时间日期</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/线程/">线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/网络NIO/">网络NIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/队列/">队列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/集合/">集合</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Application-Event/">Application Event</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/JPA/">JPA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Security/">Security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Spring-Boot/">Spring Boot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Spring-Session/">Spring Session</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Task/">Task</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-MVC/">spring MVC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-data-redis/">spring data redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/基础/">基础</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/">前端技术相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/forever/">forever</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/javascript/">javascript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库相关/">数据库相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据库相关/mysql/">mysql</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/">服务器相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hessian/">Hessian</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hudson-Jenkins/">Hudson & Jenkins</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Memcached/">Memcached</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Nginx/">Nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Tomcat/">Tomcat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/red5/">red5</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/resin/">resin</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/正则表达式/">正则表达式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/08/正则表达式/正则表达式/">正则表达式</a>
          </li>
        
          <li>
            <a href="/2018/02/25/Java/基础/类加载机制/">类加载机制</a>
          </li>
        
          <li>
            <a href="/2018/02/25/Java/集合/HashSet原理/">HashSet原理</a>
          </li>
        
          <li>
            <a href="/2018/02/25/Java/集合/几种常见的map/">几种常见的map</a>
          </li>
        
          <li>
            <a href="/2018/02/25/Java/集合/Hashtable与ConcurrentHashMap区别/">Hashtable与ConcurrentHashMap区别</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 LeoChan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>