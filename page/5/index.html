<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LeoChan&#39;s 个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="描述啊">
<meta property="og:type" content="website">
<meta property="og:title" content="LeoChan&#39;s 个人博客">
<meta property="og:url" content="https://clq2owesome.github.io/page/5/index.html">
<meta property="og:site_name" content="LeoChan&#39;s 个人博客">
<meta property="og:description" content="描述啊">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeoChan&#39;s 个人博客">
<meta name="twitter:description" content="描述啊">
  
    <link rel="alternate" href="/atom.xml" title="LeoChan&#39;s 个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LeoChan&#39;s 个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术都是通用的，重要的是是否具有自主解决问题的能力！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://clq2owesome.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-服务器相关/redis/Redis集群" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/服务器相关/redis/Redis集群/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/服务器相关/redis/Redis集群/">Redis集群</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Redis集群介绍"><a href="#Redis集群介绍" class="headerlink" title="Redis集群介绍"></a>Redis集群介绍</h3><p>Redis 集群是一个提供在<strong>多个Redis间节点间共享数据</strong>的程序集。 </p>
<p>Redis集群并不支持处理多个keys的命令,因为这需要在不同的节点间移动数据,从而达不到像Redis那样的性能,在高负载的情况下可能会导致不可预料的错误.  </p>
<p>Redis 集群通过分区来提供<strong>一定程度的可用性</strong>,在实际环境中当某个节点宕机或者不可达的情况下继续处理命令. Redis 集群的优势:</p>
<ul>
<li>自动分割数据到不同的节点上。</li>
<li>整个集群的部分节点失败或者不可达的情况下能够继续处理命令。</li>
</ul>
<h3 id="Redis-集群的数据分片"><a href="#Redis-集群的数据分片" class="headerlink" title="Redis 集群的数据分片"></a>Redis 集群的数据分片</h3><p>Redis 集群没有使用一致性hash, 而是引入了 <strong>哈希槽</strong>的概念.</p>
<p>Redis 集群有<strong>16384</strong>个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽,举个例子,比如当前集群有3个节点,那么:</p>
<ul>
<li>节点 A 包含 0 到 5500号哈希槽.</li>
<li>节点 B 包含5501 到 11000 号哈希槽.</li>
<li>节点 C 包含11001 到 16384号哈希槽.</li>
</ul>
<p>这种结构很容易添加或者删除节点. 比如如果我想新添加个节点D, 我需要从节点 A, B, C中得部分槽到D上. 如果我像移除节点A,需要将A中得槽移到B和C节点上,然后将没有任何槽的A节点从集群中移除即可. 由于从一个节点将哈希槽移动到另一个节点并不会停止服务,所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态.</p>
<h3 id="Redis-集群的主从复制模型"><a href="#Redis-集群的主从复制模型" class="headerlink" title="Redis 集群的主从复制模型"></a>Redis 集群的主从复制模型</h3><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品.</p>
<p>在我们例子中具有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用.</p>
<p>然而如果在集群创建的时候（或者过一段时间）我们为每个节点添加一个从节点A1，B1，C1,那么整个集群便有三个master节点和三个slave节点组成，这样在节点B失败后，集群便会选举B1为新的主节点继续服务，整个集群便不会因为槽找不到而不可用了</p>
<p>不过当B和B1 都失败后，集群是不可用的.</p>
<h3 id="Redis-一致性保证"><a href="#Redis-一致性保证" class="headerlink" title="Redis 一致性保证"></a>Redis 一致性保证</h3><p>Redis 并不能保证数据的<strong>强一致性</strong>. 这意味这在实际中集群在特定的条件下可能会丢失写操作.</p>
<p>第一个原因是因为集群是用了异步复制. 写操作过程:</p>
<ol>
<li>客户端向主节点B写入一条命令.</li>
<li>主节点B向客户端回复命令状态.</li>
<li>主节点将写操作复制给他得从节点 B1, B2 和 B3.</li>
</ol>
<p>主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。 注意：Redis 集群可能会在将来提供同步写的方法。 Redis 集群另外一种可能会丢失命令的情况是集群出现了网络分区， 并且一个客户端与至少包括一个主节点在内的少数实例被孤立。</p>
<p>举个例子 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点， 其中 A 、B 、C 为主节点， A1 、B1 、C1 为A，B，C的从节点， 还有一个客户端 Z1 假设集群中发生网络分区，那么集群可能会分为两方，大部分的一方包含节点 A 、C 、A1 、B1 和 C1 ，小部分的一方则包含节点 B 和客户端 Z1 .</p>
<p>Z1仍然能够向主节点B中写入, 如果网络分区发生时间较短,那么集群将会继续正常运作,如果分区的时间足够让大部分的一方将B1选举为新的master，那么Z1写入B中得数据便丢失了.</p>
<p>注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项</p>
<h3 id="搭建并使用Redis集群"><a href="#搭建并使用Redis集群" class="headerlink" title="搭建并使用Redis集群"></a>搭建并使用Redis集群</h3><p>搭建集群的第一件事情我们需要一些运行在 集群模式的Redis实例. 这意味这集群并不是由一些普通的Redis实例组成的，集群模式需要通过配置启用，开启集群模式后的Redis实例便可以使用集群特有的命令和特性了.<br>下面是一个最少选项的集群的配置文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">port 7000</div><div class="line">cluster-enabled yes</div><div class="line">cluster-config-file nodes.conf</div><div class="line">cluster-node-timeout 5000</div><div class="line">appendonly yes</div></pre></td></tr></table></figure></p>
<p>文件中的 cluster-enabled 选项用于开实例的集群模式， 而 cluster-conf-file 选项则设定了保存节点配置文件的路径， 默认值为 nodes.conf.节点配置文件无须人为修改， 它由 Redis 集群在启动时创建， 并在有需要时自动进行更新。 </p>
<p>要让集群正常运作至少需要三个主节点，不过在刚开始试用集群功能时， 强烈建议使用六个节点： 其中三个为主节点， 而其余三个则是各个主节点的从节点。</p>
<p>首先， 让我们进入一个新目录， 并创建六个以端口号为名字的子目录， 稍后我们在将每个目录中运行一个 Redis 实例：  命令如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir cluster-test</div><div class="line">cd cluster-test</div><div class="line">mkdir 7000 7001 7002 7003 7004 7005</div></pre></td></tr></table></figure></p>
<p>在文件夹 7000 至 7005 中， 各创建一个 redis.conf 文件， 文件的内容可以使用上面的示例配置文件， 但记得将配置中的端口号从 7000 改为与文件夹名字相同的号码,并且nodes.conf的文件名也要相应调整，如nodes-7000.conf。</p>
<p>启动6个集群示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/Cellar/redis/3.2.8/bin</div><div class="line">1./usr/local/Cellar/redis/3.2.8/cluster-test/7000/redis.conf</div><div class="line">2./usr/local/Cellar/redis/3.2.8/cluster-test/70010/redis.conf</div><div class="line">3./usr/local/Cellar/redis/3.2.8/cluster-test/7002/redis.conf</div><div class="line">4./usr/local/Cellar/redis/3.2.8/cluster-test/7003/redis.conf</div><div class="line">5./usr/local/Cellar/redis/3.2.8/cluster-test/7004/redis.conf</div><div class="line">6./usr/local/Cellar/redis/3.2.8/cluster-test/7005/redis.conf</div></pre></td></tr></table></figure></p>
<p>实例打印的日志显示， 因为 nodes.conf 文件不存在， 所以每个节点都为它自身指定了一个新的 ID ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[82462] 26 Nov 11:56:55.329 * No cluster configuration found, I&apos;m 97a3a64667477371c4479320d683e4c8db5858b1</div></pre></td></tr></table></figure></p>
<p>实例会一直使用同一个 ID ， 从而在集群中保持一个独一无二（unique）的名字。</p>
<h3 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h3><p>现在我们已经有了六个正在运行中的 Redis 实例， 接下来我们需要使用这些实例来创建集群， 并为每个节点编写配置文件。<br>通过使用 Redis 集群命令行工具 redis-trib ， 编写节点配置文件的工作可以非常容易地完成： redis-trib 位于 Redis 源码的 src 文件夹中， 它是一个 Ruby 程序， 这个程序通过向实例发送特殊命令来完成创建新集群， 检查集群， 或者对集群进行重新分片（reshared）等工作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 \</div><div class="line">127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</div></pre></td></tr></table></figure></p>
<p>这个命令在这里用于创建一个新的集群, 选项–replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。<br>之后跟着的其他参数则是这个集群实例的地址列表,3个master3个slave redis-trib 会打印出一份预想中的配置给你看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</div><div class="line">&gt;&gt;&gt; Creating cluster</div><div class="line">&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...</div><div class="line">Using 3 masters:</div><div class="line">127.0.0.1:7000</div><div class="line">127.0.0.1:7001</div><div class="line">127.0.0.1:7002</div><div class="line">Adding replica 127.0.0.1:7003 to 127.0.0.1:7000</div><div class="line">Adding replica 127.0.0.1:7004 to 127.0.0.1:7001</div><div class="line">Adding replica 127.0.0.1:7005 to 127.0.0.1:7002</div><div class="line">M: 83976d23ea61befbacc383aa03bd2da9f08fa7fa 127.0.0.1:7000</div><div class="line">   slots:0-5460 (5461 slots) master</div><div class="line">M: c2f4de6b29648599ade1d596b96838cdf559f397 127.0.0.1:7001</div><div class="line">   slots:5461-10922 (5462 slots) master</div><div class="line">M: 3e9798d73cc0685745c18cb15cf68c75c746e0a5 127.0.0.1:7002</div><div class="line">   slots:10923-16383 (5461 slots) master</div><div class="line">S: dfcad7da198267663734490dc876a7c072d186f1 127.0.0.1:7003</div><div class="line">   replicates 83976d23ea61befbacc383aa03bd2da9f08fa7fa</div><div class="line">S: d415630bb73d2df4ddbe8032ac3034756dff838c 127.0.0.1:7004</div><div class="line">   replicates c2f4de6b29648599ade1d596b96838cdf559f397</div><div class="line">S: ccda46a376b2a473ac596c80050b464ca9ba30d4 127.0.0.1:7005</div><div class="line">   replicates 3e9798d73cc0685745c18cb15cf68c75c746e0a5</div><div class="line">Can I set the above configuration? (type &apos;yes&apos; to accept):</div></pre></td></tr></table></figure></p>
<p>如果你觉得没问题的话， 就可以输入 yes ， redis-trib 就会将这份配置应用到集群当中,让各个节点开始互相通讯,最后可以得到如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">Can I set the above configuration? (type &apos;yes&apos; to accept): yes</div><div class="line">&gt;&gt;&gt; Nodes configuration updated</div><div class="line">&gt;&gt;&gt; Assign a different config epoch to each node</div><div class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</div><div class="line">Waiting for the cluster to join...</div><div class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)</div><div class="line">M: 83976d23ea61befbacc383aa03bd2da9f08fa7fa 127.0.0.1:7000</div><div class="line">   slots:0-5460 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: d415630bb73d2df4ddbe8032ac3034756dff838c 127.0.0.1:7004</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates c2f4de6b29648599ade1d596b96838cdf559f397</div><div class="line">M: c2f4de6b29648599ade1d596b96838cdf559f397 127.0.0.1:7001</div><div class="line">   slots:5461-10922 (5462 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: ccda46a376b2a473ac596c80050b464ca9ba30d4 127.0.0.1:7005</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates 3e9798d73cc0685745c18cb15cf68c75c746e0a5</div><div class="line">M: 3e9798d73cc0685745c18cb15cf68c75c746e0a5 127.0.0.1:7002</div><div class="line">   slots:10923-16383 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: dfcad7da198267663734490dc876a7c072d186f1 127.0.0.1:7003</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates 83976d23ea61befbacc383aa03bd2da9f08fa7fa</div><div class="line">[OK] All nodes agree about slots configuration.</div><div class="line">&gt;&gt;&gt; Check for open slots...</div><div class="line">&gt;&gt;&gt; Check slots coverage...</div><div class="line">[OK] All 16384 slots covered.</div></pre></td></tr></table></figure></p>
<p>这表示集群中的 16384 个槽都有至少一个主节点在处理， 集群运作正常。</p>
<p><strong>注意</strong>：如果脚本报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">custom_require.rb:36:in `require&apos;: cannot load such file -- redis (LoadError)</div><div class="line">from /usr/lib/ruby/1.9.1/rubygems/custom_require.rb:36:in `require&apos;</div><div class="line">from ./redis-trib.rb:25:in `&lt;main&gt;&apos;</div></pre></td></tr></table></figure></p>
<p>那么说明Ruby的redis接口没有安装，可以通过<code>sudo gem install redis</code>进行安装。</p>
<h3 id="Creating-a-Redis-Cluster-using-the-create-cluster-script"><a href="#Creating-a-Redis-Cluster-using-the-create-cluster-script" class="headerlink" title="Creating a Redis Cluster using the create-cluster script"></a>Creating a Redis Cluster using the create-cluster script</h3><p>If you don’t want to create a Redis Cluster by configuring and executing individual instances manually as explained above, there is a much simpler system (but you’ll not learn the same amount of operational details).</p>
<p>Just check utils/create-cluster directory in the Redis distribution. There is a script called create-cluster inside (same name as the directory it is contained into), it’s a simple bash script. In order to start a 6 nodes cluster with 3 masters and 3 slaves just type the following commands:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1. create-cluster start</div><div class="line">2. create-cluster create</div></pre></td></tr></table></figure></p>
<p>Reply to yes in step 2 when the redis-trib utility wants you to accept the cluster layout.<br>You can now interact with the cluster, the first node will start at port 30001 by default. When you are done, stop the cluster with:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">create-cluster stop</div></pre></td></tr></table></figure></p>
<p>Please read the README inside this directory for more information on how to run the script.</p>
<h3 id="使用集群"><a href="#使用集群" class="headerlink" title="使用集群"></a>使用集群</h3><p>Redis 集群现阶段的一个问题是客户端实现很少。<br>以下是一些我知道的实现：</p>
<ul>
<li><a href="https://github.com/antirez/redis-rb-cluster" target="_blank" rel="external">redis-rb-cluster</a> 是我（@antirez）编写的 Ruby 实现， 用于作为其他实现的参考。 该实现是对 redis-rb 的一个简单包装， 高效地实现了与集群进行通讯所需的最少语义（semantic）.</li>
<li><a href="https://github.com/Grokzen/redis-py-cluster" target="_blank" rel="external">redis-py-cluster</a> 看上去是 redis-rb-cluster 的一个 Python 版本， 这个项目有一段时间没有更新了（最后一次提交是在六个月之前）， 不过可以将这个项目用作学习集群的起点。</li>
<li>流行的 <a href="https://github.com/nrk/predis" target="_blank" rel="external">Predis</a> 曾经对早期的 Redis 集群有过一定的支持， 但我不确定它对集群的支持是否完整， 也不清楚它是否和最新版本的 Redis 集群兼容 （因为新版的 Redis 集群将槽的数量从 4k 改为 16k 了）.</li>
<li>使用最多的时java客户端, <a href="https://github.com/xetorthio/jedis" target="_blank" rel="external">Jedis</a> 最近添加了对集群的支持, 详细请查看项目README中Jedis Cluster部分.</li>
<li><a href="https://github.com/StackExchange/StackExchange.Redis" target="_blank" rel="external">StackExchange.Redis</a> 提供对 C# 的支持(并且包括大部分 .NET 下面的语言，比如： VB, F#等等)</li>
<li><a href="https://github.com/thunks/thunk-redis" target="_blank" rel="external">thunk-redis</a> 提供对 Node.js 和 io.js的支持。</li>
<li>Redis unstable 分支中的 redis-cli 程序实现了非常基本的集群支持， 可以使用命令 redis-cli -c 来启动。</li>
</ul>
<p>测试 Redis 集群比较简单的办法就是使用 redis-rb-cluster 或者 redis-cli ， 接下来我们将使用 redis-cli 为例来进行演示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -c -p 7000</div><div class="line">redis 127.0.0.1:7000&gt; set foo bar</div><div class="line">-&gt; Redirected to slot [12182] located at 127.0.0.1:7002</div><div class="line">OK</div><div class="line">redis 127.0.0.1:7002&gt; set hello world</div><div class="line">-&gt; Redirected to slot [866] located at 127.0.0.1:7000</div><div class="line">OK</div><div class="line">redis 127.0.0.1:7000&gt; get foo</div><div class="line">-&gt; Redirected to slot [12182] located at 127.0.0.1:7002</div><div class="line">&quot;bar&quot;</div><div class="line">redis 127.0.0.1:7000&gt; get hello</div><div class="line">-&gt; Redirected to slot [866] located at 127.0.0.1:7000</div><div class="line">&quot;world&quot;</div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>: 如果你是使用脚本创建的集群节点，那么默认端口可能是从30001开始。</p>
<p>redis-cli 对集群的支持是非常基本的， 所以它总是依靠 Redis 集群节点来将它转向（redirect）至正确的节点。一个真正的（serious）集群客户端应该做得比这更好： 它应该用缓存记录起哈希槽与节点地址之间的映射（map）， 从而直接将命令发送到正确的节点上面。这种映射只会在集群的配置出现某些修改时变化， 比如说， 在一次故障转移（failover）之后， 或者系统管理员通过添加节点或移除节点来修改了集群的布局（layout）之后， 诸如此类。</p>
<h3 id="使用redis-rb-cluster写一个例子"><a href="#使用redis-rb-cluster写一个例子" class="headerlink" title="使用redis-rb-cluster写一个例子"></a>使用redis-rb-cluster写一个例子</h3><p>在展示如何使用集群进行故障转移、重新分片等操作之前， 我们需要创建一个示例应用， 了解一些与 Redis 集群客户端进行交互的基本方法。  </p>
<p>在运行示例应用的过程中， 我们会尝试让节点进入失效状态， 又或者开始一次重新分片， 以此来观察 Redis 集群在真实世界运行时的表现， 并且为了让这个示例尽可能地有用， 我们会让这个应用向集群进行写操作。<br>本节将通过两个示例应用来展示 redis-rb-cluster 的基本用法， 以下是本节的第一个示例应用， 它是一个名为 example.rb 的文件， 包含在redis-rb-cluster 项目里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"> 1  require &apos;./cluster&apos;</div><div class="line"> 2</div><div class="line"> 3  startup_nodes = [</div><div class="line"> 4      &#123;:host =&gt; &quot;127.0.0.1&quot;, :port =&gt; 7000&#125;,</div><div class="line"> 5      &#123;:host =&gt; &quot;127.0.0.1&quot;, :port =&gt; 7001&#125;</div><div class="line"> 6  ]</div><div class="line"> 7  rc = RedisCluster.new(startup_nodes,32,:timeout =&gt; 0.1)</div><div class="line"> 8</div><div class="line"> 9  last = false</div><div class="line">10</div><div class="line">11  while not last</div><div class="line">12      begin</div><div class="line">13          last = rc.get(&quot;__last__&quot;)</div><div class="line">14          last = 0 if !last</div><div class="line">15      rescue =&gt; e</div><div class="line">16          puts &quot;error #&#123;e.to_s&#125;&quot;</div><div class="line">17          sleep 1</div><div class="line">18      end</div><div class="line">19  end</div><div class="line">20</div><div class="line">21  ((last.to_i+1)..1000000000).each&#123;|x|</div><div class="line">22      begin</div><div class="line">23          rc.set(&quot;foo#&#123;x&#125;&quot;,x)</div><div class="line">24          puts rc.get(&quot;foo#&#123;x&#125;&quot;)</div><div class="line">25          rc.set(&quot;__last__&quot;,x)</div><div class="line">26      rescue =&gt; e</div><div class="line">27          puts &quot;error #&#123;e.to_s&#125;&quot;</div><div class="line">28      end</div><div class="line">29      sleep 0.1</div><div class="line">30  &#125;</div></pre></td></tr></table></figure></p>
<p>这个应用所做的工作非常简单： 它不断地以 foo<number> 为键， number 为值， 使用 SET 命令向数据库设置键值对:</number></p>
<ul>
<li>SET foo0 0</li>
<li>SET foo1 1</li>
<li>SET foo2 2</li>
<li>And so forth…</li>
</ul>
<p>代码中的每个集群操作都使用一个 begin 和 rescue 代码块（block）包裹着， 因为我们希望在代码出错时， 将错误打印到终端上面， 而不希望应用因为异常（exception）而退出。</p>
<p>代码的第七行是代码中第一个有趣的地方， 它创建了一个 Redis 集群对象， 其中创建对象所使用的参数及其意义如下：第一个参数是记录了启动节点的 startup_nodes 列表， 列表中包含了两个集群节点的地址。第二个参数指定了对于集群中的各个不同的节点， Redis 集群对象可以获得的最大连接数 ，第三个参数 timeout 指定了一个命令在执行多久之后， 才会被看作是执行失败。</p>
<p>启动列表中并不需要包含所有集群节点的地址， 但这些地址中至少要有一个是有效的： 一旦 redis-rb-cluster 成功连接上集群中的某个节点时， 集群节点列表就会被自动更新， 任何真正的的集群客户端都应该这样做。</p>
<p>现在， 程序创建的 Redis 集群对象实例被保存到 rc 变量里面， 我们可以将这个对象当作普通 Redis 对象实例来使用。<br>在十一至十九行， 我们先尝试阅读计数器中的值， 如果计数器不存在的话， 我们才将计数器初始化为 0 ： 通过将计数值保存到 Redis 的计数器里面， 我们可以在示例重启之后， 仍然继续之前的执行过程， 而不必每次重启之后都从 foo0 开始重新设置键值对。为了让程序在集群下线的情况下， 仍然不断地尝试读取计数器的值， 我们将读取操作包含在了一个 while 循环里面， 一般的应用程序并不需要如此小心。</p>
<p>二十一至三十行是程序的主循环， 这个循环负责设置键值对， 并在设置出错时打印错误信息。程序在主循环的末尾添加了一个 sleep 调用， 让写操作的执行速度变慢， 帮助执行示例的人更容易看清程序的输出。执行 example.rb 程序将产生以下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ruby ./example.rb</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">^C (I stopped the program here)</div></pre></td></tr></table></figure></p>
<p>这个程序并不是十分有趣， 稍后我们就会看到一个更有趣的集群应用示例， 不过在此之前， 让我们先使用这个示例来演示集群的重新分片操作。</p>
<h3 id="集群重新分片"><a href="#集群重新分片" class="headerlink" title="集群重新分片"></a>集群重新分片</h3><p>现在， 让我们来试试对集群进行重新分片操作。在执行重新分片的过程中， 请让你的 example.rb 程序处于运行状态， 这样你就会看到， 重新分片并不会对正在运行的集群程序产生任何影响， 你也可以考虑将 example.rb 中的 sleep 调用删掉， 从而让重新分片操作在近乎真实的写负载下执行 重新分片操作基本上就是将某些节点上的哈希槽移动到另外一些节点上面， 和创建集群一样， 重新分片也可以使用 redis-trib 程序来执行 执行以下命令可以开始一次重新分片操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb reshard 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<p>你只需要指定集群中其中一个节点的地址， redis-trib 就会自动找到集群中的其他节点。<br>目前 redis-trib 只能在管理员的协助下完成重新分片的工作， 要让 redis-trib 自动将哈希槽从一个节点移动到另一个节点， 目前来说还做不到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">你想移动多少个槽( 从1 到 16384)?</div></pre></td></tr></table></figure></p>
<p>我们尝试从将100个槽重新分片， 如果 example.rb 程序一直运行着的话， 现在 1000 个槽里面应该有不少键了。<br>除了移动的哈希槽数量之外， redis-trib 还需要知道重新分片的目标， 也即是， 负责接收这 1000 个哈希槽的节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -p 7000 cluster nodes | grep myself</div><div class="line">97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5460</div></pre></td></tr></table></figure></p>
<p>我的目标节点是 97a3a64667477371c4479320d683e4c8db5858b1.<br>现在需要指定从哪些节点来移动keys到目标节点 我输入的是all ，这样就会从其他每个master上取一些哈希槽。<br>最后确认后你将会看到每个redis-trib移动的槽的信息，每个key的移动的信息也会打印出来        在重新分片的过程中，你的例子程序是不会受到影响的,你可以停止或者重新启动多次。<br>在重新分片结束后你可以通过如下命令检查集群状态:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb check 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<h3 id="一个更有趣的程序"><a href="#一个更有趣的程序" class="headerlink" title="一个更有趣的程序"></a>一个更有趣的程序</h3><p>我们在前面使用的示例程序 example.rb 并不是十分有趣， 因为它只是不断地对集群进行写入， 但并不检查写入结果是否正确。 比如说， 集群可能会错误地将 example.rb 发送的所有 SET 命令都改成了 SET foo 42 ， 但因为 example.rb 并不检查写入后的值， 所以它不会意识到集群实际上写入的值是错误的 因为这个原因， redis-rb-cluster 项目包含了一个名为 consistency-test.rb 的示例应用， 这个应用比起 example.rb 有趣得多： 它创建了多个计数器（默认为 1000 个）， 并通过发送 INCR 命令来增加这些计数器的值。</p>
<p>在增加计数器值的同时， consistency-test.rb 还执行以下操作： 每次使用 INCR 命令更新一个计数器时， 应用会记录下计数器执行 INCR 命令之后应该有的值。 举个例子， 如果计数器的起始值为 0 ， 而这次是程序第 50 次向它发送 INCR 命令， 那么计数器的值应该是 50 。</p>
<p>在每次发送 INCR 命令之前， 程序会随机从集群中读取一个计数器的值， 并将它与自己记录的值进行对比， 看两个值是否相同。</p>
<p>换句话说， 这个程序是一个一致性检查器（consistency checker）： 如果集群在执行 INCR 命令的过程中， 丢失了某条 INCR 命令， 又或者多执行了某条客户端没有确认到的 INCR 命令， 那么检查器将察觉到这一点 —— 在前一种情况中， consistency-test.rb 记录的计数器值将比集群记录的计数器值要大； 而在后一种情况中， consistency-test.rb 记录的计数器值将比集群记录的计数器值要小。</p>
<p>运行 consistency-test 程序将产生类似以下的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ ruby consistency-test.rb</div><div class="line">925 R (0 err) | 925 W (0 err) |</div><div class="line">5030 R (0 err) | 5030 W (0 err) |</div><div class="line">9261 R (0 err) | 9261 W (0 err) |</div><div class="line">13517 R (0 err) | 13517 W (0 err) |</div><div class="line">17780 R (0 err) | 17780 W (0 err) |</div><div class="line">22025 R (0 err) | 22025 W (0 err) |</div><div class="line">25818 R (0 err) | 25818 W (0 err) |</div></pre></td></tr></table></figure></p>
<p>结果展示了执行的读和 写,和错误(由于系统不可用而没有接受的查询发生的错误）的数量.<br>如果程序察觉了不一致的情况出现， 它将在输出行的末尾显式不一致的详细情况。比如说， 如果我们在 consistency-test.rb 运行的过程中， 手动修改某个计数器的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ redis 127.0.0.1:7000&gt; set key_217 0</div><div class="line">OK</div><div class="line"></div><div class="line">(in the other tab I see...)</div><div class="line"></div><div class="line">94774 R (0 err) | 94774 W (0 err) |</div><div class="line">98821 R (0 err) | 98821 W (0 err) |</div><div class="line">102886 R (0 err) | 102886 W (0 err) | 114 lost |</div><div class="line">107046 R (0 err) | 107046 W (0 err) | 114 lost |</div></pre></td></tr></table></figure></p>
<p>在我们修改计数器值的时候， 计数器的正确值是 114 （执行了 114 次 INCR 命令）， 因为我们将计数器的值设成了 0 ， 所以 consistency-test.rb 会向我们报告说丢失了 114 个 INCR 命令。<br>这个程序作为测试程序很有意思，所以我们用这个程序来测试故障恢复.</p>
<h3 id="测试故障转移"><a href="#测试故障转移" class="headerlink" title="测试故障转移"></a>测试故障转移</h3><p>在执行本节操作的过程中， 请一直运行 consistency-test 程序。 要触发一次故障转移， 最简单的办法就是令集群中的某个主节点进入下线状态。首先用以下命令列出集群中的所有主节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -p 7000 cluster nodes | grep master</div><div class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385482984082 0 connected 5960-10921</div><div class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 master - 0 1385482983582 0 connected 11423-16383</div><div class="line">97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422</div></pre></td></tr></table></figure></p>
<p>通过命令输出得知端口号为 7000 、 7001 和 7002 的节点都是主节点， 然后我们可以通过向端口号为7002 的主节点发送 <strong>DEBUG SEGFAULT</strong> 命令， 让这个主节点崩溃：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -p 7002 debug segfault</div><div class="line">Error: Server closed the connection</div></pre></td></tr></table></figure></p>
<p>现在，切换到运行着 consistency-test 的标签页， 可以看到， consistency-test 在 7002 下线之后的一段时间里将产生大量的错误警告信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">18849 R (0 err) | 18849 W (0 err) |</div><div class="line">23151 R (0 err) | 23151 W (0 err) |</div><div class="line">27302 R (0 err) | 27302 W (0 err) |</div><div class="line"></div><div class="line">... many error warnings here ...</div><div class="line"></div><div class="line">29659 R (578 err) | 29660 W (577 err) |</div><div class="line">33749 R (578 err) | 33750 W (577 err) |</div><div class="line">37918 R (578 err) | 37919 W (577 err) |</div><div class="line">42077 R (578 err) | 42078 W (577 err) |</div></pre></td></tr></table></figure></p>
<p>从 consistency-test 的这段输出可以看到， 集群在执行故障转移期间， 总共丢失了 578 个读命令和 577 个写命令， 但是并没有产生任何数据不一致。这听上去可能有点奇怪， 因为在教程的开头我们提到过， Redis 使用的是异步复制， 在执行故障转移期间， 集群可能会丢失写命令。但是在实际上， 丢失命令的情况并不常见， 因为 Redis 几乎是同时执行将命令回复发送给客户端， 以及将命令复制给从节点这两个操作， 所以实际上造成命令丢失的时间窗口是非常小的。不过， 尽管出现的几率不高， 但丢失命令的情况还是有可能会出现的， 所以我们对 Redis 集群不能提供强一致性的这一描述仍然是正确的。现在， 让我们使用 cluster nodes 命令,查看集群在执行故障转移操作之后， 主从节点的布局情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -p 7000 cluster nodes</div><div class="line">3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385503418521 0 connected</div><div class="line">a211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385503419023 0 connected</div><div class="line">97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422</div><div class="line">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385503419023 3 connected 11423-16383</div><div class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385503417005 0 connected 5960-10921</div><div class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385503418016 3 connected</div></pre></td></tr></table></figure></p>
<p>现在masters运行在 7000, 7001 和 7005端口上. 原来的master 7002现在变成了一个7005的一个从节点.<br>CLUSTER NODES 命令的输出看起来有点复杂,其实他非常的简单，含义如下:</p>
<ul>
<li>节点ID</li>
<li>IP:端口</li>
<li>标志: master, slave, myself, fail, …</li>
<li>如果是个从节点, 这里是它的主节点的NODE ID</li>
<li>集群最近一次向节点发送 PING 命令之后， 过去了多长时间还没接到回复。.</li>
<li>节点最近一次返回 PONG 回复的时间。</li>
<li>节点的配置纪元（configuration epoch）：详细信息请参考 Redis 集群规范 。</li>
<li>本节点的网络连接情况：例如 connected 。</li>
<li>节点目前包含的槽：例如 127.0.0.1:7001 目前包含号码为 5960 至 10921 的哈希槽。</li>
</ul>
<h3 id="手动故障转移"><a href="#手动故障转移" class="headerlink" title="手动故障转移"></a>手动故障转移</h3><p>有的时候在主节点没有任何问题的情况下强制手动故障转移也是很有必要的，比如想要升级主节点的Redis进程，我们可以通过故障转移将其转为slave再进行升级操作来避免对集群的可用性造成很大的影响。</p>
<p>Redis集群使用 <code>CLUSTER FAILOVER</code>命令来进行故障转移，不过要被转移的主节点的从节点上执行该命令 手动故障转移比主节点失败自动故障转移更加安全，因为手动故障转移时客户端的切换是在确保新的主节点完全复制了失败的旧的主节点数据的前提下下发生的，所以避免了数据的丢失。<br>执行手动故障转移时从节点日志如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># Manual failover user request accepted.</div><div class="line"># Received replication offset for paused master manual failover: 347540</div><div class="line"># All master replication stream processed, manual failover can start.</div><div class="line"># Start of election delayed for 0 milliseconds (rank #0, offset 347540).</div><div class="line"># Starting a failover election for epoch 7545.</div><div class="line"># Failover election won: I&apos;m the new master.</div></pre></td></tr></table></figure></p>
<p>其基本过程如下：客户端不再链接我们淘汰的主节点，同时主节点向从节点发送复制偏移量,从节点得到复制偏移量后故障转移开始,接着通知主节点进行配置切换,当客户端在旧的master上解锁后重新连接到新的主节点上。</p>
<h3 id="添加一个新节点"><a href="#添加一个新节点" class="headerlink" title="添加一个新节点"></a>添加一个新节点</h3><p>添加新的节点的基本过程就是添加一个空的节点然后移动一些数据给它，有两种情况，添加一个主节点和添加一个从节点（添加从节点时需要将这个新的节点设置为集群中某个节点的复制）<br>针对这两种情况，本节都会介绍，先从添加主节点开始.</p>
<p>两种情况第一步都是要添加 一个空的节点.<br>启动新的7006节点,使用的配置文件和以前的一样,只要把端口号改一下即可，过程如下:   </p>
<ul>
<li>在终端打开一个新的标签页.</li>
<li>进入cluster-test 目录.</li>
<li>创建并进入 7006文件夹.</li>
<li>和其他节点一样，创建redis.conf文件,需要将端口号改成7006.</li>
<li>最后启动节点 ../redis-server ./redis.conf</li>
<li>如果正常的话，节点会正确的启动.</li>
</ul>
<p>接下来使用redis-trib 来添加这个节点到现有的集群中去.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb add-node 127.0.0.1:7006 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<p>可以看到.使用<strong>addnode</strong>命令来添加节点，第一个参数是新节点的地址，第二个参数是任意一个已经存在的节点的IP和端口. 我们可以看到新的节点已经添加到集群中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:7006&gt; cluster nodes</div><div class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385543178575 0 connected 5960-10921</div><div class="line">3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385543179583 0 connected</div><div class="line">f093c80dde814da99c5cf72a7dd01590792b783b :0 myself,master - 0 0 0 connected</div><div class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543178072 3 connected</div><div class="line">a211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385543178575 0 connected</div><div class="line">97a3a64667477371c4479320d683e4c8db5858b1 127.0.0.1:7000 master - 0 1385543179080 0 connected 0-5959 10922-11422</div><div class="line">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385543177568 3 connected 11423-16383</div></pre></td></tr></table></figure></p>
<p>新节点现在已经连接上了集群， 成为集群的一份子， 并且可以对客户端的命令请求进行转向了， 但是和其他主节点相比， 新节点还有两点区别： </p>
<ul>
<li>新节点没有包含任何数据， 因为它没有包含任何哈希槽.</li>
<li>尽管新节点没有包含任何哈希槽， 但它仍然是一个主节点， 所以在集群需要将某个从节点升级为新的主节点时， 这个新节点不会被选中。</li>
</ul>
<p>接下来， 只要使用 redis-trib 程序， 将集群中的某些哈希桶移动到新节点里面， 新节点就会成为真正的主节点了。</p>
<h3 id="添加一个从节点"><a href="#添加一个从节点" class="headerlink" title="添加一个从节点"></a>添加一个从节点</h3><p>有两种方法添加从节点，可以像添加主节点一样使用redis-trib 命令，也可以像下面的例子一样使用 –slave选项:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb add-node --slave 127.0.0.1:7006 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<p>此处的命令和添加一个主节点命令类似，此处并没有指定添加的这个从节点的主节点，这种情况下系统会在其他的复制集中的主节点中随机选取一个作为这个从节点的主节点。<br>你可以通过下面的命令指定主节点:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb add-node --slave --master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7006 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<p>也可以使用CLUSTER REPLICATE 命令添加.这个命令也可以改变一个从节点的主节点。<br>例如，要给主节点 127.0.0.1:7005添加一个从节点，该节点哈希槽的范围1423-16383, 节点 ID 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e,我们需要链接新的节点（已经是空的主节点）并执行命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:7006&gt; cluster replicate 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</div></pre></td></tr></table></figure></p>
<p>我们新的从节点有了一些哈希槽，其他的节点也知道（过几秒后会更新他们自己的配置），可以使用如下命令确认:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -p 7000 cluster nodes | grep slave | grep 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</div><div class="line">f093c80dde814da99c5cf72a7dd01590792b783b 127.0.0.1:7006 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617702 3 connected</div><div class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617198 3 connected</div></pre></td></tr></table></figure></p>
<p>节点 3c3a0c… 有两个从节点， 7002 (已经存在的) 和 7006 (新添加的).</p>
<h3 id="移除一个节点"><a href="#移除一个节点" class="headerlink" title="移除一个节点"></a>移除一个节点</h3><p>只要使用 del-node 命令即可:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb del-node 127.0.0.1:7000 `&lt;node-id&gt;`</div></pre></td></tr></table></figure></p>
<p>第一个参数是任意一个节点的地址,第二个节点是你想要移除的节点地址。<br>使用同样的方法移除主节点,不过在移除主节点前，<strong>需要确保这个主节点是空的</strong>. 如果不是空的,需要将这个节点的数据重新分片到其他主节点上.</p>
<p>替代移除主节点的方法是手动执行故障恢复，被移除的主节点会作为一个从节点存在，不过这种情况下不会减少集群节点的数量，也需要重新分片数据.</p>
<h3 id="从节点的迁移"><a href="#从节点的迁移" class="headerlink" title="从节点的迁移"></a>从节点的迁移</h3><p>在Redis集群中会存在改变一个从节点的主节点的情况，需要执行如下命令 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CLUSTER REPLICATE &lt;master-node-id&gt;</div></pre></td></tr></table></figure></p>
<p>在特定的场景下，不需要系统管理员的协助下，自动将一个从节点从当前的主节点切换到另一个主节 的自动重新配置的过程叫做复制迁移（从节点迁移），从节点的迁移能够提高整个Redis集群的可用性.</p>
<p>你可以阅读（Redis集群规范）<a href="http://www.redis.cn/topics/cluster-spec.html" target="_blank" rel="external">/topics/cluster-spec</a>了解细节.</p>
<p>简短的概况一下从节点迁移</p>
<ul>
<li>集群会在有从节点数量最多的主节点上进行从节点的迁移.</li>
<li>要在一个主节点上添加多个从节点.</li>
<li>参数来控制从节点迁移 replica-migration-barrier:你可以仔细阅读redis.conf 。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/服务器相关/redis/Redis集群/" data-id="cjei97eil00eu89blrh7zliq6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器相关/redis/redis快速的几个原因" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/服务器相关/redis/redis快速的几个原因/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/服务器相关/redis/redis快速的几个原因/">redis快速的几个原因</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>总体来说快速的原因如下：        </p>
<ol>
<li>绝大部分请求是纯粹的内存操作（非常快速）   </li>
<li>采用单线程,避免了不必要的上下文切换和竞争条件   </li>
<li>非阻塞IO  </li>
</ol>
<p>内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间</p>
<p>这3个条件不是相互独立的，特别是第一条，如果请求都是耗时的，采用单线程吞吐量及性能可想而知了。应该说redis为特殊的场景选择了合适的技术方案。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/服务器相关/redis/redis快速的几个原因/" data-id="cjei97eik00er89bln4q9xbd2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux/jenkins安装和启动" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Linux/jenkins安装和启动/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Linux/jenkins安装和启动/">jenkins安装和启动</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>多种安装方式，参考<a href="https://www.ilanni.com/?p=12545" target="_blank" rel="external">https://www.ilanni.com/?p=12545</a> 或者 参考官网</p>
<p><a href="http://blog.csdn.net/wh211212/article/details/53644980" target="_blank" rel="external">http://blog.csdn.net/wh211212/article/details/53644980</a></p>
<h3 id="运行和停止Jenkins"><a href="#运行和停止Jenkins" class="headerlink" title="运行和停止Jenkins"></a>运行和停止Jenkins</h3><p>普通启动，关闭进程后jenkins关闭<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 启动Jenkins</div><div class="line">java -jar /usr/share/jenkins/jenkins.war     </div><div class="line"></div><div class="line"># 停止Jenkins</div><div class="line">按Ctrl+C 组合键</div></pre></td></tr></table></figure></p>
<p>后台启动，指定端口，指定log文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">参数：</div><div class="line">--httpPort：指定端口</div><div class="line">--daemon：后台启动</div><div class="line">--logfile：指定jenkins启动日志路径</div><div class="line"></div><div class="line">例一：</div><div class="line">java -jar /usr/share/jenkins/jenkins.war --httpPort=8081 --daemon</div><div class="line"></div><div class="line"></div><div class="line">例二：</div><div class="line">mkdir /var/log/jenkins</div><div class="line">java -jar /usr/local/src/jenkins.war --logfile=/var/log/jenkins/jenkins.log</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Linux/jenkins安装和启动/" data-id="cjei97eap000f89blt8dxliix" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器相关/redis/5种数据结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/服务器相关/redis/5种数据结构/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/服务器相关/redis/5种数据结构/">5种数据结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <table>
<thead>
<tr>
<th>结构类型</th>
<th>存储结构的值</th>
<th>结构的读写能力</th>
</tr>
</thead>
<tbody>
<tr>
<td>STRING</td>
<td>可以是字符串，整数，或者浮点数</td>
<td>对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增（increment）或者自减（decrement）操作</td>
</tr>
<tr>
<td>LIST</td>
<td>一个链表，链表上的每个节点都包含了一个字符串</td>
<td>从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪（trim）；读取单个或者多个元素；根据值查找或者移除元素</td>
</tr>
<tr>
<td>SET</td>
<td>包含字符串的无序收集器（unordered collection），并且被包含的每个字符串都是独一无二，各不相同的</td>
<td>添加，获取，移除元素；检查一个元素是否存在于集合中；计算交集，并集，差集；从集合里面随机获取元素</td>
</tr>
<tr>
<td>HASH</td>
<td>包含键值对的无序散列表</td>
<td>添加，获取，移除单个键值对；获取所有的键值对</td>
</tr>
<tr>
<td>ZSET（有序集合）</td>
<td>字符串成员（member）与浮点数分值（score）之间的有序映射，元素的排列顺序由分值的大小决定</td>
<td>添加，获取，删除单个元素；根据分值范围（range）或者成员来获取元素</td>
</tr>
</tbody>
</table>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h5 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>get</td>
<td>get key-name 获取存储在给定键中的值</td>
</tr>
<tr>
<td>set</td>
<td>set key-name value 设置存储在给定键中的值</td>
</tr>
<tr>
<td>del</td>
<td>del  key-name 删除存储在给定键中的值</td>
</tr>
</tbody>
</table>
<h5 id="自增命令和自减命令"><a href="#自增命令和自减命令" class="headerlink" title="自增命令和自减命令"></a>自增命令和自减命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>incr</td>
<td>incr key-name 将键存储的值加上1</td>
</tr>
<tr>
<td>decr</td>
<td>decr key-name 将键存储的值减去1</td>
</tr>
<tr>
<td>incrby</td>
<td>incrby key-name amount 将键存储的值加上整数amount</td>
</tr>
<tr>
<td>decrby</td>
<td>将键存储的值减去整数amount</td>
</tr>
<tr>
<td>incrbyfloat</td>
<td>incrbyfloat key-name amount 将键存储的值加上浮点数amount，这个命令在Redis 2.6 或以上的版本可用</td>
</tr>
</tbody>
</table>
<h5 id="处理子串和二进制位的命令"><a href="#处理子串和二进制位的命令" class="headerlink" title="处理子串和二进制位的命令"></a>处理子串和二进制位的命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>append</td>
<td>append key-name value 将值value追加到给定键key-name当前存储的值的末尾</td>
</tr>
<tr>
<td>getrange</td>
<td>getrange key-name start end 获取一个由偏移量start至偏移量end范围内所有字符组成的子串，包括start和end在内</td>
</tr>
<tr>
<td>setrange</td>
<td>setrange ke-name offset value 将从offset偏移量开始的字串设置为给定值</td>
</tr>
<tr>
<td>getbit</td>
<td>getbit key-name offset 将字符串看作是二进制位串（bit string），并返回位串中偏移量位offset的二进制位的值</td>
</tr>
<tr>
<td>setbit</td>
<td>setbit key-name offset value 将字节串看作是二进制位串，并将位串中的偏移量为offset的二进制位的值设置为value</td>
</tr>
<tr>
<td>bitcount</td>
<td>bitcount key-name [start end] 将统计二进制位串里面值为1的二进制位的数量，如果给定了可选的start偏移量和end偏移量，那么只对偏移量指定范围内的二进制位进行统计</td>
</tr>
<tr>
<td>bitof</td>
<td>bitof operation dest-key key-name [key-name …] 对一个或多个二进制位串执行包括并（and），或（or），异或（xor），非（not）在内的任意一种位运算操作（bitwise operation），并将计算得出的结果保存在dest-key键里面</td>
</tr>
</tbody>
</table>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h5 id="基础命令-1"><a href="#基础命令-1" class="headerlink" title="基础命令"></a>基础命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>rpush</td>
<td>rpush key-name value [value .. .] 将一个或者多个推入列表的右端</td>
</tr>
<tr>
<td>lpush</td>
<td>lpush key-name value [value…] 将一个或者多个值推入列表的左端</td>
</tr>
<tr>
<td>lrange</td>
<td>lrange key-name start end 返回列表从start偏移量到end偏移量范围内的所有元素，其中偏移量为start和end的元素也会包含在被返回的元素之内</td>
</tr>
<tr>
<td>lindex</td>
<td>lindex key-name offset 返回列表中偏移量为offset的元素</td>
</tr>
<tr>
<td>lpop</td>
<td>lpop key-name 移除并返回列表最左端的元素</td>
</tr>
<tr>
<td>rpop</td>
<td>rpop key-name 移除并返回列表最右端的元素</td>
</tr>
<tr>
<td>ltrim</td>
<td>ltrim key-name start end 对列表进行修剪，只保留从start偏移量到end偏移量范围内的元素，其中偏移量为start和end的元素也会被保留</td>
</tr>
</tbody>
</table>
<h5 id="阻塞式的列表弹出命令以及在列表之间移动元素的命令"><a href="#阻塞式的列表弹出命令以及在列表之间移动元素的命令" class="headerlink" title="阻塞式的列表弹出命令以及在列表之间移动元素的命令"></a>阻塞式的列表弹出命令以及在列表之间移动元素的命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>blpop</td>
<td>blpop key-name [key-name …] timeout 从第一个非空列表中弹出位于最左端的元素，或者在timeout秒之内阻塞并等待可弹出的元素出现</td>
</tr>
<tr>
<td>brpop</td>
<td>brpop key-name [key-name …] timeout 从第一个非空列表中弹出位于最右端的元素，或者在timeout秒之内阻塞并等待可弹出的元素出现</td>
</tr>
<tr>
<td>rpoplpush</td>
<td>rpoplrush source-key dest-key 从source-key列表中弹出位于最右端的元素，然后将这个元素推入dest-key列表的最左端，并向用户返回这个元素</td>
</tr>
<tr>
<td>brpoplpush</td>
<td>brpoplrush source-key dest-key timeout 从source-key列表中弹出位于最右端的元素，然后将这个元素推入dest-key列表的最左端，并向用户返回这个元素；如果source-key为空，那么在timeout秒之内阻塞并等待可弹出的元素出现</td>
</tr>
</tbody>
</table>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h5 id="基础命令-2"><a href="#基础命令-2" class="headerlink" title="基础命令"></a>基础命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>sadd</td>
<td>sadd key-name item [item …] 将一个或者多个元素添加到集合里面，并返回被添加元素当中原本并不存在于集合里面的元素数量</td>
</tr>
<tr>
<td>srem</td>
<td>srem key-name item [item …] 从集合里面移除一个或者多个元素，并返回被移除元素的数量</td>
</tr>
<tr>
<td>sismember</td>
<td>sismember key-name item 检查元素item是否存在于集合key-name里</td>
</tr>
<tr>
<td>scard</td>
<td>scard key-name 返回集合包含的元素的数量</td>
</tr>
<tr>
<td>smembers</td>
<td>smembers key-name 返回集合包含的所有元素</td>
</tr>
<tr>
<td>srandmember</td>
<td>srandmember key-name [count] 从集合里面随机地返回一个或者多个元素。当count为正数时，命令返回的随机元素不会重复；当count为负数时，命令返回的随机元素可能会出现重复</td>
</tr>
<tr>
<td>spop</td>
<td>spop key-name 随机地移除集合中的一个元素，并返回被移除的元素</td>
</tr>
<tr>
<td>smove</td>
<td>smove source-key dest-key item 如果集合source-key包含元素item，那么从集合source-key里面移除元素item，并将元素item添加到集合dest-key中；如果item被成功移除，那么命令返回1，否则返回0</td>
</tr>
</tbody>
</table>
<h5 id="用于组合和处理多个集合的命令"><a href="#用于组合和处理多个集合的命令" class="headerlink" title="用于组合和处理多个集合的命令"></a>用于组合和处理多个集合的命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>sdiff</td>
<td>sdiff key-name [key-name …] 返回那些存在于第一集合，但不存在于其他集合中的元素（数学上的差集运算）</td>
</tr>
<tr>
<td>sdiffstore</td>
<td>sdiffstore dest-key key-name [key-name…] 将那些存在于第一个集合但并不存在于其他集合中的元素存储到dest-key键里面</td>
</tr>
<tr>
<td>sinter</td>
<td>sinter key-name [key-name…] 返回那些同时存在于所有集合中的元素（数学上的交集运算）</td>
</tr>
<tr>
<td>sinterstore</td>
<td>sinterstore dest-key key-name [key-name …] 返回那些同时存在于所有集合中的元素并存储到dest-key键里面</td>
</tr>
<tr>
<td>sunion</td>
<td>sunion key-name [key-name…] 返回那些至少存在于一个集合中的元素（数学上的并集计算）</td>
</tr>
<tr>
<td>sunionstore</td>
<td>sunionstore dest-key key-name [key-name…] 返回那些至少存在于一个集合中的元素并存储到dest-key键里面</td>
</tr>
</tbody>
</table>
<h3 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h3><h5 id="基础命令-3"><a href="#基础命令-3" class="headerlink" title="基础命令"></a>基础命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>hset</td>
<td>hset key-name key 为散列里面设置一个值</td>
</tr>
<tr>
<td>hget</td>
<td>hget key-name 为散列里面获取一个键的值</td>
</tr>
<tr>
<td>hgetall</td>
<td>获取散列包含的所有键值对</td>
</tr>
<tr>
<td>hmget</td>
<td>hmget key-name key [key …] 从散列里面获取一个或多个键的值</td>
</tr>
<tr>
<td>hmset</td>
<td>hmset key-name key value [key value …] 为散列里面的一个或多个键设置值</td>
</tr>
<tr>
<td>hdel</td>
<td>hdel key-name key [key …] 删除散列里面的一个或多个键值对，返回成功找到并删除的键值对数量</td>
</tr>
<tr>
<td>hlen</td>
<td>hlen key-name 返回散列表包含的键值对数量</td>
</tr>
</tbody>
</table>
<h5 id="散列的更高级特性"><a href="#散列的更高级特性" class="headerlink" title="散列的更高级特性"></a>散列的更高级特性</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>hexists</td>
<td>hexists key-name key 检查给定键是否存在于散列中</td>
</tr>
<tr>
<td>hkeys</td>
<td>hkeys key-name 获取散列包含的所有键</td>
</tr>
<tr>
<td>hvals</td>
<td>获取散列包含的所有值</td>
</tr>
<tr>
<td>hgetall</td>
<td>hgetall key-name 获取散列包含的所有键值对</td>
</tr>
<tr>
<td>hincrby</td>
<td>hincrby key-name key increment 将键key存储的值加上整数increment</td>
</tr>
<tr>
<td>hincrbyfloat</td>
<td>hincrbyfloat key-name key increment 将键key存储的值加上浮点数increment</td>
</tr>
</tbody>
</table>
<h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>zadd</td>
<td>zadd key-name score member [score member …] 将带有给定分值的成员添加到有序集合里面</td>
</tr>
<tr>
<td>zrem</td>
<td>zrem key-name member [member …] 从有序集合里面移除给定的成员，并返回被移除成员的数量</td>
</tr>
<tr>
<td>zcard</td>
<td>zcard key-name 返回有序集合包含的成员数量</td>
</tr>
<tr>
<td>zincrby</td>
<td>zincrby key-name increment member 将member成员的分值加上</td>
</tr>
<tr>
<td>zcount</td>
<td>zcount key-name min max 返回分值介于min和max之间的成员数量</td>
</tr>
<tr>
<td>zrank</td>
<td>zrank key-name member 返回成员member在有序集合中的排名</td>
</tr>
<tr>
<td>zscore</td>
<td>zscore key-name member 返回成员member的分值</td>
</tr>
<tr>
<td>zrange</td>
<td>zrange key-name start stop [withscores] 返回有序集合中排名介于start和stop之间的成员，如果给定了可选的withscores选项，那么命令会将成员的分值也一并返回</td>
</tr>
</tbody>
</table>
<h5 id="范围型数据获取命令和范围型数据删除命令，以及并集和交集命令"><a href="#范围型数据获取命令和范围型数据删除命令，以及并集和交集命令" class="headerlink" title="范围型数据获取命令和范围型数据删除命令，以及并集和交集命令"></a>范围型数据获取命令和范围型数据删除命令，以及并集和交集命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>zrevrank</td>
<td>zrevrank key-name member 返回有序集合成员member的排名，成员按照分值从大到小排列</td>
</tr>
<tr>
<td>zrevrange</td>
<td>zrevrange key-name start stop [withscores] 返回有序集合给定排名范围内的成员，成员按照分值从大到小排列</td>
</tr>
<tr>
<td>zrangebyscore</td>
<td>zrangebyscore key min max [withscores] [limit offset count] 返回有序集合中，分值介于min和max之间的所有成员</td>
</tr>
<tr>
<td>zrevrangebyscore</td>
<td>zrevrangebyscore key min max [withscores] [limit offset count] 获取有序集合中分值介于min和max之间所有成员，并按照分值从大到小的顺序来返回它们</td>
</tr>
<tr>
<td>zremrangebyrank</td>
<td>zremrangebyrank key-name start stop 移除有序集合中排名介于start和stop之间的所有成员</td>
</tr>
<tr>
<td>zremrangebyscore</td>
<td>zremrangebyscore key-name min max 移除有序集合中分值介于min和max之间的所有成员</td>
</tr>
<tr>
<td>zinterstore</td>
<td>zinterstore dest-key key-count key [key …] [withscores weight [weight …]] [aggregate sum\</td>
<td>min\</td>
<td>max] 对给定的有序集合执行类似于集合的交集运算</td>
</tr>
<tr>
<td>zunionstore</td>
<td>zunionstore dest-key key-count key [key …] [withscores weight [weight …]] [aggregate sum\</td>
<td>min\</td>
<td>max] 对给定的有序集合执行类似于集合的并集运算</td>
</tr>
</tbody>
</table>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>sort</td>
<td>sort source-key [by pattern] [limit offset count] [get pattern [get pattern …]] [asc\</td>
<td>desc] [alpha] [store dest-key] 根据给定的选项，对输入列表，集合或者有序集合进行排序，然后返回或者存储排序的结果</td>
</tr>
</tbody>
</table>
<h5 id="用于处理过期时间的命令"><a href="#用于处理过期时间的命令" class="headerlink" title="用于处理过期时间的命令"></a>用于处理过期时间的命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>persist</td>
<td>persist key-name 移除键的过期时间</td>
</tr>
<tr>
<td>ttl</td>
<td>ttl key-name 查看给定键距离过期还有多少秒</td>
</tr>
<tr>
<td>expire</td>
<td>expire key-name seconds 让给定键在指定的秒数之后过期</td>
</tr>
<tr>
<td>expireat</td>
<td>expireat key-name timestamp 将给定键的过期时间设置为给定的unix时间戳</td>
</tr>
<tr>
<td>pttl</td>
<td>pttl key-name 查看给定键距离过期时间还有多少毫秒，这个命令在Redis 2.6 或以上版本可用</td>
</tr>
<tr>
<td>pexpire</td>
<td>pexpire key-name milliseconds 让给定键在指定的毫秒数之后过期，这个命令在Redis 2.6 或以上版本可用</td>
</tr>
<tr>
<td>pexpireat</td>
<td>pexpireat key-name timestamp-milliseconds 将一个毫秒级精度的unix时间戳设置为给定键的过期时间，这个命令在Redis 2.6 或以上版本可用</td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/服务器相关/redis/5种数据结构/" data-id="cjei97eij00ep89bl0hcjyt8y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据库相关/mysql/索引的类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/数据库相关/mysql/索引的类型/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库相关/">数据库相关</a>►<a class="article-category-link" href="/categories/数据库相关/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/数据库相关/mysql/索引的类型/">索引的类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>这是最基本的索引，它没有任何限制。它有以下几种创建方式：</p>
<h5 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CREATE INDEX indexName ON mytable(username(length));</div></pre></td></tr></table></figure>
<p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length，下同。</p>
<h5 id="修改表结构的方式"><a href="#修改表结构的方式" class="headerlink" title="修改表结构的方式"></a>修改表结构的方式</h5><p>创建表后，修改表的结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER mytable ADD INDEX [indexName] ON (username(length))</div></pre></td></tr></table></figure></p>
<p>创建表的时候直接指定:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE mytable(  </div><div class="line"> </div><div class="line">    ID INT NOT NULL,   </div><div class="line">     </div><div class="line">    username VARCHAR(16) NOT NULL,  </div><div class="line">     </div><div class="line">    INDEX [indexName] (username(length))  </div><div class="line"> </div><div class="line">);</div></pre></td></tr></table></figure></p>
<h5 id="删除索引的语法："><a href="#删除索引的语法：" class="headerlink" title="删除索引的语法："></a>删除索引的语法：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DROP INDEX [indexName] ON mytable;</div></pre></td></tr></table></figure>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：</p>
<h5 id="创建索引-1"><a href="#创建索引-1" class="headerlink" title="创建索引"></a>创建索引</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CREATE UNIQUE INDEX indexName ON mytable(username(length))</div></pre></td></tr></table></figure>
<h5 id="修改表结构的方式-1"><a href="#修改表结构的方式-1" class="headerlink" title="修改表结构的方式"></a>修改表结构的方式</h5><p>创建表后，修改表的结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER mytable ADD UNIQUE [indexName] ON (username(length))</div></pre></td></tr></table></figure></p>
<p>创建表的时候直接指定:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE mytable(  </div><div class="line"> </div><div class="line">    ID INT NOT NULL,   </div><div class="line">     </div><div class="line">    username VARCHAR(16) NOT NULL,  </div><div class="line">     </div><div class="line">    UNIQUE [indexName] (username(length))  </div><div class="line"> </div><div class="line">);</div></pre></td></tr></table></figure></p>
<h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE mytable(  </div><div class="line"> </div><div class="line">    ID INT NOT NULL,   </div><div class="line">     </div><div class="line">    username VARCHAR(16) NOT NULL,  </div><div class="line">     </div><div class="line">    PRIMARY KEY(ID)  </div><div class="line"> </div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>当然也可以用 ALTER 命令。记住：一个表只能有一个主键。</p>
<h3 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h3><p>为了形象地对比单列索引和组合索引，为表添加多个字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE mytable(  </div><div class="line"> </div><div class="line">    ID INT NOT NULL,   </div><div class="line">     </div><div class="line">    username VARCHAR(16) NOT NULL,  </div><div class="line">     </div><div class="line">    city VARCHAR(50) NOT NULL,  </div><div class="line">     </div><div class="line">    age INT NOT NULL </div><div class="line"> </div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>为了进一步榨取MySQL的效率，就要考虑建立组合索引。就是将 name, city, age建到一个索引里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE mytable ADD INDEX name_city_age (name(10),city,age);</div></pre></td></tr></table></figure></p>
<p>建表时，usernname长度为 16，这里用 10。这是因为一般情况下名字的长度不会超过10，这样会加速索引查询速度，还会减少索引文件的大小，提高INSERT的更新速度。    </p>
<p>如果分别在usernname，city，age上建立单列索引，让该表有3个单列索引，查询时和上述的组合索引效率也会大不一样，远远低于我们的组合索引。虽然此时有了三个索引，但MySQL只能用到其中的那个它认为似乎是最有效率的单列索引。</p>
<p>建立这样的组合索引，其实是相当于分别建立了下面三组组合索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">usernname,city,age  </div><div class="line"> </div><div class="line">usernname,city  </div><div class="line"> </div><div class="line">usernname</div></pre></td></tr></table></figure></p>
<p>为什么没有city，age这样的组合索引呢？这是因为MySQL组合索引“<strong>最左前缀</strong>”的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这三列的查询都会用到该组合索引，下面的几个SQL就会用到这个组合索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM mytable WHREE username=&quot;admin&quot; AND city=&quot;郑州&quot; </div><div class="line"> </div><div class="line">SELECT * FROM mytable WHREE username=&quot;admin&quot;</div></pre></td></tr></table></figure></p>
<p>而下面几个则不会用到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM mytable WHREE age=20 AND city=&quot;郑州&quot; </div><div class="line"> </div><div class="line">SELECT * FROM mytable WHREE city=&quot;郑州&quot;</div></pre></td></tr></table></figure></p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>全文索引(也称全文检索)是目前搜索引擎使用的一种关键技术。它能够利用“分词技术”等多种算法智能分析出文本文字中关键字词的频率及重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。</p>
<h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><p>建表的时候确定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE article ( </div><div class="line">      id INT AUTO_INCREMENT NOT NULL PRIMARY KEY, </div><div class="line">      title VARCHAR(200), </div><div class="line">      body TEXT, </div><div class="line">      FULLTEXT(title, body) </div><div class="line">) TYPE=MYISAM;</div></pre></td></tr></table></figure></p>
<p>通过 alter table 的方式来添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> ALTER TABLE `student` ADD FULLTEXT INDEX INDEX_NAME  (`name`) </div><div class="line"></div><div class="line">或者：ALTER TABLE `student` ADD FULLTEXT INDEX_NAME  (`name`)</div></pre></td></tr></table></figure></p>
<p>直接通过create index的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CREATE FULLTEXT INDEX INDEX_NAME ON `student` (`name`)</div><div class="line"></div><div class="line">也可以在创建索引的时候指定索引的长度：</div><div class="line">CREATE FULLTEXT INDEX INDEX_NAME ON `student` (`name`(20))</div></pre></td></tr></table></figure></p>
<h5 id="删除全文索引"><a href="#删除全文索引" class="headerlink" title="删除全文索引"></a>删除全文索引</h5><p>直接使用 drop index(注意：没有 drop fulltext index 这种用法)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DROP INDEX INDEX_NAME ON TABLENAME ;</div></pre></td></tr></table></figure></p>
<p>使用 alter table的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE TABLENAME DROP INDEX INDEX_NAME;</div></pre></td></tr></table></figure></p>
<h5 id="使用全文索引"><a href="#使用全文索引" class="headerlink" title="使用全文索引"></a>使用全文索引</h5><p>跟普通索引稍有不同,使用全文索引的格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MATCH (columnName) AGAINST (&apos;string&apos;)</div></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM `student` WHERE MATCH(`name`) AGAINST(&apos;聪&apos;)</div></pre></td></tr></table></figure></p>
<h5 id="设置条件"><a href="#设置条件" class="headerlink" title="设置条件"></a>设置条件</h5><ol>
<li>表的存储引擎是MyISAM，默认存储引擎InnoDB不支持全文索引（新版本MYSQL5.6的InnoDB支持全文索引）    </li>
<li>字段类型：char、varchar和text</li>
</ol>
<p>MySQL自带的全文索引只能对英文进行全文检索，目前无法对中文进行全文检索。如果需要对包含中文在内的文本数据进行全文检索，我们需要采用Sphinx(斯芬克斯)/Coreseek技术来处理中文</p>
<h5 id="全文索引应用流程："><a href="#全文索引应用流程：" class="headerlink" title="全文索引应用流程："></a>全文索引应用流程：</h5><ol>
<li>接收数据-数据分词-入库</li>
<li>接收数据-数据分词-查询</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/数据库相关/mysql/索引的类型/" data-id="cjei97ehx00dj89blbf1kosro" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据库相关/mysql/查询性能优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/数据库相关/mysql/查询性能优化/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库相关/">数据库相关</a>►<a class="article-category-link" href="/categories/数据库相关/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/数据库相关/mysql/查询性能优化/">查询性能优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="慢查询基础：优化数据访问"><a href="#慢查询基础：优化数据访问" class="headerlink" title="慢查询基础：优化数据访问"></a>慢查询基础：优化数据访问</h2><p>对于低效的查询，我们发现通过下面两个步骤来分析总是很有效的：</p>
<ul>
<li>确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多列。</li>
<li>确认MySQL服务器层是否在分析大量超过需要的数据行。</li>
</ul>
<p>对于MySQL，最简单的衡量查询开销的三个指标如下：</p>
<ul>
<li>响应时间</li>
<li>扫描的行数</li>
<li>返回的行数</li>
</ul>
<p>一般MySQL能够使用如下三种方式应用WHERE条件，从好到坏依次为：</p>
<ul>
<li>在索引中使用WHERE条件来过滤不匹配的记录。这是在存储引擎层完成的。</li>
<li>使用索引覆盖扫描（在Extra列中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无须再回表查询记录。</li>
<li>从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using Where）。这是在MySQL服务器层完成，MySQL需要先从数据表读出记录然后过滤。</li>
</ul>
<p>如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试下面的技巧去优化它：</p>
<ul>
<li>使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果了</li>
<li>改变库表结构</li>
<li>重写这个复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询</li>
</ul>
<h2 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h2><h6 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h6><p>有时候对于一个大查询我们需要“分而治之”，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果</p>
<h6 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h6><p>很多高性能的应用都会对关联查询进行分解。简单地，可以对每一个表进行一次单表查询，然后将结果在应用程序中进行关联。例如，下面这个查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT * FROM tag</div><div class="line">    -&gt;   JOIN tag_post ON tag_post.tag_id=tag.id</div><div class="line">    -&gt;   JOIN post on tag_post.post_id=post.id</div><div class="line">    -&gt; WHERE tag.tag=&apos;mysql&apos;;</div></pre></td></tr></table></figure></p>
<p>可以分解成下面这些查询来代替：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT * FROM tag WHERE tag=&apos;mysql&apos;;</div><div class="line">mysql&gt; SELECT * FROM tag_post WHERE tag_id=1234;</div><div class="line">mysql&gt; SELECT * FROM post WHERE post.id in(123, 456, 789);</div></pre></td></tr></table></figure></p>
<p>用分解关联查询的方式重构查询有如下的优势：</p>
<ul>
<li>让缓存更高效。许多应用程序可以方便地缓存单表查询对应的结果对象。</li>
<li>将查询分解后，执行单个查询可以减少锁的竞争</li>
<li>在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展</li>
<li>查询本身效率也可能会有所提升。在这个例子中，使用IN()代替关联查询，可以染MySQL按照ID顺序进行查询，这可能比随机的关联要更高效。</li>
<li>可以减少冗余记录的查询。在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复地访问一部分数据。从这点看，这样的重构还可能会减少网络和内存的消耗。</li>
<li>更进一步，这样做相当于在应用中实现了哈希关联，而不是使用MySQL的嵌套循环查询。</li>
</ul>
<h2 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h2><p>MySQL执行一个查询的过程：<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/MySQL8.jpeg" alt="image"></p>
<ol>
<li>客户端发送一条查询给服务器</li>
<li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段</li>
<li>服务器进行SQL解析，预处理，再由优化器生成对应的执行计划</li>
<li>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询</li>
<li>将结果返回给客户端</li>
</ol>
<h6 id="MySQL客户端-服务器通信协议"><a href="#MySQL客户端-服务器通信协议" class="headerlink" title="MySQL客户端/服务器通信协议"></a>MySQL客户端/服务器通信协议</h6><p>MySQL客户端和服务器之间的通信协议是“半双工”的，这意味着，在任何一个时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生。所以，我们无法也无须将一个消息切成小块独立来发送。</p>
<p>这种协议让MySQL通信简单快速，但是也从很多地方限制了MySQL。一个明显的限制是，这意味着无法进行流量控制。一旦一端开始发送消息，另一端要接收完整个消息才能响应它。</p>
<p>客户端用一个单独的数据包将查询传给服务器。这也是为什么当查询的语句很长的时候，参数<code>max_allowed_packet</code>就特别重要了。一旦客户端发送了请求，它能做的事情就只是等待结果了。</p>
<p>相反的，一般服务器响应给用户的数据通常很多，由多个数据包组成。当服务器开始响应客户端请求时，客户端必须完整地接收整个返回结果，而不能简单地只取前面几条结果，然后让服务器停止发送数据。</p>
<p>换一种方式解释这种行为：当客户端从服务器取数据时，看起来是一个拉数据的过程，但实际上是MySQL在向客户端推送数据的过程。客户端不断地接收从服务器推送的数据，客户端也无法让服务器停下来。</p>
<p>多数连接MySQL的库函数都可以获得全部结果集并缓存到内存里，还可以逐行获取需要的数据。默认一般是获得全部结果集并缓存到内存中。MySQL通常需要等所有的数据都已经发送给客户端才能释放这条查询所占用的资源，所以接收全部结果并缓存通常可以减少服务器的压力，让查询能够早点结束，早点释放相应的资源。</p>
<h6 id="查询状态"><a href="#查询状态" class="headerlink" title="查询状态"></a>查询状态</h6><p>对于一个MySQL连接，或者说一个线程，任何时刻都由一个状态，该状态表示了MySQL当前正在做什么。由很多中方式能够查看当前的状态，最简单的是使用<code>SHOW FULL PROCESSLIST</code>命令（该命令返回结果中的Command列就表示当前的状态）</p>
<h6 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h6><p>当不能使用索引生成排序结果的时候，MySQL需要自己进行排序，如果数据量小则在内存中进行，如果数据量大则需要使用磁盘，不过MySQL将这个过程统一称为文件排序（filesort），即使完全是内存排序不需要任何磁盘文件时也是如此。</p>
<p>如果需要排序的数据量小于“排序缓冲区”，MySQL使用内存进行“快速排序”操作。如果内存不够排序，那么MySQL会先将数据分块，对每个独立的块使用“快速排序”进行排序，并将各个块的排序结果存放在磁盘上，然后将各个拍好序的块进行合并（merge），最后返回排序结果。</p>
<p>MySQL有两种排序算法，新版本使用的是<strong>单次传输排序</strong>：<br>先读取查询所需要的所有列，然后再根据给定列进行排序，最后直接返回排序结果。这个算法只在MySQL4.1及后续更新的版本引入。因为不再需要从数据表读取两次数据，对于I/O密集型的应用，这样做的效率高了很多。另外，相比两次传输排序，这个算法只需要一次顺序I/O读取所有的数据，而无须任何的随机I/O。缺点是，如果需要返回的列非常多，非常大，会额外占用大量的空间，而这些列对排序操作本身来说是没有任何作用的。因为单条排序记录很大，所以可能会有更多的排序块需要合并。</p>
<p><strong>在关联查询的时候如果需要排序，MySQL会分两种情况来处理这样的文件排序。如果ORDER BY 子句中的所有列都来自关联的第一个表。那么MySQL在关联处理第一个表的时候就进行文件排序。如果是这样，那么在MySQL的EXPLAIN结果中可以看到Extra字段会有“Using filesort”。除此之外的所有情况，MySQL都会先将关联的结果存放到一个临时表中，然后再所有的关联都结束后，再进行文件排序。这种情况下，在MySQL的EXPLAIN结果的Extra字段可以看到“Using temporary；Using filesort”。如果查询中有LIMIT的话，LIMIT也会在排序之后应用，所以即使需要返回较少的数据，临时表和需要排序的数据量仍然会非常大</strong>。</p>
<h2 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h2><h6 id="优化count-查询"><a href="#优化count-查询" class="headerlink" title="优化count()查询"></a>优化count()查询</h6><p>count()是一个特殊的函数，有两种非常不同的作用：它可以统计某个列值的数量，也可以统计行数。</p>
<p>在统计列值时要求列值是非空的（不统计NULL）。如果在count()的括号中指定了列或者列的表达式，则统计的就是这个表达式有值的结果数。</p>
<p>在统计结果集的行数时，当MySQL确认括号内的表达式值不可能为空时，实际上就是在统计行数。最简单的就是当我们使用count(*)的时候，它会忽略所有的列而直接统计所有的行数。</p>
<h6 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h6><ul>
<li>确保ON 或者 USING 子句中的列上有索引。一般来说，除非有其他理由，否则只需要在关联顺序中的第二个表的相应列上创建索引。</li>
<li>确保任何的 GROUP BY 和 ORDER BY 中的表达式只涉及到一个表中的列。这样MySQL才有可能使用索引来优化这个过程。</li>
<li>当升级MySQL的时候需要注意：关联语法，运算符优先级等其他可能会发生变化的地方。</li>
</ul>
<h6 id="优化GROUP-BY-和-DISTINCT"><a href="#优化GROUP-BY-和-DISTINCT" class="headerlink" title="优化GROUP BY 和 DISTINCT"></a>优化GROUP BY 和 DISTINCT</h6><p>MySQL优化器会在内部处理的时候相互转化这两类查询。它们都可以使用索引来优化，这也是最有效的优化办法。</p>
<p>在MySQL中，当无法使用索引的时候，GROUP BY使用两种策略来完成：<strong>使用临时表或者文件排序来做分组</strong>。</p>
<p><strong>如果没有通过ORDER BY子句显式地指定排序列，当查询使用GROUP BY子句的时候，结果集会自动按照分组的字段进行排序。如果不关心结果集的顺序，而这种默认排序又导致了需要文件排序，则可以使用ORDER BY NULL，让MySQL不再进行文件排序。也可以在GROUP BY子句中直接使用DESC 或ASC关键字，使分组的结果集按需要的方向排序</strong>。</p>
<h6 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h6><p>优化此类分页查询的一个最简单的办法就是尽可能地使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候，这样做的效率会提升非常大。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/数据库相关/mysql/查询性能优化/" data-id="cjei97ehw00dh89blwcofrisu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/基础/java中的访问修饰符" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/13/Java/基础/java中的访问修饰符/" class="article-date">
  <time datetime="2017-10-13T02:09:45.000Z" itemprop="datePublished">2017-10-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/13/Java/基础/java中的访问修饰符/">java中的访问修饰符</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java面向对象的基本思想之一是封装细节并且公开接口。Java语言采用访问控制修饰符来控制类及类的方法和变量的访问权限，从而向使用者暴露接口，但隐藏实现细节。访问控制分为四种级别：</p>
<ol>
<li><p><code>public</code>： 用public修饰的类、类属变量及方法，包内及包外的任何类（包括子类和普通类）均可以访问；</p>
</li>
<li><p><code>protected</code>： 用protected修饰的类、类属变量及方法，包内的任何类及包外那些继承了该类的子类才能访问），==protected重点突出继承==；</p>
</li>
<li><p><code>default</code>： 如果一个类、类属变量及方法没有用任何修饰符（即没有用public、protected及private中任何一种修饰），则其访问权限为default（默认访问权限）。默认访问权限的类、类属变量及方法，包内的任何类（包括继承了此类的子类）都可以访问它，而对于包外的任何类都不能访问它（包括包外继承了此类的子类）。==default重点突出包==；</p>
</li>
<li><p><code>private</code>： 用private修饰的类、类属变量及方法，只有本类可以访问，而包内包外的任何类均不能访问它。　</p>
</li>
</ol>
<p>网上一些资料及一些书上用表格对java访问修饰符做了清楚的总结，如下表所示： </p>
<table>
<thead>
<tr>
<th>访问控制修饰符</th>
<th>访问级别</th>
<th>同类</th>
<th>同包</th>
<th>子类</th>
<th>不同的包</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>公开的</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td>protected</td>
<td>受保护的</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td>✖️</td>
</tr>
<tr>
<td>default</td>
<td>默认的</td>
<td>✔️</td>
<td>✔️</td>
<td>✖️</td>
<td>✖️</td>
</tr>
<tr>
<td>private</td>
<td>私有的</td>
<td>✔️</td>
<td>✖️</td>
<td>✖️</td>
<td>✖️</td>
</tr>
</tbody>
</table>
<p>重要总结：通过上面的分析，我们可以看到：    </p>
<ol>
<li><p>顶层类只能用public访问修饰符和default（默认）访问修饰符修饰，其中用默认修饰符修饰的类（即没有任何修饰符的类，如class B{}）不能被其他包中的类继承，这也说明了default（默认）访问修饰符突出的是包权限</p>
</li>
<li><p>protected：本人做了一次实验，发现在不同包的子类中，new一个父类对象，并用该父类对象去访问父类中的用protected修饰的类属变量和方法时不能访问，而new一个子类对象时，子类对象可以访问（说明protected修饰的类可以被其他包中的类继承）。也可以在子类重写父类的方法中使用super关键字调用。　　　　</p>
<p> protected修饰符的修饰的成员变量和方法也称为受保护的成员变量和方法， 受保护的成员变量和方法可以在本类或同一个包中的其它类（包括子类）中通过类的实例进行访问，也可以被同一个包中的类或不同包中的类继承，但是不能在不同包中的其它类（包括子类）中通过类的实例进行访问。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//注：TestA和TestB位于不同的包中</div><div class="line">public class TestA &#123;</div><div class="line">	protected String aa = &quot;123&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class TestB extends TestA &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		TestA a = new TestA();</div><div class="line">		System.out.println(a.aa);//报错</div><div class="line">		</div><div class="line">		TestB b = new TestB();</div><div class="line">		System.out.println(b.aa);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>如果一个类使用public修饰，那该类的类名必须与他所在的源文件名相同。一个.java源文件中有且只有一个public类，顶层类只能用public和默认修饰符（即无修饰符）修饰；</p>
</li>
<li><p>final修饰的类不能被继承，没有子类。</p>
</li>
<li><p>abstract修饰的类不能被实例化，必须被子类继承。类只要有一个抽象方法就必定是抽象类，但抽象类不一定要有抽象方法。</p>
</li>
</ol>
<p>最终总结，就一句话：<strong>protected修饰符所修饰的类（这句话中指父类）属成员变量和方法，只可以被子类访问，而不管子类是不是和父类位于同一个包中。default修饰符所修饰的类属成员变量和方法，只可被同一个包中的其他类访问，而不管其他类是不是该类的子类。protected属于子类限制修饰符，而default属于包限制修饰符</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/10/13/Java/基础/java中的访问修饰符/" data-id="cjei97edo004189blqexr7zjb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/基础/Filter过滤器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/28/Java/基础/Filter过滤器/" class="article-date">
  <time datetime="2017-08-28T02:09:45.000Z" itemprop="datePublished">2017-08-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/28/Java/基础/Filter过滤器/">Filter过滤器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Filter也称之为过滤器，它是Servlet技术中最激动人心的技术之一，WEB开发人员通过Filter技术，对web服务器管理的所有web资源：例如Jsp,Servlet,静态图片文件或静态html文件等进行拦截，从而实现一些特殊的功能。例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。  </p>
<p>Servlet API中提供了一个Filter接口，开发web应用时，如果编写的Java类实现了这个接口，则把这个java类称之为过滤器Filter。通过Filter技术，开发人员可以实现用户在访问某个目标资源之前，对访问的请求和响应进行拦截，Filter接口源代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public abstract interface Filter&#123;  </div><div class="line">    public abstract void init(FilterConfig paramFilterConfig) throws ServletException;  </div><div class="line">    public abstract void doFilter(ServletRequest paramServletRequest, ServletResponse paramServletResponse, FilterChain   </div><div class="line">        paramFilterChain) throws IOException, ServletException;  </div><div class="line">    public abstract void destroy();  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Servlet API中提供了一个Filter接口，开发web应用时，如果编写的Java类实现了这个接口，则把这个java类称之为过滤器Filter。通过Filter技术，开发人员可以实现用户在访问某个目标资源之前，对访问的请求和响应进行拦截，如下所示：<br><img src="http://images2015.cnblogs.com/blog/892393/201604/892393-20160425211729548-1717874729.png" alt="image"><br>filter是如何实现过滤的：<br>Filter接口中有一个doFilter方法，当我们编写好Filter，并配置对哪个web资源进行拦截后，WEB服务器每次在调用web资源的service方法之前，都会先调用一下filter的doFilter方法，因此，在该方法内编写代码可达到如下目的：</p>
<ol>
<li>调用目标资源之前，让一段代码执行。</li>
<li>是否调用目标资源（即是否让用户访问web资源）。</li>
<li>调用目标资源之后，让一段代码执行。</li>
</ol>
<p>web服务器在调用doFilter方法时，会传递一个filterChain对象进来，filterChain对象是filter接口中最重要的一个对 象，它也提供了一个doFilter方法，开发人员可以根据需求决定是否调用此方法，调用该方法，则web服务器就会调用web资源的service方 法，即web资源就会被访问，否则web资源不会被访问。</p>
<h4 id="Filter链"><a href="#Filter链" class="headerlink" title="Filter链"></a>Filter链</h4><p>在一个web应用中，可以开发编写多个Filter，这些Filter组合起来称之为一个Filter链。web服务器根据Filter在web.xml文件中的注册顺序，决定先调用哪个Filter，当第一个Filter的doFilter方法被调用时，web服务器会创建一个代表Filter链的FilterChain对象传递给该方法。在doFilter方法中，开发人员如果调用了FilterChain对象的doFilter方法，则web服务器会检查FilterChain对象中是否还有filter，如果有，则调用第2个filter，如果没有，则调用目标资源。</p>
<h2 id="Filter的生命周期"><a href="#Filter的生命周期" class="headerlink" title="Filter的生命周期"></a>Filter的生命周期</h2><h4 id="Filter的创建"><a href="#Filter的创建" class="headerlink" title="Filter的创建"></a>Filter的创建</h4><p>Filter的创建和销毁由web服务器负责。 web应用程序启动时，web服务器将创建Filter的实例对象，并调用其init方法，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作，filter对象只会创建一次，init方法也只会执行一次。通过init方法的参数，可获得代表当前filter配置信息的FilterConfig对象。</p>
<h4 id="Filter的销毁"><a href="#Filter的销毁" class="headerlink" title="Filter的销毁"></a>Filter的销毁</h4><p>web容器调用destroy方法销毁Filter。destroy方法在Filter的生命周期中仅执行一次。在destroy方法中，可以释放过滤器使用的资源。</p>
<h4 id="FilterConfig接口"><a href="#FilterConfig接口" class="headerlink" title="FilterConfig接口"></a>FilterConfig接口</h4><p>用户在配置filter时，可以使用<init-param>为filter配置一些初始化参数，当web容器实例化Filter对象，调用其init方法时，会把封装了filter初始化参数的filterConfig对象传递进来。因此开发人员在编写filter时，通过filterConfig对象的方法，就可获得：</init-param></p>
<ul>
<li>String getFilterName()：得到filter的名称。</li>
<li>String getInitParameter(String name)： 返回在部署描述中指定名称的初始化参数的值。如果不存在返回null.</li>
<li>Enumeration getInitParameterNames()：返回过滤器的所有初始化参数的名字的枚举集合。</li>
<li>public ServletContext getServletContext()：返回Servlet上下文对象的引用。</li>
</ul>
<h2 id="Filter配置"><a href="#Filter配置" class="headerlink" title="Filter配置"></a>Filter配置</h2><h4 id="Filter实现"><a href="#Filter实现" class="headerlink" title="Filter实现"></a>Filter实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class EncodingFilter implements Filter &#123;  </div><div class="line">    private String encoding;  </div><div class="line">    private Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();  </div><div class="line">    // 项目结束时就已经进行销毁  </div><div class="line">    public void destroy() &#123;  </div><div class="line">        //进行资源回收等，只调用一次</div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    public void doFilter(ServletRequest req, ServletResponse resp,  </div><div class="line">            FilterChain chain) throws IOException, ServletException &#123;  </div><div class="line">        //调用资源前的逻辑处理</div><div class="line">        ...</div><div class="line">        </div><div class="line">        //调用下一个过滤器，如果没有过滤器，则调用真正的service方法</div><div class="line">        chain.doFilter(req, resp);   </div><div class="line">        </div><div class="line">        //调用资源后的逻辑处理</div><div class="line">        ...</div><div class="line">    &#125;  </div><div class="line">   </div><div class="line">    // 项目启动时就已经进行读取  </div><div class="line">    public void init(FilterConfig config) throws ServletException &#123;  </div><div class="line">        //初始化资源，在web容器启动时只调用一次</div><div class="line">    &#125;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h4 id="注册Filter"><a href="#注册Filter" class="headerlink" title="注册Filter"></a>注册Filter</h4><p>开发好Filter之后，需要在web.xml文件中进行注册，这样才能够被web服务器调用。在web.xml文件中注册Filter范例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;filter&gt;  </div><div class="line">    &lt;description&gt;过滤器描述&lt;/description&gt;  </div><div class="line">    &lt;filter-name&gt;过滤器名称&lt;/filter-name&gt;  </div><div class="line">    &lt;filter-class&gt;过滤器地址&lt;/filter-class&gt;  </div><div class="line">    &lt;!--配置FilterTest过滤器的初始化参数--&gt;  </div><div class="line">    &lt;init-param&gt;  </div><div class="line">        &lt;description&gt;配置过滤器的初始化参数&lt;/description&gt;  </div><div class="line">        &lt;param-name&gt;name&lt;/param-name&gt;  </div><div class="line">        &lt;param-value&gt;gacl&lt;/param-value&gt;  </div><div class="line">    &lt;/init-param&gt;  </div><div class="line">    &lt;init-param&gt;  </div><div class="line">        &lt;description&gt;配置FilterTest过滤器的初始化参数&lt;/description&gt;  </div><div class="line">        &lt;param-name&gt;like&lt;/param-name&gt;  </div><div class="line">        &lt;param-value&gt;java&lt;/param-value&gt;  </div><div class="line">    &lt;/init-param&gt;  </div><div class="line">&lt;/filter&gt;</div></pre></td></tr></table></figure></p>
<ul>
<li><description>用于添加描述信息，该元素的内容可为空，<description>可以不配置。</description></description></li>
<li><filter-name>用于为过滤器指定一个名字，该元素的内容不能为空。</filter-name></li>
<li><filter-class>元素用于指定过滤器的完整的限定类名。</filter-class></li>
<li><init-param>元素用于为过滤器指定初始化参数，它的子元素<param-name>指定参数的名字，<param-value>指定参数的值。</param-value></param-name></init-param></li>
</ul>
<p>在过滤器中，<br>可以使用FilterConfig接口对象来访问初始化参数。如果过滤器不需要指定初始化参数，那么<init-param>元素可以不配置。</init-param></p>
<h4 id="映射Filter"><a href="#映射Filter" class="headerlink" title="映射Filter"></a>映射Filter</h4><p>在web.xml文件中注册了Filter之后，还要在web.xml文件中映射Filter<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;!--映射过滤器--&gt;</div><div class="line">&lt;filter-mapping&gt;</div><div class="line">  &lt;filter-name&gt;FilterTest&lt;/filter-name&gt;</div><div class="line">  &lt;!--“/*”表示拦截所有的请求 --&gt;</div><div class="line">  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">&lt;/filter-mapping&gt;</div></pre></td></tr></table></figure></p>
<ul>
<li><filter-mapping>元素用于设置一个 Filter 所负责拦截的资源。一个Filter拦截的资源可通过两种方式来指定：Servlet 名称和资源访问的请求路径</filter-mapping></li>
<li><filter-name>子元素用于设置filter的注册名称。该值必须是在<filter>元素中声明过的过滤器的名字</filter></filter-name></li>
<li><url-pattern>设置 filter 所拦截的请求路径(过滤器关联的URL样式)</url-pattern></li>
<li><servlet-name>指定过滤器所拦截的Servlet名称。</servlet-name></li>
<li><p><dispatcher>指定过滤器所拦截的资源被 Servlet 容器调用的方式，可以是<code>REQUEST</code>,<code>INCLUDE</code>,<code>FORWARD</code>和<code>ERROR</code>之一，<strong>默认REQUEST</strong>。用户可以设置多个<dispatcher> 子元素用来指定 Filter 对资源的多种调用方式进行拦截。如下：</dispatcher></dispatcher></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;filter-mapping&gt;</div><div class="line">    &lt;filter-name&gt;testFilter&lt;/filter-name&gt;</div><div class="line">    &lt;url-pattern&gt;/index.jsp&lt;/url-pattern&gt;</div><div class="line">    &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;</div><div class="line">    &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;</div><div class="line">&lt;/filter-mapping&gt;</div></pre></td></tr></table></figure>
<p>  <dispatcher> 子元素可以设置的值及其意义：</dispatcher></p>
<ul>
<li>REQUEST：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过RequestDispatcher的include()或forward()方法访问<br>时，那么该过滤器就不会被调用。</li>
<li>INCLUDE：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。</li>
<li>FORWARD：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。</li>
<li>ERROR：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/28/Java/基础/Filter过滤器/" data-id="cjei97edj003n89bl30oevybu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/基础/java三大特性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/28/Java/基础/java三大特性/" class="article-date">
  <time datetime="2017-08-28T02:09:45.000Z" itemprop="datePublished">2017-08-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/28/Java/基础/java三大特性/">java三大特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。    </p>
<p>指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。    </p>
<p>多态有两种表现形式：编译时多态（方法重载）和运行时多态（方法重写）</p>
<p>Java实现多态有三个必要条件（运行时多态）：继承、重写、向上转型（子类引用指向父类）。</p>
<ul>
<li>继承：在多态中必须存在有继承关系的子类和父类。</li>
<li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li>
<li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</li>
</ul>
<p>方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。</p>
<p>使用封装有三大好处：</p>
<ol>
<li>良好的封装能够减少耦合</li>
<li>类内部的结构可以自由修改，模块之间互不干扰</li>
<li>隐藏信息，对外只提供接口，提高安全性</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>通过继承实现代码复用。Java中所有的类都是通过直接或间接地继承java.lang.Object类得到的。继承而得到的类称为子类，被继承的类称为父类。子类不能继承父类中访问权限为private的成员变量和方法。子类可以重写父类的方法，及命名与父类同名的成员变量。但Java不支持多重继承，即一个类从多个超类派生的能力。在开发中尽量减少继承关系，这样做是为了把程序的耦合度降低。  </p>
<h3 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h3><ol>
<li><p>构造函数<br>当子类继承一个父类时，构造子类时需要调用父类的构造函数，存在三种情况:<br>（1），父类无构造函数或者一个无参数构造函数，子类若无构造函数或者有无参数构造函数，子类构造函数中不需要显式调用父类的构造函数，系统会自动在调用子类构造函数前调用父类的构造函数<br>（2），父类只有有参数构造函数，子类在构造方法中必须要显示调用父类的构造函数，否则编译出错<br>（3），父类既有无参数构造函数，也有有参构造函数，子类可以不在构造方法中调用父类的构造函数，这时使用的是父类的无参数构造函数    </p>
</li>
<li><p>方法覆盖<br>（1）子类覆盖父类的方法，在jdk1.5后，参数返回类可以是父类方法返回类的子类<br>（2）子类覆盖父类方法，可以修改方法作用域修饰符，但只能把方法的作用域放大，而不能把public修改为private<br>(3) 子类方法能够访问父类的protected作用域成员，不能够访问默认的作用域成员<br>（4）子类的静态方法不能隐藏同名的父类实例方法<br>（5）继承的方法具有多态性    </p>
</li>
<li><p>成员覆盖<br>（1）当子类覆盖父类的成员变量时，父类方法使用的是父类的成员变量，子类方法使用的是子类的成员变量    </p>
</li>
</ol>
<h3 id="类的继承知识点"><a href="#类的继承知识点" class="headerlink" title="类的继承知识点"></a>类的继承知识点</h3><ol>
<li>java不支持多重继承，也就是说子类至多只能有一个父类</li>
<li>子类继承了其父类中不是私有的成员变量和成员方法，作为自己的成员变量和方法</li>
<li>子类中定义的成员变量和父类中定义的成员变量相同时，则父类中的成员变量不能被继承</li>
<li>子类中定义的成员方法，并且这个成员方法的名字，返回类型，及参数个数和类型与父类的某个成员方法完全相同，则父类的成员方法不能被继承。</li>
</ol>
<h3 id="谨慎继承"><a href="#谨慎继承" class="headerlink" title="谨慎继承"></a>谨慎继承</h3><p>首先我们需要明确，继承存在如下缺陷：</p>
<ol>
<li>父类变，子类就必须变。</li>
<li>继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。</li>
<li>继承是一种强耦合关系。</li>
</ol>
<p>所以说当我们使用继承的时候，我们需要确信使用继承确实是有效可行的办法。那么到底要不要使用继承呢？《Think in java》中提供了解决办法：问一问自己是否需要从子类向父类进行向上转型。如果必须向上转型，则继承是必要的，但是如果不需要，则应当好好考虑自己是否需要继承。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/28/Java/基础/java三大特性/" data-id="cjei97edo003z89bl0e9k9aep" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/基础/泛型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/27/Java/基础/泛型/" class="article-date">
  <time datetime="2017-08-27T02:09:45.000Z" itemprop="datePublished">2017-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/27/Java/基础/泛型/">泛型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>泛型，即“参数化类型”</strong>。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p>
<p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，<strong>这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法</strong>。</p>
<h4 id="类型的好处"><a href="#类型的好处" class="headerlink" title="类型的好处"></a>类型的好处</h4><ul>
<li><strong>类型安全</strong>。泛型的主要目标是提高Java程序的类型安全。通过知道使用泛型定义的变量的类型限制，编译器可以在一个高得多的程度上验证类型假设。没有泛型，这些假设就只存在于程序员的头脑中（或者如果幸运的话，还存在于代码注释中）。通过在变量声明中捕获这一附加的类型信息，泛型允许编译器实施这些附加的类型约束。类型错误现在就可以在编译时被捕获了，而不是在运行时当作 ClassCastException 展示出来。将类型检查从运行时挪到编译时有助于您更容易找到错误，并可提高程序的可靠性。</li>
<li><strong>消除强制类型转换</strong>。泛型的一个附带好处是，消除源代码中的许多强制类型转换。这使得代码更加可读，并且减少了出错机会。</li>
</ul>
<h2 id="泛型的产生"><a href="#泛型的产生" class="headerlink" title="泛型的产生"></a>泛型的产生</h2><p>一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">List arrayList = new ArrayList();</div><div class="line">arrayList.add(&quot;aaaa&quot;);</div><div class="line">arrayList.add(100);</div><div class="line"></div><div class="line">for(int i = 0; i&lt; arrayList.size();i++)&#123;</div><div class="line">    String item = (String)arrayList.get(i);</div><div class="line">    Log.d(&quot;泛型测试&quot;,&quot;item = &quot; + item);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>毫无疑问，程序的运行结果会以崩溃结束：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</div></pre></td></tr></table></figure></p>
<p>ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。    </p>
<p>我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();</div><div class="line">...</div><div class="line">//arrayList.add(100); 在编译阶段，编译器就会报错</div></pre></td></tr></table></figure></p>
<h2 id="泛型的特性"><a href="#泛型的特性" class="headerlink" title="泛型的特性"></a>泛型的特性</h2><p><strong>泛型只在编译阶段有效</strong>。看下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;();</div><div class="line">List&lt;Integer&gt; integerArrayList = new ArrayList&lt;Integer&gt;();</div><div class="line"></div><div class="line">Class classStringArrayList = stringArrayList.getClass();</div><div class="line">Class classIntegerArrayList = integerArrayList.getClass();</div><div class="line"></div><div class="line">if(classStringArrayList.equals(classIntegerArrayList))&#123;</div><div class="line">    Log.d(&quot;泛型测试&quot;,&quot;类型相同&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：D/泛型测试: 类型相同。    </p>
<p>通过上面的例子可以证明，<strong>在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段</strong>。  </p>
<p>对此总结成一句话：<strong>泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</strong></p>
<h2 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h2><p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法</p>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。  </p>
<p>一个最普通的泛型类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</div><div class="line">//在实例化泛型类时，必须指定T的具体类型</div><div class="line">public class Generic&lt;T&gt;&#123; </div><div class="line">    //key这个成员变量的类型为T,T的类型由外部指定  </div><div class="line">    private T key;</div><div class="line"></div><div class="line">    public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定</div><div class="line">        this.key = key;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定</div><div class="line">        return key;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型</div><div class="line">//传入的实参类型需与泛型的类型参数类型相同，即为Integer.</div><div class="line">Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456);</div><div class="line"></div><div class="line">//传入的实参类型需与泛型的类型参数类型相同，即为String.</div><div class="line">Generic&lt;String&gt; genericString = new Generic&lt;String&gt;(&quot;key_vlaue&quot;);</div><div class="line">Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericInteger.getKey());</div><div class="line">Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericString.getKey());</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">泛型测试: key is 123456</div><div class="line">泛型测试: key is key_vlaue</div></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>泛型的类型参数只能是类类型，不能是简单类型。</li>
<li>不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if(ex_num instanceof Generic&lt;Number&gt;)&#123;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//定义一个泛型接口</div><div class="line">public interface Generator&lt;T&gt; &#123;</div><div class="line">    public T next();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当实现泛型接口的类，未传入泛型实参时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</div><div class="line"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</div><div class="line"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;</div><div class="line"> */</div><div class="line">class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</div><div class="line">    @Override</div><div class="line">    public T next() &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当实现泛型接口的类，传入泛型实参时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 传入泛型实参时：</div><div class="line"> * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</div><div class="line"> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</div><div class="line"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</div><div class="line"> * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</div><div class="line"> */</div><div class="line">public class FruitGenerator implements Generator&lt;String&gt; &#123;</div><div class="line"></div><div class="line">    private String[] fruits = new String[]&#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;&#125;;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String next() &#123;</div><div class="line">        Random rand = new Random();</div><div class="line">        return fruits[rand.nextInt(3)];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><p>我们知道Ingeter是Number的一个子类，同时在特性章节中我们也验证过Generic<ingeter>与Generic<number>实际上是相同的一种基本类型。那么问题来了，在使用Generic<number>作为形参的方法中，能否使用Generic<ingeter>的实例传入呢？在逻辑上类似于Generic<number>和Generic<ingeter>是否可以看成具有父子关系的泛型类型呢？    </ingeter></number></ingeter></number></number></ingeter></p>
<p>为了弄清楚这个问题，我们使用Generic<t>这个泛型类继续看下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void showKeyValue1(Generic&lt;Number&gt; obj)&#123;</div><div class="line">    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</div><div class="line">&#125;</div></pre></td></tr></table></figure></t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Generic&lt;Integer&gt; gInteger = new Generic&lt;Integer&gt;(123);</div><div class="line">Generic&lt;Number&gt; gNumber = new Generic&lt;Number&gt;(456);</div><div class="line"></div><div class="line">showKeyValue(gNumber);</div><div class="line"></div><div class="line">// showKeyValue这个方法编译器会为我们报错：Generic&lt;java.lang.Integer&gt; </div><div class="line">// cannot be applied to Generic&lt;java.lang.Number&gt;</div><div class="line">// showKeyValue(gInteger);</div></pre></td></tr></table></figure>
<p>通过提示信息我们可以看到Generic<integer>不能被看作为`Generic<number>的子类。由此可以看出:<strong>同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的</strong>。  </number></integer></p>
<p>回到上面的例子，如何解决上面的问题？总不能为了定义一个新的方法来处理Generic<integer>类型的类，这显然与java中的多台理念相违背。因此我们需要一个在逻辑上可以表示同时是Generic<integer>和Generic<number>父类的引用类型。由此类型通配符应运而生。 </number></integer></integer></p>
<p>我们可以将上面的方法改一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void showKeyValue1(Generic&lt;?&gt; obj)&#123;</div><div class="line">    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>类型通配符一般是使用？代替具体的类型实参，注意了，此处’？’是类型实参，而不是类型形参 。再直白点的意思就是，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。</p>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>在java中,泛型类的定义非常简单，但是泛型方法就比较复杂了。<br>尤其是我们见到的大多数泛型类中的成员方法也都使用了泛型，有的甚至泛型类中也包含着泛型方法，这样在初学者中非常容易将泛型方法理解错了。    </p>
<p><strong>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 </strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 泛型方法的基本介绍</div><div class="line"> * @param tClass 传入的泛型实参</div><div class="line"> * @return T 返回值为T类型</div><div class="line"> * 说明：</div><div class="line"> *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</div><div class="line"> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</div><div class="line"> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</div><div class="line"> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</div><div class="line"> */</div><div class="line">public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException ,</div><div class="line">  IllegalAccessException&#123;</div><div class="line">        T instance = tClass.newInstance();</div><div class="line">        return instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="泛型方法的基本用法"><a href="#泛型方法的基本用法" class="headerlink" title="泛型方法的基本用法"></a>泛型方法的基本用法</h4><p>光看上面的例子有的同学可能依然会非常迷糊，我们再通过一个例子，把泛型方法再总结一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">public class GenericTest &#123;</div><div class="line">   //这个类是个泛型类，在上面已经介绍过</div><div class="line">   public class Generic&lt;T&gt;&#123;     </div><div class="line">        private T key;</div><div class="line"></div><div class="line">        public Generic(T key) &#123;</div><div class="line">            this.key = key;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。</div><div class="line">        //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</div><div class="line">        //所以在这个方法中才可以继续使用 T 这个泛型。</div><div class="line">        public T getKey()&#123;</div><div class="line">            return key;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息&quot;cannot reslove symbol E&quot;</div><div class="line">         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。</div><div class="line">        public E setKey(E key)&#123;</div><div class="line">             this.key = keu</div><div class="line">        &#125;</div><div class="line">        */</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** </div><div class="line">     * 这才是一个真正的泛型方法。</div><div class="line">     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T</div><div class="line">     * 这个T可以出现在这个泛型方法的任意位置.</div><div class="line">     * 泛型的数量也可以为任意多个 </div><div class="line">     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</div><div class="line">     *        ...</div><div class="line">     *        &#125;</div><div class="line">     */</div><div class="line">    public &lt;T&gt; T showKeyName(Generic&lt;T&gt; container)&#123;</div><div class="line">        System.out.println(&quot;container key :&quot; + container.getKey());</div><div class="line">        //当然这个例子举的不太合适，只是为了说明泛型方法的特性。</div><div class="line">        T test = container.getKey();</div><div class="line">        return test;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。</div><div class="line">    public void showKeyValue1(Generic&lt;Number&gt; obj)&#123;</div><div class="line">        Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?</div><div class="line">    //同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类</div><div class="line">    public void showKeyValue2(Generic&lt;?&gt; obj)&#123;</div><div class="line">        Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     /**</div><div class="line">     * 这个方法是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &apos;E&apos; &quot;</div><div class="line">     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。</div><div class="line">     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。</div><div class="line">    public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;</div><div class="line">        ...</div><div class="line">    &#125;  </div><div class="line">    */</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 这个方法也是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &apos;T&apos; &quot;</div><div class="line">     * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。</div><div class="line">     * 所以这也不是一个正确的泛型方法声明。</div><div class="line">    public void showkey(T genericObj)&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    */</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="类中的泛型方法"><a href="#类中的泛型方法" class="headerlink" title="类中的泛型方法"></a>类中的泛型方法</h4><p>当然这并不是泛型方法的全部，泛型方法可以出现杂任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，我们再通过一个例子看一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">public class GenericFruit &#123;</div><div class="line">    class Fruit&#123;</div><div class="line">        @Override</div><div class="line">        public String toString() &#123;</div><div class="line">            return &quot;fruit&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class Apple extends Fruit&#123;</div><div class="line">        @Override</div><div class="line">        public String toString() &#123;</div><div class="line">            return &quot;apple&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class Person&#123;</div><div class="line">        @Override</div><div class="line">        public String toString() &#123;</div><div class="line">            return &quot;Person&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class GenerateTest&lt;T&gt;&#123;</div><div class="line">        public void show_1(T t)&#123;</div><div class="line">            System.out.println(t.toString());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</div><div class="line">        //由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</div><div class="line">        public &lt;E&gt; void show_3(E t)&#123;</div><div class="line">            System.out.println(t.toString());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</div><div class="line">        public &lt;T&gt; void show_2(T t)&#123;</div><div class="line">            System.out.println(t.toString());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Apple apple = new Apple();</div><div class="line">        Person person = new Person();</div><div class="line"></div><div class="line">        GenerateTest&lt;Fruit&gt; generateTest = new GenerateTest&lt;Fruit&gt;();</div><div class="line">        //apple是Fruit的子类，所以这里可以</div><div class="line">        generateTest.show_1(apple);</div><div class="line">        //编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person</div><div class="line">        //generateTest.show_1(person);</div><div class="line"></div><div class="line">        //使用这两个方法都可以成功</div><div class="line">        generateTest.show_2(apple);</div><div class="line">        generateTest.show_2(person);</div><div class="line"></div><div class="line">        //使用这两个方法也都可以成功</div><div class="line">        generateTest.show_3(apple);</div><div class="line">        generateTest.show_3(person);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="泛型方法与可变参数"><a href="#泛型方法与可变参数" class="headerlink" title="泛型方法与可变参数"></a>泛型方法与可变参数</h4><p>再看一个泛型方法和可变参数的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public &lt;T&gt; void printMsg( T... args)&#123;</div><div class="line">    for(T t : args)&#123;</div><div class="line">        Log.d(&quot;泛型测试&quot;,&quot;t is &quot; + t);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">printMsg(&quot;111&quot;,222,&quot;aaaa&quot;,&quot;2323.4&quot;,55.55);</div></pre></td></tr></table></figure>
<h4 id="静态方法与泛型"><a href="#静态方法与泛型" class="headerlink" title="静态方法与泛型"></a>静态方法与泛型</h4><p>静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：<strong>静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上</strong>。    </p>
<p>即：<strong>如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 </strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class StaticGenerator&lt;T&gt; &#123;</div><div class="line">    ....</div><div class="line">    ....</div><div class="line">    /**</div><div class="line">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</div><div class="line">     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。</div><div class="line">     * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：</div><div class="line">          &quot;StaticGenerator cannot be refrenced from static context&quot;</div><div class="line">     */</div><div class="line">    public static &lt;T&gt; void show(T t)&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="泛型上下边界"><a href="#泛型上下边界" class="headerlink" title="泛型上下边界"></a>泛型上下边界</h3><p><strong>泛型添加上边界，即传入的类型实参必须是指定类型的子类型</strong></p>
<p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void showKeyValue1(Generic&lt;? extends Number&gt; obj)&#123;</div><div class="line">    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;(&quot;11111&quot;);</div><div class="line">Generic&lt;Integer&gt; generic2 = new Generic&lt;Integer&gt;(2222);</div><div class="line">Generic&lt;Float&gt; generic3 = new Generic&lt;Float&gt;(2.4f);</div><div class="line">Generic&lt;Double&gt; generic4 = new Generic&lt;Double&gt;(2.56);</div><div class="line"></div><div class="line">//这一行代码编译器会提示错误，因为String类型并不是Number类型的子类</div><div class="line">//showKeyValue1(generic1);</div><div class="line"></div><div class="line">showKeyValue1(generic2);</div><div class="line">showKeyValue1(generic3);</div><div class="line">showKeyValue1(generic4);</div></pre></td></tr></table></figure>
<p>如果我们把泛型类的定义也改一下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Generic&lt;T extends Number&gt;&#123;</div><div class="line">    private T key;</div><div class="line"></div><div class="line">    public Generic(T key) &#123;</div><div class="line">        this.key = key;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public T getKey()&#123;</div><div class="line">        return key;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//这一行代码也会报错，因为String不是Number的子类</div><div class="line">Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;(&quot;11111&quot;);</div></pre></td></tr></table></figure>
<p>再来一个泛型方法的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加</div><div class="line">//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错：&quot;Unexpected bound&quot;</div><div class="line">public &lt;T extends Number&gt; T showKeyName(Generic&lt;T&gt; container)&#123;</div><div class="line">    System.out.println(&quot;container key :&quot; + container.getKey());</div><div class="line">    T test = container.getKey();</div><div class="line">    return test;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过上面的两个例子可以看出：<strong>泛型的上下边界添加，必须与泛型的声明在一起</strong>。</p>
<h4 id="泛型方法总结"><a href="#泛型方法总结" class="headerlink" title="泛型方法总结"></a>泛型方法总结</h4><p>泛型方法能使方法独立于类而产生变化，以下是一个基本的指导原则：<br><code>无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。所以如果static方法要使用泛型能力，就必须使其成为泛型方法。</code></p>
<h4 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h4><p>看到了很多文章中都会提起泛型数组，经过查看sun的说明文档，在java中是”<strong>不能创建一个确切的泛型类型的数组</strong>”的。    </p>
<p>也就是说下面的这个例子是不可以的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt;[] ls = new ArrayList&lt;String&gt;[10];</div></pre></td></tr></table></figure></p>
<p>而使用通配符创建泛型数组是可以的，如下面这个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;?&gt;[] ls = new ArrayList&lt;?&gt;[10];</div></pre></td></tr></table></figure></p>
<p>这样也是可以的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt;[] ls = new ArrayList[10];</div></pre></td></tr></table></figure></p>
<p>下面使用Sun的一篇文档的一个例子来说明这个问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt;[] lsa = new List&lt;String&gt;[10]; // Not really allowed.    </div><div class="line">Object o = lsa;    </div><div class="line">Object[] oa = (Object[]) o;    </div><div class="line">List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;();    </div><div class="line">li.add(new Integer(3));    </div><div class="line">oa[1] = li; // Unsound, but passes run time store check    </div><div class="line">String s = lsa[1].get(0); // Run-time error: ClassCastException.</div></pre></td></tr></table></figure></p>
<p>这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。</p>
<p>而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。</p>
<p>下面采用通配符的方式是被允许的:数组的类型不可以是类型变量，除非是采用通配符的方式，因为对于通配符的方式，最后取出数据是要做显式的类型转换的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">List&lt;?&gt;[] lsa = new List&lt;?&gt;[10]; // OK, array of unbounded wildcard type.    </div><div class="line">Object o = lsa;    </div><div class="line">Object[] oa = (Object[]) o;    </div><div class="line">List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;();    </div><div class="line">li.add(new Integer(3));    </div><div class="line">oa[1] = li; // Correct.    </div><div class="line">Integer i = (Integer) lsa[1].get(0); // OK</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/27/Java/基础/泛型/" data-id="cjei97edx004p89blo9pwrje5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/6/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Eclipse/">Eclipse</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Github/">Github</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Cookie/">Cookie</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JAXB/">JAXB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JavaMail/">JavaMail</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/基础/">基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/数据类型/">数据类型</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/日记/">日记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/时间日期/">时间日期</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/线程/">线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/网络NIO/">网络NIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/队列/">队列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/集合/">集合</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Application-Event/">Application Event</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/JPA/">JPA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Security/">Security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Spring-Boot/">Spring Boot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Spring-Session/">Spring Session</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Task/">Task</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-MVC/">spring MVC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-data-redis/">spring data redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/基础/">基础</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/">前端技术相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/forever/">forever</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/javascript/">javascript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库相关/">数据库相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据库相关/mysql/">mysql</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/">服务器相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hessian/">Hessian</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hudson-Jenkins/">Hudson & Jenkins</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Memcached/">Memcached</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Nginx/">Nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Tomcat/">Tomcat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/red5/">red5</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/resin/">resin</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/正则表达式/">正则表达式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/08/正则表达式/正则表达式/">正则表达式</a>
          </li>
        
          <li>
            <a href="/2018/02/25/Java/基础/类加载机制/">类加载机制</a>
          </li>
        
          <li>
            <a href="/2018/02/25/Java/集合/HashSet原理/">HashSet原理</a>
          </li>
        
          <li>
            <a href="/2018/02/25/Java/集合/几种常见的map/">几种常见的map</a>
          </li>
        
          <li>
            <a href="/2018/02/25/Java/集合/Hashtable与ConcurrentHashMap区别/">Hashtable与ConcurrentHashMap区别</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 LeoChan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>