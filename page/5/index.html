<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LeoChan&#39;s 个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="描述啊">
<meta property="og:type" content="website">
<meta property="og:title" content="LeoChan&#39;s 个人博客">
<meta property="og:url" content="https://clq2owesome.github.io/page/5/index.html">
<meta property="og:site_name" content="LeoChan&#39;s 个人博客">
<meta property="og:description" content="描述啊">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeoChan&#39;s 个人博客">
<meta name="twitter:description" content="描述啊">
  
    <link rel="alternate" href="/atom.xml" title="LeoChan&#39;s 个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LeoChan&#39;s 个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术都是通用的，重要的是是否具有自主解决问题的能力！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://clq2owesome.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-GitHub/git命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/GitHub/git命令/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Github/">Github</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/GitHub/git命令/">git命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：</p>
<ol>
<li><p><code>/etc/gitconfig</code> 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 –system 选项的 git config 时，它会从此文件读写配置变量。</p>
</li>
<li><p><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：只针对当前用户。 可以传递 –global 选项让 Git 读写此文件。</p>
</li>
<li><p>当前使用仓库的 Git 目录中的 config 文件（就是 <code>.git/config</code>）：针对该仓库。</p>
</li>
</ol>
<p>每一个级别覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。</p>
<h4 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h4><p>当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;John Doe&quot;</div><div class="line">$ git config --global user.email johndoe@example.com</div></pre></td></tr></table></figure></p>
<p>再次强调，如果使用了 –global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 –global 选项的命令来配置。</p>
<h4 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h4><p>如果想要检查你的配置，可以使用 <code>git config --list</code> 命令来列出所有 Git 当时能找到的配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ git config --list</div><div class="line">credential.helper=osxkeychain</div><div class="line">user.name=陈礼强</div><div class="line">user.email=chenliqiang@000861.com</div><div class="line">difftool.sourcetree.cmd=opendiff &quot;$LOCAL&quot; &quot;$REMOTE&quot;</div><div class="line">difftool.sourcetree.path=</div><div class="line">mergetool.sourcetree.cmd=/Applications/SourceTree.app/Contents/Resources/opendiff-w.sh &quot;$LOCAL&quot; &quot;$REMOTE&quot; -ancestor &quot;$BASE&quot; -merge &quot;$MERGED&quot;</div><div class="line">mergetool.sourcetree.trustexitcode=true</div><div class="line">core.excludesfile=/Users/chenliqiang/.gitignore_global</div><div class="line">core.quotepath=false</div><div class="line">commit.template=/Users/chenliqiang/.stCommitMsg</div></pre></td></tr></table></figure></p>
<p>你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：/etc/gitconfig 与 ~/.gitconfig）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。</p>
<p>你可以通过输入 git config <key>： 来检查 Git 的某一项配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config user.name</div><div class="line">clq</div></pre></td></tr></table></figure></key></p>
<h3 id="git基础"><a href="#git基础" class="headerlink" title="git基础"></a>git基础</h3><h4 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h4><p>有两种取得 Git 项目仓库的方法。   </p>
<ul>
<li>在现有项目或目录下导入所有文件到 Git 中； </li>
<li>从一个服务器克隆一个现有的 Git 仓库。</li>
</ul>
<h5 id="在现有目录中初始化仓库"><a href="#在现有目录中初始化仓库" class="headerlink" title="在现有目录中初始化仓库"></a>在现有目录中初始化仓库</h5><p>如果你打算使用 Git 来对现有的项目进行管理，你只需要进入该项目目录并输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git init</div></pre></td></tr></table></figure></p>
<p>该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。</p>
<h5 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h5><p>Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。 当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。 事实上，如果你的服务器的磁盘坏掉了，你通常可以使用任何一个克隆下来的用户端来重建服务器上的仓库</p>
<p>克隆仓库的命令格式是 <code>git clone [url]</code>。 比如，要克隆 Git 的可链接库 libgit2，可以用下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/libgit2/libgit2</div></pre></td></tr></table></figure></p>
<p>这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹，从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 libgit2 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。 如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/libgit2/libgit2 mylibgit</div></pre></td></tr></table></figure></p>
<p>这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为 mylibgit。</p>
<h4 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h4><p>请记住，你工作目录下的每一个文件都不外乎这两种状态：<strong>已跟踪或未跟踪</strong>。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。 工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。</p>
<p>编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。所以使用 Git 时文件的生命周期如下：<br><img src="https://git-scm.com/book/en/v2/images/lifecycle.png" alt="image"></p>
<h5 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h5><p>要查看哪些文件处于什么状态，可以用 git status 命令。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">nothing to commit, working directory clean</div></pre></td></tr></table></figure></p>
<p>这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。 此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。 最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。 现在，分支名是 “master”,这是默认的分支名。</p>
<p>现在，让我们在项目下创建一个新的 text.txt 文件。 如果之前并不存在这个文件，使用 git status 命令，你将看到一个新的未跟踪文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">echo &apos;test&apos; &gt; text.txt</div><div class="line">chenliqiangdeMacBook-Pro:jenkinsTest chenliqiang$ git status</div><div class="line">On branch master</div><div class="line">Your branch is up to date with &apos;origin/master&apos;.</div><div class="line"></div><div class="line">Untracked files:</div><div class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</div><div class="line"></div><div class="line">	text.txt</div><div class="line"></div><div class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</div></pre></td></tr></table></figure></p>
<p>在状态报告中可以看到新建的 README 文件出现在 Untracked files 下面。 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”， 这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。 不过现在的例子中，我们确实想要跟踪管理 test.txt 这个文件。</p>
<h6 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h6><p>git status命令的输出十分详细，但其用语有些繁琐。 如果你使用 ·git status -s· 命令或 ·git status –short· 命令，你将得到一种更为紧凑的格式输出。 运行 git status -s ，状态报告输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git status -s</div><div class="line"> M README.md //未暂存的已修改的文件</div><div class="line">M  pom.xml //已暂存的已修改的文件</div><div class="line">A  text.txt //已暂存的新文件</div><div class="line">?? aa.txt  //表示未暂存新加的文件</div></pre></td></tr></table></figure></p>
<h5 id="暂存文件"><a href="#暂存文件" class="headerlink" title="暂存文件"></a>暂存文件</h5><p>git add 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。</p>
<p>将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适</p>
<p>使用命令 git add 开始暂存一个文件。 所以，要暂存 text.txt 文件，运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git add text.txt</div></pre></td></tr></table></figure></p>
<p>此时再运行 git status 命令，会看到 README 文件已被跟踪，并处于暂存状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Your branch is up to date with &apos;origin/master&apos;.</div><div class="line"></div><div class="line">Changes to be committed:</div><div class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</div><div class="line"></div><div class="line">	new file:   text.txt</div></pre></td></tr></table></figure></p>
<p>只要在 <code>Changes to be committed</code> 这行下面的，就说明是已暂存状态。 如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。 你可能会想起之前我们使用 git init 后就运行了 git add (files) 命令，开始跟踪当前目录下的文件。</p>
<h5 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h5><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。 来看一个实际的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cat .gitignore</div><div class="line">*.[oa]</div><div class="line">*~</div></pre></td></tr></table></figure></p>
<p>第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。</p>
<h5 id="查看已暂存和未暂存的修改-diff"><a href="#查看已暂存和未暂存的修改-diff" class="headerlink" title="查看已暂存和未暂存的修改(diff)"></a>查看已暂存和未暂存的修改(diff)</h5><p><code>git diff</code> 看暂存前后的变化<br><code>git diff --cached</code> 查看已经暂存起来的变化：（–staged 和 –cached 是同义词）</p>
<h5 id="提交更新-git-commit"><a href="#提交更新-git-commit" class="headerlink" title="提交更新(git commit)"></a>提交更新(git commit)</h5><p>一般会在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$git commit -m &quot;这是本次提交说明&quot;</div><div class="line"></div><div class="line">[master d78b417] 这是本次提交说明</div><div class="line"> 2 files changed, 2 insertions(+), 1 deletion(-)</div><div class="line"> create mode 100644 text.txt</div></pre></td></tr></table></figure></p>
<p>可以看到，提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整 SHA-1 校验和是什么（463dc4f），以及在本次提交中，有多少文件修订过，多少行添加和删改过。</p>
<p>请记住，提交时记录的是放在暂存区域的快照。 任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p>
<h6 id="跳过使用暂存区域-git-commit-a"><a href="#跳过使用暂存区域-git-commit-a" class="headerlink" title="跳过使用暂存区域(git commit -a)"></a>跳过使用暂存区域(git commit -a)</h6><p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，<strong>Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git commit -m &quot;提交为暂存的文件&quot; -a</div><div class="line">[master 3e3a5fe] 提交为暂存的文件</div><div class="line"> 1 file changed, 1 insertion(+)</div></pre></td></tr></table></figure></p>
<h5 id="移除文件-rm"><a href="#移除文件-rm" class="headerlink" title="移除文件(rm)"></a>移除文件(rm)</h5><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是<strong>从暂存区域移除</strong>），然后提交。 可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git rm aa.txt</div></pre></td></tr></table></figure></p>
<p>下一次提交时，该文件就不再纳入版本管理了。 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。</p>
<p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 <code>--cached</code> 选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git rm --cached aa.txt</div></pre></td></tr></table></figure></p>
<h5 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h5><p>不像其它的 VCS 系统，Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。<br>既然如此，当你看到 Git 的 mv 命令时一定会困惑不已。 要在 Git 中对文件改名，可以这么做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># aa.txt文件必须先要加入暂存中</div><div class="line">$ git mv aa.txt abc.txt</div></pre></td></tr></table></figure></p>
<p>其实，运行 git mv 就相当于运行了下面三条命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ mv README.md README</div><div class="line">$ git rm README.md</div><div class="line">$ git add README</div></pre></td></tr></table></figure></p>
<h4 id="撤消操作"><a href="#撤消操作" class="headerlink" title="撤消操作"></a>撤消操作</h4><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 –amend 选项的提交命令尝试重新提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git commit --amend</div></pre></td></tr></table></figure></p>
<p>这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。</p>
<h4 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git reset HEAD abcd.txt</div></pre></td></tr></table></figure>
<h4 id="撤消对文件的修改"><a href="#撤消对文件的修改" class="headerlink" title="撤消对文件的修改"></a>撤消对文件的修改</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -- abcd.txt</div></pre></td></tr></table></figure>
<h4 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h4><p>如果想查看你已经配置的远程仓库服务器，可以运行 <code>git remote</code> 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin - 这是 Git 给你克隆的仓库服务器的默认名字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git remote</div><div class="line">origin</div></pre></td></tr></table></figure></p>
<p>你也可以指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git remote -v</div><div class="line">origin	git@120.77.81.95:root/JenkinsTest.git (fetch)</div><div class="line">origin	git@120.77.81.95:root/JenkinsTest.git (push)</div></pre></td></tr></table></figure></p>
<h4 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h4><p>运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote add gittest git@120.77.81.95:root/gittest.git</div></pre></td></tr></table></figure></p>
<p>现在你可以在命令行中使用字符串 pb 来代替整个 URL。</p>
<h4 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h4><p>从远程仓库中获得数据，可以执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git fetch [remote-name]</div></pre></td></tr></table></figure></p>
<p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p>
<p>如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 <strong>必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作</strong>。</p>
<p>如果你有一个分支设置为跟踪一个远程分支，可以使用 git pull 命令来自动的抓取然后合并远程分支到当前分支。 这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支。 运行 <code>git pull</code> 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p>
<h4 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h4><p>当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：<code>git push [remote-name] [branch-name]</code>。 当你想要将 master 分支推送到 origin 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push origin master</div></pre></td></tr></table></figure></p>
<p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。</p>
<h4 id="查看远程仓库-1"><a href="#查看远程仓库-1" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h4><p>如果想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show [remote-name]</code> 命令。 如果想以一个特定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote show origin</div></pre></td></tr></table></figure></p>
<p>它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 master 分支，并且如果运行 git pull，就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。 它也会列出拉取到的所有远程引用。</p>
<h4 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h4><p>如果想要重命名引用的名字可以运行 git remote rename 去修改一个远程仓库的简写名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote rename gittest git1test</div></pre></td></tr></table></figure></p>
<p>如果因为一些原因想要移除一个远程仓库,可以使用 git remote rm ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git remote rm git1test</div><div class="line">$ git remote -v</div><div class="line">origin	git@120.77.81.95:root/JenkinsTest.git (fetch)</div><div class="line">origin	git@120.77.81.95:root/JenkinsTest.git (push)</div></pre></td></tr></table></figure></p>
<h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><h5 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h5><p>在 Git 中列出已有的标签是非常简单直观的。 只需要输入 git tag：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag</div></pre></td></tr></table></figure></p>
<p>你也可以使用特定的模式查找标签。 例如，Git 自身的源代码仓库包含标签的数量超过 500 个。 如果只对 1.8.5 系列感兴趣，可以运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git tag -l &apos;v1.8.5*&apos;</div><div class="line">v1.8.5</div><div class="line">v1.8.5-rc0</div></pre></td></tr></table></figure></p>
<h5 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h5><p>Git 使用两种主要类型的标签：<strong>轻量标签（lightweight）与附注标签（annotated）</strong>。</p>
<p>一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。</p>
<p>然而，附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。</p>
<h6 id="附注标签"><a href="#附注标签" class="headerlink" title="附注标签"></a>附注标签</h6><p>在 Git 中创建一个附注标签是很简单的。 最简单的方式是当你在运行 tag 命令时指定 -a 选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag -a v1.0 -m &quot;测试标签&quot;</div></pre></td></tr></table></figure></p>
<p>-m 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入信息。</p>
<p>通过使用 git show 命令可以看到标签信息与对应的提交信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git show v1.0</div></pre></td></tr></table></figure></p>
<h6 id="轻量标签"><a href="#轻量标签" class="headerlink" title="轻量标签"></a>轻量标签</h6><p>另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中 - 没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag v1.0</div></pre></td></tr></table></figure></p>
<h6 id="后期打标签"><a href="#后期打标签" class="headerlink" title="后期打标签"></a>后期打标签</h6><p>你也可以对过去的提交打标签。<br>现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag -a v1.2 9fceb02</div></pre></td></tr></table></figure></p>
<h6 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h6><p>默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样 - 你可以运行 <code>git push origin [tagname]</code>。</p>
<p>如果想要一次性推送很多标签，也可以使用带有 <code>--tags</code> 选项的 git push 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p>
<h6 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h6><p>在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。 如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用 git checkout -b [branchname] [tagname] 在特定的标签上创建一个新分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b version2 v2.0.0</div><div class="line">Switched to a new branch &apos;version2&apos;</div></pre></td></tr></table></figure></p>
<h3 id="Git-分支"><a href="#Git-分支" class="headerlink" title="Git 分支"></a>Git 分支</h3><h4 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h4><p>Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 git branch 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git branch testing</div></pre></td></tr></table></figure></p>
<p>这会在当前所在的提交对象上创建一个指针。<br><img src="https://git-scm.com/book/en/v2/images/two-branches.png" alt="image"></p>
<p>那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 HEAD 的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 <code>HEAD</code> 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。 在本例中，你仍然在 master 分支上。 因为 git branch 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。<br><img src="https://git-scm.com/book/en/v2/images/head-to-master.png" alt="image">  </p>
<p>想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 -b 参数的 git checkout 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b iss53</div><div class="line">Switched to a new branch &quot;iss53&quot;</div></pre></td></tr></table></figure></p>
<p>它是下面两条命令的简写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch iss53</div><div class="line">$ git checkout iss53</div></pre></td></tr></table></figure></p>
<h4 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h4><p>要切换到一个已存在的分支，你需要使用 git checkout 命令。 我们现在切换到新创建的 testing 分支去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout testing</div></pre></td></tr></table></figure></p>
<p>这样 HEAD 就指向 testing 分支了。<br><img src="https://git-scm.com/book/en/v2/images/head-to-testing.png" alt="image"> </p>
<h4 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h4><p>出到你想合并入的分支，然后运行 git merge 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">Switched to branch &apos;master&apos;</div><div class="line">$ git merge iss53</div></pre></td></tr></table></figure></p>
<h4 id="分支删除"><a href="#分支删除" class="headerlink" title="分支删除"></a>分支删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git branch -d iss53</div></pre></td></tr></table></figure>
<h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p>git branch 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git branch</div><div class="line">* master</div><div class="line">  testing</div></pre></td></tr></table></figure></p>
<p>注意 master 分支前的 * 字符：它代表现在检出的那一个分支（也就是说，当前 HEAD 指针所指向的分支）。 这意味着如果在这时候提交，master 分支将会随着新的工作向前移动。 如果需要查看每一个分支的最后一次提交，可以运行 git branch -v 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git branch -v</div><div class="line">* master  32262c1 [ahead 1] 123</div><div class="line">  testing 32262c1 123</div></pre></td></tr></table></figure></p>
<p>–merged 与 –no-merged 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 git branch –merged：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git branch --merged</div><div class="line">* master</div><div class="line">  testing</div></pre></td></tr></table></figure></p>
<h4 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h4><h5 id="显式地获得远程引用的完整列表"><a href="#显式地获得远程引用的完整列表" class="headerlink" title="显式地获得远程引用的完整列表"></a>显式地获得远程引用的完整列表</h5><p><code>git ls-remote (remote)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git ls-remote origin</div><div class="line">877993c88d9772791f18d6b5a913f57b6282f0e5	HEAD</div><div class="line">877993c88d9772791f18d6b5a913f57b6282f0e5	refs/heads/master</div><div class="line">8b41f3c4ccc0c8f3eb5a0a5ba6c84c849c752a37	refs/tags/v1.0</div><div class="line">877993c88d9772791f18d6b5a913f57b6282f0e5	refs/tags/v1.0^&#123;&#125;</div></pre></td></tr></table></figure></p>
<h5 id="获得远程分支的更多信息"><a href="#获得远程分支的更多信息" class="headerlink" title="获得远程分支的更多信息"></a>获得远程分支的更多信息</h5><p><code>git remote show (remote)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ git remote show origin</div><div class="line">* remote origin</div><div class="line">  Fetch URL: git@120.77.81.95:root/JenkinsTest.git</div><div class="line">  Push  URL: git@120.77.81.95:root/JenkinsTest.git</div><div class="line">  HEAD branch: master</div><div class="line">  Remote branch:</div><div class="line">    master tracked</div><div class="line">  Local branch configured for &apos;git pull&apos;:</div><div class="line">    master merges with remote master</div><div class="line">  Local ref configured for &apos;git push&apos;:</div><div class="line">    master pushes to master (fast-forwardable)</div></pre></td></tr></table></figure></p>
<h5 id="推送远程分支"><a href="#推送远程分支" class="headerlink" title="推送远程分支"></a>推送远程分支</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push (remote) (branch)</div></pre></td></tr></table></figure>
<p>如果并不想让远程仓库上的分支叫做 serverfix，可以运行 git push origin serverfix:awesomebranch 来将本地的 serverfix 分支推送到远程仓库上的 awesomebranch 分支。</p>
<h5 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h5><p>从一个远程跟踪分支检出一个本地分支会自动创建一个叫做 “跟踪分支”（有时候也叫做 “上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p>
<p>当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。 然而，如果你愿意的话可以设置其他的跟踪分支 - 其他远程仓库上的跟踪分支，或者不跟踪 master 分支。 最简单的就是之前看到的例子，运行 git checkout -b [branch] [remotename]/[branch]。 这是一个十分常用的操作所以 Git 提供了 –track 快捷方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git checkout --track origin/serverfix</div><div class="line">Branch serverfix set up to track remote branch serverfix from origin.</div><div class="line">Switched to a new branch &apos;serverfix&apos;</div></pre></td></tr></table></figure></p>
<p>如果想要将本地分支与远程分支设置为不同名字，你可以轻松地增加一个不同名字的本地分支的上一个命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b sf origin/serverfix</div><div class="line">Branch sf set up to track remote branch serverfix from origin.</div><div class="line">Switched to a new branch &apos;sf&apos;</div></pre></td></tr></table></figure></p>
<p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用 -u 或 –set-upstream-to 选项运行 git branch 来显式地设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch -u origin/serverfix</div><div class="line">Branch serverfix set up to track remote branch serverfix from origin.</div></pre></td></tr></table></figure></p>
<h5 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h5><p>当 git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 clone 或 checkout 命令为你创建的，git pull 都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。</p>
<p>由于 git pull 的魔法经常令人困惑所以通常单独显式地使用 fetch 与 merge 命令会更好一些。</p>
<h5 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h5><p>假设你已经通过远程分支做完所有的工作了 - 也就是说你和你的协作者已经完成了一个特性并且将其合并到了远程仓库的 master 分支（或任何其他稳定代码分支）。 可以运行带有 –delete 选项的 git push 命令来删除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git push origin --delete serverfix</div><div class="line">To https://github.com/schacon/simplegit</div><div class="line"> - [deleted]         serverfix</div></pre></td></tr></table></figure></p>
<p>基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/GitHub/git命令/" data-id="cjfvvphgv0004m9fyiqfigqan" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/Spring Boot/多环境配置" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Spring/Spring Boot/多环境配置/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/Spring-Boot/">Spring Boot</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Spring/Spring Boot/多环境配置/">多环境配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="配置文件加载顺序"><a href="#配置文件加载顺序" class="headerlink" title="配置文件加载顺序"></a>配置文件加载顺序</h2><ol>
<li>在命令行中传入的参数</li>
<li>SPRING_APPLICATION_JSON中的属性。SPRING_APPLICATION_JSON是以JSON格式配置在系统环境变量中的内容</li>
<li>java:comp/env中的JNDI属性</li>
<li>java的系统属性，可以通过System.getproperties()获得的内容</li>
<li>操作系统的环境变量</li>
<li>通过random.*配置的随机属性</li>
<li>位于当前应用jar包之外，针对不同{profile}环境的配置文件内容，例如application-{profile}.properties或是YAML定义的配置文件</li>
<li>位于当前应用jar包之内，针对不同{profile}环境的配置文件内容，例如application-{profile}.properties或是YAML定义的配置文件</li>
<li>位于当前应用jar包之外的application.properties和YAML配置内容</li>
<li>位于当前应用jar包之内的application.properties和YAML配置内容</li>
<li>在@Configuration注解修改的类中，通过@PropertySource注解定义的属性</li>
<li>应用默认属性，使用SpringApplication.setDefaultProperties定义的内容</li>
</ol>
<p>优先级按上面的顺序由高到低，数字越小优先级越高</p>
<p>可以看到，其中第7项和第9项都是从应用jar包之外读取配置文件，所以，实现外部化配置的原理就是从此切入，为其指定外部配置文件的记载位置来取代jar包之内的配置内容。通过这样的实现，我们的工程在配置中就变的非常干净，只需在本地放置开发需要的配置即可，而不用关心其他环境的配置，由其对应环境的负责人去维护即可</p>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>使用命令<code>java -jar</code>来启动应用时，还可以在命令行中指定应用的参数，比如<code>java -jar xxx.jar --server.port=8888</code>，直接以命令行的方式来设置<code>server.port</code>属性，并将启动应用的端口设为8888</p>
<p>在命令行方式启动Spring Boot应用时，连续的两个减号–就是对application.properties中的属性值进行赋值的标识。所以，<code>java -jar xxx.jar --server.port=8888</code>命令，等价于在application.properties中添加属性server.port=8888</p>
<h2 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h2><p><strong>Spring Boot的默认配置文件位置为：src/main/resources/application.properties 或者 application.yml；Spring Boot默认会加载放置在src/main/resources目录或者类路径的/config下</strong></p>
<p>在Spring Boot中，多环境配置的文件名需要满足application-{profile}.properties的格式，其中{profile}对应你的环境标识，如下所示：</p>
<ul>
<li><strong>application-dev.properties</strong>（开发环境）</li>
<li><strong>application-test.properties</strong>（测试环境）</li>
<li><strong>application-prod.properties</strong>（生产环境）</li>
</ul>
<p>至于具体哪个配置文件会被加载，需要在application.properties文件中通过<strong>spring.profiles.active</strong>属性来设置，其值对应配置文件中的{profile}值。如spring.profiles.active=test就会加载application-test.properties配置文件内容</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>application.properties<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root=http://localhost</div><div class="line"></div><div class="line">#spring.profiles.active</div><div class="line">spring.profiles.active=dev</div></pre></td></tr></table></figure></p>
<ol>
<li>Controller<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Autowired  </div><div class="line">private Environment env;  </div><div class="line">           </div><div class="line">@RequestMapping(&quot;/testProfile&quot;)  </div><div class="line">public String testProfile()&#123;  </div><div class="line">    return env.getProperty(&quot;profile&quot;);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>测试：</p>
<ul>
<li>上述代码执行后的结果是：dev_envrimont</li>
<li>如果application.properties的配置改为：spring.profiles.active=prod，则结果是：prod_envrimont</li>
<li>如果application.properties的配置改为：spring.profiles.active=prod，而application.properties中也配置了profile=xxx（不管该配置配置在spring.profiles.active=prod的上方还是下方），这个时候结果是：prod_envrimont</li>
<li>如果application.properties的配置改为：spring.profiles.active=prod，而application.properties中也配置了profile=xxx（不管该配置配置在spring.profiles.active=prod的上方还是下方），但是application-prod.properties删掉了profile = prod_envrimont，这个时候结果是：xxx</li>
</ul>
<p>结论：</p>
<ul>
<li>各个环境公共的配置写在application.properties中</li>
<li>各个模块独有的配置配置在自己的application-{xxx}.properties文件中</li>
<li>程序读取的时候优先读取application.properties中选中的profile的配置，若读不到才会从application.properties去读</li>
</ul>
<h2 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h2><p>缺陷：无法通过@PropertySource注解来加载配置</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>spring boot中，可以通过在application.yml配置文件中，配置多个不同的profile，实现在不同的环境（比如开发、测试和生产环境）使用不同的配置变量。</p>
<p>具体配置如下（application.yml中的内容）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">server:  </div><div class="line">  port: 8082  </div><div class="line">  </div><div class="line"># 默认的profile为dev，其他环境通过指定启动参数使用不同的profile，比如：  </div><div class="line">#   测试环境：java -jar my-spring-boot.jar --spring.profiles.active=test  </div><div class="line">#   生产环境：java -jar my-spring-boot.jar --spring.profiles.active=prod  </div><div class="line">spring:  </div><div class="line">  profiles:  </div><div class="line">    active: dev  </div><div class="line">  </div><div class="line">---  </div><div class="line"># 开发环境配置  </div><div class="line">spring:  </div><div class="line">  profiles: dev  </div><div class="line">mysql:  </div><div class="line">  ipPort: localhost:3306  </div><div class="line">    </div><div class="line">---  </div><div class="line"># 测试环境配置  </div><div class="line">spring:  </div><div class="line">  profiles: test  </div><div class="line">mysql:  </div><div class="line">  ipPort: 192.168.0.12:8066  </div><div class="line">    </div><div class="line">---  </div><div class="line"># 生产环境配置  </div><div class="line">spring:  </div><div class="line">  profiles: prod  </div><div class="line">mysql:  </div><div class="line">  ipPort: 192.168.0.13:8066</div></pre></td></tr></table></figure></p>
<h2 id="启动Spring-Boot的方式"><a href="#启动Spring-Boot的方式" class="headerlink" title="启动Spring Boot的方式"></a>启动Spring Boot的方式</h2><ol>
<li>作为一个Java应用程序，可以直接通过运行拥有main函数的类来启动</li>
<li><p>通过maven执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn spring-boot:run命令</div></pre></td></tr></table></figure>
</li>
<li><p>在服务其上部署运行时，通常先使用<code>mvn install</code>将应用打包成jar包，再通过<code>java -jar xxx.jar</code>来启动应用</p>
</li>
</ol>
<p>通过指定启动参数使用不同的profile，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#   测试环境：Java -jar my-spring-boot.jar --spring.profiles.active=test</div><div class="line">#   生产环境：java -jar my-spring-boot.jar --spring.profiles.active=prod</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Spring/Spring Boot/多环境配置/" data-id="cjfvvphn600b2m9fy4tqmtlfd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-GitHub/打开SSH功能" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/GitHub/打开SSH功能/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Github/">Github</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/GitHub/打开SSH功能/">打开SSH功能</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Mac通过ssh localhost 拒绝访问的问题，可能是由于sshd服务未开启</p>
<h3 id="开启sshd服务"><a href="#开启sshd服务" class="headerlink" title="开启sshd服务"></a>开启sshd服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo launchctl load -w /System/Library/LaunchDaemons/ssh.plist</div></pre></td></tr></table></figure>
<h3 id="关闭sshd服务"><a href="#关闭sshd服务" class="headerlink" title="关闭sshd服务"></a>关闭sshd服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo launchctl unload -w /System/Library/LaunchDaemons/ssh.plist</div></pre></td></tr></table></figure>
<h3 id="查看ssh的服务是否开启"><a href="#查看ssh的服务是否开启" class="headerlink" title="查看ssh的服务是否开启"></a>查看ssh的服务是否开启</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">launchctl list | grep ssh</div><div class="line">------------------</div><div class="line">-	0	com.openssh.sshd</div></pre></td></tr></table></figure>
<h3 id="查看是否成功"><a href="#查看是否成功" class="headerlink" title="查看是否成功"></a>查看是否成功</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ssh localhost</div><div class="line">-------------------</div><div class="line">The authenticity of host &apos;localhost (::1)&apos; can&apos;t be established.</div><div class="line">ECDSA key fingerprint is SHA256:uS8js0TJ5KVjuNBq9dA2PnVWghti86Wf17B08r8cXyg.</div><div class="line">Are you sure you want to continue connecting (yes/no)? yes</div><div class="line">Warning: Permanently added &apos;localhost&apos; (ECDSA) to the list of known hosts.</div><div class="line">PTY allocation request failed on channel 0</div><div class="line">Hi there, You&apos;ve successfully authenticated, but Gogs does not provide shell access.</div><div class="line">If this is unexpected, please log in with password and setup Gogs under another user.</div><div class="line">Connection to localhost closed.</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20150503221150338?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGlhbnlpaWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/GitHub/打开SSH功能/" data-id="cjfvvphgu0003m9fyq6p2jia7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux/权限相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Linux/权限相关/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Linux/权限相关/">权限相关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="列出所有的文件详细的权限与属性"><a href="#列出所有的文件详细的权限与属性" class="headerlink" title="列出所有的文件详细的权限与属性"></a>列出所有的文件详细的权限与属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ls -al</div><div class="line">drwxr-xr-x+  42 chenliqiang  staff   1344 12  2 14:20 .</div><div class="line">drwxr-xr-x    6 root         admin    192 11 15 11:23 ..</div><div class="line">-r--------    1 chenliqiang  staff      9 11 15 15:44 .CFUserTextEncoding</div><div class="line">-rw-r--r--@   1 chenliqiang  staff  18436 12  2 15:05 .DS_Store</div><div class="line">drwxr-xr-x   11 chenliqiang  staff    352  4 24  2017 .MarkEditorData</div><div class="line">drwx------    2 chenliqiang  staff     64 12  2 15:08 .Trash</div><div class="line">-rw-------    1 chenliqiang  staff  18925 12  2 14:31 .bash_history</div><div class="line">-rw-r--r--@   1 chenliqiang  staff    354 11 30 17:27 .bash_profile</div><div class="line">drwx------  459 chenliqiang  staff  14688 12  2 14:31 .bash_sessions</div><div class="line">drwx------    6 chenliqiang  staff    192 11 28 17:46 .config</div><div class="line">[权限]      [连接]   [所有者] [用户组] [容量：B] [修改时间]   [文件名]</div></pre></td></tr></table></figure>
<h4 id="第一列代表这个文件的类型与权限"><a href="#第一列代表这个文件的类型与权限" class="headerlink" title="第一列代表这个文件的类型与权限"></a>第一列代表这个文件的类型与权限</h4><h5 id="第一个字符代表这个文件是“目录，文件或链接文件等”"><a href="#第一个字符代表这个文件是“目录，文件或链接文件等”" class="headerlink" title="第一个字符代表这个文件是“目录，文件或链接文件等”"></a>第一个字符代表这个文件是“目录，文件或链接文件等”</h5><ul>
<li>d：目录</li>
<li>-：文件</li>
<li>l：连接文件</li>
<li>b：设备文件里面的可供存储的接口设备</li>
<li>c：设备文件里面的串行端口设备</li>
</ul>
<h5 id="接下来的字符中，以3个为一组，且均为“rwx”的3个参数的组合。其中-r-代表可读（read），-w-代表可写（write），-x-代表可执行（execute）"><a href="#接下来的字符中，以3个为一组，且均为“rwx”的3个参数的组合。其中-r-代表可读（read），-w-代表可写（write），-x-代表可执行（execute）" class="headerlink" title="接下来的字符中，以3个为一组，且均为“rwx”的3个参数的组合。其中[r]代表可读（read）， [w]代表可写（write），[x]代表可执行（execute）"></a>接下来的字符中，以3个为一组，且均为“rwx”的3个参数的组合。其中[r]代表可读（read）， [w]代表可写（write），[x]代表可执行（execute）</h5><p>注意：这3个权限的位置不会改变，如果没有权限，就会出现减号[-]而已</p>
<ul>
<li>第一组为“文件所有者的权限”</li>
<li>第二组为“同用户组的权限”</li>
<li>第三组为“其他非本用户组的权限”</li>
</ul>
<h3 id="查看文件或者目录的权限"><a href="#查看文件或者目录的权限" class="headerlink" title="查看文件或者目录的权限"></a>查看文件或者目录的权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">ls -l webapps</div><div class="line">total 0</div><div class="line">drwxr-xr-x  17 chenliqiang  staff   544  9 29 20:27 ROOT</div><div class="line">drwxr-xr-x  54 chenliqiang  staff  1728  9 29 20:27 docs</div><div class="line">drwxr-xr-x   8 chenliqiang  staff   256  9 29 20:27 examples</div><div class="line">drwxr-xr-x   7 chenliqiang  staff   224  9 29 20:27 host-manager</div><div class="line">drwxr-xr-x   8 chenliqiang  staff   256  9 29 20:27 manager</div><div class="line"></div><div class="line">//包括隐藏文件</div><div class="line">ls -al webapps</div><div class="line">total 16</div><div class="line">drwxr-xr-x   8 chenliqiang  staff   256 12  1 15:35 .</div><div class="line">drwxrwxr-x  14 chenliqiang  staff   448 11 30 15:52 ..</div><div class="line">-rw-r--r--@  1 chenliqiang  staff  6148 12  2 15:49 .DS_Store</div><div class="line">drwxr-xr-x  17 chenliqiang  staff   544  9 29 20:27 ROOT</div><div class="line">drwxr-xr-x  54 chenliqiang  staff  1728  9 29 20:27 docs</div><div class="line">drwxr-xr-x   8 chenliqiang  staff   256  9 29 20:27 examples</div><div class="line">drwxr-xr-x   7 chenliqiang  staff   224  9 29 20:27 host-manager</div><div class="line">drwxr-xr-x   8 chenliqiang  staff   256  9 29 20:27 manager</div></pre></td></tr></table></figure>
<h3 id="改变文件属性与权限"><a href="#改变文件属性与权限" class="headerlink" title="改变文件属性与权限"></a>改变文件属性与权限</h3><ul>
<li><code>chgrp</code>：改变文件所属用户组</li>
<li><code>chown</code>：改变文件所属者</li>
<li><code>chmod</code>：改变文件的权限</li>
</ul>
<h4 id="改变所属用户组：chgrp"><a href="#改变所属用户组：chgrp" class="headerlink" title="改变所属用户组：chgrp"></a>改变所属用户组：chgrp</h4><p>注意：要被改变的组名必须要在<code>/etc/group</code>文件内存在才行，否则就会显示错误</p>
<p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">chgrp [-R] 用户组名 目录名/文件名</div><div class="line">选项与参数：</div><div class="line">—R:进行递归（recursive）的持续更改，也即连同子目录下的所有文件，目录</div></pre></td></tr></table></figure></p>
<h4 id="改变文件所有者：chown"><a href="#改变文件所有者：chown" class="headerlink" title="改变文件所有者：chown"></a>改变文件所有者：chown</h4><p>注意：用户必须已经存在与系统中的账号，也就是在<code>/etc/passwd</code>这个文件中有记录的用户名称才能改变</p>
<p>chown还可以直接修改用户组的名称</p>
<p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">chown [-R] 用户名 目录名/文件名</div><div class="line">chown [-R] 用户名:组名 目录名/文件名</div><div class="line">chown [-R] 用户名.组名 目录名/文件名(不建议这样的写法，因为账号中可能会有小数点，如：vbird.tsai)</div><div class="line">选项与参数：</div><div class="line">—R:进行递归（recursive）的持续更改，也即连同子目录下的所有文件，目录</div></pre></td></tr></table></figure></p>
<h4 id="改变权限：chmod"><a href="#改变权限：chmod" class="headerlink" title="改变权限：chmod"></a>改变权限：chmod</h4><p>权限的设置方法有两种，可以使用数字或者是符号来进行权限的更改</p>
<h6 id="1-数字类型改变文件权限"><a href="#1-数字类型改变文件权限" class="headerlink" title="1.数字类型改变文件权限"></a>1.数字类型改变文件权限</h6><p>Linux文件的基本权限就有9个，分别是owner，group，others三种身份各有自己的read，write，execute权限</p>
<p>我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p>
<ul>
<li>r：4</li>
<li>w：2</li>
<li>x：1</li>
</ul>
<p>每种身份（owner，group，others）各自三个权限（r，w，x）分数是需要累加的，例如当权限为[-rwxrwx—],分数则是：</p>
<ul>
<li>owner=rwx=4+2+1=7</li>
<li>group=rwx=4+2+1=7</li>
<li>others=—=0+0+0=0</li>
</ul>
<p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">chmod [-R] rwx 目录名/文件名</div><div class="line">选项与参数：</div><div class="line">—R:进行递归（recursive）的持续更改，也即连同子目录下的所有文件，目录</div></pre></td></tr></table></figure></p>
<h6 id="2-符号类型改变文件权限"><a href="#2-符号类型改变文件权限" class="headerlink" title="2.符号类型改变文件权限"></a>2.符号类型改变文件权限</h6><p>user，group，others3种身份可以通过u，g，o来代表，此外，a代表all，也即全部的身份</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>身份简写</th>
<th>权限操作</th>
<th>权限</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>chmod</td>
<td><code>u:用户身份</code><br> <code>g:组身份</code><br> <code>o:其他身份</code><br> <code>a:所有身份</code><br></td>
<td>+（加入）<br> -（除去）<br>=（设置）</td>
<td>r <br>w <br>x</td>
<td>文件或者目录</td>
</tr>
</tbody>
</table>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1.设置一个文件的权限为“-rwxr-xr-x”</div><div class="line">chmod u=rwx,go=rx .bashrc  注意：那个u=rwx,go=rx是连在一起的，中间没有任何空格</div><div class="line"></div><div class="line">2.如果只想要增加.bashrc这个文件的每个人均可写入的权限，那么可以使用</div><div class="line">chmod a+w .bashrc</div><div class="line"></div><div class="line">3.去掉全部人的可执行权限</div><div class="line">chmod a-x .bashrc</div></pre></td></tr></table></figure></p>
<p>在+与-的状态下，只要是没有指定到的选项，则该权限“不会被变动”，例如上面的例子中，由于仅以-去掉x，则其他两个权限保持当时的值不变</p>
<p>如果让一个程序可以拥有执行的权限，但你又不知道该文件原本的权限，此时利用<code>chmod a+x filename</code>就可以让该程序拥有执行的权限了</p>
<h3 id="目录与文件的权限意义"><a href="#目录与文件的权限意义" class="headerlink" title="目录与文件的权限意义"></a>目录与文件的权限意义</h3><h4 id="权限对文件的重要性"><a href="#权限对文件的重要性" class="headerlink" title="权限对文件的重要性"></a>权限对文件的重要性</h4><ul>
<li>r：可读取此文件的实际内容，如读取文本文件的文字内容等</li>
<li>w：可以编辑，新增，或者是修改该文件的内容（但不含删除该文件）</li>
<li>x：该文件具有可以被系统执行的权限</li>
</ul>
<p>对于文件的r，w，x来说，主要都是针对“文件的内容”而言，与文件名的存在与否没有关系的，因为文件记录的是实际的数据</p>
<h4 id="权限对目录的重要性"><a href="#权限对目录的重要性" class="headerlink" title="权限对目录的重要性"></a>权限对目录的重要性</h4><p>文件是存放实际数据的所在，目录主要的内容是记录文件名列表，文件名与目录有强烈的关联</p>
<ul>
<li>r：表示具有读取目录结构列表的权限，所以当你具有读取一个目录的权限时，表示你可以查询该目录下的文件名数据</li>
<li>w：表示你具有更改该目录结构列表的权限，也就是下面这些权限<ul>
<li>新建心的文件与目录</li>
<li>删除已经存在的文件与目录</li>
<li>将已存在的文件或者目录进行重命名</li>
<li>转移该目录内的文件，目录位置</li>
</ul>
</li>
<li>x：<strong>目录的x代表的是用户能否进入该目录成为工作目录</strong>的用途。所谓的工作目录（work directory）就是你目前所在的目录。工作目录对于命令的执行是非常重要的，如果你在某目录下不具有x的权限，那么你就无法切换到该目录下，也就无法执行该目录下的任何命令，即使你具有该目录的r权限</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Linux/权限相关/" data-id="cjfvvphhl001jm9fy27hr8cd4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux/文件和目录管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Linux/文件和目录管理/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Linux/文件和目录管理/">文件和目录管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="显示目前所在的目录（pwd）"><a href="#显示目前所在的目录（pwd）" class="headerlink" title="显示目前所在的目录（pwd）"></a>显示目前所在的目录（pwd）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pwd [-P]</div><div class="line">参数：</div><div class="line">-P：显示出当前的路径，而非使用连接路径</div></pre></td></tr></table></figure>
<h3 id="新建目录（mkdir）"><a href="#新建目录（mkdir）" class="headerlink" title="新建目录（mkdir）"></a>新建目录（mkdir）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir [-mp] 目录名称</div><div class="line">参数：</div><div class="line">-m：配置目录的权限，直接设置，不需要看默认权限（umask）</div><div class="line">-p：帮助你直接将所需的目录（包含上层目录）递归创建起来</div></pre></td></tr></table></figure>
<h3 id="删除空的目录（rmdir）"><a href="#删除空的目录（rmdir）" class="headerlink" title="删除空的目录（rmdir）"></a>删除空的目录（rmdir）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rmdir [-p] 目录名称</div><div class="line">参数：</div><div class="line">-p：连同上层“空的”目录也一起删除</div></pre></td></tr></table></figure>
<h3 id="查看文件与目录（ls）"><a href="#查看文件与目录（ls）" class="headerlink" title="查看文件与目录（ls）"></a>查看文件与目录（ls）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ls [-aAdfFhilnrRSt] 目录名称</div><div class="line">参数：</div><div class="line">-a：全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用）</div><div class="line">-d：仅列出目录本身，而不是列出目录内的文件数据（常用）</div><div class="line">-l：列出长数据串，包含文件的属性与权限等数据（常用）</div></pre></td></tr></table></figure>
<h3 id="复制文件或目录（cp）"><a href="#复制文件或目录（cp）" class="headerlink" title="复制文件或目录（cp）"></a>复制文件或目录（cp）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">cp [-adfilprsu] 源文件（source） 目标文件（destination）</div><div class="line">cp [options] source1 source2 source3 ... directory</div><div class="line">参数：</div><div class="line">-a：相当于-pdr的意思（常用）</div><div class="line">-i：若目标文件已经存在时，在覆盖时会先询问操作的进行（常用）</div><div class="line">-r：递归持续复制，用于目录的复制行为（常用）</div><div class="line">-d：若源文件为连接文件的属性，则复制连接文件属性而非文件本身</div><div class="line">-p：连同文件的属性一起复制过期，而非使用默认属性（备份常用）</div></pre></td></tr></table></figure>
<p>在默认的条件中，cp的源文件与目的文件的权限是不同的，目的文件的所有者通常会是命令操作者本身</p>
<p>由于具有这个特性，因为当我们在进行备份的时候，某些需要特别注意的特殊权限文件，例如密码文件（/etc/shadow）以及一些配置文件，就不能直接以cp来复制，而必须要加上-a或者是-p等可以完整复制文件权限的参数才行。另外，如果你想要复制文件给其他的用户，也必须要注意到文件的权限（包含读，写，执行以及文件所有者等），否则，其他人还是无法针对你给予的文件进行修订的操作</p>
<h3 id="移除文件或目录（rm）"><a href="#移除文件或目录（rm）" class="headerlink" title="移除文件或目录（rm）"></a>移除文件或目录（rm）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">rm [-fir] 文件或目录</div><div class="line">参数：</div><div class="line">-f：就是force意思，忽略不存在的文件，不会出现警告信息</div><div class="line">-i：互动模式，在删除前会询问用户是否操作</div><div class="line">-r：递归删除，最常用在目录的删除了，这是个非常危险的参数！！！！</div></pre></td></tr></table></figure>
<h3 id="移动文件与目录，或更名（mv）"><a href="#移动文件与目录，或更名（mv）" class="headerlink" title="移动文件与目录，或更名（mv）"></a>移动文件与目录，或更名（mv）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mv [-fiu] source destination</div><div class="line">mv [options] source1 source2 source3 ... directory</div><div class="line">参数：</div><div class="line">-f：就是force强制的意思，如果目标文件以及存在，不会询问直接覆盖</div><div class="line">-i：若目标文件已经存在时，就会询问是否覆盖</div><div class="line">-u：若目标文件已经存在，且source比较新，才会更新</div></pre></td></tr></table></figure>
<h3 id="取得路径的文件名与目录名称（basename，dirname）"><a href="#取得路径的文件名与目录名称（basename，dirname）" class="headerlink" title="取得路径的文件名与目录名称（basename，dirname）"></a>取得路径的文件名与目录名称（basename，dirname）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">basename /etc/sysconfig/network</div><div class="line">network #取得最后的文件名</div><div class="line"></div><div class="line">dirname /etc/sysconfig/network</div><div class="line">/etc/sysconfig #取得目录名</div></pre></td></tr></table></figure>
<h3 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="文件内容查阅"></a>文件内容查阅</h3><ul>
<li>cat：由第一行开始显示文件内容</li>
<li>tac：从最后一行开始显示，可以看出tac是cat的倒写形式</li>
<li>nl：显示的时候，顺便输出行号</li>
<li>more：一页一页地显示文件内容</li>
<li>less：与more类似，但是比more更好的是，它可以往前翻页</li>
<li>head：只看头几行</li>
<li>tail：只看结尾几行</li>
<li>od：以二进制的方式读取文件内容</li>
</ul>
<h5 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cat [-AbEnTv]</div><div class="line">参数：</div><div class="line">-n：打印出行号，连同空白行也会有行号</div></pre></td></tr></table></figure>
<h5 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">nl [-bnw] 文件</div><div class="line">参数：</div><div class="line">-b：指定行号指定的方式，主要有两种：</div><div class="line">    -b a：表示不论是否为空行，也同样列出行号（类似 cat -n）</div><div class="line">    -b t：如果有空行，空的那一行不要列出行号（默认值）</div><div class="line">-n：列出行号的表示方法，主要有三种：</div><div class="line">    -n ln：行号在屏幕的最左方显示</div><div class="line">    -n rn：行号在自己字段的最右方显示，且不加0</div><div class="line">    -n rz：行号在自己字段的最右方显示，且加0</div><div class="line">-w：行号字段占用的位数</div></pre></td></tr></table></figure>
<h5 id="more"><a href="#more" class="headerlink" title="more"></a>more</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">空格键：向下翻一页</div><div class="line">Enter：向下滚一行</div><div class="line">/字符串</div><div class="line">:f：立刻显示出文件名以及目前显示的行数</div><div class="line">q：立刻离开more，不再显示该文件内容</div><div class="line">b：往回翻页，不过这操作只对文件有用，对管道无用</div></pre></td></tr></table></figure>
<h5 id="less"><a href="#less" class="headerlink" title="less"></a>less</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">空格键：向下翻一页</div><div class="line">[PageDown]：向下翻动一页</div><div class="line">[PageUp]：向上翻动一页</div><div class="line">/字符串：向下查询“字符串”的功能</div><div class="line">?字符串：向上查询“字符串”的功能</div><div class="line">n：重复前一个查询（与/或?有关）</div><div class="line">N：反向重复前一个查询（与/或?有关）</div><div class="line">q：离开</div></pre></td></tr></table></figure>
<h5 id="head"><a href="#head" class="headerlink" title="head"></a>head</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">head [-n number] 文件</div><div class="line">参数：</div><div class="line">-n：后面接数字，代表显示几行的意思（默认显示10行）</div></pre></td></tr></table></figure>
<h5 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tail [-n number] 文件</div><div class="line">参数：</div><div class="line">-n：后面接数字，代表显示几行的意思</div><div class="line">-f：表示持续输出文件内容，要等到按下[ctrl]+c才会结束tail的输出</div></pre></td></tr></table></figure>
<h3 id="修改文件时间或创建新文件（touch）"><a href="#修改文件时间或创建新文件（touch）" class="headerlink" title="修改文件时间或创建新文件（touch）"></a>修改文件时间或创建新文件（touch）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">touch [-acdmt] 文件</div><div class="line">参数：</div><div class="line">-a：仅修改访问时间</div><div class="line">-c：仅修改文件的时间，若该文件不存在则不创建新文件</div><div class="line">-d：后面可以接欲修改的日期而不用目前的日期，也可以使用 --date=&quot;日期或时间&quot;</div><div class="line">-m：仅修改mtime</div><div class="line">-t：后面可以接欲修改的时间而不用目前的时间，格式为[YYMMDDhhmm]</div></pre></td></tr></table></figure>
<h3 id="文件默认权限（umask）"><a href="#文件默认权限（umask）" class="headerlink" title="文件默认权限（umask）"></a>文件默认权限（umask）</h3><p>umask就是指定“<strong>目前用户在新建文件或目录时候的权限默认值</strong>”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">umask</div><div class="line">0022</div><div class="line"></div><div class="line">umask -S</div><div class="line">u=rwx,g=rx,o=rx</div></pre></td></tr></table></figure></p>
<p>查看的方式有两种，一种可以直接输入umask，就可以看到数字形态的权限设置分数，一种则是加入-S这个参数，就会以符号类型的方式来显示出权限</p>
<p>在默认权限的属性上，目录与文件是不一样的，默认的情况如下：</p>
<ul>
<li>若用户创建“文件”则默认没有可执行（x）权限，即只有r，w这两个选项，也就是最大为666，默认权限为：<code>-rw-rw-rw-</code></li>
<li>若用户新建“目录”，则由于x与是否可以进入此目录有关，因此默认所有权限均开放，即为777，默认权限为：<code>drwxrwxrwx</code></li>
</ul>
<p>要注意的是，umask的分数是指“<strong>该默认值需要减掉的权限</strong>”。因为r，w，x分别是4，2，1，也就是说当要拿掉能写的权限，就是输入2，而如果要拿掉能读的权限，也就是4，那么要拿掉读与写的权限，也就是6，而要拿掉执行与写入的权限，也就是3，要拿掉读与执行的权限，也就是5</p>
<p>所以在设置了umask的时候，默认新建文件和目录的权限为：</p>
<ul>
<li>新建文件时：（-rw-rw-rw-）-（—–w–w-）==&gt;-rw-r–r–(644)</li>
<li>新建目录时：（drwxrwxrwx）-（d—-w–w-）==&gt;drwxr-xr-x(755)</li>
</ul>
<h3 id="命令与文件的查询"><a href="#命令与文件的查询" class="headerlink" title="命令与文件的查询"></a>命令与文件的查询</h3><h4 id="脚本文件名的查询（which）"><a href="#脚本文件名的查询（which）" class="headerlink" title="脚本文件名的查询（which）"></a>脚本文件名的查询（which）</h4><p>which是根据用户所设置的PATH变量内的目录去查找可执行文件的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">which [-a] command</div><div class="line">参数：</div><div class="line">-a：将所有有PATH目录中可以找到的命令均列出，而不只第一个被找到的命令名称</div></pre></td></tr></table></figure></p>
<h4 id="文件名的查询（whereis，locate）"><a href="#文件名的查询（whereis，locate）" class="headerlink" title="文件名的查询（whereis，locate）"></a>文件名的查询（whereis，locate）</h4><p>whereis与locate是利用数据库来查找数据，所以速度相当快速，而且并没有实际查询硬盘，比较节省时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">whereis [-bmsu] 文件或目录名</div><div class="line">参数：</div><div class="line">-b：只找二进制格式的文件</div><div class="line">-m：只找在说明文件mamual路径下的文件</div><div class="line">-s：只找source源文件</div><div class="line">-u：查找不在上述三个选项当中的其他特殊文件</div></pre></td></tr></table></figure></p>
<p>locate的使用更简单，直接在后面输入“文件的部分名称”后就能够得到结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">locate [-ir] keyword</div><div class="line">参数：</div><div class="line">-i：忽略大小写的差异</div><div class="line">-r：后面可接正则表达式的显示方式</div></pre></td></tr></table></figure></p>
<p>locate是依据/var/lib/mlocate内的数据库记载，查出用户输入的关键字文件名</p>
<p>可以输入<code>updatedb</code>来手动更新数据库，updatedb命令回去读取<code>/etc/updatedb.conf</code>这个配置文件的设置，然后再去硬盘里面进行查找文件名的操作，最后就更新整个数据库文件（/var/lib/mlocate）</p>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">find [PATH] [option] [action]</div><div class="line">参数：</div><div class="line">1.与时间有关的参数：共有-atime，-ctime，-mtime，下面以-mtime说明</div><div class="line">-mtime n：n为数字，意义为在n天之前的“一天之内”被更改过的文件</div><div class="line">-mtime +n：列出在n天之前（不含n天本身）被更改过的文件名</div><div class="line">-mtime -n：列出n天之内（含n本身）被更改过的文件名</div><div class="line">-newer file：file为一个存在的文件，列出比file还要新的文件名</div><div class="line"></div><div class="line">2.用户或用户组名有关的参数：</div><div class="line">-uid n：n为数字，这个数字是用户的账号ID，即UID，这个UID是记录在/etc/passwd里面与账号名称对应的数字</div><div class="line">-gid n：n为数字，这个数字是用户组名的ID，即GID，这个GID记录在/etc/group中</div><div class="line">-user name：name为用户账号名称</div><div class="line">-group name：name为用户组名称</div><div class="line">-nouser：寻找文件的所有者不在/etc/passwd的人</div><div class="line">-nogroup：选找文件的所有用户组不存在于/etc/group中的文件</div><div class="line">当你自行安装软件时，很可能该软件的属性当中并没有文件所有者，这是可能的，在这个时候，就可以使用-nouser和-nogroup查找</div><div class="line"></div><div class="line">3.与文件权限及名称有关的参数：</div><div class="line">-name filename：查找文件名为filename的文件</div><div class="line">-size [+-]SIZE:查找比SIZE还要大（+）或小（-）的文件，这个SIZE的规格有：</div><div class="line">    c：代表byte k：代表1024bytes 。所以，要找比50KB还要大的文件，就是“-size +50k”</div><div class="line">-type TYPE：查找文件的类型为TYPE的，类型主要有：一般正规文件（f），设备文件（b，c），目录（d），连接文件（l），socket（s）及FIFO（p）等属性</div><div class="line">-perm mode：查找文件权限“刚好等于”mode的文件，这个mode类似chmod的属性值，举例来说，-rwsr-xr-x的属性为4755</div><div class="line">-perm -mode：查找文件权限“必须要全部包括mode的权限”的文件，举例来说，我们要查找-rwxr--r--，即0744的文件，使用-perm -0744，当一个文件的权限为-rwsr-xr-x，即4755时，也会被列出，因为-rwsr-xr-x的属性已经包括了-rwxr--r--的属性了</div><div class="line">-perm +mode：查找文件权限“包含任一mode的权限”的文件，举例来说，我们查找-rwxr-xr-x，即-perm +755时，但一个文件属性为-rw-------也会被列出来，因为它有-rw...的属性存在</div><div class="line"></div><div class="line">4.其他可进行的操作：</div><div class="line">-exec command：command为其他命令，-exec后面可再接其他的命令来处理查找到的结果</div><div class="line">-print：将结果打印到屏幕上，这个操作是默认操作</div><div class="line"></div><div class="line">例子：find / -perm +7000 -exec ls -l &#123;&#125; \;</div><div class="line">&#123;&#125;代表的是“由find找到的内容”，find的结果会被放置在&#123;&#125;位置中</div><div class="line">-exec 一直到“\;”是关键字，代表find额外命令的开始（-exec）到结束（\;）,在这个中间的就是find命令内的额外命令，在本例中就是“ls -l &#123;&#125;”</div><div class="line">因为“;”在bash环境下是有特殊意义的，因此利用反斜杠来转义</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Linux/文件和目录管理/" data-id="cjfvvphhm001mm9fykhgnbyik" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据库相关/mysql/建立索引的原则" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/数据库相关/mysql/建立索引的原则/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库相关/">数据库相关</a>►<a class="article-category-link" href="/categories/数据库相关/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/数据库相关/mysql/建立索引的原则/">建立索引的原则</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><strong>最左前缀匹配原则</strong>，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li>
<li>尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录</li>
<li>索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);</li>
<li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</li>
</ol>
<h3 id="实际中的一些通用的原则："><a href="#实际中的一些通用的原则：" class="headerlink" title="实际中的一些通用的原则："></a>实际中的一些通用的原则：</h3><ol>
<li><p>在经常用作过滤器的字段上建立索引；</p>
</li>
<li><p>在SQL语句中经常进行GROUP BY、ORDER BY的字段上建立索引；MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</p>
</li>
<li><p>在不同值较少的字段上不必要建立索引，如性别字段；</p>
</li>
<li><p>对于经常存取的列避免建立索引；</p>
</li>
<li><p>用于联接的列（主健/外健）上建立索引；</p>
</li>
<li><p>在经常查询的多个列上建立复合索引，但要注意复合索引的建立顺序要按照使用的频率来确定；</p>
</li>
<li><p>缺省情况下建立的是非簇集索引，但在以下情况下最好考虑簇集索引，如：含有有限数目（不是很少）唯一的列；进行大范围的查询；充分的利用索引可以减少表扫描I/0的次数，有效的避免对整表的搜索。当然合理的索引要建立在对各种查询的分析和预测中，也取决于DBA的所设计的数据库结构。</p>
</li>
<li><p>MySQL只对以下操作符才使用索引：&lt;,&lt;=,=,&gt;,&gt;=,between,in,以及某些时候的like(不以通配符%或_开头的情形)</p>
</li>
<li><p>索引不会包含有NULL值的列。只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。</p>
</li>
<li><p>使用短索引。<br>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引,只需要针对特定的前缀进行索引即可。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</p>
</li>
</ol>
<h3 id="索引的不足之处"><a href="#索引的不足之处" class="headerlink" title="索引的不足之处"></a>索引的不足之处</h3><p>过多的使用索引将会造成滥用。因此索引也会有它的缺点：  </p>
<ol>
<li><p>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。</p>
</li>
<li><p>建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/数据库相关/mysql/建立索引的原则/" data-id="cjfvvphpo00fym9fyatln43aj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/Spring Cloud/简介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Spring/Spring Cloud/简介/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/Spring-Session/">Spring Session</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Spring/Spring Cloud/简介/">简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spring Cloud 是一个基于Spring Boot实现的微服务架构开发工具。它为微服务架构中涉及的<strong>配置管理</strong>，<strong>服务治理</strong>，<strong>断路器</strong>，<strong>智能路由</strong>，<strong>微代理</strong>，<strong>控制总线</strong>，<strong>全局锁</strong>，<strong>决策竞选</strong>，<strong>分布式会话</strong>和<strong>集群状态管理</strong>等操作提供了一种简单的开发方式。</p>
<p>Spring Cloud包含了多个子项目：</p>
<ul>
<li><strong>Spring Cloud Config</strong>：配置管理工具，支持使用Git存储配置内容，可以使用它实现应用配置的外部化存储，并支持客户端配置信息刷新，加密/解密配置内容等</li>
<li><strong>Spring Cloud Netflix</strong>：核心组件，对多个NetFlix OSS开源套件进行整合<ul>
<li><strong>Eureka</strong>：服务治理组件，包含服务注册中心，服务注册与发现机制的实现</li>
<li><strong>Hystrix</strong>：容错管理组件，实现断路器模式，帮助服务依赖中出现的延迟和为故障提供强大的容错能力</li>
<li><strong>Ribbon</strong>：客户端负载均衡的服务调用组件</li>
<li><strong>Feign</strong>：基于Ribbon和Hystrix的声明式服务调用组件</li>
<li><strong>Zuul</strong>：网关组件，提供智能路由，访问过滤等功能</li>
<li><strong>Archaius</strong>：外部化配置组件</li>
</ul>
</li>
<li><strong>Spring Cloud Bus</strong>：事件，消息总线，用于传播集群中的状态变化和事件，以触发后续的处理，比如用来动态刷新配置等</li>
<li><strong>Spring Cloud Cluster</strong>：针对ZooKeeper，Redis，Hazelcast，Consul的选举算法和通用状态模式的实现</li>
<li><strong>Spring Cloud Cloudfoundry</strong>：与Pivotal Cloudfounddry的整合支持</li>
<li><strong>Spring Cloud Consul</strong>：服务发现与配置管理工具</li>
<li><strong>Spring Cloud Stream</strong>：通过Redis，Rabbit或者Kafka实现的消费微服务，可以通过简单的声明式模型来发送和接收消息</li>
<li><strong>Spring Cloud AWS</strong>：用于简化整合Amazon Web Service组件</li>
<li><strong>Spring Cloud Security</strong>：安全工具包，提供在Zuul代理中对OAuth2客户端请求的中继器</li>
<li><strong>Spring Cloud Sleuth</strong>：Spring Cloud应用的分布式跟踪实现，可以完美整合Zipkin</li>
<li><strong>Spring Cloud ZooKeeper</strong>：基于ZooKeeper的服务发现与配置管理组件</li>
<li><strong>Spring Cloud Starters</strong>：Spring Cloud的基础组件，它是基于Spring Boot风格项目的基础依赖模块</li>
<li><strong>Spring Cloud CLI</strong>：用于在Groovy中快速创建Spring Cloud应用的Spring Boot CLI插件</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Spring/Spring Cloud/简介/" data-id="cjfvvphn500b0m9fyzrm2dat9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据库相关/mysql/查询性能优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/数据库相关/mysql/查询性能优化/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库相关/">数据库相关</a>►<a class="article-category-link" href="/categories/数据库相关/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/数据库相关/mysql/查询性能优化/">查询性能优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="慢查询基础：优化数据访问"><a href="#慢查询基础：优化数据访问" class="headerlink" title="慢查询基础：优化数据访问"></a>慢查询基础：优化数据访问</h2><p>对于低效的查询，我们发现通过下面两个步骤来分析总是很有效的：</p>
<ul>
<li>确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多列。</li>
<li>确认MySQL服务器层是否在分析大量超过需要的数据行。</li>
</ul>
<p>对于MySQL，最简单的衡量查询开销的三个指标如下：</p>
<ul>
<li>响应时间</li>
<li>扫描的行数</li>
<li>返回的行数</li>
</ul>
<p>一般MySQL能够使用如下三种方式应用WHERE条件，从好到坏依次为：</p>
<ul>
<li>在索引中使用WHERE条件来过滤不匹配的记录。这是在存储引擎层完成的。</li>
<li>使用索引覆盖扫描（在Extra列中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无须再回表查询记录。</li>
<li>从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using Where）。这是在MySQL服务器层完成，MySQL需要先从数据表读出记录然后过滤。</li>
</ul>
<p>如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试下面的技巧去优化它：</p>
<ul>
<li>使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果了</li>
<li>改变库表结构</li>
<li>重写这个复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询</li>
</ul>
<h2 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h2><h6 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h6><p>有时候对于一个大查询我们需要“分而治之”，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果</p>
<h6 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h6><p>很多高性能的应用都会对关联查询进行分解。简单地，可以对每一个表进行一次单表查询，然后将结果在应用程序中进行关联。例如，下面这个查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT * FROM tag</div><div class="line">    -&gt;   JOIN tag_post ON tag_post.tag_id=tag.id</div><div class="line">    -&gt;   JOIN post on tag_post.post_id=post.id</div><div class="line">    -&gt; WHERE tag.tag=&apos;mysql&apos;;</div></pre></td></tr></table></figure></p>
<p>可以分解成下面这些查询来代替：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT * FROM tag WHERE tag=&apos;mysql&apos;;</div><div class="line">mysql&gt; SELECT * FROM tag_post WHERE tag_id=1234;</div><div class="line">mysql&gt; SELECT * FROM post WHERE post.id in(123, 456, 789);</div></pre></td></tr></table></figure></p>
<p>用分解关联查询的方式重构查询有如下的优势：</p>
<ul>
<li>让缓存更高效。许多应用程序可以方便地缓存单表查询对应的结果对象。</li>
<li>将查询分解后，执行单个查询可以减少锁的竞争</li>
<li>在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展</li>
<li>查询本身效率也可能会有所提升。在这个例子中，使用IN()代替关联查询，可以染MySQL按照ID顺序进行查询，这可能比随机的关联要更高效。</li>
<li>可以减少冗余记录的查询。在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复地访问一部分数据。从这点看，这样的重构还可能会减少网络和内存的消耗。</li>
<li>更进一步，这样做相当于在应用中实现了哈希关联，而不是使用MySQL的嵌套循环查询。</li>
</ul>
<h2 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h2><p>MySQL执行一个查询的过程：<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/MySQL8.jpeg" alt="image"></p>
<ol>
<li>客户端发送一条查询给服务器</li>
<li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段</li>
<li>服务器进行SQL解析，预处理，再由优化器生成对应的执行计划</li>
<li>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询</li>
<li>将结果返回给客户端</li>
</ol>
<h6 id="MySQL客户端-服务器通信协议"><a href="#MySQL客户端-服务器通信协议" class="headerlink" title="MySQL客户端/服务器通信协议"></a>MySQL客户端/服务器通信协议</h6><p>MySQL客户端和服务器之间的通信协议是“半双工”的，这意味着，在任何一个时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生。所以，我们无法也无须将一个消息切成小块独立来发送。</p>
<p>这种协议让MySQL通信简单快速，但是也从很多地方限制了MySQL。一个明显的限制是，这意味着无法进行流量控制。一旦一端开始发送消息，另一端要接收完整个消息才能响应它。</p>
<p>客户端用一个单独的数据包将查询传给服务器。这也是为什么当查询的语句很长的时候，参数<code>max_allowed_packet</code>就特别重要了。一旦客户端发送了请求，它能做的事情就只是等待结果了。</p>
<p>相反的，一般服务器响应给用户的数据通常很多，由多个数据包组成。当服务器开始响应客户端请求时，客户端必须完整地接收整个返回结果，而不能简单地只取前面几条结果，然后让服务器停止发送数据。</p>
<p>换一种方式解释这种行为：当客户端从服务器取数据时，看起来是一个拉数据的过程，但实际上是MySQL在向客户端推送数据的过程。客户端不断地接收从服务器推送的数据，客户端也无法让服务器停下来。</p>
<p>多数连接MySQL的库函数都可以获得全部结果集并缓存到内存里，还可以逐行获取需要的数据。默认一般是获得全部结果集并缓存到内存中。MySQL通常需要等所有的数据都已经发送给客户端才能释放这条查询所占用的资源，所以接收全部结果并缓存通常可以减少服务器的压力，让查询能够早点结束，早点释放相应的资源。</p>
<h6 id="查询状态"><a href="#查询状态" class="headerlink" title="查询状态"></a>查询状态</h6><p>对于一个MySQL连接，或者说一个线程，任何时刻都由一个状态，该状态表示了MySQL当前正在做什么。由很多中方式能够查看当前的状态，最简单的是使用<code>SHOW FULL PROCESSLIST</code>命令（该命令返回结果中的Command列就表示当前的状态）</p>
<h6 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h6><p>当不能使用索引生成排序结果的时候，MySQL需要自己进行排序，如果数据量小则在内存中进行，如果数据量大则需要使用磁盘，不过MySQL将这个过程统一称为文件排序（filesort），即使完全是内存排序不需要任何磁盘文件时也是如此。</p>
<p>如果需要排序的数据量小于“排序缓冲区”，MySQL使用内存进行“快速排序”操作。如果内存不够排序，那么MySQL会先将数据分块，对每个独立的块使用“快速排序”进行排序，并将各个块的排序结果存放在磁盘上，然后将各个拍好序的块进行合并（merge），最后返回排序结果。</p>
<p>MySQL有两种排序算法，新版本使用的是<strong>单次传输排序</strong>：<br>先读取查询所需要的所有列，然后再根据给定列进行排序，最后直接返回排序结果。这个算法只在MySQL4.1及后续更新的版本引入。因为不再需要从数据表读取两次数据，对于I/O密集型的应用，这样做的效率高了很多。另外，相比两次传输排序，这个算法只需要一次顺序I/O读取所有的数据，而无须任何的随机I/O。缺点是，如果需要返回的列非常多，非常大，会额外占用大量的空间，而这些列对排序操作本身来说是没有任何作用的。因为单条排序记录很大，所以可能会有更多的排序块需要合并。</p>
<p><strong>在关联查询的时候如果需要排序，MySQL会分两种情况来处理这样的文件排序。如果ORDER BY 子句中的所有列都来自关联的第一个表。那么MySQL在关联处理第一个表的时候就进行文件排序。如果是这样，那么在MySQL的EXPLAIN结果中可以看到Extra字段会有“Using filesort”。除此之外的所有情况，MySQL都会先将关联的结果存放到一个临时表中，然后再所有的关联都结束后，再进行文件排序。这种情况下，在MySQL的EXPLAIN结果的Extra字段可以看到“Using temporary；Using filesort”。如果查询中有LIMIT的话，LIMIT也会在排序之后应用，所以即使需要返回较少的数据，临时表和需要排序的数据量仍然会非常大</strong>。</p>
<h2 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h2><h6 id="优化count-查询"><a href="#优化count-查询" class="headerlink" title="优化count()查询"></a>优化count()查询</h6><p>count()是一个特殊的函数，有两种非常不同的作用：它可以统计某个列值的数量，也可以统计行数。</p>
<p>在统计列值时要求列值是非空的（不统计NULL）。如果在count()的括号中指定了列或者列的表达式，则统计的就是这个表达式有值的结果数。</p>
<p>在统计结果集的行数时，当MySQL确认括号内的表达式值不可能为空时，实际上就是在统计行数。最简单的就是当我们使用count(*)的时候，它会忽略所有的列而直接统计所有的行数。</p>
<h6 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h6><ul>
<li>确保ON 或者 USING 子句中的列上有索引。一般来说，除非有其他理由，否则只需要在关联顺序中的第二个表的相应列上创建索引。</li>
<li>确保任何的 GROUP BY 和 ORDER BY 中的表达式只涉及到一个表中的列。这样MySQL才有可能使用索引来优化这个过程。</li>
<li>当升级MySQL的时候需要注意：关联语法，运算符优先级等其他可能会发生变化的地方。</li>
</ul>
<h6 id="优化GROUP-BY-和-DISTINCT"><a href="#优化GROUP-BY-和-DISTINCT" class="headerlink" title="优化GROUP BY 和 DISTINCT"></a>优化GROUP BY 和 DISTINCT</h6><p>MySQL优化器会在内部处理的时候相互转化这两类查询。它们都可以使用索引来优化，这也是最有效的优化办法。</p>
<p>在MySQL中，当无法使用索引的时候，GROUP BY使用两种策略来完成：<strong>使用临时表或者文件排序来做分组</strong>。</p>
<p><strong>如果没有通过ORDER BY子句显式地指定排序列，当查询使用GROUP BY子句的时候，结果集会自动按照分组的字段进行排序。如果不关心结果集的顺序，而这种默认排序又导致了需要文件排序，则可以使用ORDER BY NULL，让MySQL不再进行文件排序。也可以在GROUP BY子句中直接使用DESC 或ASC关键字，使分组的结果集按需要的方向排序</strong>。</p>
<h6 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h6><p>优化此类分页查询的一个最简单的办法就是尽可能地使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候，这样做的效率会提升非常大。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/数据库相关/mysql/查询性能优化/" data-id="cjfvvphpn00fxm9fy6kiscx0l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据库相关/mysql/索引的类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/数据库相关/mysql/索引的类型/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库相关/">数据库相关</a>►<a class="article-category-link" href="/categories/数据库相关/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/数据库相关/mysql/索引的类型/">索引的类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>这是最基本的索引，它没有任何限制。它有以下几种创建方式：</p>
<h5 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CREATE INDEX indexName ON mytable(username(length));</div></pre></td></tr></table></figure>
<p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length，下同。</p>
<h5 id="修改表结构的方式"><a href="#修改表结构的方式" class="headerlink" title="修改表结构的方式"></a>修改表结构的方式</h5><p>创建表后，修改表的结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER mytable ADD INDEX [indexName] ON (username(length))</div></pre></td></tr></table></figure></p>
<p>创建表的时候直接指定:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE mytable(  </div><div class="line"> </div><div class="line">    ID INT NOT NULL,   </div><div class="line">     </div><div class="line">    username VARCHAR(16) NOT NULL,  </div><div class="line">     </div><div class="line">    INDEX [indexName] (username(length))  </div><div class="line"> </div><div class="line">);</div></pre></td></tr></table></figure></p>
<h5 id="删除索引的语法："><a href="#删除索引的语法：" class="headerlink" title="删除索引的语法："></a>删除索引的语法：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DROP INDEX [indexName] ON mytable;</div></pre></td></tr></table></figure>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：</p>
<h5 id="创建索引-1"><a href="#创建索引-1" class="headerlink" title="创建索引"></a>创建索引</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CREATE UNIQUE INDEX indexName ON mytable(username(length))</div></pre></td></tr></table></figure>
<h5 id="修改表结构的方式-1"><a href="#修改表结构的方式-1" class="headerlink" title="修改表结构的方式"></a>修改表结构的方式</h5><p>创建表后，修改表的结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER mytable ADD UNIQUE [indexName] ON (username(length))</div></pre></td></tr></table></figure></p>
<p>创建表的时候直接指定:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE mytable(  </div><div class="line"> </div><div class="line">    ID INT NOT NULL,   </div><div class="line">     </div><div class="line">    username VARCHAR(16) NOT NULL,  </div><div class="line">     </div><div class="line">    UNIQUE [indexName] (username(length))  </div><div class="line"> </div><div class="line">);</div></pre></td></tr></table></figure></p>
<h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE mytable(  </div><div class="line"> </div><div class="line">    ID INT NOT NULL,   </div><div class="line">     </div><div class="line">    username VARCHAR(16) NOT NULL,  </div><div class="line">     </div><div class="line">    PRIMARY KEY(ID)  </div><div class="line"> </div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>当然也可以用 ALTER 命令。记住：一个表只能有一个主键。</p>
<h3 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h3><p>为了形象地对比单列索引和组合索引，为表添加多个字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE mytable(  </div><div class="line"> </div><div class="line">    ID INT NOT NULL,   </div><div class="line">     </div><div class="line">    username VARCHAR(16) NOT NULL,  </div><div class="line">     </div><div class="line">    city VARCHAR(50) NOT NULL,  </div><div class="line">     </div><div class="line">    age INT NOT NULL </div><div class="line"> </div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>为了进一步榨取MySQL的效率，就要考虑建立组合索引。就是将 name, city, age建到一个索引里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE mytable ADD INDEX name_city_age (name(10),city,age);</div></pre></td></tr></table></figure></p>
<p>建表时，usernname长度为 16，这里用 10。这是因为一般情况下名字的长度不会超过10，这样会加速索引查询速度，还会减少索引文件的大小，提高INSERT的更新速度。    </p>
<p>如果分别在usernname，city，age上建立单列索引，让该表有3个单列索引，查询时和上述的组合索引效率也会大不一样，远远低于我们的组合索引。虽然此时有了三个索引，但MySQL只能用到其中的那个它认为似乎是最有效率的单列索引。</p>
<p>建立这样的组合索引，其实是相当于分别建立了下面三组组合索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">usernname,city,age  </div><div class="line"> </div><div class="line">usernname,city  </div><div class="line"> </div><div class="line">usernname</div></pre></td></tr></table></figure></p>
<p>为什么没有city，age这样的组合索引呢？这是因为MySQL组合索引“<strong>最左前缀</strong>”的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这三列的查询都会用到该组合索引，下面的几个SQL就会用到这个组合索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM mytable WHREE username=&quot;admin&quot; AND city=&quot;郑州&quot; </div><div class="line"> </div><div class="line">SELECT * FROM mytable WHREE username=&quot;admin&quot;</div></pre></td></tr></table></figure></p>
<p>而下面几个则不会用到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM mytable WHREE age=20 AND city=&quot;郑州&quot; </div><div class="line"> </div><div class="line">SELECT * FROM mytable WHREE city=&quot;郑州&quot;</div></pre></td></tr></table></figure></p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>全文索引(也称全文检索)是目前搜索引擎使用的一种关键技术。它能够利用“分词技术”等多种算法智能分析出文本文字中关键字词的频率及重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。</p>
<h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><p>建表的时候确定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE article ( </div><div class="line">      id INT AUTO_INCREMENT NOT NULL PRIMARY KEY, </div><div class="line">      title VARCHAR(200), </div><div class="line">      body TEXT, </div><div class="line">      FULLTEXT(title, body) </div><div class="line">) TYPE=MYISAM;</div></pre></td></tr></table></figure></p>
<p>通过 alter table 的方式来添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> ALTER TABLE `student` ADD FULLTEXT INDEX INDEX_NAME  (`name`) </div><div class="line"></div><div class="line">或者：ALTER TABLE `student` ADD FULLTEXT INDEX_NAME  (`name`)</div></pre></td></tr></table></figure></p>
<p>直接通过create index的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CREATE FULLTEXT INDEX INDEX_NAME ON `student` (`name`)</div><div class="line"></div><div class="line">也可以在创建索引的时候指定索引的长度：</div><div class="line">CREATE FULLTEXT INDEX INDEX_NAME ON `student` (`name`(20))</div></pre></td></tr></table></figure></p>
<h5 id="删除全文索引"><a href="#删除全文索引" class="headerlink" title="删除全文索引"></a>删除全文索引</h5><p>直接使用 drop index(注意：没有 drop fulltext index 这种用法)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DROP INDEX INDEX_NAME ON TABLENAME ;</div></pre></td></tr></table></figure></p>
<p>使用 alter table的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE TABLENAME DROP INDEX INDEX_NAME;</div></pre></td></tr></table></figure></p>
<h5 id="使用全文索引"><a href="#使用全文索引" class="headerlink" title="使用全文索引"></a>使用全文索引</h5><p>跟普通索引稍有不同,使用全文索引的格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MATCH (columnName) AGAINST (&apos;string&apos;)</div></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM `student` WHERE MATCH(`name`) AGAINST(&apos;聪&apos;)</div></pre></td></tr></table></figure></p>
<h5 id="设置条件"><a href="#设置条件" class="headerlink" title="设置条件"></a>设置条件</h5><ol>
<li>表的存储引擎是MyISAM，默认存储引擎InnoDB不支持全文索引（新版本MYSQL5.6的InnoDB支持全文索引）    </li>
<li>字段类型：char、varchar和text</li>
</ol>
<p>MySQL自带的全文索引只能对英文进行全文检索，目前无法对中文进行全文检索。如果需要对包含中文在内的文本数据进行全文检索，我们需要采用Sphinx(斯芬克斯)/Coreseek技术来处理中文</p>
<h5 id="全文索引应用流程："><a href="#全文索引应用流程：" class="headerlink" title="全文索引应用流程："></a>全文索引应用流程：</h5><ol>
<li>接收数据-数据分词-入库</li>
<li>接收数据-数据分词-查询</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/数据库相关/mysql/索引的类型/" data-id="cjfvvphpm00fvm9fyfr3u3za9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux/Bash Shell的操作环境" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Linux/Bash Shell的操作环境/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Linux/Bash Shell的操作环境/">Bash Shell的操作环境</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="路径与命令查找顺序"><a href="#路径与命令查找顺序" class="headerlink" title="路径与命令查找顺序"></a>路径与命令查找顺序</h3><p>基本上，命令运行的顺序可以这样看：</p>
<ol>
<li>以相对/绝对路径执行命令，例如：<code>/bin/ls</code> 或 <code>./ls</code></li>
<li>由alias找到该命令执行</li>
<li>由bash内置的命令来执行</li>
<li>通过$PATH这个变量的顺序找到的第一个命令来执行</li>
</ol>
<h3 id="bash的登录与欢迎信息：-etc-issue，-etc-motd"><a href="#bash的登录与欢迎信息：-etc-issue，-etc-motd" class="headerlink" title="bash的登录与欢迎信息：/etc/issue，/etc/motd"></a>bash的登录与欢迎信息：/etc/issue，/etc/motd</h3><h4 id="登录界面"><a href="#登录界面" class="headerlink" title="登录界面"></a>登录界面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cat /etc/issue</div><div class="line">Ubuntu 16.04.3 LTS \n \l</div></pre></td></tr></table></figure>
<p>issue这个文件的内容可以使用反斜杠作为变量调用</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>issue内的各代码意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>\d</td>
<td>本地端的日期</td>
</tr>
<tr>
<td>\l</td>
<td>显示第几个终端机接口</td>
</tr>
<tr>
<td>\m</td>
<td>显示硬件的等级（i386/i486/i586/i686）</td>
</tr>
<tr>
<td>\n</td>
<td>显示主机的网络名称</td>
</tr>
<tr>
<td>\o</td>
<td>显示domain name</td>
</tr>
<tr>
<td>\r</td>
<td>操作系统的版本（相当于 uname -r）</td>
</tr>
<tr>
<td>\t</td>
<td>显示本地端时间的时间</td>
</tr>
<tr>
<td>\s</td>
<td>操作系统的名称</td>
</tr>
<tr>
<td>\v</td>
<td>操作系统的版本</td>
</tr>
</tbody>
</table>
<h4 id="欢迎内容"><a href="#欢迎内容" class="headerlink" title="欢迎内容"></a>欢迎内容</h4><p>如果你想要让用户登录后取得一些信息，例如你想要让大家都知道的信息，那么可以将信息加入/etc/motd里面去</p>
<h3 id="bash的环境配置文件"><a href="#bash的环境配置文件" class="headerlink" title="bash的环境配置文件"></a>bash的环境配置文件</h3><h4 id="login-shell"><a href="#login-shell" class="headerlink" title="login shell"></a>login shell</h4><p>取得bash时需要完整的登录流程的，就称为login shell</p>
<p>login shell其实只会读取这两个配置文件：</p>
<ul>
<li><code>/etc/profile</code>：这是系统整体的设置，你最好不要修改这个文件</li>
<li><code>~/.bash_profile</code> 或 <code>~/.bash_login</code> 或 <code>~/.profile</code>：属于用户个人设置，你要改自己的数据，就写入这里</li>
</ul>
<p>bash的login shell情况下所读取的整体环境配置文件其实只有/etc/profile，但是/etc/profile还会调用其他的配置文件（/etc/inputrc，/etc/profile.d/*.sh，/etc/sysconfig/i18n）</p>
<p>在login shell的bash环境中，所读取的个人偏好配置文件其实主要有三个，并且只会依序读取其中一个，三个文件的顺序为：</p>
<ol>
<li>~/.bash_profile</li>
<li>~/.bash_login</li>
<li>~/.profile</li>
</ol>
<p>bash配置文件的读入方式比较有趣，主要通过一个命令“source”来读取的。也就是说~/.bash_profile其实会再调用~/.bashrc的设置内容，整个login shell的读取流程如下：<br><img src="https://raw.githubusercontent.com/clq2owesome/image/master/bash.png" alt="image"></p>
<h4 id="non-login-shell"><a href="#non-login-shell" class="headerlink" title="non-login shell"></a>non-login shell</h4><p>当你取得non-login shell时，该bash配置文件仅会读取~/.bashrc</p>
<h4 id="读取环境配置文件的命令：source"><a href="#读取环境配置文件的命令：source" class="headerlink" title="读取环境配置文件的命令：source"></a>读取环境配置文件的命令：source</h4><p>由于/etc/profile 与 ~/.bash_profile都是取得login shell的时候才会读取的配置文件，所以如果你将自己的偏好设置写入上述的文件后，通常都是得注销再登录后该设置才会生效。那么能不能直接读取配置文件而不注销登录呢？可以的！那就是得要利用source这个命令了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">source 配置文件</div><div class="line">例：</div><div class="line">将主文件夹的~/.bashrc的设置读入目前的bash环境中</div><div class="line">source ~/.bashrc</div><div class="line">. ~/.bashrc</div></pre></td></tr></table></figure></p>
<p>利用source或者小数点（.）都可以将配置文件的内容读进目前的shell环境中</p>
<h3 id="bash默认组合键"><a href="#bash默认组合键" class="headerlink" title="bash默认组合键"></a>bash默认组合键</h3><table>
<thead>
<tr>
<th>组合按键</th>
<th>执行结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl+C</td>
<td>终止目前的命令</td>
</tr>
<tr>
<td>Ctrl+D</td>
<td>输入结束（EOF）</td>
</tr>
<tr>
<td>Ctrl+M</td>
<td>就是Enter</td>
</tr>
<tr>
<td>Ctrl+S</td>
<td>暂停屏幕的输出</td>
</tr>
<tr>
<td>Ctrl+Q</td>
<td>恢复屏幕的输出</td>
</tr>
<tr>
<td>Ctrl+U</td>
<td>在提示符下，将整行命令删除</td>
</tr>
<tr>
<td>Ctrl+Z</td>
<td>暂停目前的命令</td>
</tr>
</tbody>
</table>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>代表0个到无穷多个任意字符</td>
</tr>
<tr>
<td>?</td>
<td>代表一定有一个任意字符</td>
</tr>
<tr>
<td>[]</td>
<td>同样代表一定有一个在中括号内的字符（非任意字符）。例如[abcd]代表一定有一个字符，可能是a，b，c，d这个四个任何一个</td>
</tr>
<tr>
<td>[-]</td>
<td>若有减号在中括号内时，代表在编码顺序内的所有字符。例如[0-9]代表0到9之间的所有数字，因为数字的语系编码是连续的</td>
</tr>
<tr>
<td>[^]</td>
<td>若中括号内的第一个字符为指数符号（^）,那表示原向选择。例如[^abc]代表一个有一个字符，只要是非a，b，c的其他字符就可以</td>
</tr>
</tbody>
</table>
<h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><table>
<thead>
<tr>
<th>符号</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>#</td>
<td>批注符号，这个最常被使用在script中，视为说明，其后的数据均不执行</td>
</tr>
<tr>
<td>\</td>
<td>转义符号，将“特殊符号或通配符”还原成一般字符</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>管道（pipe），分隔两个管道命令的界定</td>
</tr>
<tr>
<td>;</td>
<td>连续命令执行分隔符，连续性命令的界定</td>
</tr>
<tr>
<td>~</td>
<td>用户的主文件夹</td>
</tr>
<tr>
<td>$</td>
<td>使用变量前导符，即是变量之前需要加的变量替代值</td>
</tr>
<tr>
<td>&amp;</td>
<td>作业控制（job control），将命令变成背景工作</td>
</tr>
<tr>
<td>!</td>
<td>逻辑运算意义上的“非”</td>
</tr>
<tr>
<td>/</td>
<td>目录符号，路径分隔的符号</td>
</tr>
<tr>
<td>&gt;,&gt;&gt;</td>
<td>数据流重定向，输出导向，分别是“替换”与“累加”</td>
</tr>
<tr>
<td>&lt;,&lt;&lt;</td>
<td>数据流重定向，输入导向</td>
</tr>
<tr>
<td>‘’</td>
<td>单引号，不具有变量置换的功能</td>
</tr>
<tr>
<td>“”</td>
<td>具有变量置换的功能</td>
</tr>
</tbody>
</table>
<p><code>` | 两个“</code>”为可以先执行的命令，也可以使用$()<br>() | 在中间为子shell的起始与结束<br>{} | 在中间为命令块的组合</p>
<h3 id="数据流重定向"><a href="#数据流重定向" class="headerlink" title="数据流重定向"></a>数据流重定向</h3><p>数据流重定向就是将某个命令执行后应该要出现在屏幕上的数据传输到其他地方</p>
<h4 id="standard-output-与-standard-error-output"><a href="#standard-output-与-standard-error-output" class="headerlink" title="standard output 与 standard error output"></a>standard output 与 standard error output</h4><p>标准输出指的是命令执行所回传的正确的信息，而标准错误输出可理解为命令执行失败后，所回传的错误信息</p>
<ul>
<li>标准输入（stdin）：代码为0，使用&lt;或&lt;&lt;</li>
<li>标准输出（stdout）：代码为1，使用&gt;或&gt;&gt;</li>
<li>标准错误输出（stderr）：代码为2，使用2&gt;或2&gt;&gt;</li>
</ul>
<p>如果仅存在&gt;时，则代表默认的代码1，也就是说：</p>
<ul>
<li><code>1&gt;</code>：以<strong>覆盖</strong>的方法将正确的数据输出到指定的文件或者设备上</li>
<li><code>1&gt;&gt;</code>：以<strong>累加</strong>的方法将正确的数据输出到指定的文件或者设备上</li>
<li><code>2&gt;</code>：以<strong>覆盖</strong>的方法将错误的数据输出到指定的文件或者设备上</li>
<li><code>2&gt;&gt;</code>：以<strong>累加</strong>的方法将错误的数据输出到指定的文件或者设备上</li>
</ul>
<h5 id="dev-null-垃圾桶黑洞设备"><a href="#dev-null-垃圾桶黑洞设备" class="headerlink" title="/dev/null 垃圾桶黑洞设备"></a>/dev/null 垃圾桶黑洞设备</h5><p>如果要将错误信息忽略掉而不显示或存储，可以使用<code>2&gt; /dev/null</code>,这个/dev/null可以吃掉任何导向这个设备的信息</p>
<h5 id="将正确数据与错误数据写入同一文件"><a href="#将正确数据与错误数据写入同一文件" class="headerlink" title="将正确数据与错误数据写入同一文件"></a>将正确数据与错误数据写入同一文件</h5><p>可以使用命令<code>2&gt;&amp;1</code> 或者 <code>&amp;&gt;</code>，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">find /home -name .bashrc &gt; list 2&gt;&amp;1</div><div class="line">find /home -name .bashrc &amp;&gt; list</div></pre></td></tr></table></figure></p>
<h3 id="命令执行的判断依据：-amp-amp"><a href="#命令执行的判断依据：-amp-amp" class="headerlink" title="命令执行的判断依据：(;, &amp;&amp;, ||)"></a>命令执行的判断依据：(<code>;</code>, <code>&amp;&amp;</code>, <code>||</code>)</h3><h4 id="cmd-cmd（在考虑命令相关性的连续命令执行）"><a href="#cmd-cmd（在考虑命令相关性的连续命令执行）" class="headerlink" title="cmd;cmd（在考虑命令相关性的连续命令执行）"></a>cmd;cmd（在考虑命令相关性的连续命令执行）</h4><p>在命令与命令中间利用分号（;）来隔开，分号前的命令执行完后就会立即接着执行后面的命令，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sync; sync; shutdown -h now</div></pre></td></tr></table></figure></p>
<h4 id="（命令回传码）与-amp-amp-或"><a href="#（命令回传码）与-amp-amp-或" class="headerlink" title="$?（命令回传码）与&amp;&amp;或||"></a>$?（命令回传码）与&amp;&amp;或||</h4><p>一般地，若前一个命令执行的结果为正确，在Linux下面会回传一个$?=0的值</p>
<p>如果要通过这个回传码来判断后续的命令是否要执行，需要借助“&amp;&amp;”或“||”</p>
<table>
<thead>
<tr>
<th>命令的执行情况</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>cmd1 &amp;&amp; cmd2</td>
<td>若cmd1执行完毕且正确执行（$?=0），则开始执行cmd2<br>若cmd1执行完毕且错误（$?≠0），则cmd2不执行</td>
</tr>
<tr>
<td>cmd1 \</td>
<td>\</td>
<td>cmd2</td>
<td>若cmd1执行完毕且正确执行（$?=0），则cmd2不执行<br>若cmd1执行完毕且错误（$?≠0），则开始执行cmd2</td>
</tr>
</tbody>
</table>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">判断一个目录是否存在，不存在则创建</div><div class="line">ls /tmp/abc || mkdir /tmp/abc</div><div class="line"></div><div class="line">要在目录创建文件，但不知道该目录是否存在</div><div class="line">ls /tmp/abc || mkdir /tmp/abc &amp;&amp; touch /tmp/abc/hehe</div></pre></td></tr></table></figure></p>
<p>一般来说，假设判断式有三个，也就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">command1 &amp;&amp; command2 || command3</div></pre></td></tr></table></figure></p>
<p>而且顺序通常不会变，因为一般来说，command2与command3会放置肯定可以执行成功的命令</p>
<h3 id="管道命令（pipe）"><a href="#管道命令（pipe）" class="headerlink" title="管道命令（pipe）"></a>管道命令（pipe）</h3><p>管道命令“|”仅能处理由前面一个命令传来的正确信息，也就是standard output的信息，对于standard error ouput并没有直接处理的能力</p>
<p>在每个管道后面接的第一个数据必定是“命令”，而且这个命令必须要能够接收standard output的数据才行，这样的命令才可以是“管道命令”，例如：less，more head，tail等</p>
<h4 id="选取命令：cut，grep"><a href="#选取命令：cut，grep" class="headerlink" title="选取命令：cut，grep"></a>选取命令：cut，grep</h4><h5 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cut -d &apos;分隔字符&apos; -f fields</div><div class="line">cut -c 字符范围</div><div class="line">参数：</div><div class="line">-d：后面接分隔字符，与-f一起使用</div><div class="line">-f：依据-d的分隔字符将一段信息切割成为数段，用-f取出第几段的意思</div><div class="line">-c：以字符的单位取出固定字符区间</div></pre></td></tr></table></figure>
<h5 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">grep [-acinv] [--color=auto] &apos;查找字符串&apos; filename</div><div class="line">参数：</div><div class="line">-a：将binary文件以text文件的方式查找数据</div><div class="line">-c：计算找到&apos;查找字符串&apos;的次数</div><div class="line">-i：忽略大小写</div><div class="line">-n：顺便输出行号</div><div class="line">-v：反向选择，即显示出没有&apos;查找字符串&apos;内容的那一行</div><div class="line">--color=auto：可以将找到的关键字部分加上颜色显示</div><div class="line"></div><div class="line">例子：将last当中有出现root那一行就取出来</div><div class="line">last | grep &apos;root&apos;</div><div class="line">----------------------------</div><div class="line">root     pts/0        210.21.9.252     Tue Dec 12 14:45   still logged in</div><div class="line">root     pts/0        210.21.9.252     Tue Dec 12 09:45 - 13:49  (04:03)</div><div class="line">root     pts/0        210.21.9.252     Mon Dec 11 15:05 - 19:19  (04:13)</div><div class="line"></div><div class="line">例子：将last当中没有出现root那一行就取出来</div><div class="line">last | grep -v &apos;root&apos;</div><div class="line">-----------------------------</div><div class="line">reboot   system boot  4.4.0-101-generi Fri Dec  8 20:22   still running</div><div class="line"></div><div class="line">wtmp begins Fri Dec  1 09:57:09 2017</div><div class="line"></div><div class="line">例子：在last的输出信息中，只要有root就取出，并且仅取第一列</div><div class="line">last | grep &apos;root&apos; | cut -d &apos; &apos; -f 1</div><div class="line">------------------------------</div><div class="line">root</div><div class="line">root</div><div class="line">root</div></pre></td></tr></table></figure>
<h3 id="排序命令：sort，wc，uniq"><a href="#排序命令：sort，wc，uniq" class="headerlink" title="排序命令：sort，wc，uniq"></a>排序命令：sort，wc，uniq</h3><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">sort [-fbMnrtuk] [file or stdin]</div><div class="line">参数：</div><div class="line">-f：忽略大小写</div><div class="line">-b：忽略最前面的空格部分</div><div class="line">-M：以月份的名字来排序，例如JAN，DEC等的排序方法</div><div class="line">-n：使用“纯数字”进行排序（默认是以文字类型来排序的）</div><div class="line">-r：反向排序</div><div class="line">-u：就是uniq，相同的数据中，仅出现一行代表</div><div class="line">-t：分隔符，默认是用[tab]键来分隔</div><div class="line">-k：以那个区间（field）来进行排序的意思</div></pre></td></tr></table></figure>
<h4 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">uniq [-ic]</div><div class="line">参数：</div><div class="line">-i：忽略大小写</div><div class="line">-c：进行计算</div></pre></td></tr></table></figure>
<h4 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">wc [-lwm]</div><div class="line">参数：</div><div class="line">-l：仅列出行</div><div class="line">-w：仅列出多少字</div><div class="line">-m：多少字符</div><div class="line"></div><div class="line">例：取得这个月登录系统的总人次</div><div class="line">last | grep [a-zA-Z] | grep -v &apos;wtmp&apos; | wc -l</div><div class="line">#由于last会输出空白行和wtmp字样在最下面两行，所以利用grep取出非空白行以及wtmp那一行，再计算行数</div></pre></td></tr></table></figure>
<h3 id="双向重定向：tee"><a href="#双向重定向：tee" class="headerlink" title="双向重定向：tee"></a>双向重定向：tee</h3><p>tee会同时将数据流保存到文件并且输出到屏幕。而输出到屏幕的，其实就是stdout，可以让下个命令继续处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">tee [-a] file</div><div class="line">参数：</div><div class="line">-a：以累加的方式，将数据加入file中</div><div class="line"></div><div class="line">例子：将last的输出存一份到last.list文件中,同时屏幕也有输出</div><div class="line">last | tee last.list | more</div></pre></td></tr></table></figure></p>
<h3 id="字符转换命令：tr，col，join，paste，expand"><a href="#字符转换命令：tr，col，join，paste，expand" class="headerlink" title="字符转换命令：tr，col，join，paste，expand"></a>字符转换命令：tr，col，join，paste，expand</h3><h4 id="tr可以用来删除一段信息当中的文字，或者是进行文字信息的替换"><a href="#tr可以用来删除一段信息当中的文字，或者是进行文字信息的替换" class="headerlink" title="tr可以用来删除一段信息当中的文字，或者是进行文字信息的替换"></a>tr可以用来删除一段信息当中的文字，或者是进行文字信息的替换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">tr [-ds] SET1 ...</div><div class="line">参数：</div><div class="line">-d：删除信息当中的SET1这个字符串</div><div class="line">-s：替换掉重复的字符</div><div class="line"></div><div class="line">例子：将/etc/passwd输出的信息中的冒号（:）删除</div><div class="line">cat /etc/passwd | tr -d &apos;:&apos;</div></pre></td></tr></table></figure>
<h4 id="col"><a href="#col" class="headerlink" title="col"></a>col</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">col -[xb]</div><div class="line">参数：</div><div class="line">-x：将tab键转换成对等的空格键</div><div class="line">-b：在文字内有反斜杠（/）时，仅保留反斜杠最后接的那个字符</div></pre></td></tr></table></figure>
<p>col经常被利用于将man page 转存为纯文本文件以方便查阅的功能</p>
<h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>主要用于处理两个文件之间的数据，而且，主要是将两个文件中有相同数据的那一行加在一起<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">join [-ti12] file1 file2</div><div class="line">参数：</div><div class="line">-t：join默认以空格符分隔数据，并且对比“第一个字段”的数据；如果两个文件相同，则将两条数据连成一行，且第一个字段放在第一个</div><div class="line">-i：忽略大小写</div><div class="line">-1:这个是数字1，代表第一个文件要用哪个字段来分析</div><div class="line">-2:代表第二个文件要用哪个字段来分析</div></pre></td></tr></table></figure></p>
<h4 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h4><p>相对于join必须要对比两个文件的数据相关性，paste就直接将两行贴在一起，且中间以[tab]键隔开而已<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">paster [-d] file1 file2</div><div class="line">参数：</div><div class="line">-d：后面可以接分隔符，默认是以[tab]来分隔的</div><div class="line">- ：如果file部分写成 - ，表示来自standard output的数据</div></pre></td></tr></table></figure></p>
<h4 id="expand"><a href="#expand" class="headerlink" title="expand"></a>expand</h4><p>将[tab]按键转成空格键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">expand [-t] file</div><div class="line">参数：</div><div class="line">-t：后面可以接数字，一般来说，一个[tab]键可以用8个空格键替换，我们也可以自行定义一个[tab]按键代表多少个字符</div></pre></td></tr></table></figure></p>
<h3 id="切割命令：split"><a href="#切割命令：split" class="headerlink" title="切割命令：split"></a>切割命令：split</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">split [-bl] file PREFIX</div><div class="line">参数：</div><div class="line">-b：后面可接欲切割成的文件大小，可加单位，例如b，k，m等</div><div class="line">-l：以行数来切割</div><div class="line">PREFIX：代表前导符，可以作为切割文件的前导文字</div></pre></td></tr></table></figure>
<h3 id="参数代换：xargs"><a href="#参数代换：xargs" class="headerlink" title="参数代换：xargs"></a>参数代换：xargs</h3><p>xargs就是产生某个命令的参数的意思。xargs可以读入stdin的数据，并且以空格符或断行字符进行分辨，将stdin的数据分隔成为arguments<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">xargs [-0epn] command</div><div class="line">参数：</div><div class="line">-0: 如果输入的stdin含有特殊字符，例如`，\，空格键等字符时，这个参数可以将它还原成一般字符。这个参数可以用于特殊状态</div><div class="line">-e：这个是EOF（end of file）的意思，后面可以接一个字符串，当xgras分析到这个字符串时，就会停止继续工作</div><div class="line">-p：在执行每个命令的参数时，都会询问用户的意思</div><div class="line">-n：后面接次数，每次command执行时，要使用几个参数的意思</div></pre></td></tr></table></figure></p>
<h3 id="关于减号的用途"><a href="#关于减号的用途" class="headerlink" title="关于减号的用途"></a>关于减号的用途</h3><p>管道命令在bash的连续的处理程序中是相当重要的，在log file 的分析当中也是相当重要的一环。另外在管道命令中，经常会使用到前一个命令的stdout作为这次的stdin，某些命令需要用到文件名来进行处理时，该stdin与stdout可以利用减号“-”来替代，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -cvf - /home | tar -xvf -</div></pre></td></tr></table></figure></p>
<p>上面的例子是说我将/home里面的文件打包，但打包的数据不是记录到文件，而是传送到sdtout；经过管道后，将<code>tar -cvf - /home</code>传送给后面的<code>tar -xvf -</code>。后面的这个-则是取用前一个命令的stdout，因此我们就不需要使用文件了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Linux/Bash Shell的操作环境/" data-id="cjfvvphh6000pm9fyuhjmpbbm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/6/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Eclipse/">Eclipse</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Github/">Github</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Cookie/">Cookie</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JAXB/">JAXB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JavaMail/">JavaMail</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/基础/">基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/数据类型/">数据类型</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/日记/">日记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/时间日期/">时间日期</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/线程/">线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/网络NIO/">网络NIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/队列/">队列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/集合/">集合</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Application-Event/">Application Event</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/JPA/">JPA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Security/">Security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Spring-Boot/">Spring Boot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Spring-Session/">Spring Session</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Task/">Task</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-MVC/">spring MVC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-data-redis/">spring data redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/基础/">基础</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/">前端技术相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/forever/">forever</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/javascript/">javascript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库相关/">数据库相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据库相关/mysql/">mysql</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/">服务器相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hessian/">Hessian</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hudson-Jenkins/">Hudson & Jenkins</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Memcached/">Memcached</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Nginx/">Nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Tomcat/">Tomcat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/red5/">red5</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/resin/">resin</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/正则表达式/">正则表达式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/12/服务器相关/Tomcat/TOMCAT原理详解及请求过程/">TOMCAT原理详解及请求过程</a>
          </li>
        
          <li>
            <a href="/2018/04/12/网络/HTTPS工作原理/">HTTPS工作原理</a>
          </li>
        
          <li>
            <a href="/2018/04/12/网络/三次握手和四次挥手/">三次握手和四次挥手</a>
          </li>
        
          <li>
            <a href="/2018/04/12/服务器相关/Tomcat/内存分配/">内存分配</a>
          </li>
        
          <li>
            <a href="/2018/04/12/服务器相关/Tomcat/Tomcat整体架构浅析/">Tomcat整体架构浅析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 LeoChan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>