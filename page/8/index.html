<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LeoChan&#39;s 个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="描述啊">
<meta property="og:type" content="website">
<meta property="og:title" content="LeoChan&#39;s 个人博客">
<meta property="og:url" content="https://clq2owesome.github.io/page/8/index.html">
<meta property="og:site_name" content="LeoChan&#39;s 个人博客">
<meta property="og:description" content="描述啊">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeoChan&#39;s 个人博客">
<meta name="twitter:description" content="描述啊">
  
    <link rel="alternate" href="/atom.xml" title="LeoChan&#39;s 个人博客" type="application/atom+xml">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  

</head>

<body>
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">LeoChan&#39;s 个人博客</h1>
  
    <p class="lead blog-description">技术都是通用的，重要的是是否具有自主解决问题的能力！</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-Spring/Security/配置十七：基于方法的权限控制" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Spring/Security/配置十七：基于方法的权限控制/">配置十七：基于方法的权限控制</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/15/Spring/Security/配置十七：基于方法的权限控制/" class="article-date"><time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a> / <a class="article-category-link" href="/categories/Spring/Security/">Security</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;之前介绍的都是基于URL的权限控制，Spring Security同样支持对于方法的权限控制。可以通过intercept-methods对某个bean下面的方法进行权限控制，也可以通过pointcut对整个Service层的方法进行统一的权限控制，还可以通过注解定义对单独的某一个方法进行权限控制。</p>
<p>一. <strong>intercept-methods定义方法权限控制</strong><br>&emsp;&emsp;intercept-methods是需要定义在bean元素下的，通过它可以定义对当前的bean的某些方法进行权限控制，具体方法是使用其下的子元素protect进行定义的。protect元素需要指定两个属性，access和method，method表示需要拦截的方法名称，可以使用通配符，access表示执行对应的方法需要拥有的权限，多个权限之间可以使用逗号分隔。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.xxx.service.impl.UserServiceImpl"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-methods</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">security:protect</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span> <span class="attr">method</span>=<span class="string">"find*"</span>/&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">security:protect</span> <span class="attr">access</span>=<span class="string">"ROLE_ADMIN"</span> <span class="attr">method</span>=<span class="string">"add*"</span>/&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">security:protect</span> <span class="attr">access</span>=<span class="string">"ROLE_ADMIN"</span> <span class="attr">method</span>=<span class="string">"update*"</span>/&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">security:protect</span> <span class="attr">access</span>=<span class="string">"ROLE_ADMIN"</span> <span class="attr">method</span>=<span class="string">"delete*"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">security:intercept-methods</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在上面的配置中表示在执行UserServiceImpl的方法名以find开始的方法时需要当前用户拥有ROLE_USER的权限，在执行方法名以add、update或delete开始的方法时需要拥有ROLE_ADMIN的权限。当访问被拒绝时还是交由ExceptionTranslationFilter处理，这也就意味着如果用户未登录则会引导用户进行登录，否则默认将返回403错误码到客户端。  </p>
<p>二. <strong>使用pointcut定义方法权限控制</strong><br>&emsp;&emsp;基于pointcut的方法权限控制是通过global-method-security下的protect-pointcut来定义的。可以在global-method-security元素下定义多个protect-pointcut以对不同的pointcut使用不同的权限控制。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:global-method-security</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:protect-pointcut</span> <span class="attr">access</span>=<span class="string">"ROLE_READ"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.elim.*..*Service.find*(..))"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:protect-pointcut</span> <span class="attr">access</span>=<span class="string">"ROLE_WRITE"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.elim.*..*Service.*(..))"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:global-method-security</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上面的定义表示我们在执行com.elim包或其子包下任意以Service结尾的类，其方法名以find开始的所有方法时都需要用户拥有ROLE_READ的权限，对于com.elim包或其子包下任意以Service结尾的类的其它方法在执行时都需要ROLE_WRITE的权限。需要注意的是对应的类需要是定义在ApplicationContext中的bean才行。此外同对于URL的权限控制一样，当定义多个protect-pointcut时更具有特性的应当先定义，因为在pointcut匹配的时候是按照声明顺序进行匹配的，一旦匹配上了后续的将不再进行匹配了。</p>
<p>三. <strong>使用注解定义方法权限控制</strong><br>&emsp;&emsp;基于注解的方法权限控制也是需要通过global-method-security元素定义来进行启用的。Spring Security在方法的权限控制上支持三种类型的注解，JSR-250注解、@Secured注解和支持表达式的注解。这三种注解默认都是没有启用的，需要单独通过global-method-security元素的对应属性进行启用。</p>
<p>四. <strong>JSR-250注解</strong><br>&emsp;&emsp;要使用JSR-250注解，首先我们需要通过设置global-method-security元素的jsr250-annotation=”enabled”来启用基于JSR-250注解的支持，默认为disabled。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:global-method-security</span> <span class="attr">jsr250-annotations</span>=<span class="string">"enabled"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;此外，还需要确保添加了jsr250-api到我们的类路径下。之后就可以在我们的Service方法上使用JSR-250注解进行权限控制了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="meta">@RolesAllowed</span>(<span class="string">"ROLE_ADMIN"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"addUser................"</span> + user);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"updateUser.............."</span> + user);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="meta">@RolesAllowed</span>(&#123;<span class="string">"ROLE_USER"</span>, <span class="string">"ROLE_ADMIN"</span>&#125;)</div><div class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"find user by id............."</span> + id);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"delete user by id................"</span>);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="meta">@RolesAllowed</span>(<span class="string">"ROLE_USER"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"find all user..............."</span>);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上面的代码表示执行UserServiceImpl里面所有的方法都需要角色ROLE_ADMIN，其中findAll()方法的执行需要ROLE_USER角色，而find()方法的执行对于ROLE_USER或者ROLE_ADMIN角色都可以。<br>&emsp;&emsp;顺便介绍一下JSR-250中对权限支持的注解。  </p>
<ol>
<li><strong>RolesAllowed</strong>表示访问对应方法时所应该具有的角色。其可以标注在类上，也可以标注在方法上，当标注在类上时表示其中所有方法的执行都需要对应的角色，当标注在方法上表示执行该方法时所需要的角色，当方法和类上都使用了@RolesAllowed进行标注，则方法上的@RolesAllowed将覆盖类上的@RolesAllowed，即方法上的@RolesAllowed将对当前方法起作用。@RolesAllowed的值是由角色名称组成的数组。</li>
<li><strong>PermitAll</strong>表示允许所有的角色进行访问，也就是说不进行权限控制。@PermitAll可以标注在方法上也可以标注在类上，当标注在方法上时则只对对应方法不进行权限控制，而标注在类上时表示对类里面所有的方法都不进行权限控制    （1）当@PermitAll标注在类上，而@RolesAllowed标注在方法上时则按照@RolesAllowed将覆盖@PermitAll，即需要@RolesAllowed对应的角色才能访问。  （2）当@RolesAllowed标注在类上，而@PermitAll标注在方法上时则对应的方法也是不进行权限控制的。  （3）当在方法上同时使用了@PermitAll和@RolesAllowed时先定义的将发生作用，而都定义在类上时则是反过来的，即后定义的将发生作用（这个没多大的实际意义，实际应用中不会有这样的定义）。</li>
<li><strong>DenyAll</strong>是和PermitAll相反的，表示无论什么角色都不能访问。@DenyAll只能定义在方法上。你可能会有疑问使用@DenyAll标注的方法无论拥有什么权限都不能访问，那还定义它干啥呢？使用@DenyAll定义的方法只是在我们的权限控制中不能访问，脱离了权限控制还是可以访问的。</li>
</ol>
<p>五. <strong>@Secured注解</strong><br>&emsp;&emsp;@Secured是由Spring Security定义的用来支持方法权限控制的注解。它的使用也是需要启用对应的支持才会生效的。通过设置global-method-security元素的secured-annotations=”enabled”可以启用Spring Security对使用@Secured注解标注的方法进行权限控制的支持，其值默认为disabled。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:global-method-security</span> <span class="attr">secured-annotations</span>=<span class="string">"enabled"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</div><div class="line"> </div><div class="line">   <span class="meta">@Secured</span>(<span class="string">"ROLE_ADMIN"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"addUser................"</span> + user);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="meta">@Secured</span>(<span class="string">"ROLE_USER"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"find all user..............."</span>);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上面的代码中我们使用@Secured定义了只有拥有ROLE_ADMIN角色的用户才能调用方法addUser()，只有拥有ROLE_USER角色的用户才能调用方法findAll()。</p>
<p>六. <strong>支持表达式的注解</strong><br>&emsp;&emsp;Spring Security中定义了四个支持使用表达式的注解，分别是@PreAuthorize、@PostAuthorize、@PreFilter和@PostFilter。其中前两者可以用来在方法调用前或者调用后进行权限检查，后两者可以用来对集合类型的参数或者返回值进行过滤。要使它们的定义能够对我们的方法的调用产生影响我们需要设置global-method-security元素的pre-post-annotations=”enabled”，默认为disabled。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:global-method-security</span> <span class="attr">pre-post-annotations</span>=<span class="string">"disabled"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>6.1 使用@PreAuthorize和@PostAuthorize进行访问控制<br>@PreAuthorize可以用来控制一个方法是否能够被调用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</div><div class="line"> </div><div class="line">   <span class="meta">@PreAuthorize</span>(<span class="string">"hasRole('ROLE_ADMIN')"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"addUser................"</span> + user);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="meta">@PreAuthorize</span>(<span class="string">"hasRole('ROLE_USER') or hasRole('ROLE_ADMIN')"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"find user by id............."</span> + id);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在上面的代码中我们定义了只有拥有角色ROLE_ADMIN的用户才能访问adduser()方法，而访问find()方法需要有ROLE_USER角色或ROLE_ADMIN角色。使用表达式时我们还可以在表达式中使用方法参数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</div><div class="line"> </div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 限制只能查询Id小于10的用户</div><div class="line">    */</div><div class="line">   <span class="meta">@PreAuthorize</span>(<span class="string">"#id&lt;10"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"find user by id........."</span> + id);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line">  </div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 限制只能查询自己的信息</div><div class="line">    */</div><div class="line">   <span class="meta">@PreAuthorize</span>(<span class="string">"principal.username.equals(#username)"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(String username)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"find user by username......"</span> + username);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 限制只能新增用户名称为abc的用户</div><div class="line">    */</div><div class="line">   <span class="meta">@PreAuthorize</span>(<span class="string">"#user.name.equals('abc')"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"addUser............"</span> + user);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在上面代码中我们定义了调用find(int id)方法时，只允许参数id小于10的调用；调用find(String username)时只允许username为当前用户的用户名；定义了调用add()方法时只有当参数user的name为abc时才可以调用。<br>&emsp;&emsp;有时候可能你会想在方法调用完之后进行权限检查，这种情况比较少，但是如果你有的话，Spring Security也为我们提供了支持，通过@PostAuthorize可以达到这一效果。使用@PostAuthorize时我们可以使用内置的表达式returnObject表示方法的返回值。我们来看下面这一段示例代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PostAuthorize</span>(<span class="string">"returnObject.id%2==0"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">  User user = <span class="keyword">new</span> User();</div><div class="line">  user.setId(id);</div><div class="line">  <span class="keyword">return</span> user;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上面这一段代码表示将在方法find()调用完成后进行权限检查，如果返回值的id是偶数则表示校验通过，否则表示校验失败，将抛出AccessDeniedException。       需要注意的是@PostAuthorize是在方法调用完成后进行权限检查，它不能控制方法是否能被调用，只能在方法调用完成后检查权限决定是否要抛出AccessDeniedException。<br>使用@PreFilter和@PostFilter进行过滤<br>6.2 使用@PreFilter和@PostFilter可以对集合类型的参数或返回值进行过滤。<br>使用@PreFilter和@PostFilter时，Spring Security将移除使对应表达式的结果为false的元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PostFilter</span>(<span class="string">"filterObject.id%2==0"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</div><div class="line">  List&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;User&gt;();</div><div class="line">  User user;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</div><div class="line">     user = <span class="keyword">new</span> User();</div><div class="line">     user.setId(i);</div><div class="line">     userList.add(user);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> userList;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上述代码表示将对返回结果中id不为偶数的user进行移除。filterObject是使用@PreFilter和@PostFilter时的一个内置表达式，表示集合中的当前对象。当@PreFilter标注的方法拥有多个集合类型的参数时，需要通过@PreFilter的filterTarget属性指定当前@PreFilter是针对哪个参数进行过滤的。如下面代码就通过filterTarget指定了当前@PreFilter是用来过滤参数ids的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PreFilter</span>(filterTarget=<span class="string">"ids"</span>, value=<span class="string">"filterObject%2==0"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(List&lt;Integer&gt; ids, List&lt;String&gt; usernames)</span> </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>七. <strong>方法权限控制的拦截器</strong><br>&emsp;&emsp;关于方法权限控制，Spring Security提供了两类AbstractSecurityInterceptor，基于AOP Alliance的MethodSecurityInterceptor，和基于Aspectj继承自MethodSecurityInterceptor的AspectJMethodSecurityInterceptor。<br>7.1 <strong>MethodSecurityInterceptor</strong><br>&emsp;&emsp;当我们在使用基于NameSpace进行方法保护的配置时，Spring Security默认配置的就是MethodSecurityInterceptor。根据配置的不同，一个拦截器可能只是针对于一个bean，也可能是针对于多个bean的。MethodSecurityInterceptor使用一个MethodSecurityMetadataSource的实例来获取特定方法调用配置的ConfigAttribute。当我们在ApplicationContext配置文件中使用intercept-methods元素或protect-point元素定义需要保护的方法调用时，Spring Security内部默认会使用一个MapBasedMethodSecurityMetadataSource来保存在这些元素上定义的配置信息，保存的key是对应的方法名（可以是含有通配符的）。类似的使用JSR-250注解时将使用Jsr250MethodSecurityMetadataSource解析配置属性；使用@Secured注解时将使用SecuredAnnotationSecurityMetadataSource解析配置属性；使用pre-post-annotations时将使用PrePostAnnotationSecurityMetadataSource解析配置属性。<br>&emsp;&emsp;MethodSecurityInterceptor是实现了MethodInterceptor接口的，所以我们在使用Spring Aop时，可以自己配置一个MethodSecurityInterceptor的bean。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 自定义MethodSecurityInterceptor --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"methodSecurityInterceptor"</span></span></div><div class="line"><span class="attr">class</span>=<span class="string">"org.springframework.security.access.intercept.aopalliance.MethodSecurityInterceptor"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationManager"</span> <span class="attr">ref</span>=<span class="string">"authenticationManager"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accessDecisionManager"</span> <span class="attr">ref</span>=<span class="string">"accessDecisionManager"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"afterInvocationManager"</span> <span class="attr">ref</span>=<span class="string">"afterInvocationManager"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"securityMetadataSource"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">security:method-security-metadata-source</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 指定需要受保护的方法和需要的权限 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:protect</span> <span class="attr">method</span>=<span class="string">"com.xxx.service.UserService.find*"</span></span></div><div class="line">            <span class="attr">access</span>=<span class="string">"ROLE_USER"</span> /&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">security:protect</span> <span class="attr">method</span>=<span class="string">"com.xxx.service.UserService.delete*"</span></span></div><div class="line">            <span class="attr">access</span>=<span class="string">"ROLE_ADMIN"</span> /&gt;</div><div class="line">     <span class="tag">&lt;/<span class="name">security:method-security-metadata-source</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;定义了MethodSecurityInterceptor以后，我们需要类似AOP配置那样，配置哪些该MethodInterceptor需要拦截哪些方法的执行。这种可选配置是很多种的，因为我们这里只是拦截UserService中的具体方法，所以就采用基于bean name的自动代理。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 基于bean的拦截 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>methodSecurityInterceptor<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanNames"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>userService<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>按照上面的配置，我们在访问UserService的find方法时就需要ROLE_USER的权限，而访问delete方法时则需要ROLE_ADMIN权限。</p>
<p>7.2 <strong>AspectJMethodSecurityInterceptor</strong><br>&emsp;&emsp;AspectJMethodSecurityInterceptor是继承自MethodSecurityInterceptor的，不同的是AspectJMethodSecurityInterceptor是用来支持AspectJ的JointPoint的，但在底层还是会把它封装成一个MethodInvocation进行调用。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Spring/Security/配置十七：基于方法的权限控制/" data-id="cje2lrz4y009kpxblr0vyr5vq" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Spring/Security/配置十二：Remember-Me功能" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Spring/Security/配置十二：Remember-Me功能/">配置十二：Remember-Me功能</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/15/Spring/Security/配置十二：Remember-Me功能/" class="article-date"><time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a> / <a class="article-category-link" href="/categories/Spring/Security/">Security</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>一. <strong>概述</strong><br>&emsp;&emsp;Remember-Me是指网站能够在Session之间记住登录用户的身份，具体来说就是我成功认证一次之后在一定的时间内我可以不用再输入用户名和密码进行登录了，系统会自动给我登录。这通常是通过服务端发送一个cookie给客户端浏览器，下次浏览器再访问服务端时服务端能够自动检测客户端的cookie，根据cookie值触发自动登录操作。Spring Security为这些操作的发生提供必要的钩子，并且针对于Remember-Me功能有两种实现。一种是简单的使用加密来保证基于cookie的token的安全，另一种是通过数据库或其它持久化存储机制来保存生成的token。<br>&emsp;&emsp;需要注意的是两种实现都需要一个UserDetailsService。如果你使用的AuthenticationProvider不使用UserDetailsService，那么记住我将会不起作用，除非在你的ApplicationContext中拥有一个UserDetailsService类型的bean。</p>
<p>二. <strong>基于简单加密token的方法</strong><br>&emsp;&emsp;当用户选择了记住我成功登录后，Spring Security将会生成一个cookie发送给客户端浏览器。cookie值由如下方式组成：<br>base64(username+”:”+expirationTime+”:”+md5Hex(username+”:”+expirationTime+”:”+password+”:”+key))  </p>
<ul>
<li>username：登录的用户名。</li>
<li>password：登录的密码。</li>
<li>expirationTime：token失效的日期和时间，以毫秒表示。</li>
<li>key：用来防止修改token的一个key。</li>
</ul>
<p>&emsp;&emsp;这样用来实现Remember-Me功能的token只能在指定的时间内有效，且必须保证token中所包含的username、password和key没有被改变才行。需要注意的是，这样做其实是存在安全隐患的，那就是在用户获取到实现记住我功能的token后，任何用户都可以在该token过期之前通过该token进行自动登录。如果用户发现自己的token被盗用了，那么他可以通过改变自己的登录密码来立即使其所有的记住我token失效。如果希望我们的应用能够更安全一点，可以使用接下来要介绍的持久化token方式，或者不使用Remember-Me功能，因为Remember-Me功能总是有点不安全的。<br>&emsp;&emsp;使用这种方式时，我们只需要在http元素下定义一个remember-me元素，同时指定其key属性即可。key属性是用来标记存放token的cookie的，对应上文提到的生成token时的那个key。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span> <span class="attr">auto-config</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:form-login</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 定义记住我功能 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:remember-me</span> <span class="attr">key</span>=<span class="string">"elim"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这里有两个需要注意的地方：</p>
<ol>
<li>如果你的登录页面是自定义的，那么需要在登录页面上新增一个名为“_spring_security_remember_me”的checkbox，这是基于NameSpace定义提供的默认名称，如果要自定义可以自己定义TokenBasedRememberMeServices或PersistentTokenBasedRememberMeServices对应的bean，然后通过其parameter属性进行指定。</li>
<li>上述功能需要一个UserDetailsService，如果在你的ApplicationContext中已经拥有一个了，那么Spring Security将自动获取；如果没有，那么当然你需要定义一个；如果拥有在ApplicationContext中拥有多个UserDetailsService定义，那么你需要通过remember-me元素的user-service-ref属性指定将要使用的那个。如：<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">  <span class="tag">&lt;<span class="name">security:http</span> <span class="attr">auto-config</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:form-login</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 定义记住我功能，通过user-service-ref指定将要使用的UserDetailsService--&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:remember-me</span> <span class="attr">key</span>=<span class="string">"elim"</span> <span class="attr">user-service-ref</span>=<span class="string">"userDetailsService"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDetailsService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>三. <strong>基于持久化token的方法</strong><br>&emsp;&emsp;持久化token的方法跟简单加密token的方法在实现Remember-Me功能上大体相同，都是在用户选择了“记住我”成功登录后，将生成的token存入cookie中并发送到客户端浏览器，待到下次用户访问系统时，系统将直接从客户端cookie中读取token进行认证。所不同的是基于简单加密token的方法，一旦用户登录成功后，生成的token将在客户端保存一段时间，如果用户不点击退出登录，或者不修改密码，那么在cookie失效之前，他都可以使用该token进行登录，哪怕该token被别人盗用了，用户与盗用者都同样可以进行登录。而基于持久化token的方法采用这样的实现逻辑：<br>（1）用户选择了“记住我”成功登录后，将会把username、随机产生的序列号、生成的token存入一个数据库表中，同时将它们的组合生成一个cookie发送给客户端浏览器。<br>（2）当下一次没有登录的用户访问系统时，首先检查cookie，如果对应cookie中包含的username、序列号和token与数据库中保存的一致，则表示其通过验证，系统将重新生成一个新的token替换数据库中对应组合的旧token，序列号保持不变，同时删除旧的cookie，重新生成包含新生成的token，旧的序列号和username的cookie发送给客户端。<br>（3）如果检查cookie时，cookie中包含的username和序列号跟数据库中保存的匹配，但是token不匹配。这种情况极有可能是因为你的cookie被人盗用了，由于盗用者使用你原本通过认证的cookie进行登录了导致旧的token失效，而产生了新的token。这个时候Spring Security就可以发现cookie被盗用的情况，它将删除数据库中与当前用户相关的所有token记录，这样盗用者使用原有的cookie将不能再登录，同时提醒用户其帐号有被盗用的可能性。<br>（4）如果对应cookie不存在，或者包含的username和序列号与数据库中保存的不一致，那么将会引导用户到登录页面。</p>
<p>&emsp;&emsp;从以上逻辑我们可以看出持久化token的方法比简单加密token的方法更安全，因为一旦你的cookie被人盗用了，你只要再利用原有的cookie试图自动登录一次，原有的token将失效导致盗用者不能再使用原来盗用的cookie进行登录了，同时用户可以发现自己的cookie有被盗用的可能性。但因为cookie被盗用后盗用者还可以在用户下一次登录前顺利的进行登录，所以如果你的应用对安全性要求比较高就不要使用Remember-Me功能了。<br>&emsp;&emsp;使用持久化token方法时需要我们的数据库中拥有如下表及其表结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">create table persistent_logins (username varchar(64) not null,</div><div class="line">    series varchar(64) primary key,</div><div class="line">    token varchar(64) not null,</div><div class="line">    last_used timestamp not null)</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;然后还是通过remember-me元素来使用，只是这个时候我们需要其data-source-ref属性指定对应的数据源，同时别忘了它也同样需要ApplicationContext中拥有UserDetailsService，如果拥有多个，请使用user-service-ref属性指定remember-me使用的是哪一个。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">security:http</span> <span class="attr">auto-config</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:form-login</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 定义记住我功能 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:remember-me</span> <span class="attr">data-source-ref</span>=<span class="string">"dataSource"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>四. <strong>Remember-Me相关接口和实现类</strong><br>&emsp;&emsp;在上述介绍中，我们实现Remember-Me功能是通过Spring Security为了简化Remember-Me而提供的NameSpace进行定义的。而底层实际上还是通过RememberMeServices、UsernamePasswordAuthenticationFilter和RememberMeAuthenticationFilter的协作来完成的。RememberMeServices是Spring Security为Remember-Me提供的一个服务接口，其定义如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">publicinterface RememberMeServices &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 自动登录。在实现这个方法的时候应该判断用户提供的Remember-Me cookie是否有效，如果无效，应当直接忽略。</div><div class="line">     * 如果认证成功应当返回一个AuthenticationToken，推荐返回RememberMeAuthenticationToken；</div><div class="line">     * 如果认证不成功应当返回null。</div><div class="line">     */</div><div class="line">    <span class="function">Authentication <span class="title">autoLogin</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在用户登录失败时调用。实现者应当做一些类似于删除cookie之类的处理。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loginFail</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在用户成功登录后调用。实现者可以在这里判断用户是否选择了“Remember-Me”登录，然后做相应的处理。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loginSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></div><div class="line">        Authentication successfulAuthentication);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;UsernamePasswordAuthenticationFilter拥有一个RememberMeServices的引用，默认是一个空实现的NullRememberMeServices，而实际当我们通过remember-me定义启用Remember-Me时，它会是一个具体的实现。用户的请求会先通过UsernamePasswordAuthenticationFilter，如认证成功会调用RememberMeServices的loginSuccess()方法，否则调用RememberMeServices的loginFail()方法。UsernamePasswordAuthenticationFilter是不会调用RememberMeServices的autoLogin()方法进行自动登录的。之后运行到RememberMeAuthenticationFilter时如果检测到还没有登录，那么RememberMeAuthenticationFilter会尝试着调用所包含的RememberMeServices的autoLogin()方法进行自动登录。关于RememberMeServices Spring Security已经为我们提供了两种实现，分别对应于前文提到的基于简单加密token和基于持久化token的方法。</p>
<p>五. <strong>TokenBasedRememberMeServices</strong><br>&emsp;&emsp;TokenBasedRememberMeServices对应于前文介绍的使用namespace时基于简单加密token的实现。TokenBasedRememberMeServices会在用户选择了记住我成功登录后，生成一个包含token信息的cookie发送到客户端；如果用户登录失败则会删除客户端保存的实现Remember-Me的cookie。需要自动登录时，它会判断cookie中所包含的关于Remember-Me的信息是否与系统一致，一致则返回一个RememberMeAuthenticationToken供RememberMeAuthenticationProvider处理，不一致则会删除客户端的Remember-Me cookie。TokenBasedRememberMeServices还实现了Spring Security的LogoutHandler接口，所以它可以在用户退出登录时立即清除Remember-Me cookie。<br>&emsp;&emsp; 如果把使用namespace定义Remember-Me改为直接定义RememberMeServices和对应的Filter来使用的话，那么我们可以如下定义。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">security:http</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:form-login</span> <span class="attr">login-page</span>=<span class="string">"/login.jsp"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/login*.jsp*"</span> <span class="attr">access</span>=<span class="string">"IS_AUTHENTICATED_ANONYMOUSLY"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 把usernamePasswordAuthenticationFilter加入FilterChain --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:custom-filter</span> <span class="attr">ref</span>=<span class="string">"usernamePasswordAuthenticationFilter"</span> <span class="attr">before</span>=<span class="string">"FORM_LOGIN_FILTER"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:custom-filter</span> <span class="attr">ref</span>=<span class="string">"rememberMeFilter"</span> <span class="attr">position</span>=<span class="string">"REMEMBER_ME_FILTER"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 用于认证的AuthenticationManager --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">security:authentication-manager</span> <span class="attr">alias</span>=<span class="string">"authenticationManager"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:authentication-provider</span></span></div><div class="line">     <span class="attr">user-service-ref</span>=<span class="string">"userDetailsService"</span>/&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">security:authentication-provider</span> <span class="attr">ref</span>=<span class="string">"rememberMeAuthenticationProvider"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDetailsService"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"usernamePasswordAuthenticationFilter"</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"rememberMeServices"</span> <span class="attr">ref</span>=<span class="string">"rememberMeServices"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationManager"</span> <span class="attr">ref</span>=<span class="string">"authenticationManager"</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 指定request中包含的用户名对应的参数名 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"usernameParameter"</span> <span class="attr">value</span>=<span class="string">"username"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"passwordParameter"</span> <span class="attr">value</span>=<span class="string">"password"</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 指定登录的提交地址 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filterProcessesUrl"</span> <span class="attr">value</span>=<span class="string">"/login.do"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- Remember-Me对应的Filter --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"rememberMeFilter"</span></span></div><div class="line"><span class="attr">class</span>=<span class="string">"org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"rememberMeServices"</span> <span class="attr">ref</span>=<span class="string">"rememberMeServices"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationManager"</span> <span class="attr">ref</span>=<span class="string">"authenticationManager"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- RememberMeServices的实现 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"rememberMeServices"</span></span></div><div class="line"><span class="attr">class</span>=<span class="string">"org.springframework.security.web.authentication.rememberme.TokenBasedRememberMeServices"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDetailsService"</span> <span class="attr">ref</span>=<span class="string">"userDetailsService"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"key"</span> <span class="attr">value</span>=<span class="string">"elim"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 指定request中包含的用户是否选择了记住我的参数名 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"parameter"</span> <span class="attr">value</span>=<span class="string">"rememberMe"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- key值需与对应的RememberMeServices保持一致 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"rememberMeAuthenticationProvider"</span></span></div><div class="line"><span class="attr">class</span>=<span class="string">"org.springframework.security.authentication.RememberMeAuthenticationProvider"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"key"</span> <span class="attr">value</span>=<span class="string">"elim"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;需要注意的是RememberMeAuthenticationProvider在认证RememberMeAuthenticationToken的时候是比较它们拥有的key是否相等，而RememberMeAuthenticationToken的key是TokenBasedRememberMeServices提供的，所以在使用时需要保证RememberMeAuthenticationProvider和TokenBasedRememberMeServices的key属性值保持一致。需要配置UsernamePasswordAuthenticationFilter的rememberMeServices为我们定义好的TokenBasedRememberMeServices，把RememberMeAuthenticationProvider加入AuthenticationManager的providers列表，并添加RememberMeAuthenticationFilter和UsernamePasswordAuthenticationFilter到FilterChainProxy。  </p>
<p>六. <strong>PersistentTokenBasedRememberMeServices</strong><br>&emsp;&emsp;PersistentTokenBasedRememberMeServices是RememberMeServices基于前文提到的持久化token的方式实现的。具体实现逻辑跟前文介绍的以NameSpace的方式使用基于持久化token的Remember-Me是一样的，这里就不再赘述了。此外，如果单独使用，其使用方式和上文描述的TokenBasedRememberMeServices是一样的，这里也不再赘述了。<br>&emsp;&emsp;需要注意的是PersistentTokenBasedRememberMeServices是需要将token进行持久化的，所以我们必须为其指定存储token的PersistentTokenRepository。Spring Security对此有两种实现，InMemoryTokenRepositoryImpl和JdbcTokenRepositoryImpl。前者是将token存放在内存中的，通常用于测试，而后者是将token存放在数据库中。PersistentTokenBasedRememberMeServices默认使用的是前者，我们可以通过其tokenRepository属性来指定使用的PersistentTokenRepository。<br>&emsp;&emsp;使用JdbcTokenRepositoryImpl时我们可以使用在前文提到的默认表结构。如果需要使用自定义的表，那么我们可以对JdbcTokenRepositoryImpl进行重写。定义JdbcTokenRepositoryImpl时需要指定一个数据源dataSource，同时可以通过设置参数createTableOnStartup的值来控制是否要在系统启动时创建对应的存入token的表，默认创建语句为“create table persistent_logins (username varchar(64) not null, series varchar(64) primary key, token varchar(64) not null, last_used timestamp not null)”，但是如果自动创建时对应的表已经存在于数据库中，则会抛出异常。createTableOnStartup属性默认为false。<br>&emsp;&emsp;直接显示地使用PersistentTokenBasedRememberMeServices和上文提到的直接显示地使用TokenBasedRememberMeServices的方式是一样的，我们只需要将上文提到的配置中RememberMeServices实现类TokenBasedRememberMeServices换成PersistentTokenBasedRememberMeServices即可。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- RememberMeServices的实现 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"rememberMeServices"</span></span></div><div class="line">   <span class="attr">class</span>=<span class="string">"org.springframework.security.web.authentication.rememberme.PersistentTokenBasedRememberMeServices"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDetailsService"</span> <span class="attr">ref</span>=<span class="string">"userDetailsService"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"key"</span> <span class="attr">value</span>=<span class="string">"elim"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 指定request中包含的用户是否选择了记住我的参数名 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"parameter"</span> <span class="attr">value</span>=<span class="string">"rememberMe"</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 指定PersistentTokenRepository --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tokenRepository"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.web.authentication.rememberme.JdbcTokenRepositoryImpl"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 数据源 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 是否在系统启动时创建持久化token的数据库表 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"createTableOnStartup"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Spring/Security/配置十二：Remember-Me功能/" data-id="cje2lrz4z009mpxblqqdc0op8" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Spring/Security/配置十九：对Acl的支持" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Spring/Security/配置十九：对Acl的支持/">配置十九：对Acl的支持</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/15/Spring/Security/配置十九：对Acl的支持/" class="article-date"><time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a> / <a class="article-category-link" href="/categories/Spring/Security/">Security</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;Acl的全称是Access Control List，俗称访问控制列表，是用以控制对象的访问权限的。其主要思想是将某个对象的某种权限授予给某个用户，或某种GrantedAuthority（可以简单的理解为某种角色），它们之间的关系都是多对多。如果某一个对象的某一操作是受保护的，那么在对该对象进行某种操作时就需要有对应的权限。</p>
<p>一. <strong>准备工作</strong><br>使用Spring Security的Acl功能需要引入Acl相关的jar包。如果我们的应用是使用Maven构建的，则可以在应用的pom.xml文件中加入如下依赖。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-acl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.security.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>此外，使用Spring Security的Acl时需要在数据库中建立四张表。在其官方文档中给出了一个基于数据库HSQLDB的建表语句。其脚本如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">create table acl_sid (</div><div class="line">  id bigint generated by default as identity(start with 100) not null primary key,</div><div class="line">  principal boolean not null,</div><div class="line">  sid varchar_ignorecase(100) not null,</div><div class="line">  constraint unique_uk_1 unique(sid,principal) );</div><div class="line"> </div><div class="line">create table acl_class (</div><div class="line">  id bigint generated by default as identity(start with 100) not null primary key,</div><div class="line">  class varchar_ignorecase(100) not null,</div><div class="line">  constraint unique_uk_2 unique(class) );</div><div class="line"> </div><div class="line">create table acl_object_identity (</div><div class="line">  id bigint generated by default as identity(start with 100) not null primary key,</div><div class="line">  object_id_class bigint not null,</div><div class="line">  object_id_identity bigint not null,</div><div class="line">  parent_object bigint,</div><div class="line">  owner_sid bigint not null,</div><div class="line">  entries_inheriting boolean not null,</div><div class="line">  constraint unique_uk_3 unique(object_id_class,object_id_identity),</div><div class="line">  constraint foreign_fk_1 foreign key(parent_object)references acl_object_identity(id),</div><div class="line">  constraint foreign_fk_2 foreign key(object_id_class)references acl_class(id),</div><div class="line">  constraint foreign_fk_3 foreign key(owner_sid)references acl_sid(id) );</div><div class="line"> </div><div class="line">create table acl_entry (</div><div class="line">  id bigint generated by default as identity(start with 100) not null primary key,</div><div class="line">  acl_object_identity bigint not null,ace_order int not null,sid bigint not null,</div><div class="line">  mask integer not null,granting boolean not null,audit_success boolean not null,</div><div class="line">  audit_failure boolean not null,</div><div class="line">  constraint unique_uk_4 unique(acl_object_identity,ace_order),</div><div class="line">  constraint foreign_fk_4 foreign key(acl_object_identity)</div><div class="line">      references acl_object_identity(id),</div><div class="line">  constraint foreign_fk_5 foreign key(sid) references acl_sid(id) );</div></pre></td></tr></table></figure></p>
<p>笔者使用的是Oracle数据库，其中没有boolean和主键自增功能，对于boolean类型都使用一位number表示。具体建表语句如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">create table acl_sid (</div><div class="line">  id number not null primary key,</div><div class="line">  principal number(1) not null,</div><div class="line">  sid varchar(100) not null,</div><div class="line">  constraint unique_uk_1 unique(sid,principal) );</div><div class="line"> </div><div class="line">create table acl_class (</div><div class="line">  id number not null primary key,</div><div class="line">  class varchar(100) not null,</div><div class="line">  constraint unique_uk_2 unique(class) );</div><div class="line"> </div><div class="line">create table acl_object_identity (</div><div class="line">  id number not null primary key,</div><div class="line">  object_id_class number not null,</div><div class="line">  object_id_identity number not null,</div><div class="line">  parent_object number,</div><div class="line">  owner_sid number not null,</div><div class="line">  entries_inheriting number(1) not null,</div><div class="line">  constraint unique_uk_3 unique(object_id_class,object_id_identity),</div><div class="line">  constraint foreign_fk_1 foreign key(parent_object)references acl_object_identity(id),</div><div class="line">  constraint foreign_fk_2 foreign key(object_id_class)references acl_class(id),</div><div class="line">  constraint foreign_fk_3 foreign key(owner_sid)references acl_sid(id) );</div><div class="line"> </div><div class="line">create table acl_entry (</div><div class="line">  id number not null primary key,</div><div class="line">  acl_object_identity number not null,ace_order int not null,sid number not null,</div><div class="line">  mask number(3) not null,granting number(1) not null,audit_success number(1) not null,</div><div class="line">  audit_failure number(1) not null,</div><div class="line">  constraint unique_uk_4 unique(acl_object_identity,ace_order),</div><div class="line">  constraint foreign_fk_4 foreign key(acl_object_identity)</div><div class="line">      references acl_object_identity(id),</div><div class="line">  constraint foreign_fk_5 foreign key(sid) references acl_sid(id) );</div><div class="line"> </div><div class="line"> 新增记录时用于生成主键的sequence定义为：</div><div class="line">  create or replace sequence seq_acl_sid start with 1 increment by 1;</div><div class="line">  create or replace sequence seq_acl_class start with 1 increment by 1;</div><div class="line">  create or replace sequence seq_acl_object_identity start with 1 increment by 1;</div><div class="line">  create or replace sequence seq_acl_entry start with 1 increment by 1;</div></pre></td></tr></table></figure></p>
<p>二. <strong>表功能介绍</strong><br>如上所示，Spring Security的Acl功能需要使用到四张数据库表，分别为acl_sid、acl_class、acl_object_identity和acl_entry。<br>2.1 <strong>表acl_sid</strong><br>表acl_sid的结构如下所示：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>number</td>
<td>主键</td>
</tr>
<tr>
<td>sid</td>
<td>varchar</td>
<td>字符串类型的sid</td>
</tr>
<tr>
<td>principal</td>
<td>boolean</td>
<td>是否用户</td>
</tr>
</tbody>
</table>
<p>表acl_sid是用来保存Sid的。对于Acl而言，有两种类型的Sid，一种是基于用户的Sid，叫PrincipalSid；另一种是基于GrantedAuthority的Sid，叫GrantedAuthoritySid。acl_sid表的sid字段存放的是用户名或者是GrantedAuthority的字符串表示。prinpal是用来区分对应的Sid是用户还是GrantedAuthority的。正如在前文所描述的那样，Acl中对象的权限是用来授予给Sid的，Sid有用户和GrantedAuthority之分，所以我们的对象权限是可以用来授予给用户或GrantedAuthority的。</p>
<p>2.2 <strong>表acl_class</strong><br>表acl_class的结构如下所示：<br>| 字段名   | 类型      | 说明        |<br>| —– | ——- | ——— |<br>| id    | number  | 主键        |<br>| class | varchar | 对象类型的全限定名 |<br>表acl_class是用来保存对象类型的，字段class中保存的是对应对象的全限定名。Acl需要使用它来区分不同的对象类型。</p>
<p>2.3 <strong>表acl_object_identity</strong><br>表acl_object_identity的结构如下：<br>| 字段名                | 类型      | 说明                                       |<br>| —————— | ——- | —————————————- |<br>| id                 | number  | 主键                                       |<br>| object_id_class    | number  | 关联acl_class，表示对象类型                       |<br>| object_id_identity | number  | 对象的主键，对于相同的class而言，其需要是唯一的。对象的主键默认需要是Long型，或者可以转换为Long型的对象，如Integer、Short等。 |<br>| parent_object      | number  | 父对象的id，关联acl_object_identity             |<br>| owner_sid          | number  | 拥有者的sid，关联acl_sid                        |<br>| entries_inheriting | boolean | 是否继承父对象的权限。打个比方，删除对象childObj需要有delete权限，用户A他没有childObj的delete权限，但是他有childObj的父对象parentObj的delete权限，当entries_inheriting为true时，用户A同样可以删除childObj。 |<br>表acl_object_identity是用来存放需要进行访问控制的对象的信息的。其保存的信息有对象的拥有者、对象的类型、对象的主键、对象的父对象和是否继承父对象的权限。</p>
<p>2.4 <strong>表acl_entry</strong><br>表acl_entry的结构如下：<br>| 字段名                 | 类型      | 说明                             |<br>| ——————- | ——- | —————————— |<br>| id                  | number  | 主键                             |<br>| acl_object_identity | number  | 对应acl_object_identity的id       |<br>| ace_order           | number  | 所属Acl的权限顺序                     |<br>| sid                 | number  | 对应acl_sid的id                   |<br>| mask                | number  | 权限对应的掩码                        |<br>| granting            | boolean | 是否授权                           |<br>| audit_success       | boolean | 暂未发现其作用，Acl中有一个更新其值的方法，但未见被调用。 |<br>| audit_failure       | boolean |                                |<br>表acl_entry是用于存放具体的权限信息的，从表结构我们也可以看出来，其描述的就是某个主体（Sid）对某个对象（acl_object_identity）是否（granting）拥有某种权限（mask）。当同一对象acl_object_identity在acl_entry表中拥有多条记录时，就会使用ace_order来标记对应的顺序，其对应于往Acl中插入AccessControlEntry时的位置，在进行权限判断时也是依靠ace_order的顺序来进行的，ace_order越小的越先进行判断。ace是Access Control Entry的简称。</p>
<p>三. <strong>Acl主要接口</strong><br>&emsp;&emsp;对于Acl而言，有两块比较核心的功能，一块是往对应的数据库表里面插数据，另一块是从数据库表里面取出对应的数据进行权限鉴定。要了解这些功能我们先来了解Acl中用到的主要接口。<br>3.1 <strong>Sid</strong>：可以用来表示一个principal，或者是一个GrantedAuthority。其对应的实现类有表示principal的PrincipalSid和表示GrantedAuthority的GrantedAuthoritySid。其信息会保存在acl_sid表中。<br>3.2  <strong>ObjectIdentity</strong>：ObjectIdentity表示Spring Security Acl中一个域对象，其默认实现类是ObjectIdentityImpl。ObjectIdentity并不是直接与acl_object_identity表相对应的，真正与acl_object_identity表直接相对应的是Acl。<br>3.3 <strong>Acl</strong>：每一个领域对象都会对应一个Acl，而且只会对应一个Acl。Acl是将Spring Security Acl中使用到的四个表串联起来的一个接口，其中会包含对象信息ObjectIdentity、对象的拥有者Sid和对象的访问控制信息AccessControlEntry。在Spring Security Acl中直接与acl_object_identity表相关联的是Acl接口，因为acl_object_identity表中的数据是通过保存Acl来进行的。一个Acl对应于一个ObjectIdentity，但是会包含有多个Sid和多个AccessControlEntry，即一个Acl表示所有Sid对一个ObjectIdentity的所有AccessControlEntry。Acl的默认实现类是AclImpl，该类实现Acl接口、MutableAcl接口、AuditableAcl接口和OwnershipAcl接口。<br>3.4 <strong>AccessControlEntry</strong>：一个AccessControlEntry表示一条访问控制信息，一个Acl中可以拥有多个AccessControlEntry。在Spring Security Acl中很多地方会使用ACE来简单的表示AccessControlEntry这个概念，比如insertAce其实表示的就是insert AccessControlEntry。每一个AccessControlEntry表示对应的Sid对于对应的对象ObjectIdentity是否被授权某一项权限Permission，是否被授权将使用granting进行区分。AccessControlEntry对应表acl_entry。<br>3.5 <strong>Permission</strong>：在Acl中使用一个bit掩码来表示一个Permission。Spring Security的Acl中默认使用的是BasePermission，其中已经定义了0-4五个bit掩码，分别对应于1、2、4、8、16，代表五种不同的Permission，分别是read (bit 0)、write (bit 1)、create (bit 2)、delete (bit 3)和administer (bit 4)。如果已经定义好的这五个bit掩码不能满足需求，我们可以对BasePermission进行扩展，也可以实现自己的Permission。Spring Security Acl默认的实现最多可以支持32个不同的掩码。<br>3.6 <strong>AclService</strong>：AclService是用来通过ObjectIdentity解析Acl的，其默认实现类是JdbcAclService。JdbcAclService底层操作是通过LookupStrategy来进行的，LookupStrategy的默认实现是BasicLookupStrategy。<br>3.7 <strong>MutableAclService</strong>：MutableAclService是用来对Acl进行持久化的，其默认实现类是JdbcMutableAclService。JdbcMutableAclService是继承自JdbcAclService的，所以我们可以同时通过JdbcMutableAclService对Acl进行读取和保存。如果我们希望自己来实现Acl信息的保存的话，我们也可以不使用该接口。</p>
<p>四. <strong>配置AclService</strong><br>&emsp;&emsp;AclService是使用Spring Security Acl功能的主入口。这里选择一个既可以从数据库读取Acl信息，又可以保存Acl信息到数据库的JdbcMutableAclService做示例。<br>&emsp;&emsp;JdbcMutableAclService只有一个构造方法，它接收三个参数，DataSource、LookupStrategy和AclCache。其对应配置信息如下所示：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aclService"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.jdbc.JdbcMutableAclService"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"lookupStrategy"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"aclCache"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;配置JdbcMutableAclService有一点需要注意的地方，那就是其在与数据库进行交互的时候所基于的脚本是本文开始部分我们提到的那些脚本。其对应的数据库表的主键是自增的，所以在保存Acl时所给出的脚本中没有新增主键id。比如在新增sid时默认使用的脚本是“insert into acl_sid (principal, sid) values (?, ?)”，显然对于使用Oracle数据库作为示例的我们来说这条SQL是有问题的，因为新增的时候主键不能为空，所以如果我们需要使用JdbcMutableAclService来创建Acl的话我们得给JdbcMutableAclService指定新增记录时使用的脚本。这里我们将在新增的时候从之前建立好的Sequence获取值作为主键，示例如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aclService"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.jdbc.JdbcMutableAclService"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"lookupStrategy"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"aclCache"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 指定新增acl_sid的脚本 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"insertSidSql"</span></span></div><div class="line">     <span class="attr">value</span>=<span class="string">"insert into acl_sid(id, principal, sid) values (seq_acl_sid.nextval, ?, ?)"</span> /&gt;</div><div class="line">  <span class="comment">&lt;!-- 指定新增acl_class的脚本 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"insertClassSql"</span></span></div><div class="line">     <span class="attr">value</span>=<span class="string">"insert into acl_class(id, class) values (seq_acl_class.nextval, ?)"</span> /&gt;</div><div class="line">  <span class="comment">&lt;!-- 指定新增acl_object_identity的脚本 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"insertObjectIdentitySql"</span></span></div><div class="line">     <span class="attr">value</span>=<span class="string">"insert into acl_object_identity(id, object_id_class, object_id_identity, owner_sid, entries_inheriting) values(seq_acl_object_identity.nextval, ?, ?, ?, ?)"</span> /&gt;</div><div class="line">  <span class="comment">&lt;!-- 指定新增acl_entry的脚本 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"insertEntrySql"</span></span></div><div class="line">     <span class="attr">value</span>=<span class="string">"insert into acl_entry(id, acl_object_identity, ace_order, sid, mask, granting, audit_success, audit_failure) values (seq_acl_entry.nextval, ?, ?, ?, ?, ?, ?, ?)"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;除了上述四个SQL之外，我们还需要指定两个属性对应的查询SQL，sidIdentityQuery和classIdentityQuery。因为JdbcMutableAclService在创建Acl时，如果当前用户在acl_sid表中不存在或当前对象类型在acl_class表中不存在，其会先将对应的信息存入acl_sid表和acl_class表，然后需要取出刚刚新增的acl_sid的主键和acl_class的主键以往acl_object_identity表中插入数据，对应acl_object_identity表中的owner_sid和object_id_class字段。这两个属性的默认值是“call identity()”，显然对于Oracle数据库来说这是行不通的，所以我们需要自己指定它们。这里我们通过对应Sequence的当前值来获取刚刚新增的记录的主键。如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aclService"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.jdbc.JdbcMutableAclService"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"lookupStrategy"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"aclCache"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 指定新增acl_sid的脚本 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"insertSidSql"</span></span></div><div class="line">     <span class="attr">value</span>=<span class="string">"insert into acl_sid(id, principal, sid) values (seq_acl_sid.nextval, ?, ?)"</span> /&gt;</div><div class="line">  <span class="comment">&lt;!-- 指定新增acl_class的脚本 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"insertClassSql"</span></span></div><div class="line">     <span class="attr">value</span>=<span class="string">"insert into acl_class(id, class) values (seq_acl_class.nextval, ?)"</span> /&gt;</div><div class="line">  <span class="comment">&lt;!-- 指定新增acl_object_identity的脚本 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"insertObjectIdentitySql"</span></span></div><div class="line">     <span class="attr">value</span>=<span class="string">"insert into acl_object_identity(id, object_id_class, object_id_identity, owner_sid, entries_inheriting) values(seq_acl_object_identity.nextval, ?, ?, ?, ?)"</span> /&gt;</div><div class="line">  <span class="comment">&lt;!-- 指定新增acl_entry的脚本 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"insertEntrySql"</span></span></div><div class="line">     <span class="attr">value</span>=<span class="string">"insert into acl_entry(id, acl_object_identity, ace_order, sid, mask, granting, audit_success, audit_failure) values (seq_acl_entry.nextval, ?, ?, ?, ?, ?, ?, ?)"</span> /&gt;</div><div class="line">  <span class="comment">&lt;!-- 查询刚刚新增的acl_sid的主键的SQL --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sidIdentityQuery"</span> <span class="attr">value</span>=<span class="string">"select seq_acl_sid.currval from dual"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 查询刚刚新增的acl_class的主键的SQL --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"classIdentityQuery"</span> <span class="attr">value</span>=<span class="string">"select seq_acl_class.currval from dual"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>4.1 <strong>配置DataSource</strong><br>&emsp;&emsp;配置数据源这个没什么好说的，大家都见惯了，为保持文章的完整性，我这里还是把它列一下。直接上代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"/WEB-INF/config/jdbc.properties"</span> /&gt;</span></div><div class="line"> </div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp2.BasicDataSource"</span></span></div><div class="line">  <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driverClassName&#125;"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>4.2 <strong>配置LookupStrategy</strong><br>&emsp;&emsp;LookupStrategy是用来通过ObjectIdentity解析为对应的Acl的。Spring Security Acl中的默认实现类是BasicLookupStrategy，其的构造需要接收四个参数。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lookupStrategy"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.jdbc.BasicLookupStrategy"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"aclCache"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"aclAuthorizationStrategy"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"grantingStrategy"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>4.3 <strong>配置AclAuthorizationStrategy</strong><br>&emsp;&emsp;aclAuthorizationStrategy是在构造Acl的实现类AclImpl时必须给定的一个参数，其会用来在对Acl进行某些操作时检查当前用户是否具有对应的权限。AclAuthorizationStrategy的默认实现类是AclAuthorizationStrategyImpl，其构造需要接收一个或三个GrantedAuthority参数，用来对Acl进行相关操作时所需要的权限，包括更改Acl对应对象的所有者需要的权限、更改Acl中包含的某个AccessControlEntry的audit信息（对应acl_entry表中的is_audit_success和is_audit_failure字段）需要的权限以及其它如增、删、改Acl中所包含的AccessControlEntry等需要的权限。这些权限的鉴定是我们在操作Acl时由Spring Security Acl内部进行判断的，我们只需要在这里定义就好。当Acl对应的所有者对Acl进行操作时，不管其是否拥有指定需要的权限，除了改变audit信息之外的所有操作默认都是被允许的。当只有一个参数时表示三者共用一个GrantedAuthority。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aclAuthorizationStrategy"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.domain.AclAuthorizationStrategyImpl"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.core.authority.SimpleGrantedAuthority"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"ROLE_ADMIN"</span> /&gt;</span><span class="comment">&lt;!-- 改变所有权需要的权限 --&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.core.authority.SimpleGrantedAuthority"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"gaModifyAuditing"</span> /&gt;</span><span class="comment">&lt;!-- 改变授权需要的权限 --&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.core.authority.SimpleGrantedAuthority"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"gaGeneralChanges"</span> /&gt;</span><span class="comment">&lt;!-- 改变其它信息所需要的权限 --&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>4.4 <strong>配置grantingStrategy</strong><br>&emsp;&emsp;grantingStrategy对应类型为PermissionGrantingStrategy接口，其中只定义了一个isGranted方法，用于判断基于指定的Permission列表和Sid列表指定的Acl是否被授予了访问权限。其默认实现类是DefaultPermissionGrantingStrategy。DefaultPermissionGrantingStrategy对于isGranted的实现逻辑是依次遍历Permission列表、Sid列表和Acl中包含的AccessControlEntry列表，找到第一个三者能够匹配的AccessControlEntry的isGranting（对应acl_entry表的granting字段）作为isGranted的返回结果。如果在当前Acl中没有找到匹配的AccessControlEntry，同时Acl对应的entriesInheriting为true时将继续使用父级的Acl进行匹配，并依次进行，如果都没有匹配到，则将抛出异常。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"grantingStrategy"</span></span></div><div class="line">   <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.domain.DefaultPermissionGrantingStrategy"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.domain.ConsoleAuditLogger"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>4.5 <strong>配置AclCache</strong><br>&emsp;&emsp;AclCache是用来缓存Acl信息的，Spring Security Acl中对于AclCache的默认实现是基于Ehcache的实现类EhCacheBasedAclCache。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aclCache"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.domain.EhCacheBasedAclCache"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"cache"</span> /&gt;</span><span class="comment">&lt;!-- 对应于Ehcache --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"grantingStrategy"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"aclAuthorizationStrategy"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 定义一个Ehcache --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cache"</span> <span class="attr">class</span>=<span class="string">"org.springframework.cache.ehcache.EhCacheFactoryBean"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheName"</span> <span class="attr">value</span>=<span class="string">"aclCache"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManager"</span> <span class="attr">ref</span>=<span class="string">"aclCacheManager"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 定义CacheManager --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aclCacheManager"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.cache.ehcache.EhCacheManagerFactoryBean"</span>&gt;</div><div class="line">  <span class="comment">&lt;!-- 指定配置文件的位置 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/config/ehcache.xml"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 指定新建的CacheManager的名称 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManagerName"</span> <span class="attr">value</span>=<span class="string">"aclCacheManager"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>为保持本文的完整性，这里贴出上述使用到的配置文件ehcache.xml的内容。具体如下所示：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line">   <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">"http://ehcache.org/ehcache.xsd"</span></div><div class="line">   <span class="attr">maxBytesLocalHeap</span>=<span class="string">"100M"</span>&gt;</div><div class="line"> </div><div class="line">   <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">"d:\\ehcache"</span> /&gt;</span></div><div class="line"> </div><div class="line">   <span class="tag">&lt;<span class="name">defaultCache</span> <span class="attr">maxEntriesLocalHeap</span>=<span class="string">"200"</span> /&gt;</span></div><div class="line"> </div><div class="line">   <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"aclCache"</span> <span class="attr">maxBytesLocalHeap</span>=<span class="string">"50M"</span> <span class="attr">maxBytesLocalDisk</span>=<span class="string">"5G"</span></span></div><div class="line">      <span class="attr">timeToIdleSeconds</span>=<span class="string">"120"</span> <span class="attr">timeToLiveSeconds</span>=<span class="string">"600"</span> /&gt;</div><div class="line"> </div><div class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>关于Ehcache的更多内容不在本文讨论范围之内，有需要的读者可以参考官方文档，也可以参考我的另一个关于Ehcache的系列文章。<br>至此，关于AclService配置的内容就讲完了，AclService配置的完整内容如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aclService"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.jdbc.JdbcMutableAclService"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"lookupStrategy"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"aclCache"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 指定新增acl_sid的脚本 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"insertSidSql"</span></span></div><div class="line">     <span class="attr">value</span>=<span class="string">"insert into acl_sid(id, principal, sid) values (seq_acl_sid.nextval, ?, ?)"</span> /&gt;</div><div class="line">  <span class="comment">&lt;!-- 指定新增acl_class的脚本 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"insertClassSql"</span></span></div><div class="line">     <span class="attr">value</span>=<span class="string">"insert into acl_class(id, class) values (seq_acl_class.nextval, ?)"</span> /&gt;</div><div class="line">  <span class="comment">&lt;!-- 指定新增acl_object_identity的脚本 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"insertObjectIdentitySql"</span></span></div><div class="line">     <span class="attr">value</span>=<span class="string">"insert into acl_object_identity(id, object_id_class, object_id_identity, owner_sid, entries_inheriting) values(seq_acl_object_identity.nextval, ?, ?, ?, ?)"</span> /&gt;</div><div class="line">  <span class="comment">&lt;!-- 指定新增acl_entry的脚本 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"insertEntrySql"</span></span></div><div class="line">     <span class="attr">value</span>=<span class="string">"insert into acl_entry(id, acl_object_identity, ace_order, sid, mask, granting, audit_success, audit_failure) values (seq_acl_entry.nextval, ?, ?, ?, ?, ?, ?, ?)"</span> /&gt;</div><div class="line">  <span class="comment">&lt;!-- 查询刚刚新增的acl_sid的主键的SQL --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sidIdentityQuery"</span> <span class="attr">value</span>=<span class="string">"select seq_acl_sid.currval from dual"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 查询刚刚新增的acl_class的主键的SQL --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"classIdentityQuery"</span> <span class="attr">value</span>=<span class="string">"select seq_acl_class.currval from dual"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lookupStrategy"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.jdbc.BasicLookupStrategy"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"aclCache"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"aclAuthorizationStrategy"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"grantingStrategy"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aclCache"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.domain.EhCacheBasedAclCache"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"cache"</span> /&gt;</span><span class="comment">&lt;!-- 对应于Ehcache --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"grantingStrategy"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"aclAuthorizationStrategy"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 定义一个Ehcache --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cache"</span> <span class="attr">class</span>=<span class="string">"org.springframework.cache.ehcache.EhCacheFactoryBean"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheName"</span> <span class="attr">value</span>=<span class="string">"aclCache"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManager"</span> <span class="attr">ref</span>=<span class="string">"aclCacheManager"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 定义CacheManager --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aclCacheManager"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.cache.ehcache.EhCacheManagerFactoryBean"</span>&gt;</div><div class="line">  <span class="comment">&lt;!-- 指定配置文件的位置 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/config/ehcache.xml"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 指定新建的CacheManager的名称 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManagerName"</span> <span class="attr">value</span>=<span class="string">"aclCacheManager"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aclAuthorizationStrategy"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.domain.AclAuthorizationStrategyImpl"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.core.authority.SimpleGrantedAuthority"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"ROLE_ADMIN"</span> /&gt;</span><span class="comment">&lt;!-- 改变所有权需要的权限 --&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.core.authority.SimpleGrantedAuthority"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"gaModifyAuditing"</span> /&gt;</span><span class="comment">&lt;!-- 改变授权需要的权限 --&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.core.authority.SimpleGrantedAuthority"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"gaGeneralChanges"</span> /&gt;</span><span class="comment">&lt;!-- 改变其它信息所需要的权限 --&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"grantingStrategy"</span></span></div><div class="line"><span class="attr">class</span>=<span class="string">"org.springframework.security.acls.domain.DefaultPermissionGrantingStrategy"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.domain.ConsoleAuditLogger"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>五. <strong>使用AclService</strong><br>&emsp;&emsp;配置好AclService之后我们就可以使用该JdbcMutableAclService来创建、更新和查找Acl了。在Spring Security Acl中Acl接口的默认实现类是AclImpl，该类实现Acl接口、MutableAcl接口、AuditableAcl接口和OwnershipAcl接口，当有必要在这几种接口之间切换时可以任意切换。<br>5.1 <strong>创建Acl</strong><br>&emsp;&emsp;可以通过调用JdbcMutableAclService的createAcl()方法来创建一个Acl，其对应返回的是一个MutableAcl，该方法接收一个ObjectIdentity作为参数。在创建的时候如果ObjectIdentity对应的类型在acl_class表中不存在，则会把ObjectIdentity对应的类型添加到acl_class表中；如果当前用户对应的Sid在acl_sid表中不存在则会将其添加到acl_sid中。最后会将ObjectIdentity保存到acl_object_identity表中。正如在本文开始部分所描述的那样，一个Acl对应于一个ObjectIdentity，创建Acl就是创建ObjectIdentity的过程。在这三部分都完成之后，会重新从数据库查询出一个Acl，只是此时该Acl对应的AccessControlEntry列表为空。通常如果我们的对象是需要利用Acl进行访问控制的话，那么我们可以在创建该对象的时候一并创建该对象对应的Acl。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> MutableAclService aclService;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">  ...</div><div class="line"> </div><div class="line">  <span class="comment">//1、构建一个ObjectIdentity</span></div><div class="line">  ObjectIdentity oi = <span class="keyword">new</span> ObjectIdentityImpl(User.class, user.getId());</div><div class="line"></div><div class="line">  <span class="comment">//2、创建一个Acl、此时会如果对应的信息不存在会依次创建，如当前用户对应的Sid、ObjectIdentity对应于acl_class表中的类型</span></div><div class="line">  <span class="comment">//最后是往acl_object_identity中插入对应的数据</span></div><div class="line">  MutableAcl acl = aclService.createAcl(oi);</div><div class="line"></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ObjectIdentityImpl拥有多个构造方法，具体可以参考Spring Security的API文档。</p>
<p>5.2 <strong>查找Acl</strong><br>&emsp;&emsp;通过AclService的系列readAclById()方法可以通过给定的ObjectIdentity查找对应的Acl。此外通过findChildren()方法可以查找指定ObjectIdentity的子ObjectIdentity。关于这些方法的具体信息可以参考Spring Security的API文档。以下是一个简单的示例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ObjectIdentity oi = <span class="keyword">new</span> ObjectIdentityImpl(User.class, user.getId());</div><div class="line"><span class="comment">//获取ObjectIdentity对应的Acl</span></div><div class="line">MutableAcl acl = (MutableAcl) aclService.readAclById(oi);</div></pre></td></tr></table></figure></p>
<p>5.3 <strong>更新Acl</strong><br>&emsp;&emsp;Acl的更新主要是对应AccessControlEntry的更新，即对AccessControlEntry的增、删、改；此外还包括对Acl对应的ObjectIdentity信息的变更，如更改所有者、父子关系等。<br>&emsp;&emsp; 如下是一些更新Acl的示例，需要注意的是在调用MutableAclService的updateAcl()方法将对应信息同步到数据库之前，对Acl所做的所有修改都只是在内存中的。使用updateAcl()更新Acl信息到数据库时，其底层实现会先将数据库中所有对应的AccessControlEntry都删除，然后再将内存中的AccessControlEntry列表保存到数据库中。以下是其实现代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> MutableAcl <span class="title">updateAcl</span><span class="params">(MutableAcl acl)</span> <span class="keyword">throws</span> NotFoundException </span>&#123;</div><div class="line">    Assert.notNull(acl.getId(), <span class="string">"Object Identity doesn't provide an identifier"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Delete this ACL's ACEs in the acl_entry table</span></div><div class="line">    deleteEntries(retrieveObjectIdentityPrimaryKey(acl.getObjectIdentity()));</div><div class="line"></div><div class="line">    <span class="comment">// Create this ACL's ACEs in the acl_entry table</span></div><div class="line">    createEntries(acl);</div><div class="line"></div><div class="line">    <span class="comment">// Change the mutable columns in acl_object_identity</span></div><div class="line">    updateObjectIdentity(acl);</div><div class="line"></div><div class="line">    <span class="comment">// Clear the cache, including children</span></div><div class="line">    clearCacheIncludingChildren(acl.getObjectIdentity());</div><div class="line"></div><div class="line">    <span class="comment">// Retrieve the ACL via superclass (ensures cache registration, proper retrieval etc)</span></div><div class="line">    <span class="keyword">return</span> (MutableAcl) <span class="keyword">super</span>.readAclById(acl.getObjectIdentity());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5.3.1 <strong>添加AccessControlEntry</strong><br>&emsp;&emsp;添加AccessControlEntry是通过MutableAcl的insertAce()方法进行的，该方法的定义如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/**</span></div><div class="line">  *</div><div class="line">  * <span class="doctag">@param</span> atIndexLocation 添加的位置，对应于acl_entry表中的ace_order字段</div><div class="line">  * <span class="doctag">@param</span> permission 对应的Permission</div><div class="line">  * <span class="doctag">@param</span> sid 对应Sid</div><div class="line">  * <span class="doctag">@param</span> granting 是否赋予</div><div class="line">  */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertAce</span><span class="params">(<span class="keyword">int</span> atIndexLocation, Permission permission, Sid sid, <span class="keyword">boolean</span> granting)</span></span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;参数atIndexLocation对应的是需要插入的AccessControlEntry在Acl对应的AccessControlEntry列表（java.util.List类型）中的位置，对应于acl_entry表中ace_order，而一个Acl代表其对应ObjectIdentity的所有关联Sid关联的所有AccessControlEntry，这个ace_order是在这个范围内的order。以下是一个添加AccessControlEntry的示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">MutableAcl acl = ...;</div><div class="line"> </div><div class="line"><span class="comment">//基于principal的Sid</span></div><div class="line">Sid sid = <span class="keyword">new</span> PrincipalSid(SecurityContextHolder.getContext().getAuthentication());</div><div class="line">Permission p = BasePermission.ADMINISTRATION;<span class="comment">//管理员权限</span></div><div class="line"><span class="comment">//将当前Acl的管理员权限赋予给指定的Sid</span></div><div class="line">acl.insertAce(acl.getEntries().size(), p, sid, <span class="keyword">true</span>);   <span class="comment">//添加AccessControlEntry到内存</span></div><div class="line"><span class="comment">//保存到数据库</span></div><div class="line">acl = aclService.updateAcl(acl);</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上述的Sid，也可以是一个GrantedAuthoritySid，当把一个Acl的某Permission赋予给一个GrantedAuthoritySid时表示拥有该GrantedAuthority的用户都将拥有对应的Permission。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">MutableAcl acl = ...;</div><div class="line"> </div><div class="line"><span class="comment">//基于GrantedAuthority的Sid</span></div><div class="line">Sid sid = <span class="keyword">new</span> GrantedAuthoritySid(<span class="string">"ROLE_ADMIN"</span>);</div><div class="line">Permission p = BasePermission.ADMINISTRATION;<span class="comment">//管理员权限</span></div><div class="line"><span class="comment">//将当前Acl的管理员权限赋予给指定的Sid</span></div><div class="line">acl.insertAce(acl.getEntries().size(), p, sid, <span class="keyword">true</span>);   <span class="comment">//添加AccessControlEntry到内存</span></div><div class="line"><span class="comment">//保存到数据库</span></div><div class="line">acl = aclService.updateAcl(acl);</div></pre></td></tr></table></figure></p>
<p>5.3.2 <strong>删除AccessControlEntry</strong><br>&emsp;&emsp;通过调用MutableAcl的deleteAce(int aceIndex)方法可以删除Acl中指定位置的AccessControlEntry，aceIndex是从0开始的，底层是使用的List的remove(int index)方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ObjectIdentity oi = <span class="keyword">new</span> ObjectIdentityImpl(User.class, user.getId());</div><div class="line"><span class="comment">//获取ObjectIdentity对应的Acl</span></div><div class="line">MutableAcl acl = (MutableAcl) aclService.readAclById(oi);</div><div class="line">acl.deleteAce(<span class="number">0</span>);<span class="comment">//内存中删除第一个AccessControlEntry</span></div><div class="line">aclService.updateAcl(acl);<span class="comment">//同步到数据库</span></div></pre></td></tr></table></figure></p>
<p>5.3.3 <strong>更新AccessControlEntry</strong><br>&emsp;&emsp;通过MutableAcl的updateAce()可以更新指定位置的AccessControlEntry的Permission。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ObjectIdentity oi = <span class="keyword">new</span> ObjectIdentityImpl(User.class, user.getId());</div><div class="line"><span class="comment">//获取ObjectIdentity对应的Acl</span></div><div class="line">MutableAcl acl = (MutableAcl) aclService.readAclById(oi);</div><div class="line">acl.updateAce(<span class="number">0</span>, BasePermission.CREATE);<span class="comment">//内存中更新第一个AccessControlEntry对应的Permission</span></div><div class="line">aclService.updateAcl(acl);<span class="comment">//同步到数据库</span></div></pre></td></tr></table></figure></p>
<p>5.3.4 <strong>修改所有者</strong><br>&emsp;&emsp;可以通过Acl的getOwner()方法获取Acl对应ObjectIdentity的拥有者Sid。通过MutableAcl的setOwner()方法可以在内存中更新对应Acl的拥有者。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ObjectIdentity oi = <span class="keyword">new</span> ObjectIdentityImpl(User.class, user.getId());</div><div class="line"><span class="comment">//获取ObjectIdentity对应的Acl</span></div><div class="line">MutableAcl acl = (MutableAcl) aclService.readAclById(oi);</div><div class="line">acl.setOwner(<span class="keyword">new</span> PrincipalSid(<span class="string">"user"</span>));<span class="comment">//内存中更改拥有者</span></div><div class="line">aclService.updateAcl(acl);<span class="comment">//同步到数据库</span></div></pre></td></tr></table></figure></p>
<p>5.3.5 <strong>修改父Acl</strong><br>&emsp;&emsp;通过Acl的getParentAcl()方法可以获取到Acl对应ObjectIdentity对应的父ObjectIdentity对应的Acl。通过MutableAcl的setParent()方法可以在内存中修改Acl对应的父Acl，即修改Acl对应ObjectIdentity对应的父ObjectIdentity。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ObjectIdentity oi = <span class="keyword">new</span> ObjectIdentityImpl(User.class, user.getId());</div><div class="line"><span class="comment">//获取ObjectIdentity对应的Acl</span></div><div class="line">MutableAcl acl = (MutableAcl) aclService.readAclById(oi);</div><div class="line">Acl newParent = ...;<span class="comment">//以某种方式获取到Acl</span></div><div class="line">acl.setParent(newParent);<span class="comment">//内存中更改父Acl</span></div><div class="line">aclService.updateAcl(acl);<span class="comment">//同步到数据库</span></div></pre></td></tr></table></figure></p>
<p>5.3.6 <strong>修改继承策略</strong><br>&emsp;&emsp;通过Acl的isEntriesInheriting()可以获取到当前Acl对应ObjectIdentity的继承策略，创建Acl时该值默认为true。通过MutableAcl的setEntriesInheriting()方法可以在内存中修改该Acl对应ObjectIdentity的继承策略。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ObjectIdentity oi = new ObjectIdentityImpl(User.class, user.getId());</div><div class="line">//获取ObjectIdentity对应的Acl</div><div class="line">MutableAcl acl = (MutableAcl) aclService.readAclById(oi);</div><div class="line">acl.setEntriesInheriting(false);//内存中修改为不从父Acl继承AccessControlEntry</div><div class="line">aclService.updateAcl(acl);//同步到数据库</div></pre></td></tr></table></figure></p>
<p>5.4 <strong>删除Acl</strong><br>&emsp;&emsp;当我们删除对象的时候应该连同对应的Acl也一起删除。使用MutableAclService的deleteAcl(ObjectIdentity oi, boolean deleteChildren)方法可以删除指定ObjectIdentity对应的Acl，deleteChildren表示是否连同子ObjectIdentity对应的Acl也一起删除。deleteAcl将删除对应的ObjectIdentity，以及对应的AccessControlEntry，即其会删除acl_object_identity表和acl_entry表中与当前Acl对应的ObjectIdentity相关的记录。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ObjectIdentity objectIdentity = <span class="keyword">new</span> ObjectIdentityImpl(User.class, id);</div><div class="line">aclService.deleteAcl(objectIdentity, <span class="keyword">true</span>);</div></pre></td></tr></table></figure></p>
<p>六. <strong>注入到AclPermissionEvaluator</strong><br>&emsp;&emsp;AclPermissionEvaluator是PermissionEvaluator的一个实现类。在之前关于使用基于表达式的权限控制一文中有提到过，PermissionEvaluator是为表达式hasPermission提供支持的。此外，PermissionEvaluator还为标签accesscontrollist提供支持。本节将就使用AclPermissionEvaluator支持在方法上使用@PreAuthorize进行权限控制时使用表达式hasPermission做一个简单讲解。<br>&emsp;&emsp;AclPermissionEvaluator的构造需要接收一个AclService参数，在进行权限鉴定时其需要通过AclService获取到对应对象对应的Acl，然后判断该Acl中是否具有指定的Sid和指定的Permission。<br>&emsp;&emsp;对于方法使用hasPermission表达式进行权限鉴定时需要做两个事情，首先需要指定global-method-security的pre-post-annotations=”enabled”。其次需要手工定义DefaultMethodSecurityExpressionHandler并指定其permissionEvaluator为我们定义的AclPermissionEvaluator。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:global-method-security</span> <span class="attr">pre-post-annotations</span>=<span class="string">"enabled"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:expression-handler</span> <span class="attr">ref</span>=<span class="string">"expressionHandler"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:global-method-security</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"expressionHandler"</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"permissionEvaluator"</span> <span class="attr">ref</span>=<span class="string">"aclPermissionEvaluator"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aclPermissionEvaluator"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.AclPermissionEvaluator"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"aclService"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;定义后之后我们就可以在方法上使用@PreAuthorize和hasPermission表达式了。关于PermissionEvaluator和hasPermission的更多介绍可以参考《基于表达式的权限控制》一文。hasPermission有两种用法，一种是直接传一个对象和对应需要的权限，如hasPermission(object,permission)；另一种是传对象的id、对应类型和需要的权限，如hasPermission(targetId,targetType,permission)。传入的Permission是Spring Security Acl中的Permission接口实现类，而不是Spring Security的GrantedAuthority。传入的permission参数可以是一个Permission对象或Permission对象数组，也可以是一个整数或字符串。当传入的permission是整数或字符串时将由AclPermissionEvaluator的PermissionFactory进行解析，AclPermissionEvaluator默认拥有的PermissionFactory是DefaultPermissionFactory，其会将整形或字符串类型的permission解析成对应的BasePermission。如前所述，BasePermission中定义了五个BasePermission，其对应的名称和掩码分别为：READ (1)、WRITE (2)、CREATE (4)、DELETE (8)和ADMINISTER (16)。当permission使用字符串时我们只能使用这五种字符串，不区分大小写，表示当前用户或其所拥有的GrantedAuthority必须拥有指定对象的指定Permission才允许访问。但是当使用掩码时我们可以使用1、2、4、8和16。<br>&emsp;&emsp;接下来将简单的介绍一个使用@PreAuthorize和hasPermission表达式在方法上进行权限控制的示例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@PreAuthorize(&quot;hasPermission(#id, &apos;com.spring.security.entity.User&apos;, 1)&quot;)</div><div class="line">public User find(int id) &#123;</div><div class="line">  User user = new User();</div><div class="line">  user.setId(id);</div><div class="line">  return user;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上述配置即表示调用find方法查看指定id对应的User对象时必须拥有掩码为1对应的Permission才行，或者在继续策略为true时拥有指定id父对象掩码为1对应的Permission也行。这时哪怕你是该User对象的拥有者，或者你拥有ADMINISTER权限，如果你没有对应的READ权限，你也不能访问该方法。如果觉得这种实现不符合你的要求，你可以实现自己的PermissionGrantingStrategy，然后将实现类bean注入到BasicLookupStrategy和EhcacheBasedAclCache中，这样在判断一个用户是否具有指定Acl的指定Permission时就可以使用自己的逻辑了。<br>&emsp;&emsp;上面的定义如果改成permission参数直接使用对象，可以这样定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PreAuthorize</span>(<span class="string">"hasPermission(#id, 'com.spring.security.entity.User', T(org.springframework.security.acls.domain.BasePermission).READ)"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">  User user = <span class="keyword">new</span> User();</div><div class="line">  user.setId(id);</div><div class="line">  <span class="keyword">return</span> user;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;当permission参数定义为一个Permission数组时，会根据顺序依次匹配当前用户在指定的Acl中是否拥有对应Permission的AccessControlEntry，如果拥有则以第一个匹配到的AccessControlEntry的granting属性作为判断结果，没有匹配到还可以根据继承策略决定是否利用父级Acl进行匹配，都没匹配到就会抛异常了。<br>&emsp;&emsp;默认使用的BasePermission中只定义了五种Permission，如果这不能满足你的要求，那么我们可以实现自己的Permission，然后把它们注册到DefaultPermissionFactory中，并手工将该DefaultPermissionFactory注入到AclPermissionEvaluator中。前文已经说过AclPermissionEvaluator中使用的PermissionFactory默认是DefaultPermissionFactory，DefaultPermissionFactory中默认只注册了BasePermission中对应的五种Permission。以下是一个扩展Permission的简单示例。<br>&emsp;&emsp;首先实现自己的Permission类，这里简单的定义一个自己的类，然后继承BasePermission类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePermissionExt</span> <span class="keyword">extends</span> <span class="title">BasePermission</span> </span>&#123;</div><div class="line"> </div><div class="line"><span class="comment">/**</span></div><div class="line">* serialVersionUID</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">BasePermissionExt</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</div><div class="line">  <span class="keyword">super</span>(mask);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">BasePermissionExt</span><span class="params">(<span class="keyword">int</span> mask, <span class="keyword">char</span> code)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(mask, code);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;然后在DefaultPermissionFactory中注册基于我们自己实现的Permission对象，并将该DefaultPermissionFactory注入到AclPermissionEvaluator中。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aclPermissionEvaluator"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.AclPermissionEvaluator"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"aclService"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 手工注册DefaultPermissionFactory和其中的Permission --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"permissionFactory"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.domain.DefaultPermissionFactory"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"READ"</span>&gt;</span></div><div class="line">                  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.xxx.spring.security.BasePermissionExt"</span>&gt;</span></div><div class="line">                     <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></div><div class="line">                  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">               <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"WRITE"</span>&gt;</span></div><div class="line">                  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.xxx.spring.security.BasePermissionExt"</span>&gt;</span></div><div class="line">                     <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"2"</span>/&gt;</span></div><div class="line">                  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">               <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>此外，还可以将我们的BasePermissionExt改成如下这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePermissionExt</span> <span class="keyword">extends</span> <span class="title">BasePermission</span> </span>&#123;</div><div class="line"> </div><div class="line">   <span class="comment">/**</span></div><div class="line">    * serialVersionUID</div><div class="line">    */</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> longserialVersionUID = <span class="number">1L</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Permission READ = <span class="keyword">new</span> BasePermissionExt(<span class="number">1</span> &lt;&lt; <span class="number">0</span>, <span class="string">'R'</span>); <span class="comment">// 1</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Permission WRITE = <span class="keyword">new</span> BasePermissionExt(<span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="string">'W'</span>); <span class="comment">// 2</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Permission CREATE = <span class="keyword">new</span> BasePermissionExt(<span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="string">'C'</span>); <span class="comment">// 4</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Permission DELETE = <span class="keyword">new</span> BasePermissionExt(<span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="string">'D'</span>); <span class="comment">// 8</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Permission ADMINISTRATION = <span class="keyword">new</span> BasePermissionExt(<span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="string">'A'</span>); <span class="comment">// 16</span></div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BasePermissionExt</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</div><div class="line">      <span class="keyword">super</span>(mask);</div><div class="line">   &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasePermissionExt</span><span class="params">(<span class="keyword">int</span> mask, <span class="keyword">char</span> code)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(mask, code);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后通过传入Class参数来构造DefaultPermissionFactory。这个时候会将对应Class中所有类型为Permission的字段分别以字段名和字段值Permission对应的掩码为Key，以字段值Permission为Value进行注册。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aclPermissionEvaluator"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.AclPermissionEvaluator"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"aclService"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 手工注册DefaultPermissionFactory和其中的Permission --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"permissionFactory"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.acls.domain.DefaultPermissionFactory"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"com.spring.security.BasePermissionExt"</span>/&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Spring/Security/配置十九：对Acl的支持/" data-id="cje2lrz50009ppxbljekas3x0" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Spring/Security/配置十五：权限鉴定结构" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Spring/Security/配置十五：权限鉴定结构/">配置十五：权限鉴定结构</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/15/Spring/Security/配置十五：权限鉴定结构/" class="article-date"><time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a> / <a class="article-category-link" href="/categories/Spring/Security/">Security</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>一. <strong>权限</strong><br>&emsp;&emsp;所有的Authentication实现类都保存了一个GrantedAuthority列表，其表示用户所具有的权限。GrantedAuthority是通过AuthenticationManager设置到Authentication对象中的，然后AccessDecisionManager将从Authentication中获取用户所具有的GrantedAuthority来鉴定用户是否具有访问对应资源的权限。<br>&emsp;&emsp;GrantedAuthority是一个接口，其中只定义了一个getAuthority()方法，其返回值为String类型。该方法允许AccessDecisionManager获取一个能够精确代表该权限的字符串。通过返回一个字符串，一个GrantedAuthority能够很轻易的被大部分AccessDecisionManager读取。如果一个GrantedAuthority不能够精确的使用一个String来表示，那么其对应的getAuthority()方法调用应当返回一个null，这表示AccessDecisionManager必须对该GrantedAuthority的实现有特定的支持，从而可以获取该GrantedAuthority所代表的权限信息。<br>&emsp;&emsp;Spring Security内置了一个GrantedAuthority的实现，SimpleGrantedAuthority。它直接接收一个表示权限信息的字符串，然后getAuthority()方法直接返回该字符串。Spring Security内置的所有AuthenticationProvider都是使用它来封装Authentication对象的。</p>
<p>二. <strong>调用前的处理</strong><br>&emsp;&emsp; Spring Security是通过拦截器来控制受保护对象的访问的，如方法调用和Web请求。在正式访问受保护对象之前，Spring Security将使用AccessDecisionManager来鉴定当前用户是否有访问对应受保护对象的权限。</p>
<p>2.1 AccessDecisionManager<br>&emsp;&emsp;AccessDecisionManager是由AbstractSecurityInterceptor调用的，它负责鉴定用户是否有访问对应资源（方法或URL）的权限。AccessDecisionManager是一个接口，其中只定义了三个方法，其定义如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccessDecisionManager</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 通过传递的参数来决定用户是否有访问对应受保护对象的权限</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> authentication 当前正在请求受包含对象的Authentication</div><div class="line">     * <span class="doctag">@param</span> object 受保护对象，其可以是一个MethodInvocation、JoinPoint或FilterInvocation。</div><div class="line">     * <span class="doctag">@param</span> configAttributes 与正在请求的受保护对象相关联的配置属性</div><div class="line">     *</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decide</span><span class="params">(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes)</span></span></div><div class="line">        <span class="keyword">throws</span> AccessDeniedException, InsufficientAuthenticationException;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 表示当前AccessDecisionManager是否支持对应的ConfigAttribute</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(ConfigAttribute attribute)</span></span>;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 表示当前AccessDecisionManager是否支持对应的受保护对象类型</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;decide()方法用于决定authentication是否符合受保护对象要求的configAttributes。supports(ConfigAttribute attribute)方法是用来判断AccessDecisionManager是否能够处理对应的ConfigAttribute的。supports(Class&lt;?&gt; clazz)方法用于判断配置的AccessDecisionManager是否支持对应的受保护对象类型。</p>
<p>2.2 基于投票的AccessDecisionManager实现<br>&emsp;&emsp;Spring Security已经内置了几个基于投票的AccessDecisionManager，当然如果需要你也可以实现自己的AccessDecisionManager。以下是Spring Security官方文档提供的一个图，其展示了与基于投票的AccessDecisionManager实现相关的类。<br><img src="http://dl2.iteye.com/upload/attachment/0112/0957/b7963b90-3877-3885-84f9-6d0054cb5eec.png" alt="image"><br>&emsp;&emsp;使用这种方式，一系列的AccessDecisionVoter将会被AccessDecisionManager用来对Authentication是否有权访问受保护对象进行投票，然后再根据投票结果来决定是否要抛出AccessDeniedException。AccessDecisionVoter是一个接口，其中定义有三个方法，具体结构如下所示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccessDecisionVoter</span>&lt;<span class="title">S</span>&gt; </span>&#123;</div><div class="line"> </div><div class="line">    intACCESS_GRANTED = <span class="number">1</span>;</div><div class="line">    intACCESS_ABSTAIN = <span class="number">0</span>;</div><div class="line">    intACCESS_DENIED = -<span class="number">1</span>;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(ConfigAttribute attribute)</span></span>;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">vote</span><span class="params">(Authentication authentication, S object, Collection&lt;ConfigAttribute&gt; attributes)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;vote()方法的返回结果会是AccessDecisionVoter中定义的三个常量之一。ACCESS_GRANTED表示同意，ACCESS_DENIED表示返回，ACCESS_ABSTAIN表示弃权。如果一个AccessDecisionVoter不能判定当前Authentication是否拥有访问对应受保护对象的权限，则其vote()方法的返回值应当为弃权ACCESS_ABSTAIN。<br>&emsp;&emsp;Spring Security内置了三个基于投票的AccessDecisionManager实现类，它们分别是AffirmativeBased、ConsensusBased和UnanimousBased。 </p>
<ol>
<li><p>AffirmativeBased的逻辑是这样的：<br>（1）只要有AccessDecisionVoter的投票为ACCESS_GRANTED则同意用户进行访问；<br>（2）如果全部弃权也表示通过；<br>（3）如果没有一个人投赞成票，但是有人投反对票，则将抛出AccessDeniedException。</p>
</li>
<li><p>ConsensusBased的逻辑是这样的：<br>（1）如果赞成票多于反对票则表示通过。<br>（2）反过来，如果反对票多于赞成票则将抛出AccessDeniedException。<br>（3）如果赞成票与反对票相同且不等于0，并且属性allowIfEqualGrantedDeniedDecisions的值为true，则表示通过，否则将抛出异常AccessDeniedException。参数allowIfEqualGrantedDeniedDecisions的值默认为true。<br>（4）如果所有的AccessDecisionVoter都弃权了，则将视参数allowIfAllAbstainDecisions的值而定，如果该值为true则表示通过，否则将抛出异常AccessDeniedException。参数allowIfAllAbstainDecisions的值默认为false。  </p>
</li>
<li>UnanimousBased的逻辑与另外两种实现有点不一样，另外两种会一次性把受保护对象的配置属性全部传递给AccessDecisionVoter进行投票，而UnanimousBased会一次只传递一个ConfigAttribute给AccessDecisionVoter进行投票。这也就意味着如果我们的AccessDecisionVoter的逻辑是只要传递进来的ConfigAttribute中有一个能够匹配则投赞成票，但是放到UnanimousBased中其投票结果就不一定是赞成了。<br>UnanimousBased的逻辑具体来说是这样的：<br>（1）如果受保护对象配置的某一个ConfigAttribute被任意的AccessDecisionVoter反对了，则将抛出AccessDeniedException。<br>（2）如果没有反对票，但是有赞成票，则表示通过。<br>（3）如果全部弃权了，则将视参数allowIfAllAbstainDecisions的值而定，true则通过，false则抛出AccessDeniedException。  </li>
</ol>
<p>2.3 RoleVoter<br>&emsp;&emsp;RoleVoter是Spring Security内置的一个AccessDecisionVoter，其会将ConfigAttribute简单的看作是一个角色名称，在投票的时如果拥有该角色即投赞成票。如果ConfigAttribute是以“ROLE<em>”开头的，则将使用RoleVoter进行投票。当用户拥有的权限中有一个或多个能匹配受保护对象配置的以“ROLE</em>”开头的ConfigAttribute时其将投赞成票；如果用户拥有的权限中没有一个能匹配受保护对象配置的以“ROLE<em>”开头的ConfigAttribute，则RoleVoter将投反对票；如果受保护对象配置的ConfigAttribute中没有以“ROLE</em>”开头的，则RoleVoter将弃权。</p>
<p>2.4 AuthenticatedVoter<br>&emsp;&emsp;AuthenticatedVoter也是Spring Security内置的一个AccessDecisionVoter实现。其主要用来区分匿名用户、通过Remember-Me认证的用户和完全认证的用户。完全认证的用户是指由系统提供的登录入口进行成功登录认证的用户。<br>&emsp;&emsp;AuthenticatedVoter可以处理的ConfigAttribute有IS_AUTHENTICATED_FULLY、IS_AUTHENTICATED_REMEMBERED和IS_AUTHENTICATED_ANONYMOUSLY。如果ConfigAttribute不在这三者范围之内，则AuthenticatedVoter将弃权。否则将视ConfigAttribute而定，如果ConfigAttribute为IS_AUTHENTICATED_ANONYMOUSLY，则不管用户是匿名的还是已经认证的都将投赞成票；如果是IS_AUTHENTICATED_REMEMBERED则仅当用户是由Remember-Me自动登录，或者是通过登录入口进行登录认证时才会投赞成票，否则将投反对票；而当ConfigAttribute为IS_AUTHENTICATED_FULLY时仅当用户是通过登录入口进行登录的才会投赞成票，否则将投反对票。<br>&emsp;&emsp;AuthenticatedVoter是通过AuthenticationTrustResolver的isAnonymous()方法和isRememberMe()方法来判断SecurityContextHolder持有的Authentication是否为AnonymousAuthenticationToken或RememberMeAuthenticationToken的，即是否为IS_AUTHENTICATED_ANONYMOUSLY和IS_AUTHENTICATED_REMEMBERED。</p>
<p>2.5 自定义Voter<br>当然，用户也可以通过实现AccessDecisionVoter来实现自己的投票逻辑。</p>
<p>三. <strong>调用后的处理</strong><br>&emsp;&emsp;AccessDecisionManager是用来在访问受保护的对象之前判断用户是否拥有访问该对象的权限。有的时候我们可能会希望在请求执行完成后对返回值做一些修改，当然，你可以简单的通过AOP来实现这一功能。Spring Security为我们提供了一个AfterInvocationManager接口，它允许我们在受保护对象访问完成后对返回值进行修改或者进行权限鉴定，看是否需要抛出AccessDeniedException，其将由AbstractSecurityInterceptor的子类进行调用。AfterInvocationManager接口的定义如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AfterInvocationManager</span> </span>&#123;</div><div class="line">  </div><div class="line">    <span class="function">Object <span class="title">decide</span><span class="params">(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; attributes,</span></span></div><div class="line">        Object returnedObject) <span class="keyword">throws</span> AccessDeniedException;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(ConfigAttribute attribute)</span></span>;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以下是Spring Security官方文档提供的一个AfterInvocationManager构造实现的图<br><img src="http://dl2.iteye.com/upload/attachment/0112/0959/e6e5dbeb-68f1-3e21-8cb9-66774e701ded.png" alt="image"></p>
<p>&emsp;&emsp;类似于AuthenticationManager，AfterInvocationManager拥有一个默认的实现类AfterInvocationProviderManager，其中拥有一个由AfterInvocationProvider组成的集合，AfterInvocationProvider与AfterInvocationManager具有相同的方法定义，在调用AfterInvocationProviderManager中的方法时实际上就是依次调用其中包含的AfterInvocationProvider对应的方法。<br>&emsp;&emsp;需要注意的是AfterInvocationManager需要在受保护对象成功被访问后才能执行。</p>
<p>四. <strong>角色的继承</strong><br>&emsp;&emsp;对于角色继承这种需求也是经常有的，比如要求ROLE_ADMIN将拥有所有的ROLE_USER所具有的权限。当然我们可以给拥有ROLE_ADMIN角色的用户同时授予ROLE_USER角色来达到这一效果或者修改需要ROLE_USER进行访问的资源使用ROLE_ADMIN也可以访问。Spring Security为我们提供了一种更为简便的办法，那就是角色的继承，它允许我们的ROLE_ADMIN直接继承ROLE_USER，这样所有ROLE_USER可以访问的资源ROLE_ADMIN也可以访问。定义角色的继承我们需要在ApplicationContext中定义一个RoleHierarchy，然后再把它赋予给一个RoleHierarchyVoter，之后再把该RoleHierarchyVoter加入到我们基于Voter的AccessDecisionManager中，并指定当前使用的AccessDecisionManager为我们自己定义的那个。以下是一个定义角色继承的完整示例。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">   <span class="attr">xmlns:security</span>=<span class="string">"http://www.springframework.org/schema/security"</span></div><div class="line">   <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">          http://www.springframework.org/schema/beans/spring-beans-3.1.xsd</div><div class="line">          http://www.springframework.org/schema/security</div><div class="line">          http://www.springframework.org/schema/security/spring-security-3.1.xsd"&gt;</div><div class="line"> </div><div class="line">   <span class="comment">&lt;!-- 通过access-decision-manager-ref指定将要使用的AccessDecisionManager --&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">security:http</span> <span class="attr">access-decision-manager-ref</span>=<span class="string">"accessDecisionManager"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:form-login</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/admin.jsp"</span> <span class="attr">access</span>=<span class="string">"ROLE_ADMIN"</span> /&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span> /&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div><div class="line"> </div><div class="line">   <span class="tag">&lt;<span class="name">security:authentication-manager</span> <span class="attr">alias</span>=<span class="string">"authenticationManager"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:authentication-provider</span></span></div><div class="line">         <span class="attr">user-service-ref</span>=<span class="string">"userDetailsService"</span>/&gt;</div><div class="line">   <span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line"> </div><div class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDetailsService"</span></span></div><div class="line">      <span class="attr">class</span>=<span class="string">"org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl"</span>&gt;</div><div class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">   <span class="comment">&lt;!-- 自己定义AccessDecisionManager对应的bean --&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accessDecisionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.access.vote.AffirmativeBased"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"decisionVoters"</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"roleVoter"</span>/&gt;</span></div><div class="line">         <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"> </div><div class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"roleVoter"</span></span></div><div class="line">      <span class="attr">class</span>=<span class="string">"org.springframework.security.access.vote.RoleHierarchyVoter"</span>&gt;</div><div class="line">      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"roleHierarchy"</span> /&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"roleHierarchy"</span></span></div><div class="line">      <span class="attr">class</span>=<span class="string">"org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl"</span>&gt;</div><div class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hierarchy"</span>&gt;</span><span class="comment">&lt;!-- 角色继承关系 --&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span></div><div class="line">            ROLE_ADMIN &gt; ROLE_USER</div><div class="line">         <span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"> </div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>在上述配置中我们就定义好了ROLE_ADMIN是继承自ROLE_USER的，这样ROLE_ADMIN将能够访问所有ROLE_USER可以访问的资源。通过RoleHierarchyImpl的hierarchy属性我们可以定义多个角色之间的继承关系，如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"roleHierarchy"</span></span></div><div class="line">      <span class="attr">class</span>=<span class="string">"org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hierarchy"</span>&gt;</span><span class="comment">&lt;!-- 角色继承关系 --&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span></div><div class="line">        ROLE_ADMIN &gt; ROLE_USER</div><div class="line">        ROLE_A &gt; ROLE_B</div><div class="line">        ROLE_B &gt; ROLE_C</div><div class="line">        ROLE_C &gt; ROLE_D</div><div class="line">     <span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>在上述配置我们同时定义了ROLE_ADMIN继承了ROLE_USER，ROLE_A继承了ROLE_B，ROLE_B又继承了ROLE_C，ROLE_C又继承了ROLE_D，这样ROLE_A将能访问ROLE_B、ROLE_C和ROLE_D所能访问的所有资源。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Spring/Security/配置十五：权限鉴定结构/" data-id="cje2lrz51009rpxblnaqa9j9j" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-前端技术相关/forever/nohup node app.js &amp;" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/13/前端技术相关/forever/nohup node app.js &/">nohup node app.js &amp;</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/13/前端技术相关/forever/nohup node app.js &/" class="article-date"><time datetime="2017-08-13T02:09:45.000Z" itemprop="datePublished">2017-08-13</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端技术相关/">前端技术相关</a> / <a class="article-category-link" href="/categories/前端技术相关/forever/">forever</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nohup node app.js &amp;</div></pre></td></tr></table></figure>
      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/13/前端技术相关/forever/nohup node app.js &/" data-id="cje2lrz6w00c9pxbl4lamlqlf" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-服务器相关/resin/resin启动，停止，重启" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/13/服务器相关/resin/resin启动，停止，重启/">resin启动，停止，重启</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/13/服务器相关/resin/resin启动，停止，重启/" class="article-date"><time datetime="2017-08-13T02:09:45.000Z" itemprop="datePublished">2017-08-13</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a> / <a class="article-category-link" href="/categories/服务器相关/resin/">resin</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><p>找到.bash_profile文件，加入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alias resinctl=./Users/xxx/Documents/resin/bin/resinctl</div><div class="line">alias resin=./Users/xxx/Documents/resin/bin/resin.sh</div></pre></td></tr></table></figure></p>
<p>配置别名的好处：不需要进入特定的目录</p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>进到rensin的bin目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">以控制台的方式启动：</div><div class="line">./resinctl console [options]</div><div class="line">./resin console [options]</div><div class="line"></div><div class="line">普通启动:</div><div class="line">./resin.sh start</div><div class="line">./resinctl start</div><div class="line"></div><div class="line">指定配置文件启动：</div><div class="line">./resin.sh -conf ./conf/resin.xml start</div><div class="line"></div><div class="line">启动所有服务：</div><div class="line">./resinctl start-all</div></pre></td></tr></table></figure></p>
<p>别名方式，不需要进入bin目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">以控制台的方式启动：</div><div class="line">resinctl console [options]</div><div class="line">resin console [options]</div><div class="line"></div><div class="line">普通启动:</div><div class="line">resin.sh start</div><div class="line">resinctl start</div><div class="line"></div><div class="line">指定配置文件启动：</div><div class="line">resin.sh -conf ./conf/resin.xml start</div><div class="line"></div><div class="line">启动所有服务：</div><div class="line">resinctl start-all</div></pre></td></tr></table></figure></p>
<h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p>进到bin目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">普通重启：</div><div class="line">./resinctl restart</div><div class="line">./resin restart</div></pre></td></tr></table></figure></p>
<p>别名方式，不需要进入bin目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">resinctl restart</div><div class="line">resin restart</div></pre></td></tr></table></figure></p>
<h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><p>进到bin目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">普通停止：</div><div class="line">./resinctl stop</div><div class="line">./resin stop</div><div class="line">./resinctl shutdown</div><div class="line">./resin shutdown</div></pre></td></tr></table></figure></p>
<p>别名方式，不需要进入bin目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">resinctl stop</div><div class="line">resin stop</div><div class="line">resinctl shutdown</div><div class="line">resin shutdown</div></pre></td></tr></table></figure></p>
<h3 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h3><p>进到bin目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./resinctl status</div><div class="line">./resin status</div></pre></td></tr></table></figure></p>
<p>别名方式，不需要进入bin目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">resinctl status</div><div class="line">resin status</div></pre></td></tr></table></figure></p>
<h3 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h3><p>进到bin目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./resin －help</div></pre></td></tr></table></figure></p>
<p>别名方式，不需要进入bin目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">resin －help</div></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/13/服务器相关/resin/resin启动，停止，重启/" data-id="cje2lrz8x00fcpxbl72jsmhgm" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Spring/基础/AOP事务管理" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/13/Spring/基础/AOP事务管理/">AOP事务管理</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/13/Spring/基础/AOP事务管理/" class="article-date"><time datetime="2017-08-13T02:09:45.000Z" itemprop="datePublished">2017-08-13</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a> / <a class="article-category-link" href="/categories/Spring/基础/">基础</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>注意：service方法中必须能抛出异常，供aop事务捕获，才会进行事务控制，若service方法中捕获了异常，则需要在catch中重新抛出异常</p>
</blockquote>
<h3 id="使用基于注解的AOP事务管理"><a href="#使用基于注解的AOP事务管理" class="headerlink" title="使用基于注解的AOP事务管理"></a>使用基于注解的AOP事务管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; </div><div class="line">&lt;aop:aspectj-autoproxy /&gt;</div></pre></td></tr></table></figure>
<h4 id="tx-annotation-driven标签"><a href="#tx-annotation-driven标签" class="headerlink" title="tx:annotation-driven标签"></a>tx:annotation-driven标签</h4><p><code>&lt;tx:annotation-driven/&gt;</code>标签是注解驱动的事务管理支持的核心。</p>
<p><tx:annotation-driven>标签的属性：</tx:annotation-driven></p>
<ul>
<li>transaction-manager：指定到现有的PlatformTransactionManager bean的引用，通知会使用该引用。default=”transactionManager” </li>
<li>mode：指定Spring事务管理框架创建通知bean的方式。可用的值有proxy和aspectj。前者是默认值，表示通知对象是个JDK代理；后者表示Spring AOP会使用AspectJ创建代理。 </li>
<li>order：指定创建的切面的顺序。只要目标对象有多个通知就可以使用该属性。 </li>
<li>proxy-target-class：该属性如果为true就表示你想要代理目标类而不是bean所实现的所有接口。default=”false” </li>
</ul>
<h4 id="Transactional注解"><a href="#Transactional注解" class="headerlink" title="@Transactional注解"></a>@Transactional注解</h4><p>你可以指定传播、隔离级别、超时以及允许和不允许的异常。<br>@Transactional注解的属性:   </p>
<ul>
<li>propagation：指定事务定义中使用的传播</li>
<li>isolation：设定事务的隔离级别</li>
<li>timeout：指定事务的超时（秒）</li>
<li>readOnly：指定事务是否是只读模式</li>
<li>noRollbackFor：该属性用于设置不需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，不进行事务回滚</li>
<li>rollbackFor：异常所构成的数组，如果目标方法抛出了这些异常，就会通知回滚事务</li>
</ul>
<p>注意的几点: </p>
<ol>
<li>@Transactional 只能被应用到public方法上, 对于其它非public的方法,如果标记了@Transactional也不会报错,但方法没有事务功能.</li>
</ol>
<p>2 用 spring 事务管理器,由spring来负责数据库的打开,提交,回滚.默认遇到运行时异常(RuntimeException)会回滚，即遇到不受检查（unchecked）的异常时回滚；而遇到需要捕获的异常不会回滚,即遇到受检查的异常（就是非运行时抛出的异常，编译器会检查到的异常叫受检查例外或说受检查异常）时，需我们指定方式来让事务回滚 要想所有异常都回滚,要加上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@Transactional( rollbackFor=&#123;Exception.class,其它异常&#125;)</div></pre></td></tr></table></figure></p>
<p>如果让unchecked例外不回滚：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@Transactional(notRollbackFor=RunTimeException.class)</div></pre></td></tr></table></figure></p>
<ol>
<li><p>@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。然而，请注意仅仅 @Transactional 注解的出现不足于开启事务行为，它仅仅 是一种元数据，能够被可以识别 @Transactional 注解和上述的配置适当的具有事务行为的beans所使用。上面的例子中，其实正是 <code>&lt;tx:annotation-driven/&gt;</code>元素的出现开启了事务行为。</p>
</li>
<li><p>Spring团队的建议是你在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。你当然可以在接口上使用 @Transactional 注解，但是这将只能当你设置了基于接口的代理时它才生效。因为注解是不能继承的，这就意味着如果你正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装（将被确认为严重的）。因 此，请接受Spring团队的建议并且在具体的类上使用 @Transactional 注解。 </p>
</li>
</ol>
<h3 id="使用XML-AOP事务管理"><a href="#使用XML-AOP事务管理" class="headerlink" title="使用XML AOP事务管理"></a>使用XML AOP事务管理</h3><p><tx:advice>标签，该标签会创建一个事务处理通知<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; </div><div class="line">    &lt;tx:attributes&gt; </div><div class="line">        &lt;tx:method name=&quot;bulk*&quot; propagation=&quot;REQUIRED&quot; isolation=&quot;DEFAULT&quot; /&gt; </div><div class="line">        &lt;tx:method name=&quot;load*&quot; propagation=&quot;REQUIRED&quot; isolation=&quot;DEFAULT&quot; read-only=&quot;true&quot;/&gt; </div><div class="line">    &lt;/tx:attributes&gt; </div><div class="line">&lt;/tx:advice&gt; </div><div class="line">&lt;aop:config&gt; </div><div class="line">    &lt;aop:advisor pointcut=&quot;execution(* *..*Service*.*(..))&quot; advice-ref=&quot;txAdvice&quot; /&gt; </div><div class="line">&lt;/aop:config&gt; </div><div class="line"> </div><div class="line">或 </div><div class="line"> </div><div class="line">&lt;tx:advice id=&quot;defaultTransactionAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; </div><div class="line">    &lt;tx:attributes&gt; </div><div class="line">        &lt;tx:method name=&quot;*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; no-rollback-for=&quot;java.lang.RuntimeException&quot; timeout=&quot;100&quot;/&gt;</div><div class="line">    &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;</div><div class="line">    &lt;/tx:attributes&gt; </div><div class="line">&lt;/tx:advice&gt; </div><div class="line"> </div><div class="line">&lt;aop:config&gt; </div><div class="line">    &lt;aop:pointcut id=&quot;allServiceMethods&quot; </div><div class="line">    expression=&quot;execution(* com.apress.prospring2.ch16.services.*.*(..))&quot;/&gt; </div><div class="line">    &lt;aop:advisor advice-ref=&quot;defaultTransactionAdvice&quot; </div><div class="line">        pointcut-ref=&quot;allServiceMethods&quot;/&gt; </div><div class="line">&lt;/aop:config&gt;</div></pre></td></tr></table></figure></tx:advice></p>
<h4 id="tx-advice标签简介"><a href="#tx-advice标签简介" class="headerlink" title="tx:advice标签简介"></a>tx:advice标签简介</h4><p>id是该advice bean的标识，而transaction-manager则必须引用一个PlatformTransactionManager bean。  </p>
<p>还可以通过<tx:attributes>标签定制<tx:advice>标签所创建的通知的行为。</tx:advice></tx:attributes></p>
<p><tx:method>标签的属性：    </tx:method></p>
<ul>
<li>name：方法名的匹配模式，通知根据该模式寻找匹配的方法。</li>
<li>propagation：设定事务定义所用的传播级别。</li>
<li>isolation：设置事务的隔离级别。</li>
<li>timeout：指定事务的超时（秒）。</li>
<li>read-only：该属性为true指示事务是只读的</li>
<li>no-rollback-for：以逗号分隔的异常类的列表，目标方法可以跑出这些异常而不会导致通知执行回滚</li>
<li>rollback-for：以逗号分隔的异常类的列表，当目标方法跑出这些异常时会导致通知执行回滚。默认情况下，该列表为空，因此不在no-rollback-for列表中的任何运行时异常都会导致回滚。</li>
</ul>
<h4 id="中isolation（隔离）和propagation（传播）参数的含义"><a href="#中isolation（隔离）和propagation（传播）参数的含义" class="headerlink" title="中isolation（隔离）和propagation（传播）参数的含义"></a><tx:method>中isolation（隔离）和propagation（传播）参数的含义</tx:method></h4><p>事务隔离级别：</p>
<ol>
<li><p><strong>@Transactional(isolation=Isolation.DEFAULT)</strong>     使用数据库默认的隔离级别（对大多数数据库来说就是@Transactional(isolation = Isolation.REPEATABLE_READ)）</p>
</li>
<li><p><strong>@Transactional(isolation = Isolation.READ_UNCOMMITTED)：读未提交</strong>    最低的隔离级别,会出现脏读, 不可重复读，幻读的情况。事实上我们不推荐该隔离级别，因为在事务完成前，其他事务可以看到该事务所修改的数据。而在其他事务提交前，该事务也可以看到其他事务所做的修改。</p>
</li>
<li><p><strong>@Transactional(isolation = Isolation.READ_COMMITTED)：读已提交</strong><br>会出现不可重复读，幻读的情况。在事务完成前，其他事务无法看到该事务所修改的数据。遗憾的是，在该事务提交后，你就可以查看其他事务插入或更新的数据。这意味着在事务的不同点上，如果其他事务修改数据，你会看到不同的数据。</p>
</li>
<li><p><strong>@Transactional(isolation = Isolation.REPEATABLE_READ)：可重复读</strong>      大多数数据库的默认级别，如Mysql。会出现幻读的情况。该隔离级别确保如果在事务中查询了某个数据集，你至少还能再次查询到相同的数据集，即使其他事务修改了所查询的数据。然而如果其他事务插入了新数据，你就可以查询到该新插入的数据。 </p>
</li>
<li><p><strong>@Transactional(isolation = Isolation.SERIALIZABLE)：串行化</strong>    代价最大、可靠性最高的隔离级别，所有的事务都是按顺序一个接一个的执行。</p>
</li>
</ol>
<p>传播行为指：</p>
<ol>
<li><p><strong>PROPAGATION_REQUIRED</strong>  当前如果有事务，Spring就会使用该事务；否则会开始一个新事务。</p>
</li>
<li><p><strong>PROPAGATION_SUPPORTS</strong>  当前如果有事务，Spring就会使用该事务；否则不会开启一个新事务。</p>
</li>
<li><p><strong>PROPAGATION_MANDATORY</strong>     当前如果有事务，Spring就会使用该事务；否则会抛出异常。</p>
</li>
<li><p><strong>PROPAGATION_REQUIRES_NEW</strong>  Spring总会开始一个新事务。如果当前有事务，则该事务挂起。</p>
</li>
<li><p><strong>PROPAGATION_NOT_SUPPORTED</strong>     Spring不会执行事务中的代码。代码总是在非事务环境下执行，如果当期有事务，则该事务挂起。</p>
</li>
<li><p><strong>PROPAGATION_NEVER</strong>     即使当前有事务，Spring也会在非事务环境下执行。如果当前有事务，则抛出异常。</p>
</li>
<li><p><strong>PROPAGATION_NESTED</strong>    如果当前有事务，则在嵌套事务中执行。如果没有，那么执行情况与PROPAGATION_REQUIRED一样。</p>
</li>
</ol>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/13/Spring/基础/AOP事务管理/" data-id="cje2lrz6r00bxpxblc1ia98ru" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Spring/基础/Bean注入：Autowired和Resource" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/13/Spring/基础/Bean注入：Autowired和Resource/">Bean注入：Autowired和Resource</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/13/Spring/基础/Bean注入：Autowired和Resource/" class="article-date"><time datetime="2017-08-13T02:09:45.000Z" itemprop="datePublished">2017-08-13</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a> / <a class="article-category-link" href="/categories/Spring/基础/">基础</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入；</li>
<li>@Autowired默认是按照类型装配注入的，如果想按照名称来转配注入，则需要结合@Qualifier一起使用；</li>
<li>@Resource注解是由J2EE提供，而@Autowired是由Spring提供，故减少系统对spring的依赖建议使用@Resource的方式；</li>
<li>@Resource和@Autowired都可以书写标注在字段或者该字段的setter方法之上</li>
</ol>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/13/Spring/基础/Bean注入：Autowired和Resource/" data-id="cje2lrz6r00bzpxblto8kjqef" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Spring/基础/Spring  Bean的scope作用域" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/13/Spring/基础/Spring  Bean的scope作用域/">Spring  Bean的scope作用域</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/13/Spring/基础/Spring  Bean的scope作用域/" class="article-date"><time datetime="2017-08-13T02:09:45.000Z" itemprop="datePublished">2017-08-13</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a> / <a class="article-category-link" href="/categories/Spring/基础/">基础</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>在SSH中一般来说Dao Service为singleton，Action为prototype</p>
</blockquote>
<h3 id="spring-Framework支持五种作用域（其中有三种只能用在基于web的Spring-ApplicationContext"><a href="#spring-Framework支持五种作用域（其中有三种只能用在基于web的Spring-ApplicationContext" class="headerlink" title="spring Framework支持五种作用域（其中有三种只能用在基于web的Spring ApplicationContext"></a>spring Framework支持五种作用域（其中有三种只能用在基于web的Spring ApplicationContext</h3><p>内置支持的作用域分列如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>singleton(默认)</td>
<td>在每个Spring IoC容器中一个bean定义对应一个对象实例。</td>
</tr>
<tr>
<td>prototype</td>
<td>一个bean定义对应多个对象实例。</td>
</tr>
<tr>
<td>request</td>
<td>在一次HTTP请求中，一个bean定义对应一个实例；即每次HTTP请求将会有各自的bean实例， 它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext 情形下有效。</td>
</tr>
<tr>
<td>session</td>
<td>在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的SpringApplicationContext 情形下有效。</td>
</tr>
<tr>
<td>global session</td>
<td>在一个全局的HTTP Session 中，一个bean定义对应一个实例。典型情况下，仅在使用portlet context的时候有效。该作用域仅在基于web的Spring ApplicationContext 情形下有效。</td>
</tr>
</tbody>
</table>
<ol>
<li>Singleton作用域<br>当一个bean的作用域为singleton, 那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。换言之，当把一个bean定义设置为singlton作用域时，Spring IoC容器只会创建该bean定义的唯一实例。这个单一实例会被存储到单例缓存（singleton cache）中，并且所有针对该bean的后续请求和引用都将返回被缓存的对象实例。<br><img src="http://note.youdao.com/yws/public/resource/e8ccc8ff6b52067fb6cb7822f7b5ab50/AFC196873FBC470D9E57DEDE8973D262" alt="image"><br>请注意Spring的singleton bean概念与GoF模式一书中定义的Singleton模式是完全不同的。经典的GoF Singleton模式中所谓的对象范围是指在每一个ClassLoader中指定class创建的实例有且仅有一个。把Spring的singleton作用域描述成一个Container (容器)对应一个bean实例最为贴切。也就是说假如在单个Spring容器内定义了某个指定class的bean，那么Spring容器将会创建一个并且仅有一个由该bean定义指定的类实例。Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;accountService&quot; class=&quot;com.foo.DefaultAccountService&quot;/&gt; </div><div class="line"> </div><div class="line">&lt;!-- the following is equivalent, though redundant (singleton scope is the default); using spring-beans-2.0.dtd or upper--&gt; </div><div class="line">&lt;bean id=&quot;accountService&quot; class=&quot;com.foo.DefaultAccountService&quot; scope=&quot;singleton&quot;/&gt; </div><div class="line"> </div><div class="line">&lt;!-- the following is equivalent  and preserved for backward compatibility in spring-beans.dtd--&gt; </div><div class="line">&lt;bean id=&quot;accountService&quot; class=&quot;com.foo.DefaultAccountService&quot; singleton=&quot;true&quot;/&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>beans.xml配置文件中配置如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;personService&quot; class=&quot;examples.test.PersonServiceBean&quot; &gt;&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>测试代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class SpringTest &#123; </div><div class="line"> </div><div class="line">    @Test </div><div class="line">    public void instanceSpring()&#123; </div><div class="line">        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); </div><div class="line">        PersonService personService1 = (PersonService)ctx.getBean(&quot;personService&quot;); </div><div class="line">        PersonService personService2 = (PersonService)ctx.getBean(&quot;personService&quot;); </div><div class="line">        System.out.println(personService1==personService2); </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行测试程序，结果输出为: true.说明是只创建了一个PersonServiceBean.</p>
<ol>
<li>Prototype作用域<br>Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean() 方法）时都会创建一个新的bean实例 。根据经验，<strong>对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域</strong>。 </li>
</ol>
<p>下图演示了Spring的prototype作用域。请注意，通常情况下，DAO不会被配置成prototype，因为DAO通常不会持有任何会话状态，因此应该使用singleton作用域。<br><img src="http://note.youdao.com/yws/public/resource/e8ccc8ff6b52067fb6cb7822f7b5ab50/421AD7A31E2E48B4BE1CAE58E7A681D4" alt="image"><br>在XML中将bean定义成prototype，可以这样配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!-- using spring-beans-2.0.dtd or upper --&gt; </div><div class="line">&lt;bean id=&quot;accountService&quot; class=&quot;com.foo.DefaultAccountService&quot; scope=&quot;prototype&quot;/&gt; </div><div class="line">&lt;!-- the following is equivalent and preserved for backward compatibility in spring-beans.dtd --&gt; </div><div class="line">&lt;bean id=&quot;accountService&quot; class=&quot;com.foo.DefaultAccountService&quot; singleton=&quot;false&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>将beans.xml配置文件中的配置信息改为如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;personService&quot; class=&quot;cn.itcast.service.impl.PersonServiceBean&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>再运行上面的测试程序，输出结果为:false，说明创建了两个PersonServiceBean.</p>
<p><strong>其他作用域，即request、session以及global session 仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架）。这些作用域仅仅在使用基于web的Spring ApplicationContext实现（如XmlWebApplicationContext）时有用。 如果在普通的Spring IoC容器中，比如像XmlBeanFactory或ClassPathXmlApplicationContext， 尝试使用这些作用域，你将会得到一个IllegalStateException异常（未知的bean作用域）。</strong></p>
<h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><h4 id="什么时候初始化bean实例"><a href="#什么时候初始化bean实例" class="headerlink" title="什么时候初始化bean实例"></a>什么时候初始化bean实例</h4><p><strong>当scope＝singleton，即默认情况，会在容器初始化时实例化。但我们可以指定Bean节点的lazy-init=”true”来延迟初始化bean,这时候，只有第一次获取bean才会初始化bean，即第一次请求该bean时才初始化</strong>。如下配置所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=”xxx” class=”examples.test.OrderServiceBean” lazy-init=”true” /&gt;</div></pre></td></tr></table></figure></p>
<p>如果想对所有bean都应用延迟初始化，可以在根节点beans设置default-lazy-init=”true”,如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;beans default-lazy-init=”true” …&gt;</div></pre></td></tr></table></figure></p>
<p><strong>当scope=prototype时，也会延迟初始化bean,即第一次请求该bean时才初始化(如调用getBean()方法时).</strong></p>
<h5 id="测试如下："><a href="#测试如下：" class="headerlink" title="测试如下："></a>测试如下：</h5><p>PersonServiceBean代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class PersonServiceBean implements PersonService &#123; </div><div class="line">    public void init()&#123; </div><div class="line">        System.out.println(&quot;Get the database connection and initialize other beans!&quot;); </div><div class="line">    &#125; </div><div class="line">    </div><div class="line">    public PersonServiceBean()&#123; </div><div class="line">        System.out.println(&quot;PersonServiceBean is initialized!&quot;); </div><div class="line">    &#125; </div><div class="line">    </div><div class="line">    public void destroy()&#123; </div><div class="line">        System.out.println(&quot;close the database connection!&quot;); </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>beans.xml配置文件如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;personService&quot; class=&quot;examples.test.PersonServiceBean&quot; /&gt; &lt;!-- 1 --&gt; </div><div class="line">&lt;bean id=&quot;personService&quot; class=&quot;examples.test.PersonServiceBean&quot;  scope=&quot;singleton&quot; /&gt; &lt;!-- 2 --&gt;</div></pre></td></tr></table></figure></p>
<p>测试程序如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class SpringTest &#123; </div><div class="line">    @Test </div><div class="line">    public void instanceSpring()&#123; </div><div class="line">        ApplicationContext ctx =  new  ClassPathXmlApplicationContext(&quot;beans.xml&quot;); </div><div class="line">        System.out.println(&quot;------------------&quot;); </div><div class="line">        PersonService personService = (PersonServiceBean)ctx.getBean(&quot;personService&quot;); </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>分1，2两种情况运行程序，控制台打印信息如下所示：<br>PersonServiceBean is initialized!<br>-—————–      </p>
<p>将配置文件修改成如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;personService&quot; class=&quot;examples.test.PersonServiceBean&quot; lazy-init=&quot;true&quot; /&gt; &lt;!-- 1 --&gt; </div><div class="line">&lt;bean id=&quot;personService&quot; class=&quot;examples.test.PersonServiceBean&quot; scope=&quot;prototype&quot; /&gt; &lt;!-- 2 --&gt;</div></pre></td></tr></table></figure></p>
<p>分1，2两种情况运行程序，控制台打印信息如下所示:<br>-—————–<br>PersonServiceBean is initialized!<br>​<br>以上测试说明：<br>Bean默认是在容器初始化时初始化的，即<br>ApplicationContext ctx = new ClassPathXmlApplicationContext(“beans.xml”);语句执行时就实例化bean了。如果把scope设成scope=”prototype” 或设置lazy-init=”true”，则会延迟bean的实例化，bean会在PersonService personService = (PersonServiceBean)ctx.getBean(“personService”);语句执行时才实例化。<br>当配置文件为如下所示时，测试结果同上。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>构造器、init方法、获取bean后的操作、destroy方法（ctx.close时执行）<br><strong>注意:如果bean的scope设为prototype时，当ctx.close时，destroy方法不会被调用.</strong>   </p>
<p>原因：对于prototype作用域的bean，有一点非常重要，那就是Spring不能对一个prototype bean的整个生命周期负责：容器在初始化、配置、装饰或者是装配完一个prototype实例后，将它交给客户端，随后就对该prototype实例不闻不问了。不管何种作用域，容器都会调用所有对象的初始化生命周期回调方法。但对prototype而言，任何配置好的析构生命周期回调方法都将不会被调用。清除prototype作用域的对象并释放任何prototype bean所持有的昂贵资源，都是客户端代码的职责。（让Spring容器释放被prototype作用域bean占用资源的一种可行方式是，通过使用bean的后置处理器，该处理器持有要被清除的bean的引用。）    </p>
<p><strong>谈及prototype作用域的bean时，在某些方面你可以将Spring容器的角色看作是Java new 操作的替代者。任何迟于该时间点的生命周期事宜都得交由客户端来处理</strong>。</p>
<p>配置文件信息如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;personService&quot; class=&quot;cn.itcast.service.impl.PersonServiceBean&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>测试程序如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class SpringTest &#123; </div><div class="line">    @Test </div><div class="line">    public void instanceSpring()&#123; </div><div class="line">        AbstractApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); </div><div class="line">        System.out.println(&quot;------------------&quot;); </div><div class="line">        PersonService personService = (PersonServiceBean)ctx.getBean(&quot;personService&quot;); </div><div class="line">        ctx.close(); </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行测试程序，控制台打印信息如下所示：<br>PersonServiceBean is initialized!<br>Get the database connection and initialize other beans!<br>-—————–<br>close the database connection!  </p>
<p>修改配置文件信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;personService&quot; class=&quot;cn.itcast.service.impl.PersonServiceBean&quot; scope=&quot;prototype&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>再次运行测试程序，控制台打印信息如下所示：<br>-—————–<br>PersonServiceBean is initialized!<br>Get the database connection and initialize other beans! </p>
<p>修改配置文件信息如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;personService&quot; class=&quot;cn.itcast.service.impl.PersonServiceBean&quot; lazy-init=&quot;true&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>此时再次运行测试程序，控制台打印信息如下所示：<br>-—————–<br>PersonServiceBean is initialized!<br>Get the database connection and initialize other beans!<br>close the database connection!  </p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/13/Spring/基础/Spring  Bean的scope作用域/" data-id="cje2lrz6s00c2pxbl26g5zfcr" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-前端技术相关/forever/使用forever后台运行node.js" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/13/前端技术相关/forever/使用forever后台运行node.js/">使用forever后台运行node.js</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/08/13/前端技术相关/forever/使用forever后台运行node.js/" class="article-date"><time datetime="2017-08-13T02:09:45.000Z" itemprop="datePublished">2017-08-13</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端技术相关/">前端技术相关</a> / <a class="article-category-link" href="/categories/前端技术相关/forever/">forever</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>forever能做更多的事情，比如分别记录输出和错误日志，宕机重启，热部署。比如可以在js中作为api使用</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install forever -g</div></pre></td></tr></table></figure>
<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service forever start</div></pre></td></tr></table></figure>
<h2 id="使用forever启动js文件"><a href="#使用forever启动js文件" class="headerlink" title="使用forever启动js文件"></a>使用forever启动js文件</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">forever start app.js</div></pre></td></tr></table></figure>
<h2 id="停止js文件"><a href="#停止js文件" class="headerlink" title="停止js文件"></a>停止js文件</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">forever stop app.js</div></pre></td></tr></table></figure>
<h2 id="启动js文件并输出日志文件"><a href="#启动js文件并输出日志文件" class="headerlink" title="启动js文件并输出日志文件"></a>启动js文件并输出日志文件</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">forever start -l forever.log -o out.log -e err.log app.js</div></pre></td></tr></table></figure>
<h2 id="重启js文件"><a href="#重启js文件" class="headerlink" title="重启js文件"></a>重启js文件</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">forever restart app.js</div></pre></td></tr></table></figure>
<h2 id="查看正在运行的进程"><a href="#查看正在运行的进程" class="headerlink" title="查看正在运行的进程"></a>查看正在运行的进程</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">forever list</div></pre></td></tr></table></figure>
      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/13/前端技术相关/forever/使用forever后台运行node.js/" data-id="cje2lrz6z00ccpxblxmfksvn7" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/page/7/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/6/">6</a></li><li><a class="page-number" href="/page/7/">7</a></li><li class="active"><span class="page-number">8</span></li><li><a class="page-number" href="/page/9/">9</a></li><li><a class="page-number" href="/page/10/">10</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/24/">24</a></li><li><a class="page-next" rel="next" href="/page/9/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-module-inset">
  <h4>关于</h4>
  <p>该博客内的文章是博主在日常工作或者学习中总结出来，部分内容来自网络.</p>

</div>


  
  <div class="sidebar-module">
    <h4>分类</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Eclipse/">Eclipse</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Github/">Github</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/">Java</a><span class="sidebar-module-list-count">84</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/Cookie/">Cookie</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/JAXB/">JAXB</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/JavaMail/">JavaMail</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/分布式/">分布式</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/基础/">基础</a><span class="sidebar-module-list-count">21</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/数据类型/">数据类型</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/日记/">日记</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/时间日期/">时间日期</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/线程/">线程</a><span class="sidebar-module-list-count">17</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/网络NIO/">网络NIO</a><span class="sidebar-module-list-count">12</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/队列/">队列</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/集合/">集合</a><span class="sidebar-module-list-count">8</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Linux/">Linux</a><span class="sidebar-module-list-count">17</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Maven/">Maven</a><span class="sidebar-module-list-count">9</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/">Spring</a><span class="sidebar-module-list-count">60</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Application-Event/">Application Event</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/JPA/">JPA</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Security/">Security</a><span class="sidebar-module-list-count">22</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Spring-Boot/">Spring Boot</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Spring-Session/">Spring Session</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Task/">Task</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/spring-MVC/">spring MVC</a><span class="sidebar-module-list-count">17</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/spring-data-redis/">spring data redis</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/基础/">基础</a><span class="sidebar-module-list-count">5</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/前端技术相关/">前端技术相关</a><span class="sidebar-module-list-count">3</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/前端技术相关/forever/">forever</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/前端技术相关/javascript/">javascript</a><span class="sidebar-module-list-count">1</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/数据库相关/">数据库相关</a><span class="sidebar-module-list-count">20</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/数据库相关/mysql/">mysql</a><span class="sidebar-module-list-count">20</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/">服务器相关</a><span class="sidebar-module-list-count">29</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Hessian/">Hessian</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Hudson-Jenkins/">Hudson & Jenkins</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Memcached/">Memcached</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Nginx/">Nginx</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Tomcat/">Tomcat</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/red5/">red5</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/redis/">redis</a><span class="sidebar-module-list-count">13</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/resin/">resin</a><span class="sidebar-module-list-count">3</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/网络/">网络</a><span class="sidebar-module-list-count">9</span></li></ul>
  </div>



  


  

  
  <div class="sidebar-module">
    <h4>归档</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">二月 2018</a><span class="sidebar-module-list-count">45</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">十月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">62</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">125</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/02/">二月 2017</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>最近文章</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/2018/02/25/Java/基础/java8新特性/">java8新特性</a>
        </li>
      
        <li>
          <a href="/2018/02/25/Java/集合/HashSet原理/">HashSet原理</a>
        </li>
      
        <li>
          <a href="/2018/02/25/Java/分布式/分布式锁/">分布式锁</a>
        </li>
      
        <li>
          <a href="/2018/02/25/Java/集合/在List循环中删除元素/">在List循环中删除元素</a>
        </li>
      
        <li>
          <a href="/2018/02/25/Java/集合/Hashtable与ConcurrentHashMap区别/">Hashtable与ConcurrentHashMap区别</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2018 LeoChan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>



<script src="/js/script.js"></script>

</body>
</html>
