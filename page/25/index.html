<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LeoChan&#39;s 个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="描述啊">
<meta property="og:type" content="website">
<meta property="og:title" content="LeoChan&#39;s 个人博客">
<meta property="og:url" content="https://clq2owesome.github.io/page/25/index.html">
<meta property="og:site_name" content="LeoChan&#39;s 个人博客">
<meta property="og:description" content="描述啊">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeoChan&#39;s 个人博客">
<meta name="twitter:description" content="描述啊">
  
    <link rel="alternate" href="/atom.xml" title="LeoChan&#39;s 个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LeoChan&#39;s 个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术都是通用的，重要的是是否具有自主解决问题的能力！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://clq2owesome.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Java/线程/线程安全基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/25/Java/线程/线程安全基础/" class="article-date">
  <time datetime="2017-02-25T02:09:45.000Z" itemprop="datePublished">2017-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/线程/">线程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/25/Java/线程/线程安全基础/">线程安全基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是线程安全性"><a href="#什么是线程安全性" class="headerlink" title="什么是线程安全性"></a>什么是线程安全性</h3><p>当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。</p>
<p><strong>无状态对象一定是线程安全的</strong>。</p>
<p>竞态条件（Race Condition）：在并发编程中，这种由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况。<br>要避免竞态条件问题，就必须在某个线程改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中。</p>
<p>原子操作：假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么B全部执行完成，要么完全不执行B，那么A和B对彼此来说是原子的。原子操作是指，对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。</p>
<h4 id="内置锁"><a href="#内置锁" class="headerlink" title="内置锁"></a>内置锁</h4><p>每个Java对象都可以用做一个实现同步的锁，这些锁被称为<strong>内置锁</strong>（Intrinsic Lock）或监视器锁（Monitor Lock）。线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁，而无论时通过正常的控制路径退出，还是通过从代码块中抛出异常退出。<strong>获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法</strong>。</p>
<p><strong>内置锁是可重入的</strong>，重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块或方法时，计数器会相应地递减。当计数值为0时，这个锁将被释放。</p>
<h4 id="发布与逸出"><a href="#发布与逸出" class="headerlink" title="发布与逸出"></a>发布与逸出</h4><p><strong>发布</strong>（Publish）一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。例如，将一个指向该对象的引用保存到其他代码可以访问的地方，或者在某一个非私有的方法中返回该引用，或者将引用传递到其他类的方法中。</p>
<p>当某个不应该发布的对象被发布时，这种情况就被称为<strong>逸出</strong>（Escape）。</p>
<p>使用封装的最主要原因：封装能够使得对程序的正确性进行分析变得可能，并使得无意中破坏设计约束条件变得更难。</p>
<h4 id="安全的对象构造过程"><a href="#安全的对象构造过程" class="headerlink" title="安全的对象构造过程"></a>安全的对象构造过程</h4><p><strong>当且仅当对象构造函数返回时，对象才处于可预测的和一致的状态</strong>。因此，当从对象的构造函数中发布对象时，只是发布了一个尚未构造完成的对象。即使发布对象的语句位于构造函数的最后一行也是如此。如果this引用在构造过程中逸出，那么这种对象就被认为是不正确构造。</p>
<p><strong>不要在构造过程中使用this引用逸出</strong>。</p>
<h4 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h4><p>一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步，这种技术被称为线程封闭（Thread Confinement），它是实现线程安全性的最简单方式之一。当某个对象封闭在一个线程中时，这种用法将自动实现线程安全性，即使被封闭的对象本身不是线程安全的。</p>
<p>线程封闭技术的另一种常见应用是JDBC的Connectuin对象。在典型的服务器应用程序中，线程从连接池中获得一个Connection对象，并且用该对象来处理请求，使用完后再将对象返还给连接池。由于大多数请求都是由单个线程采用同步的方式来处理，并且在Connection对象返回之前，连接池不会再将它分配给其他线程，因此，这种连接关联模式在处理请求时隐含地将Connection对象封闭在线程中。</p>
<p>Java语言及其核心库提供了一些机制来帮助线程封闭性，例如局部变量和ThreadLocal类。</p>
<h4 id="栈封闭"><a href="#栈封闭" class="headerlink" title="栈封闭"></a>栈封闭</h4><p>栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。正如封装能使得代码更容易维持不变性条件那样，同步变量也能使对象更易于封闭在线程中。<strong>局部变量的固有属性之一就是封闭在执行线程中</strong>。</p>
<h4 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h4><p>ThreadLocal对象通常用于防止对可变的单实例（Single）或全局变量进行共享。</p>
<h4 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h4><p>如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为<strong>不可变对象</strong>。线程安全性是不可变对象的固有属性之一，它们的不变性条件是由构造函数创建的，只要它们的状态不改变，那么这些不变性条件就能得以维持。</p>
<p>不可变对象一定是线程安全的。</p>
<p>不可变性并不等于将对象中所有的域都声明为final类型，即使对象中所有的域都是final类型的，这个对象也仍然是可变的，因为在final类型的域中可以保存对可变对象的引用。</p>
<p>当满足以下条件时，对象才是不可变的：</p>
<ul>
<li>对象创建以后其状态就不能修改</li>
<li>对象的所有域都是final类型</li>
<li>对象是正确创建的（在对象的创建期间，this引用没有逸出）</li>
</ul>
<h4 id="Final域"><a href="#Final域" class="headerlink" title="Final域"></a>Final域</h4><p>final类型的域是不能修改的（但如果final域所引用的对象是可变的，那么这些被引用的对象是可以修改的）。然而，在Java内存模型中，final域还有着特殊的语义，final域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无须同步。</p>
<p>对于在访问和更新多个相关变量时出现的竞争条件问题，可以通过将这些变量全部保存在一个不可变对象来消除。</p>
<p>通过使用包含多个状态变量的容器对象来维持不变性条件，并使用一个volatile类型的引用来确保可见性，使得在没有显式地使用锁的情况下仍然式线程安全的。</p>
<h4 id="安全发布"><a href="#安全发布" class="headerlink" title="安全发布"></a>安全发布</h4><p>要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布：</p>
<ul>
<li>在静态初始化函数中初始化一个对象引用</li>
<li>将对象的引用保存到volatile类型的域或者AtomicReferance对象中</li>
<li>将对象的引用保存到某个正确构造对象的final类型域中</li>
<li>将对象的引用保存到一个由锁保护的域中</li>
</ul>
<p>线程安全库中的容器类提供了以下的安全发布保证：</p>
<ul>
<li>通过将一个键或者值放入HashTable，SynchronizedMap，ConcurrentMap中，可以安全地将它发布给任何从这些容器中访问它的线程</li>
<li>通过将某个元素放入Vector，CopyOnWriteArrayList，CopyOnWriteArraySet，SynchronizedList，SynchronizedSet中，可以将该元素安全地发布到任何从这些容器中访问该元素的线程</li>
<li>通过将某个元素放入BlockQueue，ConcurrentLinkedQueue中，可以将该元素安全地发布到任何从这些队列中访问该元素的线程</li>
</ul>
<p>通常，要发布一个静态构造的对象，最简单和最安全的方式是使用静态的初始化器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static Holder holder = new Holder(11);</div></pre></td></tr></table></figure></p>
<p>静态初始化器由JVM在类的初始化阶段执行。由于在JVM内存存在着同步机制，因此通过这种方式初始化的任何对象都可以被安全地发布。</p>
<h4 id="事实不可变对象"><a href="#事实不可变对象" class="headerlink" title="事实不可变对象"></a>事实不可变对象</h4><p>如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么把这种对象称为“事实不可变对象”（Effectively Immutable Object）。</p>
<p>在没有额外的同步的情况下，任何线程都可以安全使用被安全发布的事实不可变对象。</p>
<h4 id="可变对象"><a href="#可变对象" class="headerlink" title="可变对象"></a>可变对象</h4><p>如果对象在构造后可以修改，那么安全发布只能确保“发布当时”状态的可见性。对于可变对象，不仅在发布对象时需要使用同步，而且在每次对象访问时同样需要使用同步来确保后续修改操作的可见性。要安全地共享可变对象，这些对象就必须被安全地发布，并且必须是线程安全的或者由某个锁保护起来。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：</p>
<ul>
<li><strong>线程封闭</strong>：线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。</li>
<li><strong>只读共享</strong>：在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。</li>
<li><strong>线程安全共享</strong>：线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步同步。</li>
<li><strong>保护对象</strong>：被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。</li>
</ul>
<h3 id="对象组合"><a href="#对象组合" class="headerlink" title="对象组合"></a>对象组合</h3><h4 id="设计线程安全的类"><a href="#设计线程安全的类" class="headerlink" title="设计线程安全的类"></a>设计线程安全的类</h4><p>在设计线程安全类的过程中，需要包含以下三个基本要素：</p>
<ul>
<li>找出构成对象状态的所有变量</li>
<li>找出约束状态变量的不变性条件</li>
<li>建立对象状态的并发访问管理策略</li>
</ul>
<h4 id="实例封闭"><a href="#实例封闭" class="headerlink" title="实例封闭"></a>实例封闭</h4><p>封装简化了线程安全类的实现过程，它提供了一种<strong>实例封闭机制</strong>（Instance  Confinement），通常也简称为<strong>封闭</strong>。当一个对象被封装到另一个对象中时，能够访问被封装对象的所有代码路径都是已知的。与对象可以由整个程序访问的情况相比，更易于对代码进行分析。通过将封闭机制与合适的加锁策略结合起来，可以确保以线程安全的方式来使用非线程安全的对象。</p>
<p>被封闭对象一定不能超出它们既定的作用域。对象可以封闭在类的一个实例（例如作为类的一个私有成员）中，或者封闭在某个作用域内（例如作为一个局部变量），再或者封闭在线程内（例如在某个线程中将对象从一个方法传递到另一个方法，而不是在多个线程之间共享该对象）。</p>
<p>通过封闭机制来确保线程安全：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@ThreadSafe</div><div class="line">public class PersionSet &#123;</div><div class="line">    @GuardedBy(&quot;this&quot;)</div><div class="line">    public final Set&lt;Person&gt; mySet = new HashSet&lt;Person&gt;();</div><div class="line">    </div><div class="line">    public synchronized void addPerson(Person p) &#123;</div><div class="line">        mySet.add(p);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public synchronized boolean containsPerson(Person p) &#123;</div><div class="line">        return mySet.contains(p);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个示例并未对Person的线程安全性做任何假设，但如果Person类是可变的，那么在访问从PersonSet中获得的Person对象时，还需要额外的同步。要想安全地使用Person对象，最可靠的方法就是使Person成为一个线程安全的类。另外，也可以使用锁来保护Person对象并确保所有客户代码在访问Person对象之前都已经获得正确的锁。</p>
<p>示例封闭是构建线程安全类的一个最简单的方式，它使得在锁策略的选择上拥有了更多的灵活性。</p>
<p>在Java平台的类库中还有很多线程封闭的示例，其中有一些类的唯一用途就是将非线程安全的类转化为线程安全的类。一些基本的容器类并非线程安全的，例如ArrayList和HashMap，但类库提供了包装器工厂方法（例如Collections.synchronizedList及其类似方法），使得这些非线程安全的类可以在多线程环境中安全地使用。<strong>这些工厂方法通过“装饰器（Decorator）”模式将容器类封装在一个同步的包装器对象中，而包装器能将接口中的每个方法都实现为同步方法，并将调用请求转发到底层的容器对象上。只要包装器对象拥有对底层容器对象的唯一引用（即底层容器对象封闭在包装器中），那么它就是线程安全的</strong>。在这些方法的javadoc中指出，对底层容器对象的所有访问必须通过包装器来进行。</p>
<h4 id="Java监视器模式"><a href="#Java监视器模式" class="headerlink" title="Java监视器模式"></a>Java监视器模式</h4><p>Java监视器模式仅仅是一种编写代码的约定，对于任何一种锁对象，只要自始至终都使用该锁对象，都可以用来保护对象的状态。</p>
<p>例如，使用私有锁来保护状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class PrivateLock &#123;</div><div class="line">    private final Object myLock = new Object();</div><div class="line">    @GuardedBy(&quot;myLock&quot;) Widget widget;</div><div class="line">    </div><div class="line">    void someMethod() &#123;</div><div class="line">        synchronized(myLock) &#123;</div><div class="line">            //访问或修改widget的状态</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用私有的锁对象而不是对象的内置锁（或任何其他通过公有方式访问的锁），有许多优点。私有的锁对象可以将锁封装起来，使客户代码无法得到锁，但客户代码可以通过公有方法来访问锁，以便（正确或不正确地）参与到它的同步策略中。</p>
<h4 id="在现有的线程安全类中添加功能（不推荐）"><a href="#在现有的线程安全类中添加功能（不推荐）" class="headerlink" title="在现有的线程安全类中添加功能（不推荐）"></a>在现有的线程安全类中添加功能（不推荐）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@ThreadSafe</div><div class="line">public class betterVector&lt;E&gt; extends Vector&lt;E&gt; &#123;</div><div class="line">    public synchronized boolean putIfAbsent(E x) &#123;</div><div class="line">        boolean absent = !list.contains(x);</div><div class="line">        if(absent) list.add(x);</div><div class="line">        return absent;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>“扩展”方法比直接将代码添加到类中更加脆弱，因为现在的同步策略实现被分布到多个单独维护的源代码文件中。如果底层的类改变了同步策略并选择了不同的锁来保护它的状态变量，那么子类会被破坏，因为在同步策略改变后它无法再使用正确的锁来控制对基类状态的并发访问。</p>
<h4 id="客户端加锁"><a href="#客户端加锁" class="headerlink" title="客户端加锁"></a>客户端加锁</h4><p>非线程安全的示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@NotThreadSafe</div><div class="line">public class ListHelper&lt;E &#123;</div><div class="line">    public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;E&gt;());</div><div class="line">    ...</div><div class="line">    public synchronized boolean putIfAbsent(E x) &#123;</div><div class="line">        boolean absent = !list.contains(x);</div><div class="line">        if(absent) list.add(x);</div><div class="line">        return absent;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该示例的问题在于错误的锁上进行了同步。无论List使用哪一个锁来保护它的状态，可以确定的是，这个锁并不是Listhelper上的锁。ListHelper只是带来了同步的假象，尽管所有的链表操作都被声明为synchronized，但却使用了不同的锁，这意味着putIfAbsent相对于List的其他操作来说并不是原子的，因此就无法确保当putIfAbsent执行时另一个线程不会修改链表。</p>
<p><strong>客户端加锁是指，对于使用某个对象X的客户端代码，使用X本身用于保护其状态的锁来保护这段客户代码</strong>。</p>
<p>例如：正确通过客户端加锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@ThreadSafe</div><div class="line">public class ListHelper&lt;E &#123;</div><div class="line">    public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;E&gt;());</div><div class="line">    ...</div><div class="line">    public boolean putIfAbsent(E x) &#123;</div><div class="line">        synchronized(list) &#123;</div><div class="line">            boolean absent = !list.contains(x);</div><div class="line">            if(absent) list.add(x);</div><div class="line">            return absent;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过添加一个原子操作来扩展类是脆弱的，因为它将类的加锁代码分布到多个类中。然而，客户端加锁却更加脆弱，因为它将类C加锁的代码放到与C完全无关的其他类中。</p>
<p>客户端记载机制与扩展类机制有许多共同点，二者都是将派生类的行为与基类的实现耦合在一起。正如扩展会破坏实现的封装性，客户端加锁同样会破坏同步策略的封装性。</p>
<h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><p>当为现有的类添加一个原子操作时，有一种更好的办法：组合。<br>下面的程序中的ImprovedList通过将List对象的操作委托给底层的List实例来实现List的操作，同时还添加了一个原子的PutIfAbsent方法。（与Collections.synchronizedList和其他容器封装器一样，ImprovedList假设把对象传给构造函数后，客户代码不会再直接使用这个对象，而只能通过ImprovedList来访问它）    </p>
<p>通过组合方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@ThreadSafe</div><div class="line">public class ImprovedList&lt;T&gt; implements List&lt;T&gt; &#123;</div><div class="line">    private final List&lt;T&gt; list;</div><div class="line">    </div><div class="line">    public ImprovedList(List&lt;T&gt; list) &#123;this.list = list&#125;;</div><div class="line">    </div><div class="line">    public synchronizedboolean putIfAbsent(E x) &#123;</div><div class="line">        boolean absent = !list.contains(x);</div><div class="line">        if(absent) list.add(x);</div><div class="line">        return absent;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ImprovedList通过自身的内置锁增加了一层额外的加锁。它并不关心底层的List是否是线程安全的，即使List不是线程安全的或者修改了它的加锁实现，ImprovedList也会提供一致的加锁机制来实现线程安全性。事实上，我们使用了Java监视器模式来封装现有的List，并且只要在类中拥有指向底层List的唯一外部引用，就能确保线程安全性。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>可变状态是至关重要的：所有的并发问题都可以归结为如何协调对并发状态的访问。可变状态越少，就越容易确保线程安全性。</li>
<li>尽量将域声明为final类型，除非需要它们是可变的。</li>
<li>不可变对象一定是线程安全的，不可变对象能极大地降低并发编程的复杂性，它们更为简单而且安全，可以任意共享而无须使用加锁或保护性复制等机制</li>
<li>封装有助于管理复杂性：在编写线程安全的程序时，虽然可以将所有数据都保存在全局变量中，但为什么要这样做？将数据封装在对象中，更易于维持不变性条件，将同步机制封装在对象中，更易于遵循同步策略。</li>
<li>用锁来保护每个可变变量</li>
<li>当保护同一个不变性条件中的所有变量时，要使用同一个锁。</li>
<li>在执行复合操作期间，要持有锁。</li>
<li>如果从多个线程中访问同一个可变变量时没有同步机制，那么程序会出现问题。</li>
<li>不要故作聪明地推断出不需要使用同步。</li>
<li>在设计过程中考虑线程安全，或者在文档中明确地指出它不是线程安全的。</li>
<li>将同步策略文档化。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/02/25/Java/线程/线程安全基础/" data-id="cjfvvphle007lm9fymgrjxz4d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/线程/Fork  、Join框架" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/25/Java/线程/Fork  、Join框架/" class="article-date">
  <time datetime="2017-02-25T02:09:45.000Z" itemprop="datePublished">2017-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/线程/">线程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/25/Java/线程/Fork  、Join框架/">Fork  、Join框架</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>通常，使用Java来开发一个简单的并发应用程序时，会创建一些Runnable对象，然后创建对应的Thread 对象来控制程序中这些线程的创建、执行以及线程的状态。自从Java 5开始引入了Executor和ExecutorService接口以及实现这两个接口的类（比如ThreadPoolExecutor）之后，使得Java在并发支持上得到了进一步的提升。</p>
<p><strong>执行器框架</strong>（Executor Framework）将任务的创建和执行进行了分离，通过这个框架，只需要实现Runnable接口的对象和使用Executor对象，然后将Runnable对象发送给执行器。执行器再负责运行这些任务所需要的线程，包括线程的创建，线程的管理以及线程的结束。</p>
<p>Java 7则又更进了一步，它包括了ExecutorService接口的另一种实现，用来解决特殊类型的问题，它就是<strong>Fork/Join框架</strong>，有时也称<strong>分解/合并框架</strong>。</p>
<p><strong>Fork/Join框架是用来解决能够通过分治技术（Divide and Conquer Technique）将问题拆分成小任务的问题。在一个任务中，先检查将要解决的问题的大小，如果大于一个设定的大小，那就将问题拆分成可以通过框架来执行的小任务。如果问题的大小比设定的大小要小，就可以直接在任务里解决这个问题，然后，根据需要返回任务的结果</strong>。下面的图形总结了这个原理。<br><img src="http://ifeve.com/wp-content/uploads/2014/02/Java-Concurrency-Cook-Book-5.1.png" alt="image">   </p>
<p>没有固定的公式来决定问题的<strong>参考大小</strong>（Reference Size），从而决定一个任务是需要进行拆分或不需要拆分，拆分与否仍是依赖于任务本身的特性。可以使用在任务中将要处理的元素的数目和任务执行所需要的时间来决定参考大小。测试不同的参考大小来决定解决问题最好的一个方案，将<strong>ForkJoinPool</strong>类看作一个特殊的 Executor 执行器类型。这个框架基于以下两种操作。  </p>
<ul>
<li><strong>分解（Fork）操作</strong>：当需要将一个任务拆分成更小的多个任务时，在框架中执行这些任务；</li>
<li><strong>合并（Join）操作</strong>：当一个主任务等待其创建的多个子任务的完成执行。</li>
</ul>
<p><strong>Fork/Join框架和执行器框架（Executor Framework）主要的区别在于工作窃取算法（Work-Stealing Algorithm）</strong>。与执行器框架不同，使用Join操作让一个主任务等待它所创建的子任务的完成，执行这个任务的线程称之为<strong>工作者线程</strong>（Worker Thread）。工作者线程寻找其他仍未被执行的任务，然后开始执行。通过这种方式，这些线程在运行时拥有所有的优点，进而提升应用程序的性能。</p>
<p>为了达到这个目标，通过Fork/Join框架执行的任务有以下限制。</p>
<ul>
<li>任务只能使用fork()和join() 操作当作同步机制。如果使用其他的同步机制，工作者线程就不能执行其他任务，当然这些任务是在同步操作里时。比如，如果在Fork/Join 框架中将一个任务休眠，正在执行这个任务的工作者线程在休眠期内不能执行另一个任务。</li>
<li>任务不能执行I/O操作，比如文件数据的读取与写入。</li>
<li>任务不能抛出非运行时异常（Checked Exception），必须在代码中处理掉这些异常。</li>
</ul>
<p>Fork/Join框架的核心是由下列两个类组成的。</p>
<ul>
<li><strong>ForkJoinPool</strong>：这个类实现了ExecutorService接口和工作窃取算法（Work-Stealing Algorithm）。它管理工作者线程，并提供任务的状态信息，以及任务的执行信息。</li>
<li><strong>ForkJoinTask</strong>：这个类是一个将在ForkJoinPool中执行的任务的基类。</li>
</ul>
<p>Fork/Join框架提供了在一个任务里执行fork()和join()操作的机制和控制任务状态的方法。通常，为了实现Fork/Join任务，需要实现一个以下两个类之一的子类。</p>
<ul>
<li><strong>RecursiveAction</strong>：用于任务没有返回结果的场景。</li>
<li><strong>RecursiveTask</strong>：用于任务有返回结果的场景。</li>
</ul>
<h2 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h2><p>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程图如下：<br><img src="http://ifeve.com/wp-content/uploads/2013/12/fj.png" alt="image"><br>那么为什么需要使用工作窃取算法呢？假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p>
<p>工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p>
<h2 id="创建Fork-Join线程池"><a href="#创建Fork-Join线程池" class="headerlink" title="创建Fork/Join线程池"></a>创建Fork/Join线程池</h2><p>在本节，我们将学习如何使用Fork／Join框架的基本元素。它包括：</p>
<ul>
<li>创建用来执行任务的ForkJoinPool对象；</li>
<li>创建即将在线程池中被执行的任务ForkJoinTask子类。</li>
</ul>
<p>本范例中即将使用的Fork/Join框架的主要特性如下：</p>
<ul>
<li>采用默认的构造器创建ForkJoinPool对象；</li>
<li>在任务中将使用JavaAPI文档推荐的结构。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">if (problem size &gt; default size)&#123;</div><div class="line"></div><div class="line">    tasks = divide(task);</div><div class="line">    </div><div class="line">    execute(tasks);</div><div class="line"></div><div class="line">&#125; else &#123;</div><div class="line"></div><div class="line">    resolve problem using another algorithm;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>我们将以同步的方式执行任务。当一个主任务执行两个或更多的子任务时，这个主任务将等待子任务的完成。用这种方法，执行主任务的线程，称之为<strong>工作者线程</strong>（Worker Thread），它将寻找其他的子任务来执行，并在子任务执行的时间里利用所有的线程优势。</p>
<p>如果将要实现的任务没有返回任何结果，那么，采用RecursiveAction类作为实现任务的基类。</p>
<h3 id="范例实现"><a href="#范例实现" class="headerlink" title="范例实现"></a>范例实现</h3><p>在本节，我们将实现一项更新产品价格的任务。最初的任务将负责更新列表中的所有元素。我们使用10来作为参考大小（ReferenceSize），如果一个任务需要更新大于10个元素，它会将这个列表分解成为两部分，然后分别创建两个任务用来更新各自部分的产品价格。</p>
<p>创建一个名为Product的类，用来存储产品的名称和价格。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Product &#123;</div><div class="line">	</div><div class="line">	//声明一个名为name的私有String属性，一个名为price的私有double属性。</div><div class="line">	private String name;</div><div class="line">	private double price;</div><div class="line">	</div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">	public double getPrice() &#123;</div><div class="line">		return price;</div><div class="line">	&#125;</div><div class="line">	public void setPrice(double price) &#123;</div><div class="line">		this.price = price;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建一个名为ProductListGenerator的类，用来生成一个随机产品列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class ProductListGenerator &#123;</div><div class="line">	</div><div class="line">	//实现generate()方法。接收一个表示列表大小的int参数，并返回一个生成产品的List&lt;Product&gt;列表。</div><div class="line">	public List&lt;Product&gt; generate (int size) &#123;</div><div class="line">		List&lt;Product&gt; ret=new ArrayList&lt;Product&gt;();</div><div class="line">		for (int i=0; i&lt;size; i++) &#123;</div><div class="line">			Product product=new Product();</div><div class="line">			product.setName(&quot;Product &quot;+i);</div><div class="line">			product.setPrice(10);</div><div class="line">			ret.add(product);</div><div class="line">		&#125;</div><div class="line">		return ret;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建一个名为Task的类，并继承RecursiveAction类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">public class Task  extends RecursiveAction &#123;</div><div class="line">	private static final long serialVersionUID = 1L;</div><div class="line">	</div><div class="line">	private List&lt;Product&gt; products;</div><div class="line"></div><div class="line">	//声明两个私有的int属性，分别命名为first和last。这两个属性将决定任务执行时对产品的分块。</div><div class="line">	private int first;</div><div class="line">	private int last;</div><div class="line">	</div><div class="line">	//声明一个名为increment的私有double属性，用来存储产品价格的增加额。</div><div class="line">	private double increment;</div><div class="line"></div><div class="line">	public Task (List&lt;Product&gt; products, int first, int last, double increment) &#123;</div><div class="line">		this.products=products;</div><div class="line">		this.first=first;</div><div class="line">		this.last=last;</div><div class="line">		this.increment=increment;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void compute() &#123;</div><div class="line">		//如果last和first属性值的差异小于10（一个任务只能更新少于10件产品的价格），</div><div class="line">		//则调用updatePrices()方法增加这些产品的价格。</div><div class="line">		if (last-first&lt;10) &#123;</div><div class="line">			updatePrices();</div><div class="line">			</div><div class="line">		&#125; else &#123;</div><div class="line">			//如果last和first属性值的差异大于或等于10，就创建两个新的Task对象，一个处理前一半的产品，</div><div class="line">			//另一个处理后一半的产品，然后调用ForkJoinPool的invokeAll()方法来执行这两个新的任务。</div><div class="line">			int middle=(last+first)/2;</div><div class="line">			System.out.printf(&quot;Task: Pending tasks:%s\n&quot;,getQueuedTaskCount());</div><div class="line">			Task t1=new Task(products, first,middle+1, increment);</div><div class="line">			Task t2=new Task(products, middle+1,last, increment);</div><div class="line">			invokeAll(t1, t2);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//实现updatePrices()方法。这个方法用来更新在产品列表中处于first和last属性之间的产品。</div><div class="line">	private void updatePrices() &#123;</div><div class="line">		for (int i=first; i&lt;last; i++)&#123;</div><div class="line">			Product product=products.get(i);</div><div class="line">			product.setPrice(product.getPrice()*(1+increment));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ProductListGenerator generator=new ProductListGenerator();</div><div class="line">		List&lt;Product&gt; products=generator.generate(100);</div><div class="line">		Task task=new Task(products, 0, products.size(), 0.20);</div><div class="line"></div><div class="line">		ForkJoinPool pool=new ForkJoinPool();</div><div class="line">		pool.execute(task);</div><div class="line">		</div><div class="line">		//实现代码块，显示关于线程池演变的信息，</div><div class="line">		//每5毫秒在控制台上输出线程池的一些参数值，直到任务执行结束。</div><div class="line">		do &#123;</div><div class="line">			System.out.printf(&quot;Main: Thread Count: %d\n&quot;,pool.getActiveThreadCount());</div><div class="line">			System.out.printf(&quot;Main: Thread Steal: %d\n&quot;,pool.getStealCount());</div><div class="line">			System.out.printf(&quot;Main: Parallelism: %d\n&quot;,pool.getParallelism());</div><div class="line">			try &#123;</div><div class="line">				TimeUnit.MILLISECONDS.sleep(5);</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125; while (!task.isDone());</div><div class="line">		</div><div class="line">		pool.shutdown();</div><div class="line">		</div><div class="line">		//调用isCompletedNormally()方法，检查任务是否已经完成并且没有错误，</div><div class="line">		//在这个示例中，在控制台输出信息表示任务已经处理结束。</div><div class="line">		if (task.isCompletedNormally())&#123;</div><div class="line">			System.out.printf(&quot;Main: The process has completed normally.\n&quot;);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		//在增加之后，所有产品的期望价格是12元。在控制台输出所有产品的名称和价格，</div><div class="line">		//如果产品的价格不是12元，就将产品信息打印出来，以便确认所有的产品价格都正确地增加了。</div><div class="line">		for (int i=0; i&lt;products.size(); i++)&#123;</div><div class="line">			Product product=products.get(i);</div><div class="line">			if (product.getPrice()!=12) &#123;</div><div class="line">				System.out.printf(&quot;Product %s: %f\n&quot;,product.</div><div class="line">				getName(),product.getPrice());</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		System.out.println(&quot;Main: End of the program.\n&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Main: Thread Count: 1</div><div class="line">Task: Pending tasks:0</div><div class="line">Task: Pending tasks:1</div><div class="line">Task: Pending tasks:1</div><div class="line">Task: Pending tasks:2</div><div class="line">Main: Thread Steal: 0</div><div class="line">Main: Parallelism: 4</div><div class="line">Task: Pending tasks:0</div><div class="line">Task: Pending tasks:1</div><div class="line">Task: Pending tasks:1</div><div class="line">Task: Pending tasks:0</div><div class="line">Task: Pending tasks:0</div><div class="line">Task: Pending tasks:0</div><div class="line">Task: Pending tasks:1</div><div class="line">Task: Pending tasks:0</div><div class="line">Task: Pending tasks:0</div><div class="line">Task: Pending tasks:1</div><div class="line">Task: Pending tasks:0</div><div class="line">Main: The process has completed normally.</div><div class="line">Main: End of the program.</div></pre></td></tr></table></figure></p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>在这个范例中，我们创建了ForkJoinPool对象，和一个将在线程池中执行的ForkJoinTask的子类。使用了无参的类构造器创建了ForkJoinPool对象，因此它将执行默认的配置。创建一个线程数等于计算机CPU数目的线程池，创建好ForkJoinPool对象之后，那些线程也创建就绪了，在线程池中等待任务的到达，然后开始执行。</p>
<p>由于Task类继承了RecursiveAction类，因此不返回结果。在本节，我们使用了推荐的结构来实现任务。如果任务需要更新大于10个产品，它将拆分这些元素为两部分，创建两个任务，并将拆分的部分相应地分配给新创建的任务。通过使用Task类的first和last属性，来获知任务将要更新的产品列表所在的位置范围。我们已经使用first和last属性，来操作产品列表中仅有的一份副本，而没有为每一个任务去创建不同的产品列表。</p>
<p><strong>调用invokeAll()方法来执行一个主任务所创建的多个子任务。这是一个同步调用，这个任务将等待子任务完成，然后继续执行（也可能是结束）</strong>。当一个主任务等待它的子任务时，执行这个主任务的工作者线程接收另一个等待执行的任务并开始执行。正因为有了这个行为，所以说Fork／Join框架提供了一种比Runnable和Callable对象更加高效的任务管理机制。</p>
<p><strong>ForkJoinTask类的invokeAll()方法是执行器框架（ExecutorFramework）和Fork／Join框架之间的主要差异之一</strong>。在执行器框架中，所有的任务必须发送给执行器，然而，在这个示例中，线程池中包含了待执行方法的任务，任务的控制也是在线程池中进行的。我们在Task类中使用了invokeAll()方法，Task类继承了RecursiveAction类，而RecursiveAction类则继承了ForkJoinTask类。</p>
<p>我们已经发送一个唯一的任务到线程池中，通过使用execute()方法来更新所有产品的列表。在这个示例中，它是一个同步调用，主线程一直等待调用的执行。</p>
<p>我们已经使用了ForkJoinPool类的一些方法，来检查正在运行的任务的状态和演变情况。这个类包含更多的方法，可以用于任务状态的检测。</p>
<p><strong>最后，像执行器框架一样，必须调用shutdown()方法来结束ForkJoinPool的执行</strong>。</p>
<h4 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h4><p>ForkJoinPool类还提供了以下方法用于执行任务。</p>
<ul>
<li><strong>execute (Runnabletask)</strong>：这是本范例中使用的execute()方法的另一种版本。这个方法发送一个Runnable任务给ForkJoinPool类。需要注意的是，<strong>使用Runnable对象时ForkJoinPool类就不采用工作窃取算法（Work-StealingAlgorithm），ForkJoinPool类仅在使用ForkJoinTask类时才采用工作窃取算法</strong>。</li>
<li><strong>invoke(ForkJoinTask<t>task)</t></strong>：正如范例所示，ForkJoinPool类的execute()方法是异步调用的，而ForkJoinPool类的invoke()方法则是同步调用的。这个方法直到传递进来的任务执行结束后才会返回。</li>
<li>也可以使用在ExecutorService类中声明的invokeAll()和invokeAny()方法，这些方法接收Callable对象作为参数。<strong>使用Callable对象时ForkJoinPool类就不采用工作窃取算法（Work-StealingAlgorithm）</strong>，因此，<strong>最好使用执行器来执行Callable对象</strong>。</li>
</ul>
<p>ForkJoinTask类也包含了在范例中所使用的invokeAll()方法的其他版本，这些版本如下。</p>
<ul>
<li><strong>invokeAll(ForkJoinTask&lt;?&gt;… tasks)</strong>：这个版本的方法接收一个可变的参数列表，可以传递尽可能多的ForkJoinTask对象给这个方法作为参数。</li>
<li><strong>invokeAll(Collection<t>tasks)</t></strong>：这个版本的方法接受一个泛型类型T的对象集合（比如，ArrayList对象、LinkedList对象或者TreeSet对象）。这个泛型类型T必须是ForkJoinTask类或者它的子类。</li>
</ul>
<p><strong>虽然ForkJoinPool类是设计用来执行ForkJoinTask对象的，但也可以直接用来执行Runnable和Callable对象。当然，也可以使用ForkJoinTask类的adapt()方法来接收一个Callable对象或者一个Runnable对象，然后将之转化为一个ForkJoinTask对象，然后再去执行</strong>。</p>
<h2 id="合并任务的结果"><a href="#合并任务的结果" class="headerlink" title="合并任务的结果"></a>合并任务的结果</h2><p>Fork／Join框架提供了执行任务并返回结果的能力。这些类型的任务都是通过RecursiveTask类来实现的。RecursiveTask类继承了ForkJoinTask类，并且实现了由执行器框架（Executor Framework）提供的Future接口。</p>
<p>在任务中，必须使用Java API文档推荐的如下结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">if (problem size &gt; size)&#123;</div><div class="line"></div><div class="line">    tasks=Divide(task);</div><div class="line">    </div><div class="line">    execute(tasks);</div><div class="line">    </div><div class="line">    groupResults()</div><div class="line">    </div><div class="line">    return result;</div><div class="line"></div><div class="line">&#125; else &#123;</div><div class="line"></div><div class="line">    resolve problem;</div><div class="line">    </div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果任务需要解决的问题大于预先定义的大小，那么就要将这个问题拆分成多个子任务，并使用Fork／Join框架来执行这些子任务。执行完成后，原始任务获取到由所有这些子任务产生的结果，合并这些结果，返回最终的结果。当原始任务在线程池中执行结束后，将高效地获取到整个问题的最终结果。</p>
<p>在本节，我们将学习如何使用Fork／Join框架来解决这种问题，开发一个应用程序，在文档中查找一个词。我们将实现以下两种任务：</p>
<ul>
<li>一个文档任务，它将遍历文档中的每一行来查找这个词；</li>
<li>一个行任务，它将在文档的一部分当中查找这个词。</li>
</ul>
<p>所有这些任务将返回文档或行中所出现这个词的次数。</p>
<p>创建一个名为DocumentMock的类。它将生成一个字符串矩阵来模拟一个文档。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class DocumentMock &#123;</div><div class="line">	private String words[]=&#123;&quot;the&quot;,&quot;hello&quot;,&quot;goodbye&quot;,&quot;packt&quot;, &quot;java&quot;,&quot;thread&quot;,</div><div class="line">			&quot;pool&quot;,&quot;random&quot;,&quot;class&quot;,&quot;main&quot;&#125;;</div><div class="line">	</div><div class="line">	//实现generateDocument()方法。它接收3个参数，分别是行数numLines，每一行词的个数numWords，</div><div class="line">	//和准备查找的词word。然后返回一个字符串矩阵。</div><div class="line">	public String[][] generateDocument(int numLines, int numWords, String word) &#123;</div><div class="line">		int counter=0;</div><div class="line">		String document[][]=new String[numLines][numWords];</div><div class="line">		Random random=new Random();</div><div class="line">		</div><div class="line">		//为字符串矩阵填上字符串。通过随机数取得数组words中的某一字符串，</div><div class="line">		//然后存入到字符串矩阵document对应的位置上，同时计算生成的字符串矩阵中将要查找的词出现的次数。</div><div class="line">		//这个值可以用来与后续程序运行查找任务时统计的次数相比较，检查两个值是否相同。</div><div class="line">		for (int i=0; i&lt;numLines; i++)&#123;</div><div class="line">			for (int j=0; j&lt;numWords; j++) &#123;</div><div class="line">				int index=random.nextInt(words.length);</div><div class="line">				document[i][j]=words[index];</div><div class="line">				if (document[i][j].equals(word))&#123;</div><div class="line">					counter++;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;DocumentMock: The word appears &quot;+counter+&quot; times in the document&quot;);</div><div class="line">		return document;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建名为DocumentTask的类，并继承RecursiveTask类，RecursiveTask类的泛型参数为Integer类型。这个DocumentTask类将实现一个任务，用来计算所要查找的词在行中出现的次数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">public class DocumentTask extends RecursiveTask&lt;Integer&gt; &#123;</div><div class="line">	private static final long serialVersionUID = 1L;</div><div class="line">	</div><div class="line">	private String document[][];</div><div class="line">	private int start, end;</div><div class="line">	private String word;</div><div class="line">	</div><div class="line">	public DocumentTask (String document[][], int start, int end, String word)&#123;</div><div class="line">		this.document=document;</div><div class="line">		this.start=start;</div><div class="line">		this.end=end;</div><div class="line">		this.word=word;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected Integer compute() &#123;</div><div class="line">		int result = 0;</div><div class="line">		//实现compute()方法。如果end和start的差异小于10，</div><div class="line">		//则调用processLines()方法，来计算这两个位置之间要查找的词出现的次数。</div><div class="line">		if (end-start&lt;10)&#123;</div><div class="line">			result=processLines(document, start, end, word);</div><div class="line">			</div><div class="line">		//否则，拆分这些行成为两个对象，并创建两个新的DocumentTask对象来处理这两个对象，</div><div class="line">		//然后调用invokeAll()方法在线程池里执行它们。</div><div class="line">		&#125; else &#123;</div><div class="line">			int mid=(start+end)/2;</div><div class="line">			DocumentTask task1=new DocumentTask(document,start,mid,word);</div><div class="line">			DocumentTask task2=new DocumentTask(document,mid,end,word);</div><div class="line">			invokeAll(task1,task2);</div><div class="line">			</div><div class="line">			try &#123;</div><div class="line">				result=groupResults(task1.get(),task2.get());</div><div class="line">			&#125; catch (InterruptedException | ExecutionException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//实现processLines()方法。接收4个参数，一个字符串document矩阵，</div><div class="line">	//start属性，end属性和任务将要查找的词word的属性。</div><div class="line">	private Integer processLines(String[][] document, int start, int end, String word) &#123;</div><div class="line">		//为任务所要处理的每一行，创建一个LineTask对象，然后存储在任务列表里。</div><div class="line">		List&lt;LineTask&gt; tasks=new ArrayList&lt;LineTask&gt;();</div><div class="line">		for (int i=start; i&lt;end; i++) &#123;</div><div class="line">			LineTask task=new LineTask(document[i], 0, document[i].length, word);</div><div class="line">			tasks.add(task);</div><div class="line">		&#125;</div><div class="line">		invokeAll(tasks);</div><div class="line">		</div><div class="line">		//合计这些任务返回的值，并返回结果。</div><div class="line">		int result=0;</div><div class="line">		for (int i=0; i&lt;tasks.size(); i++) &#123;</div><div class="line">			LineTask task=tasks.get(i);</div><div class="line">			try &#123;</div><div class="line">				result=result+task.get();</div><div class="line">			&#125; catch (InterruptedException | ExecutionException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return new Integer(result);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//实现groupResults()方法。它将两个数字相加并返回结果。</div><div class="line">	private Integer groupResults(Integer number1, Integer number2) &#123;</div><div class="line">		Integer result;</div><div class="line">		result=number1+number2;</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建名为LineTask的类，并继承RecursiveTask类，RecursiveTask类的泛型参数为Integer类型。这个RecursiveTask类实现了一个任务，用来计算所要查找的词在一行中出现的次数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line">public class LineTask extends RecursiveTask&lt;Integer&gt; &#123;</div><div class="line">	private static final long serialVersionUID = 1L;</div><div class="line">	</div><div class="line">	//声明一个名为line的私有String数组属性和两个名为start和end的私有int属性。</div><div class="line">	//最后，声明一个名为word的私有String属性。</div><div class="line">	private String line[];</div><div class="line">	private int start, end;</div><div class="line">	private String word;</div><div class="line">	</div><div class="line">	public LineTask(String line[], int start, int end, String word) &#123;</div><div class="line">		this.line=line;</div><div class="line">		this.start=start;</div><div class="line">		this.end=end;</div><div class="line">		this.word=word;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected Integer compute() &#123;</div><div class="line">		Integer result=null;</div><div class="line"></div><div class="line">		if (end-start&lt;100) &#123;</div><div class="line">			result=count(line, start, end, word);</div><div class="line">			</div><div class="line">		&#125; else &#123;</div><div class="line">			int mid=(start+end)/2;</div><div class="line">			LineTask task1=new LineTask(line, start, mid, word);</div><div class="line">			LineTask task2=new LineTask(line, mid, end, word);</div><div class="line">			invokeAll(task1, task2);</div><div class="line"></div><div class="line">			try &#123;</div><div class="line">				result=groupResults(task1.get(),task2.get());</div><div class="line">				&#125; catch (InterruptedException | ExecutionException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//实现count()方法。它接收4个参数，一个完整行字符串line数组，</div><div class="line">	//start属性，end属性和任务将要查找的词word的属性。</div><div class="line">	private Integer count(String[] line, int start, int end, String word) &#123;</div><div class="line">		int counter;</div><div class="line">		counter=0;</div><div class="line">		for (int i=start; i&lt;end; i++)&#123;</div><div class="line">			if (line[i].equals(word))&#123;</div><div class="line">				counter++;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		//为了延缓范例的执行，将任务休眠10毫秒。</div><div class="line">		try &#123;</div><div class="line">			Thread.sleep(10);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		return counter;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private Integer groupResults(Integer number1, Integer number2) &#123;</div><div class="line">		Integer result;</div><div class="line">		result=number1+number2;</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		//创建Document对象，包含100行，每行1,000个词。</div><div class="line">		DocumentMock mock=new DocumentMock();</div><div class="line">		String[][] document=mock.generateDocument(100, 1000, &quot;the&quot;);</div><div class="line">		//创建一个DocumentTask对象，用来更新整个文档。传递数字0给参数start，以及数字100给参数end。</div><div class="line">		DocumentTask task=new DocumentTask(document, 0, 100, &quot;the&quot;);</div><div class="line"></div><div class="line">		ForkJoinPool pool=new ForkJoinPool();</div><div class="line">		pool.execute(task);</div><div class="line">		</div><div class="line">		do &#123;</div><div class="line">			System.out.printf(&quot;******************************************\n&quot;);</div><div class="line">			System.out.printf(&quot;Main: Parallelism: %d\n&quot;,pool.getParallelism());</div><div class="line">			System.out.printf(&quot;Main: Active Threads: %d\n&quot;,pool.getActiveThreadCount());</div><div class="line">			System.out.printf(&quot;Main: Task Count: %d\n&quot;,pool.getQueuedTaskCount());</div><div class="line">			System.out.printf(&quot;Main: Steal Count: %d\n&quot;,pool.getStealCount());</div><div class="line">			System.out.printf(&quot;******************************************\n&quot;);</div><div class="line"></div><div class="line">			try &#123;</div><div class="line">				TimeUnit.SECONDS.sleep(1);</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125; while (!task.isDone());</div><div class="line"></div><div class="line">		pool.shutdown();</div><div class="line"></div><div class="line">		//调用awaitTermination()等待任务执行结束。</div><div class="line">		try &#123;</div><div class="line">			pool.awaitTermination(1, TimeUnit.DAYS);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		try &#123;</div><div class="line">			System.out.printf(&quot;Main: The word appears %d in the document&quot;,task.get());</div><div class="line">		&#125; catch (InterruptedException | ExecutionException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">DocumentMock: The word appears 9921 times in the document</div><div class="line">******************************************</div><div class="line">Main: Parallelism: 4</div><div class="line">Main: Active Threads: 4</div><div class="line">Main: Task Count: 31</div><div class="line">Main: Steal Count: 0</div><div class="line">******************************************</div><div class="line">******************************************</div><div class="line">Main: Parallelism: 4</div><div class="line">Main: Active Threads: 4</div><div class="line">Main: Task Count: 32</div><div class="line">Main: Steal Count: 0</div><div class="line">******************************************</div><div class="line">******************************************</div><div class="line">Main: Parallelism: 4</div><div class="line">Main: Active Threads: 4</div><div class="line">Main: Task Count: 12</div><div class="line">Main: Steal Count: 0</div><div class="line">******************************************</div><div class="line">******************************************</div><div class="line">Main: Parallelism: 4</div><div class="line">Main: Active Threads: 4</div><div class="line">Main: Task Count: 18</div><div class="line">Main: Steal Count: 0</div><div class="line">******************************************</div><div class="line">******************************************</div><div class="line">Main: Parallelism: 4</div><div class="line">Main: Active Threads: 4</div><div class="line">Main: Task Count: 15</div><div class="line">Main: Steal Count: 0</div><div class="line">******************************************</div><div class="line">Main: The word appears 9921 in the document</div></pre></td></tr></table></figure></p>
<h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h4><p>在这个范例中，我们实现了两个不同的任务。</p>
<ul>
<li>DocumentTask类：这个类的任务需要处理由start和end属性决定的文档行。如果这些行数小于10，那么，就每行创建一个LineTask对象，然后在任务执行结束后，合计返回的结果，并返回总数。如果任务要处理的行数大于10，那么，将任务拆分成两组，并创建两个DocumentTask对象来处理这两组对象。当这些任务执行结束后，同样合计返回的结果，并返回总数。</li>
<li>LineTask类：这个类的任务需要处理文档中一行的某一组词。如果一组词的个数小100，那么任务将直接在这一组词里搜索特定词，然后返回查找词在这一组词中出现的次数。否则，任务将拆分这些词为两组，并创建两个LineTask对象来处理这两组词。当这些任务执行完成后，合计返回的结果，并返回总数。</li>
</ul>
<p>在Main主类中，我们通过默认的构造器创建了ForkJoinPool对象，然后执行DocumentTask类，来处理一个共有100行，每行1,000字的文档。这个任务将问题拆分成DocumentTask对象和LineTask对象，然后当所有的任务执行完成后，使用原始的任务来获取整个文档中所要查找的词出现的次数。由于任务继承了RecursiveTask类，因此能够返回结果。</p>
<p>调用get()方法来获得Task返回的结果。这个方法声明在Future接口里，并由RecursiveTask类实现。</p>
<p>执行程序时，在控制台上，我们可以比较第一行与最后一行的输出信息。第一行是文档生成时被查找的词出现的次数，最后一行则是通过Fork／Join任务计算而来的被查找的词出现的次数，而且这两个数字相同。</p>
<h4 id="更多信息-1"><a href="#更多信息-1" class="headerlink" title="更多信息"></a>更多信息</h4><p><strong>ForkJoinTask类提供了另一个complete()方法来结束任务的执行并返回结果。这个方法接收一个对象，对象的类型就是RecursiveTask类的泛型参数，然后在任务调用join()方法后返回这个对象作为结果。这一过程采用了推荐的异步任务来返回任务的结果</strong>。</p>
<p>由于RecursiveTask类实现了Future接口，因此还有get()方法调用的其他版本：</p>
<ul>
<li>get(long timeout, TimeUnit unit)：这个版本中，如果任务的结果未准备好，将等待指定的时间。如果等待时间超出，而结果仍未准备好，那方法就会返回null值。</li>
</ul>
<p><strong>TimeUnit是一个枚举类，有如下的常量：DAYS、HOURS、MICROSECONDS、MILLISECONDS、MINUTES、NANOSECONDS和SECONDS</strong>。</p>
<h2 id="异步运行任务"><a href="#异步运行任务" class="headerlink" title="异步运行任务"></a>异步运行任务</h2><p><strong>在ForkJoinPool中执行 ForkJoinTask时，可以采用同步或异步方式。当采用同步方式执行时，发送任务给Fork/Join线程池的方法直到任务执行完成后才会返回结果。而采用异步方式执行时，发送任务给执行器的方法将立即返回结果，但是任务仍能够继续执行</strong>。</p>
<p>需要明白这两种方式在执行任务时的一个很大的区别。<strong>当采用同步方式，调用这些方法（比如，invokeAll()方法）时，任务被挂起，直到任务被发送到Fork/Join线程池中执行完成。这种方式允许ForkJoinPool类采用工作窃取算法（Work-StealingAlgorithm）来分配一个新任务给在执行休眠任务的工作者线程（WorkerThread）。相反，当采用异步方法（比如，fork()方法）时，任务将继续执行，因此ForkJoinPool类无法使用工作窃取算法来提升应用程序的性能</strong>。在这个示例中，只有调用join()或get()方法来等待任务的结束时，ForkJoinPool类才可以使用工作窃取算法。</p>
<p>本节将学习如何使用ForkJoinPool和ForkJoinTask类所提供的异步方法来管理任务。我们将实现一个程序：在一个文件夹及其子文件夹中来搜索带有指定扩展名的文件。ForkJoinTask类将实现处理这个文件夹的内容。而对于这个文件夹中的每一个子文件，任务将以异步的方式发送一个新的任务给ForkJoinPool类。对于每个文件夹中的文件，任务将检查任务文件的扩展名，如果符合条件就将其增加到结果列表中。</p>
<h4 id="范例实现-1"><a href="#范例实现-1" class="headerlink" title="范例实现"></a>范例实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">public class FolderProcessor  extends RecursiveTask&lt;List&lt;String&gt;&gt; &#123;</div><div class="line">	private static final long serialVersionUID = 1L;</div><div class="line">	</div><div class="line">	//声明一个名为path的私有String属性，用来存储任务将要处理的文件夹的完整路径。</div><div class="line">	private String path;</div><div class="line">	//声明一个名为extension的私有String属性，用来存储任务将要查找的文件的扩展名。</div><div class="line">	private String extension;</div><div class="line"></div><div class="line">	public FolderProcessor (String path, String extension) &#123;</div><div class="line">		this.path=path;</div><div class="line">		this.extension=extension;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected List&lt;String&gt; compute() &#123;</div><div class="line">		//声明一个名为list的String对象列表，用来存储文件夹中文件的名称。</div><div class="line">		List&lt;String&gt; list=new ArrayList&lt;&gt;();</div><div class="line">		//声明一个名为tasks的FolderProcessor任务列表，用来存储子任务，这些子任务将处理文件夹中的子文件夹。</div><div class="line">		List&lt;FolderProcessor&gt; tasks=new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">		File file=new File(path);</div><div class="line">		File content[] = file.listFiles();</div><div class="line">		</div><div class="line">		if (content != null) &#123;</div><div class="line">			for (int i = 0; i &lt; content.length; i++) &#123;</div><div class="line">				//对于文件夹中的每一个元素，如果它是子文件夹，就创建一个新的FolderProcessor对象，</div><div class="line">				//然后调用fork()方法采用异步方式来执行它。</div><div class="line">				if (content[i].isDirectory()) &#123;</div><div class="line">					FolderProcessor task=new FolderProcessor(content[i].getAbsolutePath(), extension);</div><div class="line">					task.fork();</div><div class="line">					tasks.add(task);</div><div class="line">					</div><div class="line">				&#125; else &#123;</div><div class="line">					//否则，调用checkFile()方法来比较文件的扩展名。如果文件的扩展名与将要搜索的扩展名相同，</div><div class="line">					//就将文件的完整路径存储到列表中。</div><div class="line">					if (checkFile(content[i].getName()))&#123;</div><div class="line">						list.add(content[i].getAbsolutePath());</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			if (tasks.size()&gt;50) &#123;</div><div class="line">				System.out.printf(&quot;%s: %d tasks ran.\n&quot;, file.getAbsolutePath(), tasks.size());</div><div class="line">			&#125;</div><div class="line">			//调用addResultsFromTask()辅助方法。它把通过这个任务而启动的子任务返回的结果增加到文件列表中。</div><div class="line">			//传递两个参数给这个方法，一个是字符串列表list，一个是FolderProcessor子任务列表tasks。</div><div class="line">			addResultsFromTasks(list,tasks);</div><div class="line">		&#125;</div><div class="line">		return list;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//实现addResultsFromTasks()方法。遍历任务列表中存储的每一个任务，调用join()方法等待任务执行结束，并且返回任务的结果。</div><div class="line">	//然后，调用addAll()方法将任务的结果增加到字符串列表中。</div><div class="line">	private void addResultsFromTasks(List&lt;String&gt; list, List&lt;FolderProcessor&gt; tasks) &#123;</div><div class="line">		for (FolderProcessor item: tasks) &#123;</div><div class="line">			list.addAll(item.join());</div><div class="line">		&#125;</div><div class="line">	 &#125;</div><div class="line">	</div><div class="line">	private boolean checkFile(String name) &#123;</div><div class="line">		return name.endsWith(extension);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ForkJoinPool pool=new ForkJoinPool();</div><div class="line"></div><div class="line">		//创建3个FolderProcessor任务，并使用不同的文件夹路径来初始化这些任务。</div><div class="line">		FolderProcessor system=new FolderProcessor(&quot;/Users/chenliqiang/Documents/git/b2b&quot;, &quot;java&quot;);</div><div class="line">		FolderProcessor apps=new FolderProcessor(&quot;/Users/chenliqiang/Documents/git/oss&quot;,&quot;java&quot;);</div><div class="line">		FolderProcessor documents=new FolderProcessor(&quot;/Users/chenliqiang/Documents/git/logistics&quot;,&quot;java&quot;);</div><div class="line">		</div><div class="line">		pool.execute(system);</div><div class="line">		pool.execute(apps);</div><div class="line">		pool.execute(documents);</div><div class="line"></div><div class="line">		do &#123;</div><div class="line">			System.out.printf(&quot;******************************************\n&quot;);</div><div class="line">			System.out.printf(&quot;Main: Parallelism: %d\n&quot;,pool.getParallelism());</div><div class="line">			System.out.printf(&quot;Main: Active Threads: %d\n&quot;,pool.getActiveThreadCount());</div><div class="line">			System.out.printf(&quot;Main: Task Count: %d\n&quot;,pool.getQueuedTaskCount());</div><div class="line">			System.out.printf(&quot;Main: Steal Count: %d\n&quot;,pool.getStealCount());</div><div class="line">			System.out.printf(&quot;******************************************\n&quot;);</div><div class="line"></div><div class="line">			try &#123;</div><div class="line">				TimeUnit.SECONDS.sleep(1);</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125; while ((!system.isDone())||(!apps.isDone())||(!documents.isDone()));</div><div class="line"></div><div class="line">		pool.shutdown();</div><div class="line"></div><div class="line">		List&lt;String&gt; results;</div><div class="line">		results = system.join();</div><div class="line">		System.out.printf(&quot;System: %d files found.\n&quot;,results.size());</div><div class="line">		results=apps.join();</div><div class="line">		System.out.printf(&quot;Apps: %d files found.\n&quot;,results.size());</div><div class="line">		results=documents.join();</div><div class="line">		System.out.printf(&quot;Documents: %d files found.\n&quot;,results.size());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">******************************************</div><div class="line">/Users/chenliqiang/Documents/git/oss/src/main/webapp/WEB-INF/template/admin: 68 tasks ran.</div><div class="line">/Users/chenliqiang/Documents/git/b2b/.git/objects: 79 tasks ran.</div><div class="line">/Users/chenliqiang/Documents/git/oss/target/oss/WEB-INF/template/admin: 67 tasks ran.</div><div class="line">/Users/chenliqiang/Documents/git/oss/target/oss/resources/admin: 63 tasks ran.</div><div class="line">/Users/chenliqiang/Documents/git/oss/.git/objects: 258 tasks ran.</div><div class="line">/Users/chenliqiang/Documents/git/oss/src/main/webapp/resources/admin: 64 tasks ran.</div><div class="line">/Users/chenliqiang/Documents/git/logistics/.git/objects: 258 tasks ran.</div><div class="line">Main: Parallelism: 4</div><div class="line">Main: Active Threads: 3</div><div class="line">Main: Task Count: 0</div><div class="line">Main: Steal Count: 809</div><div class="line">******************************************</div><div class="line">System: 1503 files found.</div><div class="line">Apps: 1123 files found.</div><div class="line">Documents: 335 files found.</div></pre></td></tr></table></figure></p>
<h4 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h4><p>这个范例的重点在于FolderProcessor类。每一个任务处理一个文件夹中的内容。文件夹中的内容有以下两种类型的元素：</p>
<ul>
<li>文件；</li>
<li>其他文件夹。</li>
</ul>
<p>如果主任务发现一个文件夹，它将创建另一个Task对象来处理这个文件夹，调用fork()方法把这个新对象发送到线程池中。fork()方法发送任务到线程池时，如果线程池中有空闲的工作者线程（WorkerThread）或者将创建一个新的线程，那么开始执行这个任务，fork()方法会立即返回，因此，主任务可以继续处理文件夹里的其他内容。对于每一个文件，任务开始比较它的文件扩展名，如果与要搜索的扩展名相同，那么将文件的完整路径增加到结果列表中。</p>
<p>一旦主任务处理完指定文件夹里的所有内容，它将调用join()方法等待发送到线程池中的所有子任务执行完成。join()方法在主任务中被调用，然后等待任务执行结束，并通过compute()方法返回值。主任务将所有的子任务结果进行合并，这些子任务发送到线程池中时带有自己的结果列表，然后通过调用compute()方法返回这个列表并作为主任务的返回值。</p>
<p>ForkJoinPool类也允许以异步的方式执行任务。调用execute()方法发送3个初始任务到线程池中。在Main主类中，调用shutdown()方法结束线程池，并在控制台输出线程池中任务的状态及其变化的过程。ForkJoinPool类包含了多个方法可以实现这个目的。</p>
<h4 id="更多信息-2"><a href="#更多信息-2" class="headerlink" title="更多信息"></a>更多信息</h4><p>本范例使用join()方法来等待任务的结束，然后获取它们的结果。也可以使用get()方法以下的两个版本来完成这个目的。</p>
<ul>
<li>get()：如果ForkJoinTask类执行结束，或者一直等到结束，那么get()方法的这个版本则返回由compute()方法返回的结果。</li>
<li>get(long timeout, TimeUnit unit)：如果任务的结果未准备好，那么get()方法的  这个版本将等待指定的时间。如果超过指定的时间了，任务的结果仍未准备好，那么这    个方法将返回 null值。TimeUnit是一个枚举类，有如下的常量：DAYS、HOURS、MICROSECONDS、MILLISECONDS、MINUTES、NANOSECONDS和SECONDS。</li>
</ul>
<p>get()方法和join()方法还存在两个主要的区别：</p>
<ul>
<li>join()方法不能被中断，如果中断调用join()方法的线程，方法将抛出InterruptedException异常；</li>
<li>如果任务抛出任何运行时异常，那么 get()方法将返回ExecutionException异常，但是join()方法将返回RuntimeException异常。</li>
</ul>
<h2 id="在任务中抛出异常"><a href="#在任务中抛出异常" class="headerlink" title="在任务中抛出异常"></a>在任务中抛出异常</h2><p>Java有两种类型的异常。</p>
<ul>
<li>非运行时异常（Checked Exception）：这些异常必须在方法上通过throws子句抛出，或者在方法体内通过try{…}catch{…}方式进行捕捉处理。比如IOException或ClassNotFoundException异常。</li>
<li>运行时异常（Unchecked Exception）：这些异常不需要在方法上通过throws子句抛出，也不需要在方法体内通过try{…}catch{…}方式进行捕捉处理。比如NumberFormatException异常。</li>
</ul>
<p><strong>不能在ForkJoinTask类的compute()方法中抛出任务非运行时异常，因为这个方法的实现没有包含任何throws声明。因此，需要包含必需的代码来处理相关的异常</strong>。另一方面，<strong>compute()方法可以抛出运行时异常（它可以是任何方法或者方法内的对象抛出的异常）</strong>。ForkJoinTask类和ForkJoinPool类的行为与我们期待的可能不同。在控制台上，程序没有结束执行，不能看到任务异常信息。如果异常不被抛出，那么它只是简单地将异常吞噬掉。然而，我们能够利用ForkJoinTask类的一些方法来获知任务是否有异常抛出，以及抛出哪一种类型的异常。在本节，我们将学习如何获取这些异常信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">public class Task extends RecursiveTask&lt;Integer&gt;  &#123;</div><div class="line">	private static final long serialVersionUID = 1L;</div><div class="line"></div><div class="line">	//声明一个名为array的私有int数组。用来模拟在这个范例中即将处理的数据数组。</div><div class="line">	private int array[];</div><div class="line"></div><div class="line">	//声明两个分别名为start和end的私有int属性。这些属性将决定任务要处理的数组元素。</div><div class="line">	private int start, end;</div><div class="line"></div><div class="line">	public Task(int array[], int start, int end)&#123;</div><div class="line">		this.array=array;</div><div class="line">		this.start=start;</div><div class="line">		this.end=end;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected Integer compute() &#123;</div><div class="line">		System.out.printf(&quot;Task: Start from %d to %d\n&quot;,start,end);</div><div class="line">		//如果由start和end属性所决定的元素块规模小于10，那么直接检查元素，</div><div class="line">		//当碰到元素块的第4个元素（索引位为3）时，就抛出RuntimeException异常。然后将任务休眠1秒钟。</div><div class="line">		if (end-start&lt;10) &#123;</div><div class="line">			if ((3&gt;start)&amp;&amp;(3&lt;end))&#123;</div><div class="line">				throw new RuntimeException(&quot;This task throws an Exception: Task from &quot;+start+&quot; to &quot;+end);</div><div class="line">			&#125;</div><div class="line">			try &#123;</div><div class="line">				TimeUnit.SECONDS.sleep(1);</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">		&#125; else &#123;</div><div class="line">			//如果要处理的元素块规模大于或等于10，就拆分这个元素块为两部分，</div><div class="line">			//并创建两个Task对象来处理这两部分，然后调用invokeAll()方法在线程池中执行这两个Task对象。</div><div class="line">			int mid=(end+start)/2;</div><div class="line">			Task task1=new Task(array,start,mid);</div><div class="line">			Task task2=new Task(array,mid,end);</div><div class="line">			invokeAll(task1, task2);</div><div class="line">		&#125;</div><div class="line">		System.out.printf(&quot;Task: End form %d to %d\n&quot;,start,end);</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int array[]=new int[20];</div><div class="line">		Task task=new Task(array,0,20);</div><div class="line">		ForkJoinPool pool=new ForkJoinPool();</div><div class="line">		pool.execute(task);</div><div class="line">		pool.shutdown();</div><div class="line"></div><div class="line">		//调用awaitTermination()方法等待任务执行结束。如果想一直等待到任务执行完成，</div><div class="line">		//那就传递值1和TimeUnit.DAYS作为参数给这个方法。</div><div class="line">		try &#123;</div><div class="line">			pool.awaitTermination(1, TimeUnit.DAYS);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		//调用isCompletedAbnormally()方法来检查主任务或者它的子任务之一是否抛出了异常。</div><div class="line">		//在这个示例中，在控制台输出信息就表示有异常抛出。调用ForkJoinTask类的getException()方法来获取异常信息。</div><div class="line">		if (task.isCompletedAbnormally()) &#123;</div><div class="line">			System.out.printf(&quot;Main: An exception has ocurred\n&quot;);</div><div class="line">			System.out.printf(&quot;Main: %s\n&quot;,task.getException());</div><div class="line">		&#125;</div><div class="line">		System.out.printf(&quot;Main: Result: %d&quot;,task.join());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">Task: Start from 0 to 20</div><div class="line">Task: Start from 0 to 10</div><div class="line">Task: Start from 10 to 20</div><div class="line">Task: Start from 5 to 10</div><div class="line">Task: Start from 0 to 5</div><div class="line">Task: Start from 15 to 20</div><div class="line">Task: Start from 10 to 15</div><div class="line">Task: End form 5 to 10</div><div class="line">Task: End form 15 to 20</div><div class="line">Task: End form 10 to 15</div><div class="line">Task: End form 10 to 20</div><div class="line">Main: An exception has ocurred</div><div class="line">Main: java.lang.RuntimeException: java.lang.RuntimeException: This task throws an Exception: Task from 0 to 5</div><div class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: java.lang.RuntimeException: This task throws an Exception: Task from 0 to 5</div><div class="line">	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</div><div class="line">	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</div><div class="line">	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</div><div class="line">	at java.lang.reflect.Constructor.newInstance(Constructor.java:422)</div><div class="line">	at java.util.concurrent.ForkJoinTask.getThrowableException(ForkJoinTask.java:593)</div><div class="line">	at java.util.concurrent.ForkJoinTask.reportException(ForkJoinTask.java:677)</div><div class="line">	at java.util.concurrent.ForkJoinTask.join(ForkJoinTask.java:720)</div><div class="line">	at com.highsunbuy.message.bean.Task.main(Task.java:72)</div><div class="line">Caused by: java.lang.RuntimeException: This task throws an Exception: Task from 0 to 5</div><div class="line">	at com.highsunbuy.message.bean.Task.compute(Task.java:31)</div><div class="line">	at com.highsunbuy.message.bean.Task.compute(Task.java:1)</div><div class="line">	at java.util.concurrent.RecursiveTask.exec(RecursiveTask.java:94)</div><div class="line">	at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)</div><div class="line">	at java.util.concurrent.ForkJoinTask.doInvoke(ForkJoinTask.java:401)</div><div class="line">	at java.util.concurrent.ForkJoinTask.invokeAll(ForkJoinTask.java:759)</div><div class="line">	at com.highsunbuy.message.bean.Task.compute(Task.java:45)</div><div class="line">	at com.highsunbuy.message.bean.Task.compute(Task.java:1)</div><div class="line">	at java.util.concurrent.RecursiveTask.exec(RecursiveTask.java:94)</div><div class="line">	at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)</div><div class="line">	at java.util.concurrent.ForkJoinTask.doInvoke(ForkJoinTask.java:401)</div><div class="line">	at java.util.concurrent.ForkJoinTask.invokeAll(ForkJoinTask.java:759)</div><div class="line">	at com.highsunbuy.message.bean.Task.compute(Task.java:45)</div><div class="line">	at com.highsunbuy.message.bean.Task.compute(Task.java:1)</div><div class="line">	at java.util.concurrent.RecursiveTask.exec(RecursiveTask.java:94)</div><div class="line">	at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)</div><div class="line">	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)</div><div class="line">	at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1689)</div><div class="line">	at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)</div></pre></td></tr></table></figure></p>
<h4 id="工作原理-3"><a href="#工作原理-3" class="headerlink" title="工作原理"></a>工作原理</h4><p>在本节，我们实现的Task类用来处理一个数字数组。它检查要处理的数字块规模是否包含有10个或更多个元素。在这个情况下，Task类拆分这个数字块为两部分，然后创建两个新的Task对象用来处理这两部分。否则，它将寻找位于数组中第4个位置（索引位为3）的元素。如果这个元素位于任务处理块中，它将抛出一个RuntimeException异常。</p>
<p>虽然运行这个程序时将抛出异常，但是程序不会停止。在Main主类中，调用原始任务ForkJoinTask类的isCompletedAbnormally()方法，如果主任务或者它的子任务之一抛出了异常，这个方法将返回true。也可以使用getException()方法来获得抛出的Exception对象。</p>
<p>当任务抛出运行时异常时，会影响它的父任务（发送到ForkJoinPool类的任务），以及父任务的父任务，以此类推。查阅程序的输出结果，将会发现有一些任务没有结束的信息。那些任务的开始信息如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Task: Start from 0 to 20</div><div class="line">Task: Start from 0 to 10</div><div class="line">Task: Start from 0 to 5</div></pre></td></tr></table></figure></p>
<p>这些任务是那些抛出异常的任务和它的父任务。所有这些任务都是异常结束的。记住一点：<strong>在用ForkJoinPool对象和ForkJoinTask对象开发一个程序时，它们是会抛出异常的，如果不想要这种行为，就得采用其他方式</strong>。</p>
<h4 id="更多信息-3"><a href="#更多信息-3" class="headerlink" title="更多信息"></a>更多信息</h4><p>在范例中，不采用抛出异常，而调用ForkJoinTask类的completeExceptionally()方法也可以获得同样的结果。代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Exception e=new Exception(&quot;This task throws an Exception: &quot;+ &quot;Task</div><div class="line">from &quot;+start+&quot; to &quot;+end);</div><div class="line"></div><div class="line">completeExceptionally(e);</div></pre></td></tr></table></figure></p>
<h2 id="取消任务"><a href="#取消任务" class="headerlink" title="取消任务"></a>取消任务</h2><p>在ForkJoinPool类中执行ForkJoinTask对象时，在任务开始执行前可以取消它。ForkJoinTask类提供了cancel()方法来达到取消任务的目的。在取消一个任务时必须要注意以下两点：</p>
<ul>
<li>ForkJoinPool类不提供任何方法来取消线程池中正在运行或者等待运行的所有任务；</li>
<li>取消任务时，不能取消已经被执行的任务。</li>
</ul>
<p>在本节，我们将实现一个取消ForkJoinTask对象的范例。该范例将寻找数组中某个数字所处的位置。第一个任务是寻找可以被取消的剩余任务数。由于Fork／Join框架没有提供取消功能，我们将创建一个辅助类来实现取消任务的操作。</p>
<h4 id="范例实现-2"><a href="#范例实现-2" class="headerlink" title="范例实现"></a>范例实现</h4><p>创建一个名为ArrayGenerator的类。这个类将生成一个指定大小的随机整数数组。实现generateArray()方法，它将生成数字数组，接收一个int参数表示数组的大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class ArrayGenerator &#123;</div><div class="line">	public int[] generateArray(int size) &#123;</div><div class="line">		int array[]=new int[size];</div><div class="line">		Random random=new Random();</div><div class="line">		for (int i=0; i&lt;size; i++)&#123;</div><div class="line">			array[i]=random.nextInt(10);</div><div class="line">		&#125;</div><div class="line">		return array;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建一个名为TaskManager的类。本示例将利用这个类来存储在ForkJoinPool中执行的任务。由于ForkJoinPool和ForkJoinTask类的局限性，将利用TaskManager类来取消ForkJoinPool类中所有的任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class TaskManager &#123;</div><div class="line">	//声明一个名为tasks的对象列表，带有ForkJoinTask泛型参数，并且ForkJoinTask带有Integer泛型参数。</div><div class="line">	private List&lt;ForkJoinTask&lt;Integer&gt;&gt; tasks;</div><div class="line"></div><div class="line">	public TaskManager()&#123;</div><div class="line">		tasks=new ArrayList&lt;&gt;();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void addTask(ForkJoinTask&lt;Integer&gt; task)&#123;</div><div class="line">		tasks.add(task);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//实现cancelTasks()方法。遍历存储在列表中的所有ForkJoinTask对象，然后调用cancel()方法取消之。</div><div class="line">	//cancelTasks()方法接收一个要取消剩余任务的ForkJoinTask对象作为参数，然后取消所有的任务。</div><div class="line">	public void cancelTasks(ForkJoinTask&lt;Integer&gt; cancelTask)&#123;</div><div class="line">		for (ForkJoinTask&lt;Integer&gt; task :tasks) &#123;</div><div class="line">			if (task!=cancelTask) &#123;</div><div class="line">				task.cancel(true);</div><div class="line">				((SearchNumberTask)task).writeCancelMessage();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现SearchNumberTask类，并继承RecursiveTask类，RecursiveTask类的泛型参数为Integer类型。这个类将寻找在整数数组元素块中的一个数字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">public class SearchNumberTask  extends RecursiveTask&lt;Integer&gt; &#123;</div><div class="line">	private static final long serialVersionUID = 1L;</div><div class="line">	private int numbers[];</div><div class="line">	private int start, end;</div><div class="line">	private int number;</div><div class="line">	</div><div class="line">	private TaskManager manager;</div><div class="line">	private final static int NOT_FOUND=-1;</div><div class="line"></div><div class="line">	public SearchNumberTask (int numbers[], int start, int end, int number, TaskManager manager)&#123;</div><div class="line">		this.numbers=numbers;</div><div class="line">		this.start=start;</div><div class="line">		this.end=end;</div><div class="line">		this.number=number;</div><div class="line">		this.manager=manager;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected Integer compute() &#123;</div><div class="line">		System.out.println(&quot;Task: &quot;+start+&quot;:&quot;+end);</div><div class="line"></div><div class="line">		int ret;</div><div class="line">		//如果start和end属性值的差异大于10（任务必须处理大于10个元素的数组），</div><div class="line">		//那么，就调用launchTasks()方法将这个任务拆分为两个子任务。</div><div class="line">		if (end-start&gt;10) &#123;</div><div class="line">			ret=launchTasks();</div><div class="line">			</div><div class="line">		&#125; else &#123;</div><div class="line">			//否则，寻找在数组块中的数字，调用lookForNumber()方法处理这个任务。</div><div class="line">			ret=lookForNumber();</div><div class="line">		&#125;</div><div class="line">		return ret;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private int lookForNumber() &#123;</div><div class="line">		//遍历任务所要处理的数组块中的所有元素，将元素中存储的数字和将要寻找的数字进行比较。</div><div class="line">		//如果它们相等，就在控制台输出信息表示找到了，并用TaskManager对象的cancelTasks()方法取消所有的任务，然后返回已找到的这个元素所在的位置。</div><div class="line">		for (int i=start; i&lt;end; i++)&#123;</div><div class="line">			if (numbers[i]==number) &#123;</div><div class="line">				System.out.printf(&quot;Task: Number %d found in position %d\n&quot;,number,i);</div><div class="line">				manager.cancelTasks(this);</div><div class="line">				return i;</div><div class="line">			&#125;</div><div class="line">			try &#123;</div><div class="line">				TimeUnit.SECONDS.sleep(1);</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return NOT_FOUND;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//实现launchTasks()方法。将这个任务要处理的元素块拆分成两部分，然后创建两个Task对象来处理它们。</div><div class="line">	private int launchTasks() &#123;</div><div class="line">		int mid=(start+end)/2;</div><div class="line">		SearchNumberTask task1=new SearchNumberTask(numbers,start,mid,number,manager);</div><div class="line">		SearchNumberTask task2=new SearchNumberTask(numbers,mid,end,number,manager);</div><div class="line">		manager.addTask(task1);</div><div class="line">		manager.addTask(task2);</div><div class="line">		//调用fork()方法采用异步方式执行这两个任务。</div><div class="line">		task1.fork();</div><div class="line">		task2.fork();</div><div class="line">		</div><div class="line">		//等待任务结束，如果第一个任务返回的结果不为-1，则返回第一个任务的结果；否则返回第二个任务的结果。</div><div class="line">		int returnValue;</div><div class="line">		returnValue=task1.join();</div><div class="line">		if (returnValue!=-1) &#123;</div><div class="line">			return returnValue;</div><div class="line">		&#125;</div><div class="line">		returnValue=task2.join();</div><div class="line">		return returnValue;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//实现writeCancelMessage()方法，在控制台输入信息表示任务已经取消了。</div><div class="line">	public void writeCancelMessage()&#123;</div><div class="line">		System.out.printf(&quot;Task: Cancelled task from %d to %d&quot;,start,end);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ArrayGenerator generator=new ArrayGenerator();</div><div class="line">		int array[]=generator.generateArray(20);</div><div class="line">		TaskManager manager=new TaskManager();</div><div class="line">		ForkJoinPool pool=new ForkJoinPool();</div><div class="line">		SearchNumberTask task=new SearchNumberTask (array,0,20,5,manager);</div><div class="line">		pool.execute(task);</div><div class="line">		pool.shutdown();</div><div class="line"></div><div class="line">		//调用ForkJoinPool类的awaitTermination()方法等待任务执行结束。</div><div class="line">		try &#123;</div><div class="line">			pool.awaitTermination(1, TimeUnit.DAYS);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.printf(&quot;Main: The program has finished\n&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Task: 0:20</div><div class="line">Task: 10:20</div><div class="line">Task: 0:10</div><div class="line">Task: Number 5 found in position 12</div><div class="line">Task: Cancelled task from 0 to 10Task: Number 5 found in position 5</div><div class="line">Task: Cancelled task from 10 to 20Main: The program has finished</div></pre></td></tr></table></figure></p>
<h4 id="工作原理-4"><a href="#工作原理-4" class="headerlink" title="工作原理"></a>工作原理</h4><p>ForkJoinTask类提供的cancel()方法允许取消一个仍没有被执行的任务，这是非常重要的一点。如果任务已经开始执行，那么调用cancel()方法也无法取消。这个方法接收一个名为mayInterruptIfRunning的boolean值参数。顾名思义，如果传递true值给这个方法，即使任务正在运行也将被取消。JavaAPI文档指出，ForkJoinTask类的默认实现，这个属性没有起作用。如果任务还没有开始执行，那么这些任务将被取消。任务的取消对于已发送到线程池中的任务没有影响，它们将继续执行。</p>
<p><strong>Fork／Join框架的局限性在于，ForkJoinPool线程池中的任务不允许被取消</strong>。为了克服这种局限性，我们实现了TaskManager类，它存储发送到线程池中的所有任务，可以用一个方法来取消存储的所有任务。如果任务正在运行或者已经执行结束，那么任务就不能被取消，cancel()方法返回false值，因此可以尝试去取消所有的任务而不用担心可能带来的间接影响。</p>
<p>这个范例实现在数字数组中寻找一个数字。根据Fork／Join框架的推荐，我们将问题拆分为更小的子问题。由于我们仅关心数字的一次出现，因此，当找到它时，就会取消其他的所有任务。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/02/25/Java/线程/Fork  、Join框架/" data-id="cjfvvphl0006rm9fyf4jmudt9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/24/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="page-number" href="/page/24/">24</a><span class="page-number current">25</span>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Eclipse/">Eclipse</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Github/">Github</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Cookie/">Cookie</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JAXB/">JAXB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JavaMail/">JavaMail</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/基础/">基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/数据类型/">数据类型</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/日记/">日记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/时间日期/">时间日期</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/线程/">线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/网络NIO/">网络NIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/队列/">队列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/集合/">集合</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Application-Event/">Application Event</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/JPA/">JPA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Security/">Security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Spring-Boot/">Spring Boot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Spring-Session/">Spring Session</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Task/">Task</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-MVC/">spring MVC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-data-redis/">spring data redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/基础/">基础</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/">前端技术相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/forever/">forever</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/javascript/">javascript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库相关/">数据库相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据库相关/mysql/">mysql</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/">服务器相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hessian/">Hessian</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hudson-Jenkins/">Hudson & Jenkins</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Memcached/">Memcached</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Nginx/">Nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Tomcat/">Tomcat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/red5/">red5</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/resin/">resin</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/正则表达式/">正则表达式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/12/服务器相关/Tomcat/TOMCAT原理详解及请求过程/">TOMCAT原理详解及请求过程</a>
          </li>
        
          <li>
            <a href="/2018/04/12/网络/HTTPS工作原理/">HTTPS工作原理</a>
          </li>
        
          <li>
            <a href="/2018/04/12/网络/三次握手和四次挥手/">三次握手和四次挥手</a>
          </li>
        
          <li>
            <a href="/2018/04/12/服务器相关/Tomcat/内存分配/">内存分配</a>
          </li>
        
          <li>
            <a href="/2018/04/12/服务器相关/Tomcat/Tomcat整体架构浅析/">Tomcat整体架构浅析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 LeoChan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>