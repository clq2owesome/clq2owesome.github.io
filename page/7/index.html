<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LeoChan&#39;s 个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="描述啊">
<meta property="og:type" content="website">
<meta property="og:title" content="LeoChan&#39;s 个人博客">
<meta property="og:url" content="https://clq2owesome.github.io/page/7/index.html">
<meta property="og:site_name" content="LeoChan&#39;s 个人博客">
<meta property="og:description" content="描述啊">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeoChan&#39;s 个人博客">
<meta name="twitter:description" content="描述啊">
  
    <link rel="alternate" href="/atom.xml" title="LeoChan&#39;s 个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LeoChan&#39;s 个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术都是通用的，重要的是是否具有自主解决问题的能力！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://clq2owesome.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Spring/Security/配置二：登录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/15/Spring/Security/配置二：登录/" class="article-date">
  <time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/Security/">Security</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Spring/Security/配置二：登录/">配置二：登录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="form-login元素介绍"><a href="#form-login元素介绍" class="headerlink" title="form-login元素介绍"></a>form-login元素介绍</h2><p>http元素下的form-login元素是用来定义表单登录信息的。当我们什么属性都不指定的时候Spring Security会为我们生成一个默认的登录页面。如果不想使用默认的登录页面，我们可以指定自己的登录页面。</p>
<h3 id="1-使用自定义登录页面"><a href="#1-使用自定义登录页面" class="headerlink" title="1.使用自定义登录页面"></a>1.使用自定义登录页面</h3><p> 自定义登录页面是通过login-page属性来指定的。提到login-page我们不得不提另外几个属性：</p>
<ul>
<li>username-parameter：表示登录时用户名使用的是哪个参数，默认是“j_username”。</li>
<li>password-parameter：表示登录时密码使用的是哪个参数，默认是“j_password”。</li>
<li>login-processing-url：表示登录时提交的地址，默认是“/j-spring-security-check”。这个只是Spring Security用来标记登录页面使用的提交地址，真正关于登录这个请求是不需要用户自己处理的。<br>所以，我们可以通过如下定义使Spring Security在需要用户登录时跳转到我们自定义的登录页面。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;security:http auto-config=&quot;true&quot;&gt;</div><div class="line">  &lt;security:form-login login-page=&quot;/login.jsp&quot;</div><div class="line">     login-processing-url=&quot;/login.do&quot; username-parameter=&quot;username&quot;</div><div class="line">     password-parameter=&quot;password&quot; /&gt;</div><div class="line">  &lt;!-- 表示匿名用户可以访问 --&gt;</div><div class="line">  &lt;security:intercept-url pattern=&quot;/login.jsp&quot; access=&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot;/&gt;</div><div class="line">  &lt;security:intercept-url pattern=&quot;/**&quot; access=&quot;ROLE_USER&quot; /&gt;</div><div class="line">&lt;/security:http&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>需要注意的是，我们之前配置的是所有的请求都需要ROLE_USER权限，这意味着我们自定义的“/login.jsp”也需要该权限，这样就会形成一个死循环了。解决办法是我们需要给“/login.jsp”放行。通过指定“/login.jsp”的访问权限为“IS_AUTHENTICATED_ANONYMOUSLY”或“ROLE_ANONYMOUS”可以达到这一效果。此外，我们也可以通过指定一个http元素的安全性为none来达到相同的效果。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;security:http security=&quot;none&quot; pattern=&quot;/login.jsp&quot; /&gt;</div><div class="line">&lt;security:http auto-config=&quot;true&quot;&gt;</div><div class="line">  &lt;security:form-login login-page=&quot;/login.jsp&quot;</div><div class="line">     login-processing-url=&quot;/login.do&quot; username-parameter=&quot;username&quot;</div><div class="line">     password-parameter=&quot;password&quot; /&gt;</div><div class="line">  &lt;security:intercept-url pattern=&quot;/**&quot; access=&quot;ROLE_USER&quot; /&gt;</div><div class="line">&lt;/security:http&gt;</div></pre></td></tr></table></figure></p>
<p>它们两者的区别是前者将进入Spring Security定义的一系列用于安全控制的filter，而后者不会。当指定一个http元素的security属性为none时，表示其对应pattern的filter链为空。从3.1开始，Spring Security允许我们定义多个http元素以满足针对不同的pattern请求使用不同的filter链。当为指定pattern属性时表示对应的http元素定义将对所有的请求发生作用。<br>根据上面的配置，我们自定义的登录页面的内容应该是这样子的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;form action=&quot;login.do&quot; method=&quot;post&quot;&gt;</div><div class="line">  &lt;table&gt;</div><div class="line">     &lt;tr&gt;</div><div class="line">        &lt;td&gt;用户名：&lt;/td&gt;</div><div class="line">        &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;/td&gt;</div><div class="line">     &lt;/tr&gt;</div><div class="line">     &lt;tr&gt;</div><div class="line">        &lt;td&gt;密码：&lt;/td&gt;</div><div class="line">        &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;/td&gt;</div><div class="line">     &lt;/tr&gt;</div><div class="line">     &lt;tr&gt;</div><div class="line">        &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;</div><div class="line">            &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;</div><div class="line">            &lt;input type=&quot;reset&quot; value=&quot;重置&quot;/&gt;</div><div class="line">        &lt;/td&gt;</div><div class="line">     &lt;/tr&gt;</div><div class="line">  &lt;/table&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p>
<h3 id="2-指定登录后的页面"><a href="#2-指定登录后的页面" class="headerlink" title="2.指定登录后的页面"></a>2.指定登录后的页面</h3><h4 id="通过default-target-url指定"><a href="#通过default-target-url指定" class="headerlink" title="通过default-target-url指定"></a>通过default-target-url指定</h4><p>默认情况下，我们在登录成功后会返回到原本受限制的页面。但如果用户是直接请求登录页面，登录成功后应该跳转到哪里呢？默认情况下它会跳转到当前应用的根路径，即欢迎页面。通过指定form-login元素的default-target-url属性，我们可以让用户在直接登录后跳转到指定的页面。如果想让用户不管是直接请求登录页面，还是通过Spring Security引导过来的，登录之后都跳转到指定的页面，我们可以通过指定form-login元素的always-use-default-target属性为true来达到这一效果。</p>
<h4 id="通过authentication-success-handler-ref指定"><a href="#通过authentication-success-handler-ref指定" class="headerlink" title="通过authentication-success-handler-ref指定"></a>通过authentication-success-handler-ref指定</h4><p>authentication-success-handler-ref对应一个AuthencticationSuccessHandler实现类的引用。如果指定了authentication-success-handler-ref，登录认证成功后会调用指定AuthenticationSuccessHandler的onAuthenticationSuccess方法。我们需要在该方法体内对认证成功做一个处理，然后返回对应的认证成功页面。使用了authentication-success-handler-ref之后认证成功后的处理就由指定的AuthenticationSuccessHandler来处理，之前的那些default-target-url之类的就都不起作用了。<br>以下是自定义的一个AuthenticationSuccessHandler的实现类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">publicclass AuthenticationSuccessHandlerImpl implements</div><div class="line">      AuthenticationSuccessHandler &#123;</div><div class="line"> </div><div class="line">   publicvoid onAuthenticationSuccess(HttpServletRequest request,</div><div class="line">         HttpServletResponse response, Authentication authentication)</div><div class="line">         throws IOException, ServletException &#123;</div><div class="line">      response.sendRedirect(request.getContextPath());</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其对应使用authentication-success-handler-ref属性的配置是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;security:http auto-config=&quot;true&quot;&gt;</div><div class="line">  &lt;security:form-login login-page=&quot;/login.jsp&quot;</div><div class="line">     login-processing-url=&quot;/login.do&quot; username-parameter=&quot;username&quot;</div><div class="line">     password-parameter=&quot;password&quot;</div><div class="line">     authentication-success-handler-ref=&quot;authSuccess&quot;/&gt;</div><div class="line">  &lt;!-- 表示匿名用户可以访问 --&gt;</div><div class="line">  &lt;security:intercept-url pattern=&quot;/login.jsp&quot;</div><div class="line">     access=&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot; /&gt;</div><div class="line">  &lt;security:intercept-url pattern=&quot;/**&quot; access=&quot;ROLE_USER&quot; /&gt;</div><div class="line">&lt;/security:http&gt;</div><div class="line">&lt;!-- 认证成功后的处理类 --&gt;</div><div class="line">&lt;bean id=&quot;authSuccess&quot; class=&quot;com.xxx.AuthenticationSuccessHandlerImpl&quot;/&gt;</div></pre></td></tr></table></figure></p>
<h3 id="3-指定登录失败后的页面"><a href="#3-指定登录失败后的页面" class="headerlink" title="3.指定登录失败后的页面"></a>3.指定登录失败后的页面</h3><p> 除了可以指定登录认证成功后的页面和对应的AuthenticationSuccessHandler之外，form-login同样允许我们指定认证失败后的页面和对应认证失败后的处理器AuthenticationFailureHandler。</p>
<h4 id="通过authentication-failure-url指定"><a href="#通过authentication-failure-url指定" class="headerlink" title="通过authentication-failure-url指定"></a>通过authentication-failure-url指定</h4><p>默认情况下登录失败后会返回登录页面，我们也可以通过form-login元素的authentication-failure-url来指定登录失败后的页面。需要注意的是登录失败后的页面跟登录页面一样也是需要配置成在未登录的情况下可以访问，否则登录失败后请求失败页面时又会被Spring Security重定向到登录页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;security:http auto-config=&quot;true&quot;&gt;</div><div class="line">  &lt;security:form-login login-page=&quot;/login.jsp&quot;</div><div class="line">     login-processing-url=&quot;/login.do&quot; username-parameter=&quot;username&quot;</div><div class="line">     password-parameter=&quot;password&quot;</div><div class="line">     authentication-failure-url=&quot;/login_failure.jsp&quot;</div><div class="line">     /&gt;</div><div class="line">  &lt;!-- 表示匿名用户可以访问 --&gt;</div><div class="line">  &lt;security:intercept-url pattern=&quot;/login*.jsp*&quot;</div><div class="line">     access=&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot; /&gt;</div><div class="line">  &lt;security:intercept-url pattern=&quot;/**&quot; access=&quot;ROLE_USER&quot; /&gt;</div><div class="line">&lt;/security:http&gt;</div></pre></td></tr></table></figure></p>
<h4 id="通过authentication-failure-handler-ref指定"><a href="#通过authentication-failure-handler-ref指定" class="headerlink" title="通过authentication-failure-handler-ref指定"></a>通过authentication-failure-handler-ref指定</h4><p>类似于authentication-success-handler-ref，authentication-failure-handler-ref对应一个用于处理认证失败的AuthenticationFailureHandler实现类。指定了该属性，Spring Security在认证失败后会调用指定AuthenticationFailureHandler的onAuthenticationFailure方法对认证失败进行处理，此时authentication-failure-url属性将不再发生作用。</p>
<h2 id="http-basic"><a href="#http-basic" class="headerlink" title="http-basic"></a>http-basic</h2><p>之前介绍的都是基于form-login的表单登录，其实Spring Security还支持弹窗进行认证。通过定义http元素下的http-basic元素可以达到这一效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;security:http auto-config=&quot;true&quot;&gt;</div><div class="line">  &lt;security:http-basic/&gt;</div><div class="line">  &lt;security:intercept-url pattern=&quot;/**&quot; access=&quot;ROLE_USER&quot; /&gt;</div><div class="line">&lt;/security:http&gt;</div></pre></td></tr></table></figure></p>
<p>此时，如果我们访问受Spring Security保护的资源时，系统将会弹出一个窗口来要求我们进行登录认证。效果如下：<br><img src="http://dl2.iteye.com/upload/attachment/0103/0663/b54058fa-adcc-3182-9e5c-456bf2658b1f.png" alt="image"><br>当然此时我们的表单登录也还是可以使用的，只不过当我们访问受包含资源的时候Spring Security不会自动跳转到登录页面。这就需要我们自己去请求登录页面进行登录。    </p>
<p>需要注意的是当我们同时定义了http-basic和form-login元素时，form-login将具有更高的优先级。即在需要认证的时候Spring Security将引导我们到登录页面，而不是弹出一个窗口。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Spring/Security/配置二：登录/" data-id="cjfvvphm10092m9fy4syjpvm2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/Security/配置二十：整合Cas" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/15/Spring/Security/配置二十：整合Cas/" class="article-date">
  <time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/Security/">Security</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Spring/Security/配置二十：整合Cas/">配置二十：整合Cas</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;众所周知，Cas是对单点登录的一种实现。本文假设读者已经了解了Cas的原理及其使用，这些内容在本文将不会讨论。Cas有Server端和Client端，Client端通常对应着我们自己的应用，Spring Security整合Cas指的就是在Spring Security应用中整合Cas Client，以达到使用Cas Server实现单点登录和登出的效果。本文旨在描述如何在Spring Security应用中使用Cas的单点登录。<br>&emsp;&emsp;首先需要将Spring Security对Cas支持的jar包加入到应用的类路径中。如果我们的应用使用Maven构造的，则可以在应用的pom.xml文件中加上如下依赖。    </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-cas<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.security.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>一. <strong>配置登录认证</strong><br>&emsp;&emsp;加入了spring-security-cas-xxx.jar到Spring Security应用的classpath后，我们便可以开始配置我们的Spring Security应用使用Cas进行单点登录了。<br>1.1 <strong>配置AuthenticationEntryPoint</strong><br>&emsp;&emsp;首先需要做的是将应用的登录认证入口改为使用CasAuthenticationEntryPoint。所以首先我们需要配置一个CasAuthenticationEntryPoint对应的bean，然后指定需要进行登录认证时使用该AuthenticationEntryPoint。配置CasAuthenticationEntryPoint时需要指定一个ServiceProperties，该对象主要用来描述service（Cas概念）相关的属性，主要是指定在Cas Server认证成功后将要跳转的地址。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 指定登录入口为casEntryPoint --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">security:http</span>  <span class="attr">entry-point-ref</span>=<span class="string">"casEntryPoint"</span>&gt;</span></div><div class="line">  ...</div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 认证的入口 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"casEntryPoint"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.cas.web.CasAuthenticationEntryPoint"</span>&gt;</div><div class="line">  <span class="comment">&lt;!-- Cas Server的登录地址 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loginUrl"</span> <span class="attr">value</span>=<span class="string">"https://localhost:8443/cas/login"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- service相关的属性 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceProperties"</span> <span class="attr">ref</span>=<span class="string">"serviceProperties"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 指定service相关信息 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"serviceProperties"</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.cas.ServiceProperties"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- Cas Server认证成功后的跳转地址，这里要跳转到我们的Spring Security应用，之后会由CasAuthenticationFilter处理，默认处理地址为/j_spring_cas_security_check --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"service"</span></span></div><div class="line">     <span class="attr">value</span>=<span class="string">"http://localhost:8080/app/j_spring_cas_security_check"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>1.2 <strong>配置CasAuthenticationFilter</strong><br>&emsp;&emsp;之后我们需要配置一个CasAuthenticationFilter，并将其放置在Filter链表中CAS_FILTER的位置，以处理Cas Server认证成功后的页面跳转，用以在Spring Security中进行认证。该Filter会将Cas Server传递过来的ticket（Cas概念）封装成一个Authentication（对应UsernamePasswordAuthenticationToken，其中ticket作为该Authentication的password），然后传递给AuthenticationManager进行认证。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;security:http entry-point-ref=&quot;casEntryPoint&quot;&gt;</div><div class="line">    ...</div><div class="line">  &lt;security:custom-filter ref=&quot;casFilter&quot; position=&quot;CAS_FILTER&quot;/&gt;</div><div class="line">  ...</div><div class="line">&lt;/security:http&gt;</div><div class="line"></div><div class="line">&lt;bean id=&quot;casFilter&quot;</div><div class="line">  class=&quot;org.springframework.security.cas.web.CasAuthenticationFilter&quot;&gt;</div><div class="line">  &lt;property name=&quot;authenticationManager&quot; ref=&quot;authenticationManager&quot; /&gt;</div><div class="line">  &lt;!-- 指定处理地址，不指定时默认将会是“/j_spring_cas_security_check” --&gt;</div><div class="line">  &lt;property name=&quot;filterProcessesUrl&quot; value=&quot;/j_spring_cas_security_check&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>1.3 <strong>配置AuthenticationManager</strong><br>&emsp;&emsp;CasAuthenticationFilter会将封装好的包含Cas Server传递过来的ticket的Authentication对象传递给AuthenticationManager进行认证。我们知道默认的AuthenticationManager实现类为ProviderManager，而ProviderManager中真正进行认证的是AuthenticationProvider。所以接下来我们要在AuthenticationManager中配置一个能够处理CasAuthenticationFilter传递过来的Authentication对象的AuthenticationProvider实现，CasAuthenticationProvider。CasAuthenticationProvider首先会利用TicketValidator（Cas概念）对Authentication中包含的ticket信息进行认证。认证通过后将利用持有的AuthenticationUserDetailsService根据认证通过后回传的Assertion对象中拥有的username加载用户对应的UserDetails，即主要是加载用户的相关权限信息GrantedAuthority。然后构造一个CasAuthenticationToken进行返回。之后的逻辑就是正常的Spring Security的逻辑了。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:authentication-manager</span> <span class="attr">alias</span>=<span class="string">"authenticationManager"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:authentication-provider</span> <span class="attr">ref</span>=<span class="string">"casAuthenticationProvider"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"casAuthenticationProvider"</span></span></div><div class="line"><span class="attr">class</span>=<span class="string">"org.springframework.security.cas.authentication.CasAuthenticationProvider"</span>&gt;</div><div class="line">  <span class="comment">&lt;!-- 通过username来加载UserDetails --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationUserDetailsService"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 真正加载UserDetails的UserDetailsService实现 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"userDetailsService"</span> /&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceProperties"</span> <span class="attr">ref</span>=<span class="string">"serviceProperties"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 配置TicketValidator在登录认证成功后验证ticket --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"ticketValidator"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.jasig.cas.client.validation.Cas20ServiceTicketValidator"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- Cas Server访问地址的前缀，即根路径--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"https://localhost:8443/cas"</span> /&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"key"</span> <span class="attr">value</span>=<span class="string">"key4CasAuthenticationProvider"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDetailsService"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>经过以上三步配置以后，我们的Spring Security应用就已经跟Cas整合好了，可以在需要登录的时候通过Cas Server进行单点登录了。</p>
<p>二. <strong>单点登出</strong><br>&emsp;&emsp;Spring Security应用整合Cas Client配置单点登出功能实际和单独使用Cas Client配置单点登出功能一样，其根本都是通过配置一个SingleSignOutFilter响应Cas Server单点登出时的回调，配置一个SingleSignOutHttpSessionListener用于在Session过期时删除SingleSignOutFilter存放的对应信息。SingleSignOutFilter需要配置在Cas 的AuthenticationFilter之前，对于Spring Security应用而言，该Filter通常是配置在Spring Security的配置文件中，而且是配置在CAS_FILTER之前。所以我们可以在Spring Security的配置文件中进行如下配置。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span> <span class="attr">entry-point-ref</span>=<span class="string">"casEntryPoint"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- SingleSignOutFilter放在CAS_FILTER之前 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:custom-filter</span> <span class="attr">ref</span>=<span class="string">"casLogoutFilter"</span> <span class="attr">before</span>=<span class="string">"CAS_FILTER"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:custom-filter</span> <span class="attr">ref</span>=<span class="string">"casFilter"</span> <span class="attr">position</span>=<span class="string">"CAS_FILTER"</span>/&gt;</span></div><div class="line">  ...</div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"casLogoutFilter"</span> <span class="attr">class</span>=<span class="string">"org.jasig.cas.client.session.SingleSignOutFilter"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>然后跟单独使用Cas Client一样，在web.xml文件中配置一个SingleSignOutHttpSessionListener。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;listener&gt;</div><div class="line">    &lt;listener-class&gt;org.jasig.cas.client.session.SingleSignOutHttpSessionListener&lt;/listener-class&gt;</div><div class="line">&lt;/listener&gt;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;经过以上配置在访问Cas Server的logout地址（如：<a href="https://localhost:8443/cas/logout）进行登出时，Cas" target="_blank" rel="external">https://localhost:8443/cas/logout）进行登出时，Cas</a> Server登出后将回调其中注册的每一个Service（Cas概念，即client应用），此时在client应用中配置好的SingleSignOutFilter将处理对应Client应用的登出操作。<br>&emsp;&emsp;虽然以上配置可以满足我们在Spring Security应用中的单点登出要求，但Cas官方文档和Spring Security官方文档都推荐我们在Cas Client应用进行登出操作时，不是直接访问Cas Server的logout，而是先登出本应用，然后告诉用户其当前登出的只是本应用，再提供一个对应Cas Server的链接，使其可以进行真正的单点登出。对此，Spring Security官方文档中给我们提供例子是提供两个LogoutFilter，一个是登出当前Spring Security应用，一个是登出Cas Server的。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span> <span class="attr">entry-point-ref</span>=<span class="string">"casEntryPoint"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 请求登出Cas Server的过滤器，放在Spring Security的登出过滤器之前 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:custom-filter</span> <span class="attr">ref</span>=<span class="string">"requestCasLogoutFilter"</span> <span class="attr">before</span>=<span class="string">"LOGOUT_FILTER"</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- SingleSignOutFilter放在CAS_FILTER之前 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:custom-filter</span> <span class="attr">ref</span>=<span class="string">"casLogoutFilter"</span> <span class="attr">before</span>=<span class="string">"CAS_FILTER"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:custom-filter</span> <span class="attr">ref</span>=<span class="string">"casFilter"</span> <span class="attr">position</span>=<span class="string">"CAS_FILTER"</span>/&gt;</span></div><div class="line">  ...</div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"requestCasLogoutFilter"</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.web.authentication.logout.LogoutFilter"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 指定登出成功后需要跳转的地址，这里指向Cas Server的登出URL，以实现单点登出 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"https://localhost:8443/cas/logout"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></div><div class="line">   <span class="comment">&lt;!-- 该Filter需要处理的地址，默认是Spring Security的默认登出地址“/j_spring_security_logout”--&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filterProcessesUrl"</span> <span class="attr">value</span>=<span class="string">"/j_spring_cas_security_logout"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>此外，Spring Security推荐我们在使用Cas Server的单点登出时一起使用CharacterEncodingFilter，以避免SingleSignOutFilter在获取参数时出现编码问题。</p>
<p>三. <strong>使用代理</strong><br>&emsp;&emsp;使用Cas Proxy时有两个主体，代理端和被代理端。而且我们知道代理端和被代理端针对Cas20ProxyReceivingTicketValidationFilter的配置是不一样的，虽然整合Cas的Spring Security应用不再使用Cas20ProxyReceivingTicketValidationFilter了，但其底层的核心机制是一样的。所以Cas整合Spring Security后的应用在作为代理端和被代理端时的配置也是不一样的。接下来将分开讲解Spring Security应用作为代理端和被代理端整合Cas后的配置。</p>
<p>3.1 <strong>代理端</strong><br>&emsp;&emsp;首先需要为CasAuthenticationFilter多指定两个参数，proxyReceptorUrl和proxyGrantingTicketStorage。proxyReceptorUrl用以指定Cas Server在回调代理端传递pgtId和pgtIou时回调地址相对于代理端的路径，如“/proxyCallback”，CasAuthenticationFilter会根据proxyReceptorUrl来确定一个请求是否来自Cas Server针对proxy的回调。如果是则需要接收Cas Server传递过来的pgtId和pgtIou，并将它们保存在持有的ProxyGrantingTicketStorage中。CasAuthenticationProvider之后会从ProxyGrantingTicketStorage中获取对应的pgtId，即proxy granting ticket，并将其保存在AttributePrincipal中，而AttributePrincipal又会保存到对应的Assertion中。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 配置ProxyGrantingTicketStorage，用以保存pgtId和pgtIou --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"proxyGrantingTicketStorage"</span> <span class="attr">class</span>=<span class="string">"org.jasig.cas.client.proxy.ProxyGrantingTicketStorageImpl"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"casFilter"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.cas.web.CasAuthenticationFilter"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationManager"</span> <span class="attr">ref</span>=<span class="string">"authenticationManager"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 指定处理地址，不指定时默认将会是“/j_spring_cas_security_check” --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filterProcessesUrl"</span> <span class="attr">value</span>=<span class="string">"/j_spring_cas_security_check"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"proxyGrantingTicketStorage"</span> <span class="attr">ref</span>=<span class="string">"proxyGrantingTicketStorage"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"proxyReceptorUrl"</span> <span class="attr">value</span>=<span class="string">"/proxyCallback"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;其次是需要将CasAuthenticationProvider持有的TicketValidator由Cas20ServiceTicketValidator改成Cas20ProxyTicketValidator。其需要配置一个ProxyGrantingTicketStorage用来获取proxy granting ticket，即我们熟知的pgtId。在单独使用Cas Proxy时，Cas20ProxyReceivingTicketValidationFilter内部默认持有一个ProxyGrantingTicketStorage实现，其使用的Cas20ProxyTicketValidator也将使用该ProxyGrantingTicketStorage。整合Spring Security之后， Spring Security不使用Cas20ProxyReceivingTicketValidationFilter，而直接由CasAuthenticationFilter获取proxy granting ticket，由CasAuthenticationProvider对ticket进行校验。Cas20ProxyTicketValidator内部没默认的ProxyGrantingTicketStorage，所以在配置Cas20ProxyTicketValidator时我们需要给其指定一个ProxyGrantingTicketStorage实现。此外还需要为Cas20ProxyTicketValidator指定一个proxyCallbackUrl用以指定在Cas20ProxyTicketValidator通过Cas Server校验service ticket成功后将回调哪个地址以传递pgtId和pgtIou。proxyCallbackUrl默认情况下必须使用https协议，而应用的其它请求可以用非https协议。其它的配置和Cas20ServiceTicketValidator一样，Cas20ProxyTicketValidator的父类其实就是Cas20ServiceTicketValidator。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;casAuthenticationProvider&quot;</div><div class="line">   class=&quot;org.springframework.security.cas.authentication.CasAuthenticationProvider&quot;&gt;</div><div class="line">  &lt;!-- 通过username来加载UserDetails --&gt;</div><div class="line">  &lt;property name=&quot;authenticationUserDetailsService&quot;&gt;</div><div class="line">     &lt;bean class=&quot;org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper&quot;&gt;</div><div class="line">        &lt;!-- 真正加载UserDetails的UserDetailsService实现 --&gt;</div><div class="line">        &lt;constructor-arg ref=&quot;userDetailsService&quot; /&gt;</div><div class="line">     &lt;/bean&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line">  &lt;property name=&quot;serviceProperties&quot; ref=&quot;serviceProperties&quot; /&gt;</div><div class="line">  &lt;!-- 配置TicketValidator在登录认证成功后验证ticket --&gt;</div><div class="line">  &lt;property name=&quot;ticketValidator&quot;&gt;</div><div class="line">     &lt;bean class=&quot;org.jasig.cas.client.validation.Cas20ProxyTicketValidator&quot;&gt;</div><div class="line">        &lt;!-- Cas Server访问地址的前缀，即根路径--&gt;</div><div class="line">        &lt;constructor-arg index=&quot;0&quot; value=&quot;https://localhost:8443/cas&quot; /&gt;</div><div class="line">        &lt;!-- 指定Cas Server回调传递pgtId和pgtIou的地址，该地址必须使用https协议 --&gt;</div><div class="line">        &lt;property name=&quot;proxyCallbackUrl&quot; value=&quot;https://elim:8043/app/proxyCallback&quot;/&gt;</div><div class="line">        &lt;property name=&quot;proxyGrantingTicketStorage&quot; ref=&quot;proxyGrantingTicketStorage&quot;/&gt;</div><div class="line">     &lt;/bean&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line">  &lt;property name=&quot;key&quot; value=&quot;key4CasAuthenticationProvider&quot; /&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;经过以上步骤后我们整合Cas后的Spring Security应用就可以作为代理端使用Cas proxy访问其它被Cas保护的应用了，当然前提是其它被代理端能够接受我们应用的代理，了解Cas Proxy的人应该都知道这一点，在接下来的Spring Security应用整合Cas作为被代理端中也会讲到这部分内容。这里我们假设现在有一个应用app2能够接受我们应用的代理访问，那么在基于上述配置的应用中我们可以通过如下代码访问app2。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/cas/test"</span>)</div><div class="line">publicclass CasTestController &#123;</div><div class="line"> </div><div class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/getData"</span>)</div><div class="line">   <span class="function">publicvoid <span class="title">getDataFromApp</span><span class="params">(PrintWriter writer)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">      <span class="comment">//1、从SecurityContextHolder获取到当前的Authentication对象，其是一个CasAuthenticationToken</span></div><div class="line">      CasAuthenticationToken cat = (CasAuthenticationToken)SecurityContextHolder.getContext().getAuthentication();</div><div class="line">      <span class="comment">//2、获取到AttributePrincipal对象</span></div><div class="line">      AttributePrincipal principal = cat.getAssertion().getPrincipal();</div><div class="line">      <span class="comment">//3、获取对应的proxy ticket</span></div><div class="line">      String proxyTicket = principal.getProxyTicketFor(<span class="string">"http://localhost:8081/app2/getData.jsp"</span>);</div><div class="line">      <span class="comment">//4、请求被代理应用时将获取到的proxy ticket以参数ticket进行传递</span></div><div class="line">      URL url = <span class="keyword">new</span> URL(<span class="string">"http://localhost:8081/app2/getData.jsp?ticket="</span> + URLEncoder.encode(proxyTicket, <span class="string">"UTF-8"</span>));</div><div class="line">      HttpURLConnection conn = (HttpURLConnection)url.openConnection();</div><div class="line">      BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(conn.getInputStream(), <span class="string">"UTF-8"</span>));</div><div class="line">      StringBuffer content = <span class="keyword">new</span> StringBuffer();</div><div class="line">      String line = <span class="keyword">null</span>;</div><div class="line">      <span class="keyword">while</span> ((line=br.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line">         content.append(line).append(<span class="string">"&lt;br/&gt;"</span>);</div><div class="line">      &#125;</div><div class="line">      writer.write(content.toString());</div><div class="line">   &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;需要注意的是通过AttributePrincipal的getProxyTicketFor()方法获取proxy ticket时，每调用一次都会获取一个全新的proxy ticket。用户可以根据自己的需要将获取到的proxy ticket按照指定的URL缓存起来，以避免每次都去针对同一个URL获取一个全新的proxy ticket。此外，如果在被代理端认证时根据proxy ticket缓存了Authentication的话也需要我们在代理端保证针对同一URL传递过去的proxy ticket是一样的，否则被代理端针对proxy ticket缓存Authentication的功能就没用了。  </p>
<p>3.2 <strong>被代理端</strong><br>&emsp;&emsp;Spring Security应用整合Cas使用Cas Proxy作为被代理端时主要需要进行三点修改。<br>&emsp;&emsp;第一点是通过ServiceProperties指定CasAuthenticationFilter的authenticateAllArtifacts为true，这样CasAuthenticationFilter将会尝试对所有ticket进行认证，而不是只认证来自filterProccessUrl指定地址的请求。这样代理端在请求被代理端的资源时将proxy ticket以参数ticket进行传递时，CasAuthenticationFilter才会让CasAuthenticationProvider对proxy ticket进行校验，这样我们的请求才有可能被CasAuthenticationProvider认证成功并请求到真正的资源。<br>&emsp;&emsp;第二点是指定CasAuthenticationFilter使用的AuthenticationDetailsSource为ServiceAuthenticationDetailsSource。CasAuthenticationFilter默认使用的是WebAuthenticationDetailsSource。ServiceAuthenticationDetailsSource将构建一个ServiceAuthenticationDetails对象作为当前Authentication的details对象。ServiceAuthenticationDetailsSource构建的ServiceAuthenticationDetails对象会将当前请求的地址构建为一个serviceUrl，通过其getServiceUrl()方法可以获取到该serviceUrl地址。之后该Authentication对象传递到CasAuthenticationProvider进行认证时就可以从Authentication的details中获取到对应的serviceUrl，并在通过Cas Server对代理端以参数ticket传递过来的proxy ticket进行验证时连同对应的serviceUrl一起传递过去。因为之前代理端申请proxy ticket时就是通过该serviceUrl进行申请的，Cas Server需要对于它们的配对来验证对应的proxy ticket是否有效。<br>&emsp;&emsp;第三点是将CasAuthenticationProvider的TicketValidator由Cas20ServiceTicketValidator改为Cas20ProxyTicketValidator，因为Cas Proxy被代理端需要调用Cas Server的proxyValidator对代理端传递过来的proxy ticket进行验证。此外需要通过acceptAnyProxy或allowedProxyChains指定将接受哪些代理。acceptAnyProxy用以指定是否接受所有的代理，可选值为true或false。allowedProxyChains则用以指定具体接受哪些代理，其对应的值是代理端在获取pgtId时提供给Cas Server的回调地址，如我们需要接受前面示例中代理端的代理，则我们的allowedProxyChains的值应该是“<a href="https://localhost:8043/app/proxyCallback”。如果需要接受多个代理端的代理，则在指定allowedProxyChains时多个代理端回调地址应各占一行。" target="_blank" rel="external">https://localhost:8043/app/proxyCallback”。如果需要接受多个代理端的代理，则在指定allowedProxyChains时多个代理端回调地址应各占一行。</a><br>&emsp;&emsp; 针对以上三点，我们的Spring Security应用整合Cas作为Cas Proxy的被代理端时需要对我们的配置进行如下改造。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 指定service相关信息 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"serviceProperties"</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.cas.ServiceProperties"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- Cas Server认证成功后的跳转地址，这里要跳转到我们的Spring Security应用，之后会由CasAuthenticationFilter处理，默认处理地址为/j_spring_cas_security_check --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"service"</span></span></div><div class="line">     <span class="attr">value</span>=<span class="string">"http://localhost:8083/app2/j_spring_cas_security_check"</span> /&gt;</div><div class="line">  <span class="comment">&lt;!-- 通过ServiceProperties指定CasAuthenticationFilter的authenticateAllArtifacts为true --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticateAllArtifacts"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"casFilter"</span></span></div><div class="line">  <span class="attr">class</span>=<span class="string">"org.springframework.security.cas.web.CasAuthenticationFilter"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationManager"</span> <span class="attr">ref</span>=<span class="string">"authenticationManager"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 指定处理地址，不指定时默认将会是“/j_spring_cas_security_check” --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filterProcessesUrl"</span> <span class="attr">value</span>=<span class="string">"/j_spring_cas_security_check"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 通过ServiceProperties指定CasAuthenticationFilter的authenticateAllArtifacts为true  --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceProperties"</span> <span class="attr">ref</span>=<span class="string">"serviceProperties"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 指定使用的AuthenticationDetailsSource为ServiceAuthenticationDetailsSource --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationDetailsSource"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.cas.web.authentication.ServiceAuthenticationDetailsSource"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"casAuthenticationProvider"</span></span></div><div class="line"><span class="attr">class</span>=<span class="string">"org.springframework.security.cas.authentication.CasAuthenticationProvider"</span>&gt;</div><div class="line">  <span class="comment">&lt;!-- 通过username来加载UserDetails --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationUserDetailsService"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 真正加载UserDetails的UserDetailsService实现 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"userDetailsService"</span> /&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceProperties"</span> <span class="attr">ref</span>=<span class="string">"serviceProperties"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 配置TicketValidator在登录认证成功后验证ticket --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"ticketValidator"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.jasig.cas.client.validation.Cas20ProxyTicketValidator"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- Cas Server访问地址的前缀，即根路径--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"https://localhost:8443/cas"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"allowedProxyChains"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>https://localhost:8043/app/proxyCallback<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"key"</span> <span class="attr">value</span>=<span class="string">"key4CasAuthenticationProvider"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;此外，对于被代理端而言，代理端在对其进行访问时都被认为是无状态的。对于无状态的认证CasAuthenticationProvider将在认证成功后将对应的Authentication对象以proxy tickit为key存放到所持有的StatelessTicketCache中，然后在下次代理端访问时将优先根据代理端传递过来的proxy ticket从StatelessTicketCache中获取Authentication对象，如果存在则不再进行认证，否则将继续进行认证。CasAuthenticationProvider默认持有的StatelessTicketCache为NullStatelessTicketCache，其所有的实现都是空的。所以默认情况下，被代理端在被代理端访问时将每次都对代理端进行认证。如果用户不希望在被代理端每次都对代理端的请求进行认证，则可以为被代理端的CasAuthenticationProvider指定一个StatelessTicketCache。用户可以实现自己的StatelessTicketCache，并指定CasAuthenticationProvider使用的StatelessTicketCache为该StatelessTicketCache。不过也可以使用Spring Security为我们提供的EhCacheBasedTicketCache。EhCacheBasedTicketCache是基于Ehcache实现的一个StatelessTicketCache。以下是一个为CasAuthenticationProvider配置EhCacheBasedTicketCache的示例。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"casAuthenticationProvider"</span></span></div><div class="line">   <span class="attr">class</span>=<span class="string">"org.springframework.security.cas.authentication.CasAuthenticationProvider"</span>&gt;</div><div class="line">……</div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"statelessTicketCache"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.cas.authentication.EhCacheBasedTicketCache"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- Ehcache对象 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cache"</span> <span class="attr">ref</span>=<span class="string">"proxyTicketCache"</span>/&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">……</div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 定义一个Ehcache --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"proxyTicketCache"</span> <span class="attr">class</span>=<span class="string">"org.springframework.cache.ehcache.EhCacheFactoryBean"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheName"</span> <span class="attr">value</span>=<span class="string">"proxyTicketCache"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeToLive"</span> <span class="attr">value</span>=<span class="string">"600"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;需要注意的是在代理端通过AttributePrincipal的getProxyTicketFor()方法获取到的proxy ticket每次都是不一样的，所以在被代理端通过StatelessTicketCache根据proxy ticket缓存认证对象Authentication时只有在同一proxy ticket能够请求多次的情况下才会有用，这也就要求我们在代理端同样能将proxy ticket缓存起来，以在请求同一地址时能使用相同的proxy ticket。    </p>
<p>3.3 <strong>既为代理端又为被代理端</strong><br>&emsp;&emsp;Cas Proxy的代理端和被代理端是相互独立的，所以一个Cas应用既可以作为代理端去访问其它Cas应用，也可以作为被代理端被其它应用访问。当Spring Security应用整合Cas后既想作为Cas Proxy的代理端访问其它Cas应用，也想作为被代理端被其它Cas应用访问时只需要将上述作为代理端的配置和作为被代理端的配置整到一起就行了。以下是一段示例代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 指定service相关信息 --&gt;</div><div class="line">&lt;bean id=&quot;serviceProperties&quot; class=&quot;org.springframework.security.cas.ServiceProperties&quot;&gt;</div><div class="line">&lt;!-- Cas Server认证成功后的跳转地址，这里要跳转到我们的Spring Security应用，之后会由CasAuthenticationFilter处理，默认处理地址为/j_spring_cas_security_check --&gt;</div><div class="line">&lt;property name=&quot;service&quot;</div><div class="line"> value=&quot;http://localhost:8080/app /j_spring_cas_security_check&quot; /&gt;</div><div class="line">&lt;property name=&quot;authenticateAllArtifacts&quot; value=&quot;true&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;!-- 配置ProxyGrantingTicketStorage，用以保存pgtId和pgtIou --&gt;</div><div class="line">&lt;bean id=&quot;proxyGrantingTicketStorage&quot; class=&quot;org.jasig.cas.client.proxy.ProxyGrantingTicketStorageImpl&quot;/&gt;</div><div class="line"></div><div class="line">&lt;bean id=&quot;casFilter&quot;</div><div class="line">  class=&quot;org.springframework.security.cas.web.CasAuthenticationFilter&quot;&gt;</div><div class="line">  &lt;property name=&quot;authenticationManager&quot; ref=&quot;authenticationManager&quot; /&gt;</div><div class="line">  &lt;!-- 指定处理地址，不指定时默认将会是“/j_spring_cas_security_check” --&gt;</div><div class="line">  &lt;property name=&quot;filterProcessesUrl&quot; value=&quot;/j_spring_cas_security_check&quot;/&gt;</div><div class="line">  &lt;property name=&quot;proxyGrantingTicketStorage&quot; ref=&quot;proxyGrantingTicketStorage&quot;/&gt;</div><div class="line">  &lt;property name=&quot;proxyReceptorUrl&quot; value=&quot;/proxyCallback&quot;/&gt;</div><div class="line">  &lt;!-- 通过ServiceProperties指定CasAuthenticationFilter的authenticateAllArtifacts为true  --&gt;</div><div class="line">  &lt;property name=&quot;serviceProperties&quot; ref=&quot;serviceProperties&quot; /&gt;</div><div class="line">  &lt;!-- 指定使用的AuthenticationDetailsSource为ServiceAuthenticationDetailsSource --&gt;</div><div class="line">  &lt;property name=&quot;authenticationDetailsSource&quot;&gt;</div><div class="line">     &lt;bean class=&quot;org.springframework.security.cas.web.authentication.ServiceAuthenticationDetailsSource&quot; /&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;bean id=&quot;casAuthenticationProvider&quot;</div><div class="line">class=&quot;org.springframework.security.cas.authentication.CasAuthenticationProvider&quot;&gt;</div><div class="line">  &lt;!-- 通过username来加载UserDetails --&gt;</div><div class="line">  &lt;property name=&quot;authenticationUserDetailsService&quot;&gt;</div><div class="line">     &lt;bean class=&quot;org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper&quot;&gt;</div><div class="line">        &lt;!-- 真正加载UserDetails的UserDetailsService实现 --&gt;</div><div class="line">        &lt;constructor-arg ref=&quot;userDetailsService&quot; /&gt;</div><div class="line">     &lt;/bean&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line">  &lt;property name=&quot;serviceProperties&quot; ref=&quot;serviceProperties&quot; /&gt;</div><div class="line">  &lt;!-- 配置TicketValidator在登录认证成功后验证ticket --&gt;</div><div class="line">  &lt;property name=&quot;ticketValidator&quot;&gt;</div><div class="line">     &lt;bean class=&quot;org.jasig.cas.client.validation.Cas20ProxyTicketValidator&quot;&gt;</div><div class="line">        &lt;!-- Cas Server访问地址的前缀，即根路径--&gt;</div><div class="line">        &lt;constructor-arg index=&quot;0&quot; value=&quot;https://localhost:8443/cas&quot; /&gt;</div><div class="line">        &lt;!-- 指定Cas Server回调传递pgtId和pgtIou的地址，该地址必须使用https协议 --&gt;</div><div class="line">        &lt;property name=&quot;proxyCallbackUrl&quot; value=&quot;https://elim:8043/app/proxyCallback&quot;/&gt;</div><div class="line">        &lt;property name=&quot;proxyGrantingTicketStorage&quot; ref=&quot;proxyGrantingTicketStorage&quot;/&gt;</div><div class="line">        &lt;!-- 作为被代理端时配置接收任何代理 --&gt;</div><div class="line">        &lt;property name=&quot;acceptAnyProxy&quot; value=&quot;true&quot;/&gt;</div><div class="line">     &lt;/bean&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line">  &lt;property name=&quot;key&quot; value=&quot;key4CasAuthenticationProvider&quot; /&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Spring/Security/配置二十：整合Cas/" data-id="cjfvvphm20094m9fyy7jjgywl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/Security/配置九：Filter" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/15/Spring/Security/配置九：Filter/" class="article-date">
  <time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/Security/">Security</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Spring/Security/配置九：Filter/">配置九：Filter</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Spring Security的底层是通过一系列的Filter来管理的，每个Filter都有其自身的功能，而且各个Filter在功能上还有关联关系，所以它们的顺序也是非常重要的。</p>
</blockquote>
<p>一. <strong>Filter顺序</strong><br>Spring Security已经定义了一些Filter，不管实际应用中你用到了哪些，它们应当保持如下顺序。<br>（1）ChannelProcessingFilter，如果你访问的channel错了，那首先就会在channel之间进行跳转，如http变为https。<br>（2）SecurityContextPersistenceFilter，这样的话在一开始进行request的时候就可以在SecurityContextHolder中建立一个SecurityContext，然后在请求结束的时候，任何对SecurityContext的改变都可以被copy到HttpSession。<br>（3）ConcurrentSessionFilter，因为它需要使用SecurityContextHolder的功能，而且更新对应session的最后更新时间，以及通过SessionRegistry获取当前的SessionInformation以检查当前的session是否已经过期，过期则会调用LogoutHandler。<br>（4）认证处理机制，如UsernamePasswordAuthenticationFilter，CasAuthenticationFilter，BasicAuthenticationFilter等，以至于SecurityContextHolder可以被更新为包含一个有效的Authentication请求。<br>（5）SecurityContextHolderAwareRequestFilter，它将会把HttpServletRequest封装成一个继承自HttpServletRequestWrapper的SecurityContextHolderAwareRequestWrapper，同时使用SecurityContext实现了HttpServletRequest中与安全相关的方法。<br>（6）JaasApiIntegrationFilter，如果SecurityContextHolder中拥有的Authentication是一个JaasAuthenticationToken，那么该Filter将使用包含在JaasAuthenticationToken中的Subject继续执行FilterChain。<br>（7）RememberMeAuthenticationFilter，如果之前的认证处理机制没有更新SecurityContextHolder，并且用户请求包含了一个Remember-Me对应的cookie，那么一个对应的Authentication将会设给SecurityContextHolder。<br>（8）AnonymousAuthenticationFilter，如果之前的认证机制都没有更新SecurityContextHolder拥有的Authentication，那么一个AnonymousAuthenticationToken将会设给SecurityContextHolder。<br>（9）ExceptionTransactionFilter，用于处理在FilterChain范围内抛出的AccessDeniedException和AuthenticationException，并把它们转换为对应的Http错误码返回或者对应的页面。<br>（10）FilterSecurityInterceptor，保护Web URI，并且在访问被拒绝时抛出异常。  </p>
<p>二. <strong>添加Filter到FilterChain</strong><br>&emsp;&emsp;当我们在使用NameSpace时，Spring Security是会自动为我们建立对应的FilterChain以及其中的Filter。但有时我们可能需要添加我们自己的Filter到FilterChain，又或者是因为某些特性需要自己显示的定义Spring Security已经为我们提供好的Filter，然后再把它们添加到FilterChain。使用NameSpace时添加Filter到FilterChain是通过http元素下的custom-filter元素来定义的。定义custom-filter时需要我们通过ref属性指定其对应关联的是哪个Filter，此外还需要通过position、before或者after指定该Filter放置的位置。Spring Security对FilterChain中Filter顺序是有严格的规定的。Spring Security对那些内置的Filter都指定了一个别名，同时指定了它们的位置。我们在定义custom-filter的position、before和after时使用的值就是对应着这些别名所处的位置。如position=”CAS_FILTER”就表示将定义的Filter放在CAS_FILTER对应的那个位置，before=”CAS_FILTER”就表示将定义的Filter放在CAS_FILTER之前，after=”CAS_FILTER”就表示将定义的Filter放在CAS_FILTER之后。此外还有两个特殊的位置可以指定，FIRST和LAST，分别对应第一个和最后一个Filter，如你想把定义好的Filter放在最后，则可以使用after=”LAST”。<br>&emsp;&emsp;接下来我们来看一下Spring Security给我们定义好的FilterChain中Filter对应的位置顺序、它们的别名以及将触发自动添加到FilterChain的元素或属性定义。下面的定义是按顺序的。</p>
<table>
<thead>
<tr>
<th>别名</th>
<th>Filter类</th>
<th>对应元素或属性</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>CHANNEL_FILTER</td>
<td>ChannelProcessingFilter</td>
<td>http/intercept-url@requires-channel</td>
<td></td>
</tr>
<tr>
<td>SECURITY_CONTEXT_FILTER</td>
<td>SecurityContextPersistenceFilter</td>
<td>http</td>
<td></td>
</tr>
<tr>
<td>CONCURRENT_SESSION_FILTER</td>
<td>ConcurrentSessionFilter</td>
<td>http/session-management/concurrency-control</td>
<td></td>
</tr>
<tr>
<td>LOGOUT_FILTER</td>
<td>LogoutFilter</td>
<td>http/logout</td>
<td></td>
</tr>
<tr>
<td>X509_FILTER</td>
<td>X509AuthenticationFilter</td>
<td>http/x509</td>
<td></td>
</tr>
<tr>
<td>PRE_AUTH_FILTER</td>
<td>AstractPreAuthenticatedProcessingFilter 的子类</td>
<td>无</td>
<td></td>
</tr>
<tr>
<td>CAS_FILTER</td>
<td>CasAuthenticationFilter</td>
<td>无</td>
<td></td>
</tr>
<tr>
<td>FORM_LOGIN_FILTER</td>
<td>UsernamePasswordAuthenticationFilter</td>
<td>http/form-login</td>
<td></td>
</tr>
<tr>
<td>BASIC_AUTH_FILTER</td>
<td>BasicAuthenticationFilter</td>
<td>http/http-basic</td>
<td></td>
</tr>
<tr>
<td>SERVLET_API_SUPPORT_FILTER</td>
<td>SecurityContextHolderAwareRequestFilter</td>
<td>http@servlet-api-provision</td>
<td></td>
</tr>
<tr>
<td>JAAS_API_SUPPORT_FILTER</td>
<td>JaasApiIntegrationFilter</td>
<td>http@jaas-api-provision</td>
<td></td>
</tr>
<tr>
<td>REMEMBER_ME_FILTER</td>
<td>RememberMeAuthenticationFilter</td>
<td>http/remember-me</td>
<td></td>
</tr>
<tr>
<td>ANONYMOUS_FILTER</td>
<td>AnonymousAuthenticationFilter</td>
<td>http/anonymous</td>
<td></td>
</tr>
<tr>
<td>SESSION_MANAGEMENT_FILTER</td>
<td>SessionManagementFilter</td>
<td>http/session-management</td>
<td></td>
</tr>
<tr>
<td>EXCEPTION_TRANSLATION_FILTER</td>
<td>ExceptionTranslationFilter</td>
<td>http</td>
<td></td>
</tr>
<tr>
<td>FILTER_SECURITY_INTERCEPTOR</td>
<td>FilterSecurityInterceptor</td>
<td>http</td>
<td></td>
</tr>
<tr>
<td>SWITCH_USER_FILTER</td>
<td>SwitchUserFilter</td>
<td>无</td>
</tr>
</tbody>
</table>
<p>三. <strong>DelegatingFilterProxy</strong><br>&emsp;&emsp;可能你会觉得奇怪，我们在web应用中使用Spring Security时只在web.xml文件中定义了如下这样一个Filter，为什么你会说是一系列的Filter呢？<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSecurityFilterChain<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSecurityFilterChain<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;而且如果你不在web.xml文件声明要使用的Filter，那么Servlet容器将不会发现它们，它们又怎么发生作用呢？这就是上述配置中DelegatingFilterProxy的作用了。<br>&emsp;&emsp;DelegatingFilterProxy是Spring中定义的一个Filter实现类，其作用是代理真正的Filter实现类，也就是说在调用DelegatingFilterProxy的doFilter()方法时实际上调用的是其代理Filter的doFilter()方法。其代理Filter必须是一个Spring bean对象，所以使用DelegatingFilterProxy的好处就是其代理Filter类可以使用Spring的依赖注入机制方便自由的使用ApplicationContext中的bean。那么DelegatingFilterProxy如何知道其所代理的Filter是哪个呢？这是通过其自身的一个叫targetBeanName的属性来确定的，通过该名称，DelegatingFilterProxy可以从WebApplicationContext中获取指定的bean作为代理对象。该属性可以通过在web.xml中定义DelegatingFilterProxy时通过init-param来指定，如果未指定的话将默认取其在web.xml中声明时定义的名称。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSecurityFilterChain<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSecurityFilterChain<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在上述配置中，DelegatingFilterProxy代理的就是名为SpringSecurityFilterChain的Filter。<br>&emsp;&emsp;需要注意的是被代理的Filter的初始化方法init()和销毁方法destroy()默认是不会被执行的。通过设置DelegatingFilterProxy的targetFilterLifecycle属性为true，可以使被代理Filter与DelegatingFilterProxy具有同样的生命周期。</p>
<p>四. <strong>FilterChainProxy</strong><br>&emsp;&emsp;Spring Security底层是通过一系列的Filter来工作的，每个Filter都有其各自的功能，而且各个Filter之间还有关联关系，所以它们的组合顺序也是非常重要的。<br>&emsp;&emsp;使用Spring Security时，DelegatingFilterProxy代理的就是一个FilterChainProxy。一个FilterChainProxy中可以包含有多个FilterChain，但是某个请求只会对应一个FilterChain，而一个FilterChain中又可以包含有多个Filter。当我们使用基于Spring Security的NameSpace进行配置时，系统会自动为我们注册一个名为springSecurityFilterChain类型为FilterChainProxy的bean（这也是为什么我们在使用SpringSecurity时需要在web.xml中声明一个name为springSecurityFilterChain类型为DelegatingFilterProxy的Filter了。），而且每一个http元素的定义都将拥有自己的FilterChain，而FilterChain中所拥有的Filter则会根据定义的服务自动增减。所以我们不需要显示的再定义这些Filter对应的bean了，除非你想实现自己的逻辑，又或者你想定义的某个属性NameSpace没有提供对应支持等。<br>&emsp;&emsp;Spring security允许我们在配置文件中配置多个http元素，以针对不同形式的URL使用不同的安全控制。Spring Security将会为每一个http元素创建对应的FilterChain，同时按照它们的声明顺序加入到FilterChainProxy。所以当我们同时定义多个http元素时要确保将更具有特性的URL配置在前。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span> <span class="attr">pattern</span>=<span class="string">"/login*.jsp*"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></div><div class="line"><span class="comment">&lt;!-- http元素的pattern属性指定当前的http对应的FilterChain将匹配哪些URL，如未指定将匹配所有的请求 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">security:http</span> <span class="attr">pattern</span>=<span class="string">"/admin/**"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_ADMIN"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">security:http</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;需要注意的是http拥有一个匹配URL的pattern，未指定时表示匹配所有的请求，其下的子元素intercept-url也有一个匹配URL的pattern，该pattern是在http元素对应pattern基础上的，也就是说一个请求必须先满足http对应的pattern才有可能满足其下intercept-url对应的pattern。</p>
<p>五. <strong>Spring Security定义好的核心Filter</strong><br>&emsp;&emsp;通过前面的介绍我们知道Spring Security是通过Filter来工作的，为保证Spring Security的顺利运行，其内部实现了一系列的Filter。这其中有几个是在使用Spring Security的Web应用中必定会用到的。接下来我们来简要的介绍一下FilterSecurityInterceptor、ExceptionTranslationFilter、SecurityContextPersistenceFilter和UsernamePasswordAuthenticationFilter。在我们使用http元素时前三者会自动添加到对应的FilterChain中，当我们使用了form-login元素时UsernamePasswordAuthenticationFilter也会自动添加到FilterChain中。所以我们在利用custom-filter往FilterChain中添加自己定义的这些Filter时需要注意它们的位置。</p>
<p>六. <strong>FilterSecurityInterceptor</strong><br>&emsp;&emsp;FilterSecurityInterceptor是用于保护Http资源的，它需要一个AccessDecisionManager和一个AuthenticationManager的引用。它会从SecurityContextHolder获取Authentication，然后通过SecurityMetadataSource可以得知当前请求是否在请求受保护的资源。对于请求那些受保护的资源，如果Authentication.isAuthenticated()返回false或者FilterSecurityInterceptor的alwaysReauthenticate属性为true，那么将会使用其引用的AuthenticationManager再认证一次，认证之后再使用认证后的Authentication替换SecurityContextHolder中拥有的那个。然后就是利用AccessDecisionManager进行权限的检查。<br>&emsp;&emsp;我们在使用基于NameSpace的配置时所配置的intercept-url就会跟FilterChain内部的FilterSecurityInterceptor绑定。如果要自己定义FilterSecurityInterceptor对应的bean，那么该bean定义大致如下所示：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"filterSecurityInterceptor"</span></span></div><div class="line">   <span class="attr">class</span>=<span class="string">"org.springframework.security.web.access.intercept.FilterSecurityInterceptor"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationManager"</span> <span class="attr">ref</span>=<span class="string">"authenticationManager"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accessDecisionManager"</span> <span class="attr">ref</span>=<span class="string">"accessDecisionManager"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"securityMetadataSource"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">security:filter-security-metadata-source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/admin/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_ADMIN"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER,ROLE_ADMIN"</span> /&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">security:filter-security-metadata-source</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;filter-security-metadata-source用于配置其securityMetadataSource属性。intercept-url用于配置需要拦截的URL与对应的权限关系。</p>
<p>七. <strong>ExceptionTranslationFilter</strong><br>&emsp;&emsp;通过前面的介绍我们知道在Spring Security的Filter链表中ExceptionTranslationFilter就放在FilterSecurityInterceptor的前面。而ExceptionTranslationFilter是捕获来自FilterChain的异常，并对这些异常做处理。ExceptionTranslationFilter能够捕获来自FilterChain所有的异常，但是它只会处理两类异常，AuthenticationException和AccessDeniedException，其它的异常它会继续抛出。如果捕获到的是AuthenticationException，那么将会使用其对应的AuthenticationEntryPoint的commence()处理。如果捕获的异常是一个AccessDeniedException，那么将视当前访问的用户是否已经登录认证做不同的处理，如果未登录，则会使用关联的AuthenticationEntryPoint的commence()方法进行处理，否则将使用关联的AccessDeniedHandler的handle()方法进行处理。<br>&emsp;&emsp;AuthenticationEntryPoint是在用户没有登录时用于引导用户进行登录认证的，在实际应用中应根据具体的认证机制选择对应的AuthenticationEntryPoint。<br>&emsp;&emsp;AccessDeniedHandler用于在用户已经登录了，但是访问了其自身没有权限的资源时做出对应的处理。ExceptionTranslationFilter拥有的AccessDeniedHandler默认是AccessDeniedHandlerImpl，其会返回一个403错误码到客户端。我们可以通过显示的配置AccessDeniedHandlerImpl，同时给其指定一个errorPage使其可以返回对应的错误页面。当然我们也可以实现自己的AccessDeniedHandler。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exceptionTranslationFilter"</span></span></div><div class="line">      <span class="attr">class</span>=<span class="string">"org.springframework.security.web.access.ExceptionTranslationFilter"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationEntryPoint"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loginFormUrl"</span> <span class="attr">value</span>=<span class="string">"/login.jsp"</span> /&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accessDeniedHandler"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.web.access.AccessDeniedHandlerImpl"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"errorPage"</span> <span class="attr">value</span>=<span class="string">"/access_denied.jsp"</span> /&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在上述配置中我们指定了AccessDeniedHandler为AccessDeniedHandlerImpl，同时为其指定了errorPage，这样发生AccessDeniedException后将转到对应的errorPage上。指定了AuthenticationEntryPoint为使用表单登录的LoginUrlAuthenticationEntryPoint。此外，需要注意的是如果该filter是作为自定义filter加入到由NameSpace自动建立的FilterChain中时需把它放在内置的ExceptionTranslationFilter后面，否则异常都将被内置的ExceptionTranslationFilter所捕获。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:form-login</span> <span class="attr">login-page</span>=<span class="string">"/login.jsp"</span></span></div><div class="line">         <span class="attr">username-parameter</span>=<span class="string">"username"</span> <span class="attr">password-parameter</span>=<span class="string">"password"</span></div><div class="line">         <span class="attr">login-processing-url</span>=<span class="string">"/login.do"</span> /&gt;</div><div class="line">  <span class="comment">&lt;!-- 退出登录时删除session对应的cookie --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:logout</span> <span class="attr">delete-cookies</span>=<span class="string">"JSESSIONID"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 登录页面应当是不需要认证的 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/login*.jsp*"</span></span></div><div class="line">     <span class="attr">access</span>=<span class="string">"IS_AUTHENTICATED_ANONYMOUSLY"</span> /&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:custom-filter</span> <span class="attr">ref</span>=<span class="string">"exceptionTranslationFilter"</span> <span class="attr">after</span>=<span class="string">"EXCEPTION_TRANSLATION_FILTER"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在捕获到AuthenticationException之后，调用AuthenticationEntryPoint的commence()方法引导用户登录之前，ExceptionTranslationFilter还做了一件事，那就是使用RequestCache将当前HttpServletRequest的信息保存起来，以至于用户成功登录后需要跳转到之前的页面时可以获取到这些信息，然后继续之前的请求，比如用户可能在未登录的情况下发表评论，待用户提交评论的时候就会将包含评论信息的当前请求保存起来，同时引导用户进行登录认证，待用户成功登录后再利用原来的request包含的信息继续之前的请求，即继续提交评论，所以待用户登录成功后我们通常看到的是用户成功提交了评论之后的页面。Spring Security默认使用的RequestCache是HttpSessionRequestCache，其会将HttpServletRequest相关信息封装为一个SavedRequest保存在HttpSession中。</p>
<p>八. <strong>SecurityContextPersistenceFilter</strong><br>&emsp;&emsp;SecurityContextPersistenceFilter会在请求开始时从配置好的SecurityContextRepository中获取SecurityContext，然后把它设置给SecurityContextHolder。在请求完成后将SecurityContextHolder持有的SecurityContext再保存到配置好的SecurityContextRepository，同时清除SecurityContextHolder所持有的SecurityContext。在使用NameSpace时，Spring  Security默认会给SecurityContextPersistenceFilter的SecurityContextRepository设置一个HttpSessionSecurityContextRepository，其会将SecurityContext保存在HttpSession中。此外HttpSessionSecurityContextRepository有一个很重要的属性allowSessionCreation，默认为true。这样需要把SecurityContext保存在session中时，如果不存在session，可以自动创建一个。也可以把它设置为false，这样在请求结束后如果没有可用的session就不会保存SecurityContext到session了。SecurityContextRepository还有一个空实现，NullSecurityContextRepository，如果在请求完成后不想保存SecurityContext也可以使用它。<br>&emsp;&emsp;这里再补充说明一点为什么SecurityContextPersistenceFilter在请求完成后需要清除SecurityContextHolder的SecurityContext。SecurityContextHolder在设置和保存SecurityContext都是使用的静态方法，具体操作是由其所持有的SecurityContextHolderStrategy完成的。默认使用的是基于线程变量的实现，即SecurityContext是存放在ThreadLocal里面的，这样各个独立的请求都将拥有自己的SecurityContext。在请求完成后清除SecurityContextHolder中的SucurityContext就是清除ThreadLocal，Servlet容器一般都有自己的线程池，这可以避免Servlet容器下一次分发线程时线程中还包含SecurityContext变量，从而引起不必要的错误。<br>&emsp;&emsp;下面是一个SecurityContextPersistenceFilter的简单配置。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"securityContextPersistenceFilter"</span></span></div><div class="line">   <span class="attr">class</span>=<span class="string">"org.springframework.security.web.context.SecurityContextPersistenceFilter"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">'securityContextRepository'</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">bean</span></span></div><div class="line">     <span class="attr">class</span>=<span class="string">'org.springframework.security.web.context.HttpSessionSecurityContextRepository'</span>&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">'allowSessionCreation'</span> <span class="attr">value</span>=<span class="string">'false'</span> /&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>十. <strong>UsernamePasswordAuthenticationFilter</strong><br>&emsp;&emsp;UsernamePasswordAuthenticationFilter用于处理来自表单提交的认证。该表单必须提供对应的用户名和密码，对应的参数名默认为j_username和j_password。如果不想使用默认的参数名，可以通过UsernamePasswordAuthenticationFilter的usernameParameter和passwordParameter进行指定。表单的提交路径默认是“j_spring_security_check”，也可以通过UsernamePasswordAuthenticationFilter的filterProcessesUrl进行指定。通过属性postOnly可以指定只允许登录表单进行post请求，默认是true。其内部还有登录成功或失败后进行处理的AuthenticationSuccessHandler和AuthenticationFailureHandler，这些都可以根据需求做相关改变。此外，它还需要一个AuthenticationManager的引用进行认证，这个是没有默认配置的。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"authenticationFilter"</span></span></div><div class="line">   <span class="attr">class</span>=<span class="string">"org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationManager"</span> <span class="attr">ref</span>=<span class="string">"authenticationManager"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"usernameParameter"</span> <span class="attr">value</span>=<span class="string">"username"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"passwordParameter"</span> <span class="attr">value</span>=<span class="string">"password"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filterProcessesUrl"</span> <span class="attr">value</span>=<span class="string">"/login.do"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;如果要在http元素定义中使用上述AuthenticationFilter定义，那么完整的配置应该类似于如下这样子。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">   <span class="attr">xmlns:security</span>=<span class="string">"http://www.springframework.org/schema/security"</span></div><div class="line">   <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">          http://www.springframework.org/schema/beans/spring-beans-3.1.xsd</div><div class="line">          http://www.springframework.org/schema/security</div><div class="line">          http://www.springframework.org/schema/security/spring-security-3.1.xsd"&gt;</div><div class="line">   <span class="comment">&lt;!-- entry-point-ref指定登录入口 --&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">security:http</span> <span class="attr">entry-point-ref</span>=<span class="string">"authEntryPoint"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:logout</span> <span class="attr">delete-cookies</span>=<span class="string">"JSESSIONID"</span> /&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/login*.jsp*"</span></span></div><div class="line">         <span class="attr">access</span>=<span class="string">"IS_AUTHENTICATED_ANONYMOUSLY"</span> /&gt;</div><div class="line">      <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span> /&gt;</span></div><div class="line">      <span class="comment">&lt;!-- 添加自己定义的AuthenticationFilter到FilterChain的FORM_LOGIN_FILTER位置 --&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:custom-filter</span> <span class="attr">ref</span>=<span class="string">"authenticationFilter"</span> <span class="attr">position</span>=<span class="string">"FORM_LOGIN_FILTER"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div><div class="line">   <span class="comment">&lt;!-- AuthenticationEntryPoint，引导用户进行登录 --&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"authEntryPoint"</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loginFormUrl"</span> <span class="attr">value</span>=<span class="string">"/login.jsp"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">   <span class="comment">&lt;!-- 认证过滤器 --&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"authenticationFilter"</span></span></div><div class="line">   <span class="attr">class</span>=<span class="string">"org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter"</span>&gt;</div><div class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationManager"</span> <span class="attr">ref</span>=<span class="string">"authenticationManager"</span> /&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"usernameParameter"</span> <span class="attr">value</span>=<span class="string">"username"</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"passwordParameter"</span> <span class="attr">value</span>=<span class="string">"password"</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filterProcessesUrl"</span> <span class="attr">value</span>=<span class="string">"/login.do"</span> /&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">  </div><div class="line">   <span class="tag">&lt;<span class="name">security:authentication-manager</span> <span class="attr">alias</span>=<span class="string">"authenticationManager"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:authentication-provider</span></span></div><div class="line">         <span class="attr">user-service-ref</span>=<span class="string">"userDetailsService"</span>&gt;</div><div class="line">         <span class="tag">&lt;<span class="name">security:password-encoder</span> <span class="attr">hash</span>=<span class="string">"md5"</span></span></div><div class="line">            <span class="attr">base64</span>=<span class="string">"true"</span>&gt;</div><div class="line">            <span class="tag">&lt;<span class="name">security:salt-source</span> <span class="attr">user-property</span>=<span class="string">"username"</span> /&gt;</span></div><div class="line">         <span class="tag">&lt;/<span class="name">security:password-encoder</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">security:authentication-provider</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></div><div class="line"> </div><div class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDetailsService"</span></span></div><div class="line">      <span class="attr">class</span>=<span class="string">"org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl"</span>&gt;</div><div class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"> </div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Spring/Security/配置九：Filter/" data-id="cjfvvphm30097m9fyanqrnbkw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/Security/配置五：异常信息本地化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/15/Spring/Security/配置五：异常信息本地化/" class="article-date">
  <time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/Security/">Security</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Spring/Security/配置五：异常信息本地化/">配置五：异常信息本地化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;Spring Security支持将展现给终端用户看的异常信息本地化，这些信息包括认证失败、访问被拒绝等。而对于展现给开发者看的异常信息和日志信息（如配置错误）则是不能够进行本地化的，它们是以英文硬编码在Spring Security的代码中的。在Spring-Security-core-xxx.jar包的org.springframework.security包下拥有一个以英文异常信息为基础的messages.properties文件，以及其它一些常用语言的异常信息对应的文件，如messages_zh_CN.properties文件。那么对于用户而言所需要做的就是在自己的ApplicationContext中定义如下这样一个bean。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageSource"</span></span></div><div class="line">    <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ReloadableResourceBundleMessageSource"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basename"</span></span></div><div class="line">         <span class="attr">value</span>=<span class="string">"classpath:org/springframework/security/messages"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果要自己定制messages.properties文件，或者需要新增本地化支持文件，则可以copy Spring Security提供的默认messages.properties文件，将其中的内容进行修改后再注入到上述bean中。比如我要定制一些中文的提示信息，那么我可以在copy一个messages.properties文件到类路径的“com/xxx”下，然后将其重命名为messages_zh_CN.properties，并修改其中的提示信息。然后通过basenames属性注入到上述bean中，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> &lt;bean id=&quot;messageSource&quot;</div><div class="line">   class=&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot;&gt;</div><div class="line">  &lt;property name=&quot;basenames&quot;&gt;</div><div class="line">     &lt;array&gt;</div><div class="line">        &lt;!-- 将自定义的放在Spring Security内置的之前 --&gt;</div><div class="line">        &lt;value&gt;classpath:com/xxx/messages&lt;/value&gt;</div><div class="line">        &lt;value&gt;classpath:org/springframework/security/messages&lt;/value&gt;</div><div class="line">     &lt;/array&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;有一点需要注意的是将自定义的messages.properties文件路径定义在Spring Security内置的message.properties路径定义之前。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Spring/Security/配置五：异常信息本地化/" data-id="cjfvvphm40099m9fy9yvdoqgg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/Security/配置十一：匿名认证" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/15/Spring/Security/配置十一：匿名认证/" class="article-date">
  <time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/Security/">Security</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Spring/Security/配置十一：匿名认证/">配置十一：匿名认证</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;对于匿名访问的用户，Spring Security支持为其建立一个匿名的AnonymousAuthenticationToken存放在SecurityContextHolder中，这就是所谓的匿名认证。这样在以后进行权限认证或者做其它操作时我们就不需要再判断SecurityContextHolder中持有的Authentication对象是否为null了，而直接把它当做一个正常的Authentication进行使用就OK了。 </p>
<p>一. <strong>配置</strong><br>&emsp;&emsp;使用NameSpace时，http元素的使用默认就会启用对匿名认证的支持，不过我们也可以通过设置http元素下的anonymous元素的enabled属性为false停用对匿名认证的支持。以下是anonymous元素可以配置的属性，以及它们的默认值。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:anonymous</span> <span class="attr">enabled</span>=<span class="string">"true"</span> <span class="attr">key</span>=<span class="string">"doesNotMatter"</span> <span class="attr">username</span>=<span class="string">"anonymousUser"</span> <span class="attr">granted-authority</span>=<span class="string">"ROLE_ANONYMOUS"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;key用于指定一个在AuthenticationFilter和AuthenticationProvider之间共享的值。username用于指定匿名用户所对应的用户名，granted-authority用于指定匿名用户所具有的权限。<br>&emsp;&emsp;与匿名认证相关的类有三个，AnonymousAuthenticationToken将作为一个Authentication的实例存放在SecurityContextHolder中；过滤器运行到AnonymousAuthenticationFilter时，如果SecurityContextHolder中持有的Authentication还是空的，则AnonymousAuthenticationFilter将创建一个AnonymousAuthenticationToken并存放在SecurityContextHolder中。最后一个相关的类是AnonymousAuthenticationProvider，其会添加到ProviderManager的AuthenticationProvider列表中，以支持对AnonymousAuthenticationToken的认证。AnonymousAuthenticationToken的认证是在AbstractSecurityInterceptor中的beforeInvocation()方法中进行的。使用http元素定义时这些bean都是会自动定义和添加的。如果需要手动定义这些bean的话，那么可以如下定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;anonymousAuthFilter&quot;</div><div class="line">   class=&quot;org.springframework.security.web.authentication.AnonymousAuthenticationFilter&quot;&gt;</div><div class="line">  &lt;property name=&quot;key&quot; value=&quot;doesNotMatter&quot; /&gt;</div><div class="line">  &lt;property name=&quot;userAttribute&quot; value=&quot;anonymousUser,ROLE_ANONYMOUS&quot; /&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;bean id=&quot;anonymousAuthenticationProvider&quot;</div><div class="line">class=&quot;org.springframework.security.authentication.AnonymousAuthenticationProvider&quot;&gt;</div><div class="line">  &lt;property name=&quot;key&quot; value=&quot;doesNotMatter&quot; /&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;key是在AnonymousAuthenticationProvider和AnonymousAuthenticationFilter之间共享的，它们必须保持一致，AnonymousAuthenticationProvider将使用本身拥有的key与传入的AnonymousAuthenticationToken的key作比较，相同则认为可以进行认证，否则将抛出异常BadCredentialsException。userAttribute属性是以usernameInTheAuthenticationToken,grantedAuthority[,grantedAuthority]的形式进行定义的。</p>
<p> 二. <strong>AuthenticationTrustResolver</strong><br> &emsp;&emsp; AuthenticationTrustResolver是一个接口，其中定义有两个方法，isAnonymous()和isRememberMe()，它们都接收一个Authentication对象作为参数。它有一个默认实现类AuthenticationTrustResolverImpl，Spring Security就是使用它来判断一个SecurityContextHolder持有的Authentication是否AnonymousAuthenticationToken或RememberMeAuthenticationToken。如当ExceptionTranslationFilter捕获到一个AccessDecisionManager后就会使用它来判断当前Authentication对象是否为一个AnonymousAuthenticationToken，如果是则交由AuthenticationEntryPoint处理，否则将返回403错误码。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Spring/Security/配置十一：匿名认证/" data-id="cjfvvphm6009cm9fybkx1zxhw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/Security/配置八：intercept-url配置" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/15/Spring/Security/配置八：intercept-url配置/" class="article-date">
  <time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/Security/">Security</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Spring/Security/配置八：intercept-url配置/">配置八：intercept-url配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一. <strong>指定拦截的url</strong><br>通过pattern指定当前intercept-url定义应当作用于哪些url。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>二. <strong>指定访问权限</strong><br>&emsp;&emsp;可以通过access属性来指定intercept-url对应URL访问所应当具有的权限。access的值是一个字符串，其可以直接是一个权限的定义，也可以是一个表达式。常用的类型有简单的角色名称定义，多个名称之间用逗号分隔，如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/secure/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER,ROLE_ADMIN"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在上述配置中就表示secure路径下的所有URL请求都应当具有ROLE_USER或ROLE<em>ADMIN权限。当access的值是以“ROLE</em>”开头的则将会交由RoleVoter进行处理。</p>
<p>&emsp;&emsp;此外，其还可以是一个表达式，上述配置如果使用表达式来表示的话则应该是如下这个样子。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span> <span class="attr">use-expressions</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:form-login</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:logout</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/secure/**"</span> <span class="attr">access</span>=<span class="string">"hasAnyRole('ROLE_USER','ROLE_ADMIN')"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;或者是使用hasRole()表达式，然后中间以or连接，如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/secure/**"</span> <span class="attr">access</span>=<span class="string">"hasRole('ROLE_USER') or hasRole('ROLE_ADMIN')"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<strong>需要注意的是使用表达式时需要指定http元素的use-expressions=”true”</strong>。更多关于使用表达式的内容将在后文介绍。当intercept-url的access属性使用表达式时默认将使用WebExpressionVoter进行处理。<br>&emsp;&emsp;       此外，还可以指定三个比较特殊的属性值，默认情况下将使用AuthenticatedVoter来处理它们。</p>
<ul>
<li>IS_AUTHENTICATED_ANONYMOUSLY表示用户不需要登录就可以访问；</li>
<li>IS_AUTHENTICATED_REMEMBERED表示用户需要是通过Remember-Me功能进行自动登录的才能访问；</li>
<li>IS_AUTHENTICATED_FULLY表示用户的认证类型应该是除前两者以外的，也就是用户需要是通过登录入口进行登录认证的才能访问。如我们通常会将登录地址设置为IS_AUTHENTICATED_ANONYMOUSLY。<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:form-login</span> <span class="attr">login-page</span>=<span class="string">"/login.jsp"</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 登录页面可以匿名访问 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/login.jsp*"</span> <span class="attr">access</span>=<span class="string">"IS_AUTHENTICATED_ANONYMOUSLY"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>三. <strong>指定访问协议</strong><br>&emsp;&emsp;如果你的应用同时支持Http和Https访问，且要求某些URL只能通过Https访问，这个需求可以通过指定intercept-url的requires-channel属性来指定。<br>requires-channel支持三个值：<code>http</code>、<code>https</code>和<code>any</code>。any表示http和https都可以访问。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span> <span class="attr">auto-config</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:form-login</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 只能通过https访问 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/admin/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_ADMIN"</span> <span class="attr">requires-channel</span>=<span class="string">"https"</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 只能通过http访问 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span> <span class="attr">requires-channel</span>=<span class="string">"http"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;需要注意的是当试图使用http请求限制了只能通过https访问的资源时会自动跳转到对应的https通道重新请求。如果所使用的http或者https协议不是监听在标准的端口上（http默认是80，https默认是443），则需要我们通过port-mapping元素定义好它们的对应关系。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span> <span class="attr">auto-config</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:form-login</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 只能通过https访问 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/admin/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_ADMIN"</span> <span class="attr">requires-channel</span>=<span class="string">"https"</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 只能通过http访问 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span> <span class="attr">requires-channel</span>=<span class="string">"http"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:port-mappings</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">security:port-mapping</span> <span class="attr">http</span>=<span class="string">"8899"</span> <span class="attr">https</span>=<span class="string">"9988"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">security:port-mappings</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>四. <strong>指定请求方法</strong><br>&emsp;&emsp;通常我们都会要求某些URL只能通过POST请求，某些URL只能通过GET请求。这些限制Spring Security也已经为我们实现了，通过指定intercept-url的method属性可以限制当前intercept-url适用的请求方式，默认为所有的方式都可以。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span> <span class="attr">auto-config</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:form-login</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 只能通过POST访问 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/post/**"</span> <span class="attr">method</span>=<span class="string">"POST"</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 只能通过GET访问 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span> <span class="attr">method</span>=<span class="string">"GET"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>method的可选值有<code>GET</code>、<code>POST</code>、<code>DELETE</code>、<code>PUT</code>、<code>HEAD</code>、<code>OPTIONS</code>和<code>TRACE</code>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Spring/Security/配置八：intercept-url配置/" data-id="cjfvvphm6009em9fyv7qufbe4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/基础/java异常" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/15/Java/基础/java异常/" class="article-date">
  <time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/基础/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Java/基础/java异常/">java异常</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>　　异常分类</p>
<p><img src="http://diycode.b0.upaiyun.com/photo/2016/ecb86e28e5df3a76a107f50d989f6123.png" alt="image"></p>
<h4 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h4><p>Throwable 类是 Java 语言中所有错误或异常的超类。只有当对象是此类（或其子类之一）的实例时，才能通过 Java 虚拟机或者 Java throw 语句抛出。类似地，只有此类或其子类之一才可以是 catch 子句中的参数类型。</p>
<h4 id="Error（错误）"><a href="#Error（错误）" class="headerlink" title="Error（错误）"></a>Error（错误）</h4><p>表示程序无法处理的错误，一般与程序员的执行操作无关。理论上这些错误是不允许发生的，如果发生，也不应该试图通过程序去处理，所以Error不是try-catch的处理对象，而JVM一般的处理方式是终止发生错误的线程。</p>
<h4 id="Exception（异常）"><a href="#Exception（异常）" class="headerlink" title="Exception（异常）"></a>Exception（异常）</h4><p>Java的异常分为两种</p>
<ul>
<li>checked Exception:检查型异常 或者 编译时异常，也叫非运行时异常</li>
<li>unchecked Exception, RuntimeException：不检查异常，也叫运行时异常</li>
</ul>
<p>运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p>
<p>非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p>
<p>java认为checked异常都是可以再编译阶段被处理的异常，所以它强制程序处理所有的checked异常，而Runtime异常无须处理，java程序必须显式处理checked异常，如果程序没有处理，则在编译时会发生错误，无法通过编译。</p>
<p>Java异常机制主要依赖于try、catch、finally、throw、throws五个关键字。</p>
<ol>
<li><p><code>try</code>：它里面放置可能引发异常的代码</p>
</li>
<li><p><code>catch</code>：后面对应异常类型和一个代码块，用于表明该catch块用于处理这种类型的代码块，可以有多个catch块。</p>
</li>
<li><p><code>finally</code>：主要用于回收在try块里打开的物力资源（如数据库连接、网络连接和磁盘文件），异常机制总是保证finally块总是被执行。</p>
</li>
</ol>
<p>finally的作用：</p>
<ul>
<li>无论try所指定的程序块中是否抛出异常，也无论catch语句的异常类型是否与所抛弃的异常的类型一致，finally中的代码一定会得到执行</li>
<li>finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序的其他部分以前，能够对程序的状态作统一的管理</li>
<li>通常再finally语句中可以进行资源的清楚工作，如关闭打开的文件，删除临时文件等</li>
</ul>
<p>当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。<br>在以下4种特殊情况下，finally块不会被执行：<br>1）在finally语句块中抛出了异常且未处理。<br>2）在前面的代码中用了System.exit()退出程序。<br>3）程序所在的线程死亡。<br>4）CPU出现异常被关闭。  </p>
<ol>
<li><p><code>throw</code>：用于抛出一个实际的异常，可以单独作为语句使用，抛出一个具体的异常对象。</p>
</li>
<li><p><code>throws</code>：用在方法头部中，用于声明该方法可能抛出的异常。</p>
</li>
</ol>
<h5 id="异常执行步骤"><a href="#异常执行步骤" class="headerlink" title="异常执行步骤"></a>异常执行步骤</h5><ol>
<li><p>如果执行try块中的业务逻辑代码时出现异常，系统自动生成一个异常对象，该异常对象被提交给java运行环境，这个过程称为<strong>抛出（throw）异常</strong>。</p>
</li>
<li><p>当java运行环境收到异常对象时，会寻找能处理该异常对象的catch块，如果找到合适的cathc块并把该异常对象交给catch块处理，那这个过程称为<strong>捕获（catch）异常</strong>；如果java运行时环境找不到捕获异常的catch块，则运行时环境终止，jav程序也将退出。</p>
</li>
</ol>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><ol>
<li><p>不管程序代码块是否处于try块中，甚至包括catch块中代码，只要执行该代码时出现了异常，系统都会自动生成一个异常对象，如果程序没有为这段代码定义任何catch块，java运行环境肯定找不到处理该异常的catch块，程序肯定在此退出。</p>
</li>
<li><p>try块后可以有多个catch块，try块后使用多个catch块是为了针对不同异常类提供的不同的异常处理方式。当系统发生不同意外情况时，系统会生成不同的异常对象，java运行时就会根据该异常对象所属的异常类来决定使用哪个catch块来处理该异常。</p>
</li>
<li><p>通常情况下，如果try块被执行一次，则try块后只有一个catch块会被执行，绝不可能有多个catch块被执行，除非在循环中使用类continue开始下一次循环，下一次循环又重新运行了try块，这才可能导致多个catch块被执行。</p>
</li>
<li><p>异常捕获顺序是从上到下的，所以一般将异常范围小放在前面，进行异常捕获时，一定要记住先捕获小的异常，再捕获大的异常。</p>
</li>
<li><p>只有try块石必须的，也就是说如果没有try块，则不可能有后面的catch块和finally块，catch块和finally块都是可选的，但catch块和finally块至少出现其中之一，也可以同时出现</p>
</li>
<li><p>使用throws声明抛出异常时有一个限制：就是方法重写时的“两小”中的一条规则：子类方法声明抛出的异常类型应该是父类方法声明抛出的异常类型的子类或或相等，子类方法中不允许比父类方法声明抛出更多异常。即如果子类抛出的异常是父类抛出的异常的父类，那么程序无法通过编译。</p>
</li>
</ol>
<h4 id="常见的运行时异常"><a href="#常见的运行时异常" class="headerlink" title="常见的运行时异常"></a>常见的运行时异常</h4><p>NullPointerException(空指针)，ArrayIndexOutOfBoundsException(数组下标越界),IndexOutOfBoundsException(索引越界异常),NumberFormatException(数字格式异常),IllegalArgumentException(方法参数错误)</p>
<h4 id="常见的非运行时异常"><a href="#常见的非运行时异常" class="headerlink" title="常见的非运行时异常"></a>常见的非运行时异常</h4><p>IOException(输入输出异常),SQLException(SQL异常)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Java/基础/java异常/" data-id="cjfvvphkn005zm9fyyrqcg4ws" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/Security/配置十七：基于方法的权限控制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/15/Spring/Security/配置十七：基于方法的权限控制/" class="article-date">
  <time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/Security/">Security</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Spring/Security/配置十七：基于方法的权限控制/">配置十七：基于方法的权限控制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;之前介绍的都是基于URL的权限控制，Spring Security同样支持对于方法的权限控制。可以通过intercept-methods对某个bean下面的方法进行权限控制，也可以通过pointcut对整个Service层的方法进行统一的权限控制，还可以通过注解定义对单独的某一个方法进行权限控制。</p>
<p>一. <strong>intercept-methods定义方法权限控制</strong><br>&emsp;&emsp;intercept-methods是需要定义在bean元素下的，通过它可以定义对当前的bean的某些方法进行权限控制，具体方法是使用其下的子元素protect进行定义的。protect元素需要指定两个属性，access和method，method表示需要拦截的方法名称，可以使用通配符，access表示执行对应的方法需要拥有的权限，多个权限之间可以使用逗号分隔。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.xxx.service.impl.UserServiceImpl"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:intercept-methods</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">security:protect</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span> <span class="attr">method</span>=<span class="string">"find*"</span>/&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">security:protect</span> <span class="attr">access</span>=<span class="string">"ROLE_ADMIN"</span> <span class="attr">method</span>=<span class="string">"add*"</span>/&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">security:protect</span> <span class="attr">access</span>=<span class="string">"ROLE_ADMIN"</span> <span class="attr">method</span>=<span class="string">"update*"</span>/&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">security:protect</span> <span class="attr">access</span>=<span class="string">"ROLE_ADMIN"</span> <span class="attr">method</span>=<span class="string">"delete*"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">security:intercept-methods</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在上面的配置中表示在执行UserServiceImpl的方法名以find开始的方法时需要当前用户拥有ROLE_USER的权限，在执行方法名以add、update或delete开始的方法时需要拥有ROLE_ADMIN的权限。当访问被拒绝时还是交由ExceptionTranslationFilter处理，这也就意味着如果用户未登录则会引导用户进行登录，否则默认将返回403错误码到客户端。  </p>
<p>二. <strong>使用pointcut定义方法权限控制</strong><br>&emsp;&emsp;基于pointcut的方法权限控制是通过global-method-security下的protect-pointcut来定义的。可以在global-method-security元素下定义多个protect-pointcut以对不同的pointcut使用不同的权限控制。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:global-method-security</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:protect-pointcut</span> <span class="attr">access</span>=<span class="string">"ROLE_READ"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.elim.*..*Service.find*(..))"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:protect-pointcut</span> <span class="attr">access</span>=<span class="string">"ROLE_WRITE"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.elim.*..*Service.*(..))"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:global-method-security</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上面的定义表示我们在执行com.elim包或其子包下任意以Service结尾的类，其方法名以find开始的所有方法时都需要用户拥有ROLE_READ的权限，对于com.elim包或其子包下任意以Service结尾的类的其它方法在执行时都需要ROLE_WRITE的权限。需要注意的是对应的类需要是定义在ApplicationContext中的bean才行。此外同对于URL的权限控制一样，当定义多个protect-pointcut时更具有特性的应当先定义，因为在pointcut匹配的时候是按照声明顺序进行匹配的，一旦匹配上了后续的将不再进行匹配了。</p>
<p>三. <strong>使用注解定义方法权限控制</strong><br>&emsp;&emsp;基于注解的方法权限控制也是需要通过global-method-security元素定义来进行启用的。Spring Security在方法的权限控制上支持三种类型的注解，JSR-250注解、@Secured注解和支持表达式的注解。这三种注解默认都是没有启用的，需要单独通过global-method-security元素的对应属性进行启用。</p>
<p>四. <strong>JSR-250注解</strong><br>&emsp;&emsp;要使用JSR-250注解，首先我们需要通过设置global-method-security元素的jsr250-annotation=”enabled”来启用基于JSR-250注解的支持，默认为disabled。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:global-method-security</span> <span class="attr">jsr250-annotations</span>=<span class="string">"enabled"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;此外，还需要确保添加了jsr250-api到我们的类路径下。之后就可以在我们的Service方法上使用JSR-250注解进行权限控制了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="meta">@RolesAllowed</span>(<span class="string">"ROLE_ADMIN"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"addUser................"</span> + user);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"updateUser.............."</span> + user);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="meta">@RolesAllowed</span>(&#123;<span class="string">"ROLE_USER"</span>, <span class="string">"ROLE_ADMIN"</span>&#125;)</div><div class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"find user by id............."</span> + id);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"delete user by id................"</span>);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="meta">@RolesAllowed</span>(<span class="string">"ROLE_USER"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"find all user..............."</span>);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上面的代码表示执行UserServiceImpl里面所有的方法都需要角色ROLE_ADMIN，其中findAll()方法的执行需要ROLE_USER角色，而find()方法的执行对于ROLE_USER或者ROLE_ADMIN角色都可以。<br>&emsp;&emsp;顺便介绍一下JSR-250中对权限支持的注解。  </p>
<ol>
<li><strong>RolesAllowed</strong>表示访问对应方法时所应该具有的角色。其可以标注在类上，也可以标注在方法上，当标注在类上时表示其中所有方法的执行都需要对应的角色，当标注在方法上表示执行该方法时所需要的角色，当方法和类上都使用了@RolesAllowed进行标注，则方法上的@RolesAllowed将覆盖类上的@RolesAllowed，即方法上的@RolesAllowed将对当前方法起作用。@RolesAllowed的值是由角色名称组成的数组。</li>
<li><strong>PermitAll</strong>表示允许所有的角色进行访问，也就是说不进行权限控制。@PermitAll可以标注在方法上也可以标注在类上，当标注在方法上时则只对对应方法不进行权限控制，而标注在类上时表示对类里面所有的方法都不进行权限控制    （1）当@PermitAll标注在类上，而@RolesAllowed标注在方法上时则按照@RolesAllowed将覆盖@PermitAll，即需要@RolesAllowed对应的角色才能访问。  （2）当@RolesAllowed标注在类上，而@PermitAll标注在方法上时则对应的方法也是不进行权限控制的。  （3）当在方法上同时使用了@PermitAll和@RolesAllowed时先定义的将发生作用，而都定义在类上时则是反过来的，即后定义的将发生作用（这个没多大的实际意义，实际应用中不会有这样的定义）。</li>
<li><strong>DenyAll</strong>是和PermitAll相反的，表示无论什么角色都不能访问。@DenyAll只能定义在方法上。你可能会有疑问使用@DenyAll标注的方法无论拥有什么权限都不能访问，那还定义它干啥呢？使用@DenyAll定义的方法只是在我们的权限控制中不能访问，脱离了权限控制还是可以访问的。</li>
</ol>
<p>五. <strong>@Secured注解</strong><br>&emsp;&emsp;@Secured是由Spring Security定义的用来支持方法权限控制的注解。它的使用也是需要启用对应的支持才会生效的。通过设置global-method-security元素的secured-annotations=”enabled”可以启用Spring Security对使用@Secured注解标注的方法进行权限控制的支持，其值默认为disabled。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:global-method-security</span> <span class="attr">secured-annotations</span>=<span class="string">"enabled"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</div><div class="line"> </div><div class="line">   <span class="meta">@Secured</span>(<span class="string">"ROLE_ADMIN"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"addUser................"</span> + user);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="meta">@Secured</span>(<span class="string">"ROLE_USER"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"find all user..............."</span>);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上面的代码中我们使用@Secured定义了只有拥有ROLE_ADMIN角色的用户才能调用方法addUser()，只有拥有ROLE_USER角色的用户才能调用方法findAll()。</p>
<p>六. <strong>支持表达式的注解</strong><br>&emsp;&emsp;Spring Security中定义了四个支持使用表达式的注解，分别是@PreAuthorize、@PostAuthorize、@PreFilter和@PostFilter。其中前两者可以用来在方法调用前或者调用后进行权限检查，后两者可以用来对集合类型的参数或者返回值进行过滤。要使它们的定义能够对我们的方法的调用产生影响我们需要设置global-method-security元素的pre-post-annotations=”enabled”，默认为disabled。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:global-method-security</span> <span class="attr">pre-post-annotations</span>=<span class="string">"disabled"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>6.1 使用@PreAuthorize和@PostAuthorize进行访问控制<br>@PreAuthorize可以用来控制一个方法是否能够被调用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</div><div class="line"> </div><div class="line">   <span class="meta">@PreAuthorize</span>(<span class="string">"hasRole('ROLE_ADMIN')"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"addUser................"</span> + user);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="meta">@PreAuthorize</span>(<span class="string">"hasRole('ROLE_USER') or hasRole('ROLE_ADMIN')"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"find user by id............."</span> + id);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在上面的代码中我们定义了只有拥有角色ROLE_ADMIN的用户才能访问adduser()方法，而访问find()方法需要有ROLE_USER角色或ROLE_ADMIN角色。使用表达式时我们还可以在表达式中使用方法参数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</div><div class="line"> </div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 限制只能查询Id小于10的用户</div><div class="line">    */</div><div class="line">   <span class="meta">@PreAuthorize</span>(<span class="string">"#id&lt;10"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"find user by id........."</span> + id);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line">  </div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 限制只能查询自己的信息</div><div class="line">    */</div><div class="line">   <span class="meta">@PreAuthorize</span>(<span class="string">"principal.username.equals(#username)"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(String username)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"find user by username......"</span> + username);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 限制只能新增用户名称为abc的用户</div><div class="line">    */</div><div class="line">   <span class="meta">@PreAuthorize</span>(<span class="string">"#user.name.equals('abc')"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"addUser............"</span> + user);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在上面代码中我们定义了调用find(int id)方法时，只允许参数id小于10的调用；调用find(String username)时只允许username为当前用户的用户名；定义了调用add()方法时只有当参数user的name为abc时才可以调用。<br>&emsp;&emsp;有时候可能你会想在方法调用完之后进行权限检查，这种情况比较少，但是如果你有的话，Spring Security也为我们提供了支持，通过@PostAuthorize可以达到这一效果。使用@PostAuthorize时我们可以使用内置的表达式returnObject表示方法的返回值。我们来看下面这一段示例代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PostAuthorize</span>(<span class="string">"returnObject.id%2==0"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">  User user = <span class="keyword">new</span> User();</div><div class="line">  user.setId(id);</div><div class="line">  <span class="keyword">return</span> user;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上面这一段代码表示将在方法find()调用完成后进行权限检查，如果返回值的id是偶数则表示校验通过，否则表示校验失败，将抛出AccessDeniedException。       需要注意的是@PostAuthorize是在方法调用完成后进行权限检查，它不能控制方法是否能被调用，只能在方法调用完成后检查权限决定是否要抛出AccessDeniedException。<br>使用@PreFilter和@PostFilter进行过滤<br>6.2 使用@PreFilter和@PostFilter可以对集合类型的参数或返回值进行过滤。<br>使用@PreFilter和@PostFilter时，Spring Security将移除使对应表达式的结果为false的元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PostFilter</span>(<span class="string">"filterObject.id%2==0"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</div><div class="line">  List&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;User&gt;();</div><div class="line">  User user;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</div><div class="line">     user = <span class="keyword">new</span> User();</div><div class="line">     user.setId(i);</div><div class="line">     userList.add(user);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> userList;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上述代码表示将对返回结果中id不为偶数的user进行移除。filterObject是使用@PreFilter和@PostFilter时的一个内置表达式，表示集合中的当前对象。当@PreFilter标注的方法拥有多个集合类型的参数时，需要通过@PreFilter的filterTarget属性指定当前@PreFilter是针对哪个参数进行过滤的。如下面代码就通过filterTarget指定了当前@PreFilter是用来过滤参数ids的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PreFilter</span>(filterTarget=<span class="string">"ids"</span>, value=<span class="string">"filterObject%2==0"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(List&lt;Integer&gt; ids, List&lt;String&gt; usernames)</span> </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>七. <strong>方法权限控制的拦截器</strong><br>&emsp;&emsp;关于方法权限控制，Spring Security提供了两类AbstractSecurityInterceptor，基于AOP Alliance的MethodSecurityInterceptor，和基于Aspectj继承自MethodSecurityInterceptor的AspectJMethodSecurityInterceptor。<br>7.1 <strong>MethodSecurityInterceptor</strong><br>&emsp;&emsp;当我们在使用基于NameSpace进行方法保护的配置时，Spring Security默认配置的就是MethodSecurityInterceptor。根据配置的不同，一个拦截器可能只是针对于一个bean，也可能是针对于多个bean的。MethodSecurityInterceptor使用一个MethodSecurityMetadataSource的实例来获取特定方法调用配置的ConfigAttribute。当我们在ApplicationContext配置文件中使用intercept-methods元素或protect-point元素定义需要保护的方法调用时，Spring Security内部默认会使用一个MapBasedMethodSecurityMetadataSource来保存在这些元素上定义的配置信息，保存的key是对应的方法名（可以是含有通配符的）。类似的使用JSR-250注解时将使用Jsr250MethodSecurityMetadataSource解析配置属性；使用@Secured注解时将使用SecuredAnnotationSecurityMetadataSource解析配置属性；使用pre-post-annotations时将使用PrePostAnnotationSecurityMetadataSource解析配置属性。<br>&emsp;&emsp;MethodSecurityInterceptor是实现了MethodInterceptor接口的，所以我们在使用Spring Aop时，可以自己配置一个MethodSecurityInterceptor的bean。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 自定义MethodSecurityInterceptor --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"methodSecurityInterceptor"</span></span></div><div class="line"><span class="attr">class</span>=<span class="string">"org.springframework.security.access.intercept.aopalliance.MethodSecurityInterceptor"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationManager"</span> <span class="attr">ref</span>=<span class="string">"authenticationManager"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accessDecisionManager"</span> <span class="attr">ref</span>=<span class="string">"accessDecisionManager"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"afterInvocationManager"</span> <span class="attr">ref</span>=<span class="string">"afterInvocationManager"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"securityMetadataSource"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">security:method-security-metadata-source</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 指定需要受保护的方法和需要的权限 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">security:protect</span> <span class="attr">method</span>=<span class="string">"com.xxx.service.UserService.find*"</span></span></div><div class="line">            <span class="attr">access</span>=<span class="string">"ROLE_USER"</span> /&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">security:protect</span> <span class="attr">method</span>=<span class="string">"com.xxx.service.UserService.delete*"</span></span></div><div class="line">            <span class="attr">access</span>=<span class="string">"ROLE_ADMIN"</span> /&gt;</div><div class="line">     <span class="tag">&lt;/<span class="name">security:method-security-metadata-source</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;定义了MethodSecurityInterceptor以后，我们需要类似AOP配置那样，配置哪些该MethodInterceptor需要拦截哪些方法的执行。这种可选配置是很多种的，因为我们这里只是拦截UserService中的具体方法，所以就采用基于bean name的自动代理。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 基于bean的拦截 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>methodSecurityInterceptor<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanNames"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>userService<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>按照上面的配置，我们在访问UserService的find方法时就需要ROLE_USER的权限，而访问delete方法时则需要ROLE_ADMIN权限。</p>
<p>7.2 <strong>AspectJMethodSecurityInterceptor</strong><br>&emsp;&emsp;AspectJMethodSecurityInterceptor是继承自MethodSecurityInterceptor的，不同的是AspectJMethodSecurityInterceptor是用来支持AspectJ的JointPoint的，但在底层还是会把它封装成一个MethodInvocation进行调用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Spring/Security/配置十七：基于方法的权限控制/" data-id="cjfvvphm9009jm9fylrnx9mm1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/Security/配置十八：Jsp标签" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/15/Spring/Security/配置十八：Jsp标签/" class="article-date">
  <time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/Security/">Security</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Spring/Security/配置十八：Jsp标签/">配置十八：Jsp标签</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;Spring Security也有对Jsp标签的支持的标签库。其中一共定义了三个标签：authorize、authentication和accesscontrollist。其中authentication标签是用来代表当前Authentication对象的，我们可以利用它来展示当前Authentication对象的相关信息。另外两个标签是用于权限控制的，可以利用它们来包裹需要保护的内容，通常是超链接和按钮。<br>&emsp;&emsp;如果需要使用Spring Security的标签库，那么首先我们应当将对应的jar包spring-security-taglibs-xxx.jar放入WEB-INF/lib下；其次我们需要在页面上引入Spring Security的标签库。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">prefix</span>=<span class="string">"sec"</span> <span class="attr">uri</span>=<span class="string">"http://www.springframework.org/security/tags"</span> %&gt;</span></div></pre></td></tr></table></figure>
<p>接下来就可以在页面上自由的使用Spring Security的标签库提供的标签了。</p>
<p>一. <strong>authorize</strong><br>&emsp;&emsp;authorize是用来判断普通权限的，通过判断用户是否具有对应的权限而控制其所包含内容的显示，其可以指定如下属性。<br>1.1 <strong>access</strong><br>access属性需要使用表达式来判断权限，当表达式的返回结果为true时表示拥有对应的权限。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">sec:authorize</span> <span class="attr">access</span>=<span class="string">"hasRole('admin')"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"admin.jsp"</span>&gt;</span>admin page<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">sec:authorize</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>需要注意的是因为access属性是使用表达式的，所以我们必须确保ApplicationContext中存在一个WebSecurityExpressionHandler，最简单的办法就是直接使用NameSpace，通过设置http元素的use-expressions=”true”让NameSpace自动为我们创建一个WebSecurityExpressionHandler。</p>
<p>1.2 <strong>ifAllGranted、ifAnyGranted和ifNotGranted</strong><br>&emsp;&emsp;这三个属性的用法类似，它们都接收以逗号分隔的权限列表，且不能使用表达式。ifAllGranted表示需要包含所有的权限，ifAnyGranted表示只需要包含其中的任意一个即可，ifNotGranted表示不能包含指定的任意一个权限。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 需要拥有所有的权限 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">sec:authorize</span> <span class="attr">ifAllGranted</span>=<span class="string">"ROLE_ADMIN"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"admin.jsp"</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">sec:authorize</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 只需拥有其中任意一个权限 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">sec:authorize</span> <span class="attr">ifAnyGranted</span>=<span class="string">"ROLE_USER,ROLE_ADMIN"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">sec:authorize</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 不允许拥有指定的任意权限 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">sec:authorize</span> <span class="attr">ifNotGranted</span>=<span class="string">"ROLE_ADMIN"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"user.jsp"</span>&gt;</span>user<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">sec:authorize</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>1.3 <strong>url</strong><br>url表示如果用户拥有访问指定url的权限即表示可以显示authorize标签包含的内容。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 拥有访问指定url的权限才显示其中包含的内容 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">sec:authorize</span> <span class="attr">url</span>=<span class="string">"/admin.jsp"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"admin.jsp"</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">sec:authorize</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>1.4 <strong>method</strong><br>method属性是配合url属性一起使用的，表示用户应当具有指定url指定method访问的权限，method的默认值为GET，可选值为http请求的7种方法。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 拥有访问指定url的权限才显示其中包含的内容 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">sec:authorize</span> <span class="attr">url</span>=<span class="string">"/admin.jsp"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"admin.jsp"</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">sec:authorize</span>&gt;</span></div><div class="line">   限制访问方法是通过http元素下的intercept-url元素的method属性来指定的，如：</div><div class="line"><span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/admin.jsp"</span> <span class="attr">access</span>=<span class="string">"ROLE_ADMIN"</span> <span class="attr">method</span>=<span class="string">"POST"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>1.5 <strong>var</strong><br>用于指定将权限鉴定的结果存放在pageContext的哪个属性中。该属性的主要作用是对于在同一页面的多个地方具有相同权限鉴定时，我们只需要定义一次，然后将鉴定结果以var指定的属性名存放在pageContext中，其它地方可以直接使用之前的鉴定结果。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">sec:authorize</span> <span class="attr">access</span>=<span class="string">"isFullyAuthenticated()"</span> <span class="attr">var</span>=<span class="string">"isFullyAuthenticated"</span>&gt;</span></div><div class="line">  只有通过登录界面进行登录的用户才能看到1。<span class="tag">&lt;<span class="name">br</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">sec:authorize</span>&gt;</span></div><div class="line">上述权限的鉴定结果是：$&#123;isFullyAuthenticated &#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">%if((Boolean)pageContext.getAttribute("isFullyAuthenticated"))</span> &#123;%&gt;</span></div><div class="line">  只有通过登录界面进行登录的用户才能看到2。</div><div class="line"><span class="tag">&lt;<span class="name">%&#125;%</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>各属性对应的优先级</strong><br>&emsp;&emsp;既然我们可以通过属性access、url、ifAllGranted、ifAnyGranted等来指定应当具有的权限，那么当同时指定多个属性时，它们的作用效果是什么样的呢？authorize标签进行权限鉴定的属性根据优先级的不同可以分为三类，access为一类；url为一类；ifAllGranted、ifAnyGranted和ifNotGranted为一类。这三类将同时只有一类产生效果。它们的优先级如下：既然我们可以通过属性access、url、ifAllGranted、ifAnyGranted等来指定应当具有的权限，那么当同时指定多个属性时，它们的作用效果是什么样的呢？authorize标签进行权限鉴定的属性根据优先级的不同可以分为三类，access为一类；url为一类；ifAllGranted、ifAnyGranted和ifNotGranted为一类。这三类将同时只有一类产生效果。它们的优先级如下：  </p>
<ol>
<li>access具有最高的优先级，如果指定了access属性，那么将以access属性指定的表达式来鉴定当前用户是否有权限。不管结果如何，此时其它属性都将被忽略。</li>
<li>如果没有指定access属性，那么url属性将具有最高优先级，此时将直接通过url属性和method属性（默认为GET）来鉴定当前用户是否有权限。不管结果如何，此时都将忽略ifAllGranted、ifAnyGranted和ifNotGranted属性。</li>
<li>如果access和url都没有指定，那么将使用第三类属性来鉴定当前用户的权限。当第三类里面同时指定了多个属性时，它们将都发生效果，即必须指定的三类权限都满足才认为是有对应的权限。如ifAllGranted要求有ROLE_USER的权限，同时ifNotGranted要求不能有ROLE_ADMIN的权限，则结果是它们的并集，即只有拥有ROLE_USER权限，同时不拥有ROLE_ADMIN权限的用户才被允许获取指定的内容。</li>
</ol>
<p>二. <strong>authentication</strong><br>&emsp;&emsp;authentication标签用来代表当前Authentication对象，主要用于获取当前Authentication的相关信息。authentication标签的主要属性是property属性，我们可以通过它来获取当前Authentication对象的相关信息。如通常我们的Authentication对象中存放的principle是一个UserDetails对象，所以我们可以通过如下的方式来获取当前用户的用户名。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">sec:authentication</span> <span class="attr">property</span>=<span class="string">"principal.username"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>当然，我们也可以直接通过Authentication的name属性来获取其用户名。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">sec:authentication</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>property属性只允许指定Authentication所拥有的属性，可以进行属性的级联获取，如“principle.username”，不允许直接通过方法进行调用<br>除了property属性之外，authentication还可以指定的属性有：var、scope和htmlScape。<br>2.1 <strong>var属性</strong><br>&emsp;&emsp;var属性用于指定一个属性名，这样当获取到了authentication的相关信息后会将其以var指定的属性名进行存放，默认是存放在pageConext中。可以通过scope属性进行指定。此外，当指定了var属性后，authentication标签不会将获取到的信息在页面上进行展示，如需展示用户应该通过var指定的属性进行展示，或去掉var属性。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 将获取到的用户名以属性名username存放在session中 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">sec:authentication</span> <span class="attr">property</span>=<span class="string">"principal.username"</span> <span class="attr">scope</span>=<span class="string">"session"</span> <span class="attr">var</span>=<span class="string">"username"</span>/&gt;</span></div><div class="line">$&#123;username &#125;</div></pre></td></tr></table></figure></p>
<p>2.2 <strong>scope属性</strong><br>与var属性一起使用，用于指定存放获取的结果的属性名的作用范围，默认为pageContext。Jsp中拥有的作用范围都进行进行指定。<br>2.3  <strong>htmlScape属性</strong><br>表示是否需要将html进行转义。默认为true。</p>
<p>三. <strong>accesscontrollist</strong><br>&emsp;&emsp;accesscontrollist标签是用于鉴定ACL权限的。其一共定义了三个属性：hasPermission、domainObject和var，其中前两个是必须指定的。hasPermission属性用于指定以逗号分隔的权限列表；domainObject用于指定对应的域对象；而var则是用以将鉴定的结果以指定的属性名存入pageContext中，以供同一页面的其它地方使用。需要注意的是使用accesscontrollist标签时ApplicationContext中必须存在一个PermissionEvaluator bean，因为accesscontrollist标签就是通过PermissionEvaluator来鉴定对应的权限的。如果我们正在使用Spring Security的ACL模块，那么PermissionEvaluator通常就对应着AclPermissionEvaluator。此外，如果domainObject属性指定的domainObject为null则默认认为是有权限的，否则如果当前Authentication对象为null则默认认为是没有权限的。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">sec:accesscontrollist</span> <span class="attr">hasPermission</span>=<span class="string">"1,2"</span> <span class="attr">domainObject</span>=<span class="string">"$&#123;someTargetDomainObject &#125;"</span> &gt;</span></div><div class="line">  如果当前Authentication对指定的domainObject拥有指定的hasPermission则将可以看到这部分内容。</div><div class="line"><span class="tag">&lt;/<span class="name">sec:accesscontrollist</span>&gt;</span></div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Spring/Security/配置十八：Jsp标签/" data-id="cjfvvphma009mm9fyvyrdiwpb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Spring/Security/配置十三：session管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/15/Spring/Security/配置十三：session管理/" class="article-date">
  <time datetime="2017-08-15T02:09:45.000Z" itemprop="datePublished">2017-08-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>►<a class="article-category-link" href="/categories/Spring/Security/">Security</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/Spring/Security/配置十三：session管理/">配置十三：session管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> &emsp;&emsp;Spring Security通过http元素下的子元素session-management提供了对Http Session管理的支持。</p>
<p> 一. <strong>检测session超时</strong><br>&emsp;&emsp;Spring Security可以在用户使用已经超时的sessionId进行请求时将用户引导到指定的页面。这个可以通过如下配置来实现。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">security:http</span>&gt;</span></div><div class="line">      ...</div><div class="line">  <span class="comment">&lt;!-- session管理，invalid-session-url指定使用已经超时的sessionId进行请求需要重定向的页面 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:session-management</span> <span class="attr">invalid-session-url</span>=<span class="string">"/session_timeout.jsp"</span>/&gt;</span></div><div class="line">  ...</div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;需要注意的是session超时的重定向页面应当是不需要认证的，否则再重定向到session超时页面时会直接转到用户登录页面。此外如果你使用这种方式来检测session超时，当你退出了登录，然后在没有关闭浏览器的情况下又重新进行了登录，Spring Security可能会错误的报告session已经超时。这是因为即使你已经退出登录了，但当你设置session无效时，对应保存session信息的cookie并没有被清除，等下次请求时还是会使用之前的sessionId进行请求。解决办法是显示的定义用户在退出登录时删除对应的保存session信息的cookie。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span>&gt;</span></div><div class="line">  ...</div><div class="line">  <span class="comment">&lt;!-- 退出登录时删除session对应的cookie --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security:logout</span> <span class="attr">delete-cookies</span>=<span class="string">"JSESSIONID"</span>/&gt;</span></div><div class="line">  ...</div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;此外，Spring Security并不保证这对所有的Servlet容器都有效，到底在你的容器上有没有效，需要你自己进行实验。</p>
<p>二. <strong>concurrency-control</strong><br>&emsp;&emsp;通常情况下，在你的应用中你可能只希望同一用户在同时登录多次时只能有一个是成功登入你的系统的，通常对应的行为是后一次登录将使前一次登录失效，或者直接限制后一次登录。Spring Security的session-management为我们提供了这种限制。<br>&emsp;&emsp;首先需要我们在web.xml中定义如下监听器。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">listener</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.security.web.session.HttpSessionEventPublisher<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在session-management元素下有一个concurrency-control元素是用来限制同一用户在应用中同时允许存在的已经通过认证的session数量。这个值默认是1，可以通过concurrency-control元素的max-sessions属性来指定。<br> <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">security:http</span> <span class="attr">auto-config</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">      ...</div><div class="line">      <span class="tag">&lt;<span class="name">security:session-management</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">security:concurrency-control</span> <span class="attr">max-sessions</span>=<span class="string">"1"</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">security:session-management</span>&gt;</span></div><div class="line">      ...</div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;当同一用户同时存在的已经通过认证的session数量超过了max-sessions所指定的值时，Spring Security的默认策略是将先前的设为无效。如果要限制用户再次登录可以设置concurrency-control的error-if-maximum-exceeded的值为true。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">security:http</span> <span class="attr">auto-config</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">      ...</div><div class="line">      <span class="tag">&lt;<span class="name">security:session-management</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">security:concurrency-control</span> <span class="attr">max-sessions</span>=<span class="string">"1"</span> <span class="attr">error-if-maximum-exceeded</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">security:session-management</span>&gt;</span></div><div class="line">      ...</div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;设置error-if-maximum-exceeded为true后如果你之前已经登录了，然后想再次登录，那么系统将会拒绝你的登录，同时将重定向到由form-login指定的authentication-failure-url。如果你的再次登录是通过Remember-Me来完成的，那么将不会转到authentication-failure-url，而是返回未授权的错误码401给客户端，如果你还是想重定向一个指定的页面，那么你可以通过session-management的session-authentication-error-url属性来指定，同时需要指定该url为不受Spring Security管理，即通过http元素设置其secure=”none”。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">security:http</span> <span class="attr">security</span>=<span class="string">"none"</span> <span class="attr">pattern</span>=<span class="string">"/none/**"</span> /&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">security:http</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:form-login</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:logout</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span>/&gt;</span></div><div class="line">      <span class="comment">&lt;!-- session-authentication-error-url必须是不受Spring Security管理的 --&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:session-management</span> <span class="attr">session-authentication-error-url</span>=<span class="string">"/none/session_authentication_error.jsp"</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">security:concurrency-control</span> <span class="attr">max-sessions</span>=<span class="string">"1"</span> <span class="attr">error-if-maximum-exceeded</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">security:session-management</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:remember-me</span> <span class="attr">data-source-ref</span>=<span class="string">"dataSource"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在上述配置中我们配置了session-authentication-error-url为“/none/session_authentication_error.jsp”，同时我们通过<code>&lt;security:http security=&quot;none&quot; pattern=&quot;/none/**&quot; /&gt;</code>指定了以“/none”开始的所有URL都不受Spring Security控制，这样当用户进行登录以后，再次通过Remember-Me进行自动登录时就会重定向到“/none/session_authentication_error.jsp”了。<br>&emsp;&emsp;在上述配置中为什么我们需要通过<code>&lt;security:http security=&quot;none&quot; pattern=&quot;/none/**&quot; /&gt;</code>指定我们的session-authentication-error-url不受Spring Security控制呢？把它换成<code>&lt;security:intercept-url pattern=&quot;/none/**&quot; access=&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot;/&gt;</code>不行吗？这就涉及到之前所介绍的它们两者之间的区别了。前者表示不使用任何Spring Security过滤器，自然也就不需要通过Spring Security的认证了，而后者是会被Spring Security的FilterChain进行过滤的，只是其对应的URL可以匿名访问，即不需要登录就可访问。使用后者时，REMEMBER_ME_FILTER检测到用户没有登录，同时其又提供了Remember-Me的相关信息，这将使得REMEMBER_ME_FILTER进行自动登录，那么在自动登录时由于我们限制了同一用户同一时间只能登录一次，后来者将被拒绝登录，这个时候将重定向到session-authentication-error-url，重定向访问session-authentication-error-url时，经过REMEMBER_ME_FILTER时又会自动登录，这样就形成了一个死循环。所以session-authentication-error-url应当使用<code>&lt;security:http security=&quot;none&quot; pattern=&quot;/none/**&quot; /&gt;</code>设置为不受Spring Security控制，而不是使用<code>&lt;security:intercept-url pattern=&quot;/none/**&quot; access=&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot;/&gt;</code>。<br>&emsp;&emsp;此外，可以通过expired-url属性指定当用户尝试使用一个由于其再次登录导致session超时的session时所要跳转的页面。同时需要注意设置该URL为不需要进行认证。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security:http</span> <span class="attr">auto-config</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:form-login</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:logout</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/expired.jsp"</span> <span class="attr">access</span>=<span class="string">"IS_AUTHENTICATED_ANONYMOUSLY"</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"ROLE_USER"</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">security:session-management</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">security:concurrency-control</span> <span class="attr">max-sessions</span>=<span class="string">"1"</span> <span class="attr">expired-url</span>=<span class="string">"/expired.jsp"</span> /&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">security:session-management</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>三. <strong>session 固定攻击保护</strong><br>&emsp;&emsp;session固定是指服务器在给客户端创建session后，在该session过期之前，它们都将通过该session进行通信。session 固定攻击是指恶意攻击者先通过访问应用来创建一个session，然后再让其他用户使用相同的session进行登录（比如通过发送一个包含该sessionId参数的链接），待其他用户成功登录后，攻击者利用原来的sessionId访问系统将和原用户获得同样的权限。Spring Security默认是对session固定攻击采取了保护措施的，它会在用户登录的时候重新为其生成一个新的session。如果你的应用不需要这种保护或者该保护措施与你的某些需求相冲突，你可以通过session-management的session-fixation-protection属性来改变其保护策略。该属性的可选值有如下三个。  </p>
<ul>
<li><strong>migrateSession</strong>：这是默认值。其表示在用户登录后将新建一个session，同时将原session中的attribute都copy到新的session中。</li>
<li><strong>none</strong>：表示继续使用原来的session。</li>
<li><strong>newSession</strong>：表示重新创建一个新的session，但是不copy原session拥有的attribute。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/08/15/Spring/Security/配置十三：session管理/" data-id="cjfvvphmg009om9fy5b2v6orl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/6/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/8/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Eclipse/">Eclipse</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Github/">Github</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Cookie/">Cookie</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JAXB/">JAXB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JavaMail/">JavaMail</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/基础/">基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/数据类型/">数据类型</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/日记/">日记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/时间日期/">时间日期</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/线程/">线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/网络NIO/">网络NIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/队列/">队列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/集合/">集合</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Application-Event/">Application Event</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/JPA/">JPA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Security/">Security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Spring-Boot/">Spring Boot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Spring-Session/">Spring Session</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Task/">Task</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-MVC/">spring MVC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-data-redis/">spring data redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/基础/">基础</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/">前端技术相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/forever/">forever</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/javascript/">javascript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库相关/">数据库相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据库相关/mysql/">mysql</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/">服务器相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hessian/">Hessian</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hudson-Jenkins/">Hudson & Jenkins</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Memcached/">Memcached</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Nginx/">Nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Tomcat/">Tomcat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/red5/">red5</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/resin/">resin</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/正则表达式/">正则表达式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/12/服务器相关/Tomcat/TOMCAT原理详解及请求过程/">TOMCAT原理详解及请求过程</a>
          </li>
        
          <li>
            <a href="/2018/04/12/网络/HTTPS工作原理/">HTTPS工作原理</a>
          </li>
        
          <li>
            <a href="/2018/04/12/网络/三次握手和四次挥手/">三次握手和四次挥手</a>
          </li>
        
          <li>
            <a href="/2018/04/12/服务器相关/Tomcat/内存分配/">内存分配</a>
          </li>
        
          <li>
            <a href="/2018/04/12/服务器相关/Tomcat/Tomcat整体架构浅析/">Tomcat整体架构浅析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 LeoChan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>