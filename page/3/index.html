<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LeoChan&#39;s 个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="描述啊">
<meta property="og:type" content="website">
<meta property="og:title" content="LeoChan&#39;s 个人博客">
<meta property="og:url" content="https://clq2owesome.github.io/page/3/index.html">
<meta property="og:site_name" content="LeoChan&#39;s 个人博客">
<meta property="og:description" content="描述啊">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeoChan&#39;s 个人博客">
<meta name="twitter:description" content="描述啊">
  
    <link rel="alternate" href="/atom.xml" title="LeoChan&#39;s 个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LeoChan&#39;s 个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术都是通用的，重要的是是否具有自主解决问题的能力！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://clq2owesome.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-数据库相关/mysql/主键约束,唯一约束与默认约束" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/数据库相关/mysql/主键约束,唯一约束与默认约束/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库相关/">数据库相关</a>►<a class="article-category-link" href="/categories/数据库相关/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/数据库相关/mysql/主键约束,唯一约束与默认约束/">主键约束,唯一约束与默认约束</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="主键约束（PRIMARY-KEY）"><a href="#主键约束（PRIMARY-KEY）" class="headerlink" title="主键约束（PRIMARY KEY）"></a>主键约束（PRIMARY KEY）</h3><ol>
<li>主键用于唯一地标识表中的每一条记录，可以定义一列或多列为主键。 一个表只有一个主键</li>
<li>是不可能（或很难）更新． 几乎不会对主键进行更新操作</li>
<li>主键列上没有任何两行具有相同值（即重复值），不允许空（NULL）． </li>
<li>主健可作外健，唯一索引不可；</li>
</ol>
<h3 id="唯一性约束（UNIQUE）"><a href="#唯一性约束（UNIQUE）" class="headerlink" title="唯一性约束（UNIQUE）"></a>唯一性约束（UNIQUE）</h3><ol>
<li>唯一性约束用来限制不受主键约束的列上的数据的唯一性，用于作为访问某行的可选手段</li>
<li>只要唯一就可以更新． </li>
<li>即表中任意两行在 指定列上都不允许有相同的值，允许空（NULL）． </li>
<li>一个表上可以放置多个唯一性约束</li>
</ol>
<h5 id="唯一性约束和主键约束的区别："><a href="#唯一性约束和主键约束的区别：" class="headerlink" title="唯一性约束和主键约束的区别："></a>唯一性约束和主键约束的区别：</h5><ol>
<li>唯一性约束允许在该列上存在NULL值，而主键约束的限制更为严格，不但不允许有重复，而且也不允许有空值。 </li>
<li>在创建唯一性约束和主键约束时可以创建聚集索引和非聚集索引，但在 默认情况下主键约束产生聚集索引，而唯一性约束产生非聚集索引</li>
</ol>
<h3 id="默认值-DEFAULT"><a href="#默认值-DEFAULT" class="headerlink" title="默认值(DEFAULT)"></a>默认值(DEFAULT)</h3><p>当插入记录时，如果没有明确为字段赋值，则自动赋予默认值。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/数据库相关/mysql/主键约束,唯一约束与默认约束/" data-id="cjfvvphpd00fjm9fyk0zrsg8x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据库相关/mysql/主从结构（master-slave）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/数据库相关/mysql/主从结构（master-slave）/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库相关/">数据库相关</a>►<a class="article-category-link" href="/categories/数据库相关/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/数据库相关/mysql/主从结构（master-slave）/">主从结构（master-slave）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>MySQL数据库自身提供的主从复制功能可以方便的实现数据的多处自动备份，实现数据库的拓展。多个数据备份不仅可以加强数据的安全性，通过实现读写分离还能进一步提升数据库的负载性能。</p>
<p>下图就描述了一个多个数据库间主从复制与读写分离的模型(来源网络)：<br><img src="http://images2015.cnblogs.com/blog/1043616/201612/1043616-20161213151157558-1150305350.jpg" alt="image"><br>在一主多从的数据库体系中，多个从服务器采用异步的方式更新主数据库的变化，业务服务器在执行写或者相关修改数据库的操作是在主服务器上进行的，读操作则是在各从服务器上进行。如果配置了多个从服务器或者多个主服务器又涉及到相应的负载均衡问题，关于负载均衡具体的技术细节还没有研究过，今天就先简单的实现一主一从的主从复制功能。</p>
<h3 id="复制概述"><a href="#复制概述" class="headerlink" title="复制概述"></a>复制概述</h3><p>Mysql内建的复制功能是构建大型，高性能应用程序的基础。将Mysql的数据分布到多个系统上去，这种分布的机制，是通过将Mysql的某一台主机的数据复制到其它主机（slaves）上，并重新执行一遍来实现的。复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循环。这些日志可以记录发送到从服务器的更新。当一个从服务器连接主服务器时，它通知主服务器从服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知新的更新。</p>
<p>请注意当你进行复制时，所有对复制中的表的更新必须在主服务器上进行。否则，你必须要小心，以避免用户对主服务器上的表进行的更新与对从服务器上的表所进行的更新之间的冲突。</p>
<h3 id="mysql支持的复制类型"><a href="#mysql支持的复制类型" class="headerlink" title="mysql支持的复制类型"></a>mysql支持的复制类型</h3><ol>
<li><p><code>基于语句的复制</code>：  在主服务器上执行的SQL语句，在从服务器上执行同样的语句。MySQL默认采用基于语句的复制，效率比较高。<br>一旦发现没法精确复制时，   会自动选着基于行的复制。 </p>
</li>
<li><p><code>基于行的复制</code>：把改变的内容复制过去，而不是把命令在从服务器上执行一遍. 从mysql5.0开始支持</p>
</li>
<li><p><code>混合类型的复制</code>: 默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。</p>
</li>
</ol>
<h3 id="复制解决的问题"><a href="#复制解决的问题" class="headerlink" title="复制解决的问题"></a>复制解决的问题</h3><p>MySQL复制技术有以下一些特点：</p>
<ol>
<li>数据分布 (Data distribution )</li>
<li>负载平衡(load balancing)</li>
<li>备份(Backups) </li>
<li>高可用性和容错行(High availability and failover)</li>
</ol>
<h3 id="复制如何工作"><a href="#复制如何工作" class="headerlink" title="复制如何工作"></a>复制如何工作</h3><p>整体上来说，复制有3个步骤：   </p>
<ol>
<li>master将改变记录到二进制日志(binary log)中（这些记录叫做二进制日志事件，binary log events）；</li>
<li>slave将master的binary log events拷贝到它的中继日志(relay log)；</li>
<li>slave重做中继日志中的事件，将改变反映它自己的数据。</li>
</ol>
<p>下图描述了复制的过程：<br><img src="http://hi.csdn.net/attachment/201202/28/0_1330439010P7lI.gif" alt="image"><br>第一步是在主库上记录二进制日志。在每次准备提交事务完成数据更新前，主库将数据更新的事件记录到二进制日志中。MySQL会按事务提交的顺序而非每条语句的执行顺序来记录二进制日志。在记录二进制日志后，主库会告诉存储引擎可以提交事务了。</p>
<p>下一步，备库将主库的二进制日志复制到其本地的中继日志中。首先，备库会启动一个工作线程，称为I/O线程，I/O线程跟主库建立一个普通的客户端连接，然后在主库上启动一个特殊的二进制转储（binlog dunp）线程（该线程没有对应的SQL命令），这个二进制转储线程会读取主库上二进制日志中的事件。它不会对事件进行轮询。如果该线程追赶上了主库，它将进入睡眠状态，直到主库发送信号量通知其有新的事件产生时才会被唤醒，备库I/O线程会将接收到的事件记录到中继日志中。</p>
<p>备库的SQL线程执行最后一步，将线程从中继日志中读取事件并在备库执行，从而实现备库数据的更新。当SQL线程追赶上I/O线程时，中继日志通常已经在系统缓存中，所以中继日志的开销很低。SQL线程执行的事件也可以通过配置选项来决定是否写入其自己的二进制日志中。</p>
<p>这种复制架构实现了获取事件和重放事件的解耦，允许这两个过程异步进行。也就是说I/O线程能够独立于SQL线程之外工作。但这种架构也限制了复制的过程，其中最重要的一点是在主库上并发运行的查询在备库只能串行化执行，因为只有一个SQL线程来重放中继日志中的事件。</p>
<h3 id="复制配置"><a href="#复制配置" class="headerlink" title="复制配置"></a>复制配置</h3><p>有两台MySQL数据库服务器Master和slave，Master为主服务器，slave为从服务器，初始状态时，Master和slave中的数据信息相同，当Master中的数据发生变化时，slave也跟着发生相应的变化，使得master和slave的数据信息同步，达到备份的目的。    </p>
<h5 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h5><p>负责在主、从服务器传输各种修改动作的媒介是主服务器的二进制变更日志，这个日志记载着需要传输给从服务器的各种修改动作。因此，主服务器必须激活二进制日志功能。从服务器必须具备足以让它连接主服务器并请求主服务器把二进制变更日志传输给它的权限。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="主服务器配置"><a href="#主服务器配置" class="headerlink" title="主服务器配置"></a>主服务器配置</h4><ol>
<li><p>修改mysql配置<br>找到主数据库的配置文件my.cnf(或者my.ini)，我的在/etc/mysql/my.cnf,在[mysqld]部分插入如下两行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[mysqld]</div><div class="line">log-bin=mysql-bin #开启二进制日志</div><div class="line">server-id=1 #设置server-id</div></pre></td></tr></table></figure>
</li>
<li><p>重启mysql，创建用于同步的用户账号<br>打开mysql会话shell&gt;<code>mysql -h localhost -u name -p password</code></p>
</li>
</ol>
<p>创建用户并授权：用户：rel1密码：slavepass<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql&gt; CREATE USER &apos;repl&apos;@&apos;123.57.44.85&apos; IDENTIFIED BY &apos;slavepass&apos;;#创建用户</div><div class="line">mysql&gt; GRANT REPLICATION SLAVE ON *.* TO &apos;repl&apos;@&apos;123.57.44.85&apos;;#分配权限</div><div class="line">mysql&gt;flush privileges;   #刷新权限</div></pre></td></tr></table></figure></p>
<ol>
<li>查看master状态，记录二进制文件名(mysql-bin.000003)和位置(73)：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql &gt; SHOW MASTER STATUS;</div><div class="line">+------------------+----------+--------------+------------------+</div><div class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |</div><div class="line">+------------------+----------+--------------+------------------+</div><div class="line">| mysql-bin.000003 | 73       | test         | manual,mysql     |</div><div class="line">+------------------+----------+--------------+------------------+</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="从服务器slave修改："><a href="#从服务器slave修改：" class="headerlink" title="从服务器slave修改："></a>从服务器slave修改：</h4><ol>
<li><p>修改mysql配置<br>同样找到my.cnf配置文件，添加server-id</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[mysqld]</div><div class="line">server-id=2 #设置server-id，必须唯一</div></pre></td></tr></table></figure>
</li>
<li><p>重启mysql，打开mysql会话，执行同步SQL语句(需要主服务器主机名，登陆凭据，二进制文件的名称和位置)：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; CHANGE MASTER TO</div><div class="line">    -&gt;     MASTER_HOST=&apos;182.92.172.80&apos;,</div><div class="line">    -&gt;     MASTER_USER=&apos;rep1&apos;,</div><div class="line">    -&gt;     MASTER_PASSWORD=&apos;slavepass&apos;,</div><div class="line">    -&gt;     MASTER_LOG_FILE=&apos;mysql-bin.000003&apos;,</div><div class="line">    -&gt;     MASTER_LOG_POS=73;</div></pre></td></tr></table></figure>
</li>
<li><p>启动slave同步进程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt;start slave;</div></pre></td></tr></table></figure>
</li>
<li><p>查看slave状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show slave status\G;</div><div class="line">*************************** 1. row ***************************</div><div class="line">               Slave_IO_State: Waiting for master to send event</div><div class="line">                  Master_Host: 182.92.172.80</div><div class="line">                  Master_User: rep1</div><div class="line">                  Master_Port: 3306</div><div class="line">                Connect_Retry: 60</div><div class="line">              Master_Log_File: mysql-bin.000013</div><div class="line">          Read_Master_Log_Pos: 11662</div><div class="line">               Relay_Log_File: mysqld-relay-bin.000022</div><div class="line">                Relay_Log_Pos: 11765</div><div class="line">        Relay_Master_Log_File: mysql-bin.000013</div><div class="line">             Slave_IO_Running: Yes</div><div class="line">            Slave_SQL_Running: Yes</div><div class="line">              Replicate_Do_DB: </div><div class="line">          Replicate_Ignore_DB: </div><div class="line">        ...</div></pre></td></tr></table></figure>
</li>
</ol>
<p>当Slave_IO_Running和Slave_SQL_Running都为YES的时候就表示主从同步设置成功了。接下来就可以进行一些验证了，比如在主master数据库的test数据库的一张表中插入一条数据，在slave的test库的相同数据表中查看是否有新增的数据即可验证主从复制功能是否有效，还可以关闭slave（<code>mysql&gt;stop slave;</code>）,然后再修改master，看slave是否也相应修改（停止slave后，master的修改不会同步到slave），就可以完成主从复制功能的验证了。</p>
<p>还可以用到的其他相关参数：</p>
<p>master开启二进制日志后默认记录所有库所有表的操作，可以通过配置来指定只记录指定的数据库甚至指定的表的操作，具体在mysql配置文件的[mysqld]可添加修改如下选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 不同步哪些数据库  </div><div class="line">binlog-ignore-db = mysql  </div><div class="line">binlog-ignore-db = test  </div><div class="line">binlog-ignore-db = information_schema  </div><div class="line">  </div><div class="line"># 只同步哪些数据库，除此之外，其他不同步  </div><div class="line">binlog-do-db = game</div></pre></td></tr></table></figure></p>
<h3 id="添加新slave服务器"><a href="#添加新slave服务器" class="headerlink" title="添加新slave服务器"></a>添加新slave服务器</h3><p>假如master已经运行很久了，想对新安装的slave进行数据同步，甚至它没有master的数据。<br>此时，有几种方法可以使slave从另一个服务开始，例如，从master拷贝数据，从另一个slave克隆，从最近的备份开始一个slave。Slave与master同步时，需要三样东西：</p>
<ol>
<li>master的某个时刻的数据快照；</li>
<li>master当前的日志文件、以及生成快照时的字节偏移。这两个值可以叫做日志文件坐标(log file coordinate)，因为它们确定了一个二进制日志的位置，你可以用SHOW MASTER STATUS命令找到日志文件的坐标；</li>
<li>master的二进制日志文件。</li>
</ol>
<p>可以通过以下几中方法来克隆一个slave：</p>
<ol>
<li>冷拷贝(cold copy)<br>停止master，将master的文件拷贝到slave；然后重启master。缺点很明显。</li>
<li>热拷贝(warm copy)<br>如果你仅使用MyISAM表，你可以使用mysqlhotcopy拷贝，即使服务器正在运行。</li>
<li><p>使用mysqldump<br>使用mysqldump来得到一个数据快照可分为以下几步：</p>
<ol>
<li><p>锁表：如果你还没有锁表，你应该对表加锁，防止其它连接修改数据库，否则，你得到的数据可以是不一致的。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; FLUSH TABLES WITH READ LOCK;</div></pre></td></tr></table></figure>
</li>
<li><p>在另一个连接用mysqldump创建一个你想进行复制的数据库的转储：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shell&gt; mysqldump --all-databases --lock-all-tables &gt;dbdump.db</div></pre></td></tr></table></figure>
</li>
<li><p>对表释放锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; UNLOCK TABLES;</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h3 id="深入了解复制"><a href="#深入了解复制" class="headerlink" title="深入了解复制"></a>深入了解复制</h3><h4 id="基于语句的复制-Statement-Based-Replication"><a href="#基于语句的复制-Statement-Based-Replication" class="headerlink" title="基于语句的复制(Statement-Based Replication)"></a>基于语句的复制(Statement-Based Replication)</h4><p>MySQL 5.0及之前的版本仅支持基于语句的复制（也叫做逻辑复制，logical replication），这在数据库并不常见。master记录下改变数据的查询，然后，slave从中继日志中读取事件，并执行它，这些SQL语句与master执行的语句一样。 </p>
<p>这种方式的优点就是实现简单。此外，基于语句的复制的二进制日志可以很好的进行压缩，而且日志的数据量也较小，占用带宽少——例如，一个更新GB的数据的查询仅需要几十个字节的二进制日志。而mysqlbinlog对于基于语句的日志处理十分方便。</p>
<p>但是，基于语句的复制并不是像它看起来那么简单，因为一些查询语句依赖于master的特定条件，例如，master与slave可能有不同的时间。所以，MySQL的二进制日志的格式不仅仅是查询语句，还包括一些元数据信息，例如，当前的时间戳。即使如此，还是有一些语句，比如，CURRENT USER函数，不能正确的进行复制。此外，存储过程和触发器也是一个问题。</p>
<p>另外一个问题就是基于语句的复制必须是串行化的。这要求大量特殊的代码，配置，例如InnoDB的next-key锁等。并不是所有的存储引擎都支持基于语句的复制。</p>
<h4 id="基于记录的复制-Row-Based-Replication"><a href="#基于记录的复制-Row-Based-Replication" class="headerlink" title="基于记录的复制(Row-Based Replication)"></a>基于记录的复制(Row-Based Replication)</h4><p>MySQL增加基于记录的复制，在二进制日志中记录下实际数据的改变，这与其它一些DBMS的实现方式类似。这种方式有优点，也有缺点。优点就是可以对任何语句都能正确工作，一些语句的效率更高。主要的缺点就是二进制日志可能会很大，而且不直观，所以，你不能使用mysqlbinlog来查看二进制日志。<br>对于一些语句，基于记录的复制能够更有效的工作，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mysql&gt; INSERT INTO summary_table(col1, col2, sum_col3)</div><div class="line">    -&gt; SELECT col1, col2, sum(col3)</div><div class="line">    -&gt; FROM enormous_table</div><div class="line">    -&gt; GROUP BY col1, col2;</div></pre></td></tr></table></figure></p>
<p>假设，只有三种唯一的col1和col2的组合，但是，该查询会扫描原表的许多行，却仅返回三条记录。此时，基于记录的复制效率更高。  </p>
<p>另一方面，下面的语句，基于语句的复制更有效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; UPDATE enormous_table SET col1 = 0;</div></pre></td></tr></table></figure></p>
<p>此时使用基于记录的复制代价会非常高。由于两种方式不能对所有情况都能很好的处理，所以，MySQL 5.1支持在基于语句的复制和基于记录的复制之前动态交换。你可以通过设置session变量binlog_format来进行控制。</p>
<h4 id="复制相关的文件"><a href="#复制相关的文件" class="headerlink" title="复制相关的文件"></a>复制相关的文件</h4><p>除了二进制日志和中继日志文件外，还有其它一些与复制相关的文件。如下：    </p>
<ul>
<li><p>mysql-bin.index<br>服务器一旦开启二进制日志，会产生一个与二日志文件同名，但是以.index结尾的文件。它用于跟踪磁盘上存在哪些二进制日志文件。MySQL用它来定位二进制日志文件。</p>
</li>
<li><p>mysql-relay-bin.index<br>该文件的功能与mysql-bin.index类似，但是它是针对中继日志，而不是二进制日志</p>
</li>
<li><p>master.info<br>保存master的相关信息。不要删除它，否则，slave重启后不能连接master</p>
</li>
<li><p>relay-log.info<br>包含slave中当前二进制日志和中继日志的信息。</p>
</li>
</ul>
<h4 id="发送复制事件到其它slave"><a href="#发送复制事件到其它slave" class="headerlink" title="发送复制事件到其它slave"></a>发送复制事件到其它slave</h4><p>当设置log_slave_updates时，你可以让slave扮演其它slave的master。此时，slave把SQL线程执行的事件写进行自己的二进制日志(binary log)，然后，它的slave可以获取这些事件并执行它。如下：<br><img src="http://images.cnblogs.com/cnblogs_com/hustcat/mysql/mysql03-5.JPG" alt="image">  </p>
<h4 id="复制过滤-Replication-Filters"><a href="#复制过滤-Replication-Filters" class="headerlink" title="复制过滤(Replication Filters)"></a>复制过滤(Replication Filters)</h4><p>复制过滤可以让你只复制服务器中的一部分数据，有两种复制过滤：在master上过滤二进制日志中的事件；在slave上过滤中继日志中的事件。如下：<br><img src="http://images.cnblogs.com/cnblogs_com/hustcat/mysql/mysql03-6.JPG" alt="image">  </p>
<h3 id="复制的常用拓扑结构"><a href="#复制的常用拓扑结构" class="headerlink" title="复制的常用拓扑结构"></a>复制的常用拓扑结构</h3><p>复制的体系结构有以下一些基本原则：</p>
<ul>
<li>每个slave只能有一个master；</li>
<li>每个slave只能有一个唯一的服务器ID；</li>
<li>每个master可以有很多slave；</li>
<li>如果你设置log_slave_updates，slave可以是其它slave的master，从而扩散master的更新。</li>
</ul>
<p>MySQL不支持多主服务器复制(Multimaster Replication)——即一个slave可以有多个master。但是，通过一些简单的组合，我们却可以建立灵活而强大的复制体系结构。</p>
<h4 id="单一master和多slave"><a href="#单一master和多slave" class="headerlink" title="单一master和多slave"></a>单一master和多slave</h4><p>由一个master和一个slave组成复制系统是最简单的情况。Slave之间并不相互通信，只能与master进行通信。如下：<br><img src="http://images.cnblogs.com/cnblogs_com/hustcat/mysql/mysql03-7.JPG" alt="image">  </p>
<p>如果写操作较少，而读操作很时，可以采取这种结构。你可以将读操作分布到其它的slave，从而减小master的压力。但是，当slave增加到一定数量时，slave对master的负载以及网络带宽都会成为一个严重的问题。</p>
<p>这种结构虽然简单，但是，它却非常灵活，足够满足大多数应用需求。一些建议：</p>
<ol>
<li>不同的slave扮演不同的作用(例如使用不同的索引，或者不同的存储引擎)；</li>
<li>用一个slave作为备用master，只进行复制；</li>
<li>用一个远程的slave，用于灾难恢复；</li>
</ol>
<h4 id="主动模式的Master-Master-Master-Master-in-Active-Active-Mode"><a href="#主动模式的Master-Master-Master-Master-in-Active-Active-Mode" class="headerlink" title="主动模式的Master-Master(Master-Master in Active-Active Mode)"></a>主动模式的Master-Master(Master-Master in Active-Active Mode)</h4><p>Master-Master复制的两台服务器，既是master，又是另一台服务器的slave。如图：<br><img src="http://images.cnblogs.com/cnblogs_com/hustcat/mysql/mysql03-8.JPG" alt="image"><br>主动的Master-Master复制有一些特殊的用处。例如，地理上分布的两个部分都需要自己的可写的数据副本。这种结构最大的问题就是更新冲突。假设一个表只有一行(一列)的数据，其值为1，如果两个服务器分别同时执行如下语句：  </p>
<p>在第一个服务器上执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; UPDATE tbl SET col=col + 1;</div></pre></td></tr></table></figure></p>
<p>在第二个服务器上执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; UPDATE tbl SET col=col * 2;</div></pre></td></tr></table></figure></p>
<p>那么结果是多少呢？一台服务器是4，另一个服务器是3，但是，这并不会产生错误。<br>实际上，MySQL并不支持其它一些DBMS支持的多主服务器复制(Multimaster Replication)，这是MySQL的复制功能很大的一个限制(多主服务器的难点在于解决更新冲突)，但是，如果你实在有这种需求，你可以采用MySQL Cluster，以及将Cluster和Replication结合起来，可以建立强大的高性能的数据库平台。但是，可以通过其它一些方式来模拟这种多主服务器的复制。</p>
<h4 id="主动-被动模式的Master-Master-Master-Master-in-Active-Passive-Mode"><a href="#主动-被动模式的Master-Master-Master-Master-in-Active-Passive-Mode" class="headerlink" title="主动-被动模式的Master-Master(Master-Master in Active-Passive Mode)"></a>主动-被动模式的Master-Master(Master-Master in Active-Passive Mode)</h4><p>这是master-master结构变化而来的，它避免了M-M的缺点，实际上，这是一种具有容错和高可用性的系统。它的不同点在于其中一个服务只能进行只读操作。如图：<br><img src="http://images.cnblogs.com/cnblogs_com/hustcat/mysql/mysql03-9.JPG" alt="image">  </p>
<h4 id="带从服务器的Master-Master结构-Master-Master-with-Slaves"><a href="#带从服务器的Master-Master结构-Master-Master-with-Slaves" class="headerlink" title="带从服务器的Master-Master结构(Master-Master with Slaves)"></a>带从服务器的Master-Master结构(Master-Master with Slaves)</h4><p>这种结构的优点就是提供了冗余。在地理上分布的复制结构，它不存在单一节点故障问题，而且还可以将读密集型的请求放到slave上。<br><img src="http://images.cnblogs.com/cnblogs_com/hustcat/mysql/mysql03-10.JPG" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/数据库相关/mysql/主从结构（master-slave）/" data-id="cjfvvphp500f9m9fy0lrbds9k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux/JDK安装" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Linux/JDK安装/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Linux/JDK安装/">JDK安装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="搜索包"><a href="#搜索包" class="headerlink" title="搜索包"></a>搜索包</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-cache search jdk</div></pre></td></tr></table></figure>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install openjdk-8-jdk</div></pre></td></tr></table></figure>
<h2 id="存在多个版本，自动配置："><a href="#存在多个版本，自动配置：" class="headerlink" title="存在多个版本，自动配置："></a>存在多个版本，自动配置：</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo update-alternatives --config Java</div></pre></td></tr></table></figure>
<h2 id="jdk安装路径"><a href="#jdk安装路径" class="headerlink" title="jdk安装路径"></a>jdk安装路径</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> root@iZwz9hwmk5t4idn4oxa4okZ:/usr/share# which java</div><div class="line">/usr/bin/java</div><div class="line">root@iZwz9hwmk5t4idn4oxa4okZ:/usr/share#  ls -lrt /usr/bin/java</div><div class="line">lrwxrwxrwx 1 root root 22 Feb  8  2017 /usr/bin/java -&gt; /etc/alternatives/java</div><div class="line">root@iZwz9hwmk5t4idn4oxa4okZ:/usr/share# ls -lrt /etc/alternatives/java</div><div class="line">lrwxrwxrwx 1 root root 46 Feb  8  2017 /etc/alternatives/java -&gt; /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java</div></pre></td></tr></table></figure>
<h2 id="Linux下修改-设置环境变量JAVA-HOME"><a href="#Linux下修改-设置环境变量JAVA-HOME" class="headerlink" title="Linux下修改/设置环境变量JAVA_HOME"></a>Linux下修改/设置环境变量JAVA_HOME</h2><h4 id="永久修改，对所有用户有效"><a href="#永久修改，对所有用户有效" class="headerlink" title="永久修改，对所有用户有效"></a>永久修改，对所有用户有效</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># vi /etc/profile</div><div class="line"></div><div class="line">export JAVA_HOME=/home/myuser/jdk1.7.0_03</div><div class="line"></div><div class="line">export PATH = $JAVA_HOME/bin:$PATH</div><div class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</div><div class="line"></div><div class="line">[注]：修改文件后如果想马上生效，还要运行 #source /etc/profile</div></pre></td></tr></table></figure>
<h4 id="永久修改，对单一用户有效"><a href="#永久修改，对单一用户有效" class="headerlink" title="永久修改，对单一用户有效"></a>永久修改，对单一用户有效</h4><p>修改用户目录下的.bash_profile文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ vi /home/myuser/.bash_profile</div><div class="line"></div><div class="line">加入：</div><div class="line">export JAVA_HOME=/home/myuser/jdk1.7.0_03</div><div class="line"></div><div class="line">export PATH = $JAVA_HOME/bin:$PATH</div><div class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</div><div class="line"></div><div class="line">[注]：修改文件后如果想马上生效，还要运行 #source /home/myuser/.bash_profile</div></pre></td></tr></table></figure></p>
<h4 id="只对当前bash-shell-生效"><a href="#只对当前bash-shell-生效" class="headerlink" title="只对当前bash /shell 生效"></a>只对当前bash /shell 生效</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ export JAVA_HOME=/home/myuser/jdk1.7.0_03</div><div class="line"></div><div class="line">$ export PATH=$JAVA_HOME/bin:$PATH</div><div class="line">$ export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Linux/JDK安装/" data-id="cjfvvphh7000sm9fyjks4hy3h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据库相关/mysql/explain分析sql效率" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/数据库相关/mysql/explain分析sql效率/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库相关/">数据库相关</a>►<a class="article-category-link" href="/categories/数据库相关/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/数据库相关/mysql/explain分析sql效率/">explain分析sql效率</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Explain命令在解决数据库性能上是第一推荐使用命令，大部分的性能问题可以通过此命令来简单的解决，Explain可以用来查看SQL语句的执行效 果，可以帮助选择更好的索引和优化查询语句，写出更好的优化语句。</p>
</blockquote>
<p>Explain语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EXPLAIN tbl_name或：EXPLAIN [EXTENDED] SELECT select_options</div></pre></td></tr></table></figure></p>
<p>前者可以得出一个表的字段结构等等，后者主要是给出相关的一些索引信息，而今天要讲述的重点是后者。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">explain select * from express_order where express_order_num = &apos;HO2016111750201&apos;</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SIMPLE</td>
<td>express_order</td>
<td>const</td>
<td>idx_express_order_num</td>
<td>idx_express_order_num</td>
<td>77</td>
<td>const</td>
<td>1</td>
</tr>
</tbody>
</table>
<ol>
<li><code>id</code>：这是SELECT的查询序列号</li>
<li><code>select_type</code>：select_type就是select的类型，可以有以下几种：</li>
</ol>
<ul>
<li>SIMPLE：简单SELECT(不使用UNION或子查询等)</li>
<li>PRIMARY：最外面的SELECT</li>
<li>UNION：UNION中的第二个或后面的SELECT语句</li>
<li>DEPENDENT UNION：UNION中的第二个或后面的SELECT语句，取决于外面的查询</li>
<li>UNION RESULT：UNION的结果。</li>
<li>SUBQUERY：子查询中的第一个SELECT</li>
<li>DEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外面的查询</li>
<li>DERIVED：导出表的SELECT(FROM子句的子查询)</li>
</ul>
<ol>
<li><code>table</code>：显示这一行的数据是关于哪张表的实际的表名或表的别名</li>
<li><code>type</code>：这列最重要，显示了连接使用了哪种类别,有无使用索引，是使用Explain命令分析性能瓶颈的关键项之一。<br>结果值从好到坏依次是：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</div></pre></td></tr></table></figure>
</li>
</ol>
<p>一般来说，得保证查询至少达到range级别，最好能达到ref，否则就可能会出现性能问题。</p>
<ul>
<li><code>all</code>: 意味着从表的第1行,往后,逐行做全表扫描.,运气不好扫描到最后一行.</li>
<li><code>index</code>: 比all性能稍好一点，<br>通俗的说: all 扫描所有的数据行,相当于data_all index 扫描所有的索引节点,相当于index_all<br>注：all是沿着磁盘扫描，index是沿着索引扫描</li>
<li><code>range</code>: 意思是查询时,能根据索引做范围的扫描,常见于　&lt;,&lt;=,&gt;,&gt;=,between,in等操作符</li>
<li><code>index_subquery</code> 在子查询中，基于除唯一索引之外的索引进行扫描;</li>
<li><code>unique_subquery</code> 在子查询中，基于唯一索引进行扫描，类似于EQ_REF;</li>
<li><code>index_merge</code> 多重范围扫描。两表连接的每个表的连接字段上均有索引存在且索引有序，结果合并在一起。适用于作集合的并、交操作。</li>
<li><code>ref_or_null</code> 类似REF，只是搜索条件包括：连接字段的值可以为NULL的情况，比如 where col = 2 or col is null</li>
<li><code>fulltext</code>全文索引</li>
<li><code>ref</code>这也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体（也是范围区间，不过比range更加精确）。ref还经常出现在JOIN操作中</li>
<li><code>eq_ref</code> 是指通过索引列,直接引用某1行数据（精确到一行数据中）常见于连接查询中.类似于ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中有一条记录匹配；简单来说，说是多表连接中使用主建或唯一健作为关联条件</li>
<li><code>const, system</code> 单表中最多有一个匹配行。主要用于比较primary key [主键索引]或者unique[唯一]索引,因为数据都是唯一的，所以性能最优。条件使用=</li>
<li><code>null</code>不用访问表或者索引，直接就能够得到结果</li>
</ul>
<ol>
<li><code>possible_keys</code>：列指出MySQL能使用哪个索引在该表中找到行</li>
<li><code>key</code>：显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL</li>
<li><code>key_len</code>：显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。使用的索引的长度。在不损失精确性的情况下，长度越短越好</li>
<li><code>ref</code>：显示使用哪个列或常数与key一起从表中选择行。</li>
<li><code>rows</code>：显示MySQL认为它执行查询时必须检查的行数。</li>
<li><code>Extra</code>：包含MySQL解决查询的详细信息，也是关键参考项之一。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">using index：出现这个说明mysql使用了覆盖索引，避免访问了表的数据行，效率不错！   </div><div class="line">using where：这说明服务器在存储引擎收到行后将进行过滤。有些where中的条件会有属于索引的列，当它读取使用索引的时候，就会被过滤，所以会出现有些where语句并没有在extra列中出现using where这么一个说明。 </div><div class="line">using temporary：这意味着mysql对查询结果进行排序的时候使用了一张临时表。     </div><div class="line">using filesort：这个说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。</div></pre></td></tr></table></figure>
</li>
</ol>
<p>除此以外，explain 的extended 扩展能够在原本explain的基础上额外的提供一些查询优化的信息，这些信息可以通过mysql的show warnings命令得到。</p>
<p>MySQL5.1开始支持分区功能，同时explain命令也增加了对分区的支持。可以通过explain partitions 命令查看SQL所访问的分区。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/数据库相关/mysql/explain分析sql效率/" data-id="cjfvvphp400f7m9fyx85s8lfs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据库相关/mysql/Btree索引和Hash索引的区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/数据库相关/mysql/Btree索引和Hash索引的区别/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库相关/">数据库相关</a>►<a class="article-category-link" href="/categories/数据库相关/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/数据库相关/mysql/Btree索引和Hash索引的区别/">Btree索引和Hash索引的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>==常用索引方法：Hash索引和B-Tree索引==</p>
<p>mysql的InnoDB默认是使用Btree索引</p>
<p>hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以Hash索引的查询效率要远高于 B-Tree 索引。</p>
<p>既然Hash索引的效率要比B-Tree高很多，为什么大家不都用Hash索引而还要使用B-Tree索引呢？任何事物都是有两面性的，Hash索引也一样，虽然Hash索引效率高，但是Hash索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些。</p>
<ol>
<li>Hash 索引仅仅能满足”=”,”IN”查询，<strong>不能使用范围查询</strong></li>
</ol>
<p>由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。</p>
<ol>
<li>Hash索引<strong>不能进行数据的排序操作</strong></li>
</ol>
<p>由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；</p>
<ol>
<li>Hash 索引<strong>不能利用部分索引键查询</strong></li>
</ol>
<p>对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。</p>
<ol>
<li>Hash索引在任何时候都<strong>不能避免表扫描</strong></li>
</ol>
<p>前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。</p>
<ol>
<li>Hash 索引<strong>遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高</strong></li>
</ol>
<p>对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/数据库相关/mysql/Btree索引和Hash索引的区别/" data-id="cjfvvphoz00f2m9fya5qg6hu3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器相关/redis/高性能IO模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/服务器相关/redis/高性能IO模型/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/服务器相关/redis/高性能IO模型/">高性能IO模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>服务器端编程经常需要构造高性能的IO模型，常见的IO模型有四种：    </p>
<ol>
<li>同步阻塞IO（Blocking IO）：即传统的IO模型。</li>
<li>同步非阻塞IO（Non-blocking IO）：默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。注意这里所说的NIO并非Java的NIO（New IO）库。</li>
<li>IO多路复用（IO Multiplexing）：即经典的Reactor设计模式，有时也称为异步阻塞IO，Java中的Selector和Linux中的epoll都是这种模型。</li>
<li>异步IO（Asynchronous IO）：即经典的Proactor设计模式，也称为异步非阻塞IO。    </li>
</ol>
<p><strong>同步和异步</strong>的概念描述的是用户线程与内核的交互方式：同步是指用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行；而异步是指用户线程发起IO请求后仍继续执行，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数。    </p>
<p><strong>阻塞和非阻塞</strong>的概念描述的是用户线程调用内核IO操作的方式：阻塞是指IO操作需要彻底完成后才返回到用户空间；而非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。    </p>
<h2 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h2><p>同步阻塞IO模型是最简单的IO模型，用户线程在内核进行IO操作时被阻塞。<br><img src="http://images.cnitblog.com/blog/405877/201411/142330286789443.png" alt="image"> </p>
<p>如上图所示，用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作。  </p>
<p>用户线程使用同步阻塞IO模型的伪代码描述为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    read(socket, buffer);</div><div class="line">    process(buffer);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>即用户需要等待read将socket中的数据读取到buffer后，才继续处理接收的数据。整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够。</p>
<h2 id="同步非阻塞IO"><a href="#同步非阻塞IO" class="headerlink" title="同步非阻塞IO"></a>同步非阻塞IO</h2><p>同步非阻塞IO是在同步阻塞IO的基础上，将socket设置为NONBLOCK。这样做用户线程可以在发起IO请求后可以立即返回。<br><img src="http://images.cnitblog.com/blog/405877/201411/142332004602984.png" alt="image"></p>
<p>如上图所示，由于socket是非阻塞的方式，因此用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。<br>用户线程使用同步非阻塞IO模型的伪代码描述为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    while(read(socket, buffer) != SUCCESS)</div><div class="line">        ;</div><div class="line">    process(buffer);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>即用户需要不断地调用read，尝试读取socket中的数据，直到读取成功后，才继续处理接收的数据。整个IO请求的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。  </p>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。<br><img src="http://images.cnitblog.com/blog/405877/201411/142332187256396.png" alt="image"><br>如上图所示，用户首先将需要进行IO操作的socket添加到select中，然后阻塞等待select系统调用返回。当数据到达时，socket被激活，select函数返回。用户线程正式发起read请求，读取数据并继续执行。    </p>
<p>从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在<strong>同一个线程内同时处理多个IO请求</strong>的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p>
<p>用户线程使用select函数的伪代码描述为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    select(socket);</div><div class="line">    while(1) &#123;</div><div class="line">        sockets = select();</div><div class="line">        for(socket in sockets) &#123;</div><div class="line">            if(can_read(socket)) &#123;</div><div class="line">                read(socket, buffer);</div><div class="line">                process(buffer);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中while循环前将socket添加到select监视中，然后在while内一直调用select获取被激活的socket，一旦socket可读，便调用read函数将socket中的数据读取出来。  </p>
<p>然而，使用select函数的优点并不仅限于此。虽然上述方式允许单线程内处理多个IO请求，但是每个IO请求的过程还是阻塞的（在select函数上阻塞），平均时间甚至比同步阻塞IO模型还要长。如果用户线程只注册自己感兴趣的socket或者IO请求，然后去做自己的事情，等到数据到来时再进行处理，则可以提高CPU的利用率。 </p>
<p>IO多路复用模型使用了Reactor设计模式实现了这一机制。<br><img src="http://images.cnitblog.com/blog/405877/201411/142332350853195.png" alt="image"><br>如上图所示，EventHandler抽象类表示IO事件处理器，它拥有IO文件句柄Handle（通过get_handle获取），以及对Handle的操作handle_event（读/写等）。继承于EventHandler的子类可以对事件处理器的行为进行定制。Reactor类用于管理EventHandler（注册、删除等），并使用handle_events实现事件循环，不断调用同步事件多路分离器（一般是内核）的多路分离函数select，只要某个文件句柄被激活（可读/写等），select就返回（阻塞），handle_events就会调用与文件句柄关联的事件处理器的handle_event进行相关操作。    </p>
<p><img src="http://images.cnitblog.com/blog/405877/201411/142333254136604.png" alt="image"><br>如上图所示，通过Reactor的方式，可以将用户线程轮询IO操作状态的工作统一交给handle_events事件循环进行处理。用户线程注册事件处理器之后可以继续执行做其他的工作（异步），而Reactor线程负责调用内核的select函数检查socket状态。当有socket被激活时，则通知相应的用户线程（或执行用户线程的回调函数），执行handle_event进行数据读取、处理的工作。由于select函数是阻塞的，因此<strong>多路IO复用模型也被称为异步阻塞IO模型</strong>。注意，这里的所说的阻塞是指select函数执行时线程被阻塞，而不是指socket。一般在使用IO多路复用模型时，socket都是设置为NONBLOCK的，不过这并不会产生影响，因为用户发起IO请求时，数据已经到达了，用户线程一定不会被阻塞。</p>
<p>用户线程使用IO多路复用模型的伪代码描述为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void UserEventHandler::handle_event() &#123;</div><div class="line">    if(can_read(socket)) &#123;</div><div class="line">        read(socket, buffer);</div><div class="line">        process(buffer);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">    Reactor.register(new UserEventHandler(socket));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用户需要重写EventHandler的handle_event函数进行读取数据、处理数据的工作，用户线程只需要将自己的EventHandler注册到Reactor即可。Reactor中handle_events事件循环的伪代码大致如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Reactor::handle_events() &#123;</div><div class="line">    while(1) &#123;</div><div class="line">        sockets = select();</div><div class="line">        for(socket in sockets) &#123;</div><div class="line">            get_event_handler(socket).handle_event();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>事件循环不断地调用select获取被激活的socket，然后根据获取socket对应的EventHandler，执行器handle_event函数即可。  </p>
<p>IO多路复用是最常使用的IO模型，但是其异步程度还不够“彻底”，因为它使用了会阻塞线程的select系统调用。因此IO多路复用只能称为异步阻塞IO，而非真正的异步IO。  </p>
<h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p>“真正”的异步IO需要操作系统更强的支持。在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。    </p>
<p>异步IO模型使用了Proactor设计模式实现了这一机制。<br><img src="http://images.cnitblog.com/blog/405877/201411/151608309061672.jpg" alt="image"> </p>
<p>如上图，Proactor模式和Reactor模式在结构上比较相似，不过在用户（Client）使用方式上差别较大。Reactor模式中，用户线程通过向Reactor对象注册感兴趣的事件监听，然后事件触发时调用事件处理函数。而Proactor模式中，用户线程将AsynchronousOperation（读/写等）、Proactor以及操作完成时的CompletionHandler注册到AsynchronousOperationProcessor。AsynchronousOperationProcessor使用Facade模式提供了一组异步操作API（读/写等）供用户使用，当用户线程调用异步API后，便继续执行自己的任务。AsynchronousOperationProcessor 会开启独立的内核线程执行异步操作，实现真正的异步。当异步IO操作完成时，AsynchronousOperationProcessor将用户线程与AsynchronousOperation一起注册的Proactor和CompletionHandler取出，然后将CompletionHandler与IO操作的结果数据一起转发给Proactor，Proactor负责回调每一个异步操作的事件完成处理函数handle_event。虽然Proactor模式中每个异步操作都可以绑定一个Proactor对象，但是一般在操作系统中，Proactor被实现为Singleton模式，以便于集中化分发操作完成事件。 </p>
<p><img src="http://images.cnitblog.com/blog/405877/201411/142333511475767.png" alt="image"><br>如上图所示，异步IO模型中，用户线程直接使用内核提供的异步IO API发起read请求，且发起后立即返回，继续执行用户线程代码。不过此时用户线程已经将调用的AsynchronousOperation和CompletionHandler注册到内核，然后操作系统开启独立的内核线程去处理IO操作。当read请求的数据到达时，由内核负责读取socket中的数据，并写入用户指定的缓冲区中。最后内核将read的数据和用户线程注册的CompletionHandler分发给内部Proactor，Proactor将IO完成的信息通知给用户线程（一般通过调用用户线程注册的完成事件处理函数），完成异步IO。    </p>
<p>用户线程使用异步IO模型的伪代码描述为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void UserCompletionHandler::handle_event(buffer) &#123;</div><div class="line">    process(buffer);</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">    aio_read(socket, new UserCompletionHandler);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用户需要重写CompletionHandler的handle_event函数进行处理数据的工作，参数buffer表示Proactor已经准备好的数据，用户线程直接调用内核提供的异步IO API，并将重写的CompletionHandler注册即可。  </p>
<p>相比于IO多路复用模型，异步IO并不十分常用，不少高性能并发服务程序使用IO多路复用模型+多线程任务处理的架构基本可以满足需求。况且目前操作系统对异步IO的支持并非特别完善，更多的是采用IO多路复用模型模拟异步IO的方式（IO事件触发时不直接通知用户线程，而是将数据读写完毕后放到用户指定的缓冲区中）。Java7之后已经支持了异步IO，感兴趣的读者可以尝试使用。  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/服务器相关/redis/高性能IO模型/" data-id="cjfvvphou00eum9fytfznt3b7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器相关/redis/Redis集群" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/服务器相关/redis/Redis集群/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/服务器相关/redis/Redis集群/">Redis集群</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Redis集群介绍"><a href="#Redis集群介绍" class="headerlink" title="Redis集群介绍"></a>Redis集群介绍</h3><p>Redis 集群是一个提供在<strong>多个Redis间节点间共享数据</strong>的程序集。 </p>
<p>Redis集群并不支持处理多个keys的命令,因为这需要在不同的节点间移动数据,从而达不到像Redis那样的性能,在高负载的情况下可能会导致不可预料的错误.  </p>
<p>Redis 集群通过分区来提供<strong>一定程度的可用性</strong>,在实际环境中当某个节点宕机或者不可达的情况下继续处理命令. Redis 集群的优势:</p>
<ul>
<li>自动分割数据到不同的节点上。</li>
<li>整个集群的部分节点失败或者不可达的情况下能够继续处理命令。</li>
</ul>
<h3 id="Redis-集群的数据分片"><a href="#Redis-集群的数据分片" class="headerlink" title="Redis 集群的数据分片"></a>Redis 集群的数据分片</h3><p>Redis 集群没有使用一致性hash, 而是引入了 <strong>哈希槽</strong>的概念.</p>
<p>Redis 集群有<strong>16384</strong>个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽,举个例子,比如当前集群有3个节点,那么:</p>
<ul>
<li>节点 A 包含 0 到 5500号哈希槽.</li>
<li>节点 B 包含5501 到 11000 号哈希槽.</li>
<li>节点 C 包含11001 到 16384号哈希槽.</li>
</ul>
<p>这种结构很容易添加或者删除节点. 比如如果我想新添加个节点D, 我需要从节点 A, B, C中得部分槽到D上. 如果我像移除节点A,需要将A中得槽移到B和C节点上,然后将没有任何槽的A节点从集群中移除即可. 由于从一个节点将哈希槽移动到另一个节点并不会停止服务,所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态.</p>
<h3 id="Redis-集群的主从复制模型"><a href="#Redis-集群的主从复制模型" class="headerlink" title="Redis 集群的主从复制模型"></a>Redis 集群的主从复制模型</h3><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品.</p>
<p>在我们例子中具有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用.</p>
<p>然而如果在集群创建的时候（或者过一段时间）我们为每个节点添加一个从节点A1，B1，C1,那么整个集群便有三个master节点和三个slave节点组成，这样在节点B失败后，集群便会选举B1为新的主节点继续服务，整个集群便不会因为槽找不到而不可用了</p>
<p>不过当B和B1 都失败后，集群是不可用的.</p>
<h3 id="Redis-一致性保证"><a href="#Redis-一致性保证" class="headerlink" title="Redis 一致性保证"></a>Redis 一致性保证</h3><p>Redis 并不能保证数据的<strong>强一致性</strong>. 这意味这在实际中集群在特定的条件下可能会丢失写操作.</p>
<p>第一个原因是因为集群是用了异步复制. 写操作过程:</p>
<ol>
<li>客户端向主节点B写入一条命令.</li>
<li>主节点B向客户端回复命令状态.</li>
<li>主节点将写操作复制给他得从节点 B1, B2 和 B3.</li>
</ol>
<p>主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。 注意：Redis 集群可能会在将来提供同步写的方法。 Redis 集群另外一种可能会丢失命令的情况是集群出现了网络分区， 并且一个客户端与至少包括一个主节点在内的少数实例被孤立。</p>
<p>举个例子 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点， 其中 A 、B 、C 为主节点， A1 、B1 、C1 为A，B，C的从节点， 还有一个客户端 Z1 假设集群中发生网络分区，那么集群可能会分为两方，大部分的一方包含节点 A 、C 、A1 、B1 和 C1 ，小部分的一方则包含节点 B 和客户端 Z1 .</p>
<p>Z1仍然能够向主节点B中写入, 如果网络分区发生时间较短,那么集群将会继续正常运作,如果分区的时间足够让大部分的一方将B1选举为新的master，那么Z1写入B中得数据便丢失了.</p>
<p>注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项</p>
<h3 id="搭建并使用Redis集群"><a href="#搭建并使用Redis集群" class="headerlink" title="搭建并使用Redis集群"></a>搭建并使用Redis集群</h3><p>搭建集群的第一件事情我们需要一些运行在 集群模式的Redis实例. 这意味这集群并不是由一些普通的Redis实例组成的，集群模式需要通过配置启用，开启集群模式后的Redis实例便可以使用集群特有的命令和特性了.<br>下面是一个最少选项的集群的配置文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">port 7000</div><div class="line">cluster-enabled yes</div><div class="line">cluster-config-file nodes.conf</div><div class="line">cluster-node-timeout 5000</div><div class="line">appendonly yes</div></pre></td></tr></table></figure></p>
<p>文件中的 cluster-enabled 选项用于开实例的集群模式， 而 cluster-conf-file 选项则设定了保存节点配置文件的路径， 默认值为 nodes.conf.节点配置文件无须人为修改， 它由 Redis 集群在启动时创建， 并在有需要时自动进行更新。 </p>
<p>要让集群正常运作至少需要三个主节点，不过在刚开始试用集群功能时， 强烈建议使用六个节点： 其中三个为主节点， 而其余三个则是各个主节点的从节点。</p>
<p>首先， 让我们进入一个新目录， 并创建六个以端口号为名字的子目录， 稍后我们在将每个目录中运行一个 Redis 实例：  命令如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir cluster-test</div><div class="line">cd cluster-test</div><div class="line">mkdir 7000 7001 7002 7003 7004 7005</div></pre></td></tr></table></figure></p>
<p>在文件夹 7000 至 7005 中， 各创建一个 redis.conf 文件， 文件的内容可以使用上面的示例配置文件， 但记得将配置中的端口号从 7000 改为与文件夹名字相同的号码,并且nodes.conf的文件名也要相应调整，如nodes-7000.conf。</p>
<p>启动6个集群示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/Cellar/redis/3.2.8/bin</div><div class="line">1./usr/local/Cellar/redis/3.2.8/cluster-test/7000/redis.conf</div><div class="line">2./usr/local/Cellar/redis/3.2.8/cluster-test/70010/redis.conf</div><div class="line">3./usr/local/Cellar/redis/3.2.8/cluster-test/7002/redis.conf</div><div class="line">4./usr/local/Cellar/redis/3.2.8/cluster-test/7003/redis.conf</div><div class="line">5./usr/local/Cellar/redis/3.2.8/cluster-test/7004/redis.conf</div><div class="line">6./usr/local/Cellar/redis/3.2.8/cluster-test/7005/redis.conf</div></pre></td></tr></table></figure></p>
<p>实例打印的日志显示， 因为 nodes.conf 文件不存在， 所以每个节点都为它自身指定了一个新的 ID ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[82462] 26 Nov 11:56:55.329 * No cluster configuration found, I&apos;m 97a3a64667477371c4479320d683e4c8db5858b1</div></pre></td></tr></table></figure></p>
<p>实例会一直使用同一个 ID ， 从而在集群中保持一个独一无二（unique）的名字。</p>
<h3 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h3><p>现在我们已经有了六个正在运行中的 Redis 实例， 接下来我们需要使用这些实例来创建集群， 并为每个节点编写配置文件。<br>通过使用 Redis 集群命令行工具 redis-trib ， 编写节点配置文件的工作可以非常容易地完成： redis-trib 位于 Redis 源码的 src 文件夹中， 它是一个 Ruby 程序， 这个程序通过向实例发送特殊命令来完成创建新集群， 检查集群， 或者对集群进行重新分片（reshared）等工作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 \</div><div class="line">127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</div></pre></td></tr></table></figure></p>
<p>这个命令在这里用于创建一个新的集群, 选项–replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。<br>之后跟着的其他参数则是这个集群实例的地址列表,3个master3个slave redis-trib 会打印出一份预想中的配置给你看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</div><div class="line">&gt;&gt;&gt; Creating cluster</div><div class="line">&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...</div><div class="line">Using 3 masters:</div><div class="line">127.0.0.1:7000</div><div class="line">127.0.0.1:7001</div><div class="line">127.0.0.1:7002</div><div class="line">Adding replica 127.0.0.1:7003 to 127.0.0.1:7000</div><div class="line">Adding replica 127.0.0.1:7004 to 127.0.0.1:7001</div><div class="line">Adding replica 127.0.0.1:7005 to 127.0.0.1:7002</div><div class="line">M: 83976d23ea61befbacc383aa03bd2da9f08fa7fa 127.0.0.1:7000</div><div class="line">   slots:0-5460 (5461 slots) master</div><div class="line">M: c2f4de6b29648599ade1d596b96838cdf559f397 127.0.0.1:7001</div><div class="line">   slots:5461-10922 (5462 slots) master</div><div class="line">M: 3e9798d73cc0685745c18cb15cf68c75c746e0a5 127.0.0.1:7002</div><div class="line">   slots:10923-16383 (5461 slots) master</div><div class="line">S: dfcad7da198267663734490dc876a7c072d186f1 127.0.0.1:7003</div><div class="line">   replicates 83976d23ea61befbacc383aa03bd2da9f08fa7fa</div><div class="line">S: d415630bb73d2df4ddbe8032ac3034756dff838c 127.0.0.1:7004</div><div class="line">   replicates c2f4de6b29648599ade1d596b96838cdf559f397</div><div class="line">S: ccda46a376b2a473ac596c80050b464ca9ba30d4 127.0.0.1:7005</div><div class="line">   replicates 3e9798d73cc0685745c18cb15cf68c75c746e0a5</div><div class="line">Can I set the above configuration? (type &apos;yes&apos; to accept):</div></pre></td></tr></table></figure></p>
<p>如果你觉得没问题的话， 就可以输入 yes ， redis-trib 就会将这份配置应用到集群当中,让各个节点开始互相通讯,最后可以得到如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">Can I set the above configuration? (type &apos;yes&apos; to accept): yes</div><div class="line">&gt;&gt;&gt; Nodes configuration updated</div><div class="line">&gt;&gt;&gt; Assign a different config epoch to each node</div><div class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</div><div class="line">Waiting for the cluster to join...</div><div class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)</div><div class="line">M: 83976d23ea61befbacc383aa03bd2da9f08fa7fa 127.0.0.1:7000</div><div class="line">   slots:0-5460 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: d415630bb73d2df4ddbe8032ac3034756dff838c 127.0.0.1:7004</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates c2f4de6b29648599ade1d596b96838cdf559f397</div><div class="line">M: c2f4de6b29648599ade1d596b96838cdf559f397 127.0.0.1:7001</div><div class="line">   slots:5461-10922 (5462 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: ccda46a376b2a473ac596c80050b464ca9ba30d4 127.0.0.1:7005</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates 3e9798d73cc0685745c18cb15cf68c75c746e0a5</div><div class="line">M: 3e9798d73cc0685745c18cb15cf68c75c746e0a5 127.0.0.1:7002</div><div class="line">   slots:10923-16383 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: dfcad7da198267663734490dc876a7c072d186f1 127.0.0.1:7003</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates 83976d23ea61befbacc383aa03bd2da9f08fa7fa</div><div class="line">[OK] All nodes agree about slots configuration.</div><div class="line">&gt;&gt;&gt; Check for open slots...</div><div class="line">&gt;&gt;&gt; Check slots coverage...</div><div class="line">[OK] All 16384 slots covered.</div></pre></td></tr></table></figure></p>
<p>这表示集群中的 16384 个槽都有至少一个主节点在处理， 集群运作正常。</p>
<p><strong>注意</strong>：如果脚本报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">custom_require.rb:36:in `require&apos;: cannot load such file -- redis (LoadError)</div><div class="line">from /usr/lib/ruby/1.9.1/rubygems/custom_require.rb:36:in `require&apos;</div><div class="line">from ./redis-trib.rb:25:in `&lt;main&gt;&apos;</div></pre></td></tr></table></figure></p>
<p>那么说明Ruby的redis接口没有安装，可以通过<code>sudo gem install redis</code>进行安装。</p>
<h3 id="Creating-a-Redis-Cluster-using-the-create-cluster-script"><a href="#Creating-a-Redis-Cluster-using-the-create-cluster-script" class="headerlink" title="Creating a Redis Cluster using the create-cluster script"></a>Creating a Redis Cluster using the create-cluster script</h3><p>If you don’t want to create a Redis Cluster by configuring and executing individual instances manually as explained above, there is a much simpler system (but you’ll not learn the same amount of operational details).</p>
<p>Just check utils/create-cluster directory in the Redis distribution. There is a script called create-cluster inside (same name as the directory it is contained into), it’s a simple bash script. In order to start a 6 nodes cluster with 3 masters and 3 slaves just type the following commands:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1. create-cluster start</div><div class="line">2. create-cluster create</div></pre></td></tr></table></figure></p>
<p>Reply to yes in step 2 when the redis-trib utility wants you to accept the cluster layout.<br>You can now interact with the cluster, the first node will start at port 30001 by default. When you are done, stop the cluster with:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">create-cluster stop</div></pre></td></tr></table></figure></p>
<p>Please read the README inside this directory for more information on how to run the script.</p>
<h3 id="使用集群"><a href="#使用集群" class="headerlink" title="使用集群"></a>使用集群</h3><p>Redis 集群现阶段的一个问题是客户端实现很少。<br>以下是一些我知道的实现：</p>
<ul>
<li><a href="https://github.com/antirez/redis-rb-cluster" target="_blank" rel="external">redis-rb-cluster</a> 是我（@antirez）编写的 Ruby 实现， 用于作为其他实现的参考。 该实现是对 redis-rb 的一个简单包装， 高效地实现了与集群进行通讯所需的最少语义（semantic）.</li>
<li><a href="https://github.com/Grokzen/redis-py-cluster" target="_blank" rel="external">redis-py-cluster</a> 看上去是 redis-rb-cluster 的一个 Python 版本， 这个项目有一段时间没有更新了（最后一次提交是在六个月之前）， 不过可以将这个项目用作学习集群的起点。</li>
<li>流行的 <a href="https://github.com/nrk/predis" target="_blank" rel="external">Predis</a> 曾经对早期的 Redis 集群有过一定的支持， 但我不确定它对集群的支持是否完整， 也不清楚它是否和最新版本的 Redis 集群兼容 （因为新版的 Redis 集群将槽的数量从 4k 改为 16k 了）.</li>
<li>使用最多的时java客户端, <a href="https://github.com/xetorthio/jedis" target="_blank" rel="external">Jedis</a> 最近添加了对集群的支持, 详细请查看项目README中Jedis Cluster部分.</li>
<li><a href="https://github.com/StackExchange/StackExchange.Redis" target="_blank" rel="external">StackExchange.Redis</a> 提供对 C# 的支持(并且包括大部分 .NET 下面的语言，比如： VB, F#等等)</li>
<li><a href="https://github.com/thunks/thunk-redis" target="_blank" rel="external">thunk-redis</a> 提供对 Node.js 和 io.js的支持。</li>
<li>Redis unstable 分支中的 redis-cli 程序实现了非常基本的集群支持， 可以使用命令 redis-cli -c 来启动。</li>
</ul>
<p>测试 Redis 集群比较简单的办法就是使用 redis-rb-cluster 或者 redis-cli ， 接下来我们将使用 redis-cli 为例来进行演示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -c -p 7000</div><div class="line">redis 127.0.0.1:7000&gt; set foo bar</div><div class="line">-&gt; Redirected to slot [12182] located at 127.0.0.1:7002</div><div class="line">OK</div><div class="line">redis 127.0.0.1:7002&gt; set hello world</div><div class="line">-&gt; Redirected to slot [866] located at 127.0.0.1:7000</div><div class="line">OK</div><div class="line">redis 127.0.0.1:7000&gt; get foo</div><div class="line">-&gt; Redirected to slot [12182] located at 127.0.0.1:7002</div><div class="line">&quot;bar&quot;</div><div class="line">redis 127.0.0.1:7000&gt; get hello</div><div class="line">-&gt; Redirected to slot [866] located at 127.0.0.1:7000</div><div class="line">&quot;world&quot;</div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>: 如果你是使用脚本创建的集群节点，那么默认端口可能是从30001开始。</p>
<p>redis-cli 对集群的支持是非常基本的， 所以它总是依靠 Redis 集群节点来将它转向（redirect）至正确的节点。一个真正的（serious）集群客户端应该做得比这更好： 它应该用缓存记录起哈希槽与节点地址之间的映射（map）， 从而直接将命令发送到正确的节点上面。这种映射只会在集群的配置出现某些修改时变化， 比如说， 在一次故障转移（failover）之后， 或者系统管理员通过添加节点或移除节点来修改了集群的布局（layout）之后， 诸如此类。</p>
<h3 id="使用redis-rb-cluster写一个例子"><a href="#使用redis-rb-cluster写一个例子" class="headerlink" title="使用redis-rb-cluster写一个例子"></a>使用redis-rb-cluster写一个例子</h3><p>在展示如何使用集群进行故障转移、重新分片等操作之前， 我们需要创建一个示例应用， 了解一些与 Redis 集群客户端进行交互的基本方法。  </p>
<p>在运行示例应用的过程中， 我们会尝试让节点进入失效状态， 又或者开始一次重新分片， 以此来观察 Redis 集群在真实世界运行时的表现， 并且为了让这个示例尽可能地有用， 我们会让这个应用向集群进行写操作。<br>本节将通过两个示例应用来展示 redis-rb-cluster 的基本用法， 以下是本节的第一个示例应用， 它是一个名为 example.rb 的文件， 包含在redis-rb-cluster 项目里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"> 1  require &apos;./cluster&apos;</div><div class="line"> 2</div><div class="line"> 3  startup_nodes = [</div><div class="line"> 4      &#123;:host =&gt; &quot;127.0.0.1&quot;, :port =&gt; 7000&#125;,</div><div class="line"> 5      &#123;:host =&gt; &quot;127.0.0.1&quot;, :port =&gt; 7001&#125;</div><div class="line"> 6  ]</div><div class="line"> 7  rc = RedisCluster.new(startup_nodes,32,:timeout =&gt; 0.1)</div><div class="line"> 8</div><div class="line"> 9  last = false</div><div class="line">10</div><div class="line">11  while not last</div><div class="line">12      begin</div><div class="line">13          last = rc.get(&quot;__last__&quot;)</div><div class="line">14          last = 0 if !last</div><div class="line">15      rescue =&gt; e</div><div class="line">16          puts &quot;error #&#123;e.to_s&#125;&quot;</div><div class="line">17          sleep 1</div><div class="line">18      end</div><div class="line">19  end</div><div class="line">20</div><div class="line">21  ((last.to_i+1)..1000000000).each&#123;|x|</div><div class="line">22      begin</div><div class="line">23          rc.set(&quot;foo#&#123;x&#125;&quot;,x)</div><div class="line">24          puts rc.get(&quot;foo#&#123;x&#125;&quot;)</div><div class="line">25          rc.set(&quot;__last__&quot;,x)</div><div class="line">26      rescue =&gt; e</div><div class="line">27          puts &quot;error #&#123;e.to_s&#125;&quot;</div><div class="line">28      end</div><div class="line">29      sleep 0.1</div><div class="line">30  &#125;</div></pre></td></tr></table></figure></p>
<p>这个应用所做的工作非常简单： 它不断地以 foo<number> 为键， number 为值， 使用 SET 命令向数据库设置键值对:</number></p>
<ul>
<li>SET foo0 0</li>
<li>SET foo1 1</li>
<li>SET foo2 2</li>
<li>And so forth…</li>
</ul>
<p>代码中的每个集群操作都使用一个 begin 和 rescue 代码块（block）包裹着， 因为我们希望在代码出错时， 将错误打印到终端上面， 而不希望应用因为异常（exception）而退出。</p>
<p>代码的第七行是代码中第一个有趣的地方， 它创建了一个 Redis 集群对象， 其中创建对象所使用的参数及其意义如下：第一个参数是记录了启动节点的 startup_nodes 列表， 列表中包含了两个集群节点的地址。第二个参数指定了对于集群中的各个不同的节点， Redis 集群对象可以获得的最大连接数 ，第三个参数 timeout 指定了一个命令在执行多久之后， 才会被看作是执行失败。</p>
<p>启动列表中并不需要包含所有集群节点的地址， 但这些地址中至少要有一个是有效的： 一旦 redis-rb-cluster 成功连接上集群中的某个节点时， 集群节点列表就会被自动更新， 任何真正的的集群客户端都应该这样做。</p>
<p>现在， 程序创建的 Redis 集群对象实例被保存到 rc 变量里面， 我们可以将这个对象当作普通 Redis 对象实例来使用。<br>在十一至十九行， 我们先尝试阅读计数器中的值， 如果计数器不存在的话， 我们才将计数器初始化为 0 ： 通过将计数值保存到 Redis 的计数器里面， 我们可以在示例重启之后， 仍然继续之前的执行过程， 而不必每次重启之后都从 foo0 开始重新设置键值对。为了让程序在集群下线的情况下， 仍然不断地尝试读取计数器的值， 我们将读取操作包含在了一个 while 循环里面， 一般的应用程序并不需要如此小心。</p>
<p>二十一至三十行是程序的主循环， 这个循环负责设置键值对， 并在设置出错时打印错误信息。程序在主循环的末尾添加了一个 sleep 调用， 让写操作的执行速度变慢， 帮助执行示例的人更容易看清程序的输出。执行 example.rb 程序将产生以下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ruby ./example.rb</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">^C (I stopped the program here)</div></pre></td></tr></table></figure></p>
<p>这个程序并不是十分有趣， 稍后我们就会看到一个更有趣的集群应用示例， 不过在此之前， 让我们先使用这个示例来演示集群的重新分片操作。</p>
<h3 id="集群重新分片"><a href="#集群重新分片" class="headerlink" title="集群重新分片"></a>集群重新分片</h3><p>现在， 让我们来试试对集群进行重新分片操作。在执行重新分片的过程中， 请让你的 example.rb 程序处于运行状态， 这样你就会看到， 重新分片并不会对正在运行的集群程序产生任何影响， 你也可以考虑将 example.rb 中的 sleep 调用删掉， 从而让重新分片操作在近乎真实的写负载下执行 重新分片操作基本上就是将某些节点上的哈希槽移动到另外一些节点上面， 和创建集群一样， 重新分片也可以使用 redis-trib 程序来执行 执行以下命令可以开始一次重新分片操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb reshard 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<p>你只需要指定集群中其中一个节点的地址， redis-trib 就会自动找到集群中的其他节点。<br>目前 redis-trib 只能在管理员的协助下完成重新分片的工作， 要让 redis-trib 自动将哈希槽从一个节点移动到另一个节点， 目前来说还做不到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">你想移动多少个槽( 从1 到 16384)?</div></pre></td></tr></table></figure></p>
<p>我们尝试从将100个槽重新分片， 如果 example.rb 程序一直运行着的话， 现在 1000 个槽里面应该有不少键了。<br>除了移动的哈希槽数量之外， redis-trib 还需要知道重新分片的目标， 也即是， 负责接收这 1000 个哈希槽的节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -p 7000 cluster nodes | grep myself</div><div class="line">97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5460</div></pre></td></tr></table></figure></p>
<p>我的目标节点是 97a3a64667477371c4479320d683e4c8db5858b1.<br>现在需要指定从哪些节点来移动keys到目标节点 我输入的是all ，这样就会从其他每个master上取一些哈希槽。<br>最后确认后你将会看到每个redis-trib移动的槽的信息，每个key的移动的信息也会打印出来        在重新分片的过程中，你的例子程序是不会受到影响的,你可以停止或者重新启动多次。<br>在重新分片结束后你可以通过如下命令检查集群状态:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb check 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<h3 id="一个更有趣的程序"><a href="#一个更有趣的程序" class="headerlink" title="一个更有趣的程序"></a>一个更有趣的程序</h3><p>我们在前面使用的示例程序 example.rb 并不是十分有趣， 因为它只是不断地对集群进行写入， 但并不检查写入结果是否正确。 比如说， 集群可能会错误地将 example.rb 发送的所有 SET 命令都改成了 SET foo 42 ， 但因为 example.rb 并不检查写入后的值， 所以它不会意识到集群实际上写入的值是错误的 因为这个原因， redis-rb-cluster 项目包含了一个名为 consistency-test.rb 的示例应用， 这个应用比起 example.rb 有趣得多： 它创建了多个计数器（默认为 1000 个）， 并通过发送 INCR 命令来增加这些计数器的值。</p>
<p>在增加计数器值的同时， consistency-test.rb 还执行以下操作： 每次使用 INCR 命令更新一个计数器时， 应用会记录下计数器执行 INCR 命令之后应该有的值。 举个例子， 如果计数器的起始值为 0 ， 而这次是程序第 50 次向它发送 INCR 命令， 那么计数器的值应该是 50 。</p>
<p>在每次发送 INCR 命令之前， 程序会随机从集群中读取一个计数器的值， 并将它与自己记录的值进行对比， 看两个值是否相同。</p>
<p>换句话说， 这个程序是一个一致性检查器（consistency checker）： 如果集群在执行 INCR 命令的过程中， 丢失了某条 INCR 命令， 又或者多执行了某条客户端没有确认到的 INCR 命令， 那么检查器将察觉到这一点 —— 在前一种情况中， consistency-test.rb 记录的计数器值将比集群记录的计数器值要大； 而在后一种情况中， consistency-test.rb 记录的计数器值将比集群记录的计数器值要小。</p>
<p>运行 consistency-test 程序将产生类似以下的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ ruby consistency-test.rb</div><div class="line">925 R (0 err) | 925 W (0 err) |</div><div class="line">5030 R (0 err) | 5030 W (0 err) |</div><div class="line">9261 R (0 err) | 9261 W (0 err) |</div><div class="line">13517 R (0 err) | 13517 W (0 err) |</div><div class="line">17780 R (0 err) | 17780 W (0 err) |</div><div class="line">22025 R (0 err) | 22025 W (0 err) |</div><div class="line">25818 R (0 err) | 25818 W (0 err) |</div></pre></td></tr></table></figure></p>
<p>结果展示了执行的读和 写,和错误(由于系统不可用而没有接受的查询发生的错误）的数量.<br>如果程序察觉了不一致的情况出现， 它将在输出行的末尾显式不一致的详细情况。比如说， 如果我们在 consistency-test.rb 运行的过程中， 手动修改某个计数器的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ redis 127.0.0.1:7000&gt; set key_217 0</div><div class="line">OK</div><div class="line"></div><div class="line">(in the other tab I see...)</div><div class="line"></div><div class="line">94774 R (0 err) | 94774 W (0 err) |</div><div class="line">98821 R (0 err) | 98821 W (0 err) |</div><div class="line">102886 R (0 err) | 102886 W (0 err) | 114 lost |</div><div class="line">107046 R (0 err) | 107046 W (0 err) | 114 lost |</div></pre></td></tr></table></figure></p>
<p>在我们修改计数器值的时候， 计数器的正确值是 114 （执行了 114 次 INCR 命令）， 因为我们将计数器的值设成了 0 ， 所以 consistency-test.rb 会向我们报告说丢失了 114 个 INCR 命令。<br>这个程序作为测试程序很有意思，所以我们用这个程序来测试故障恢复.</p>
<h3 id="测试故障转移"><a href="#测试故障转移" class="headerlink" title="测试故障转移"></a>测试故障转移</h3><p>在执行本节操作的过程中， 请一直运行 consistency-test 程序。 要触发一次故障转移， 最简单的办法就是令集群中的某个主节点进入下线状态。首先用以下命令列出集群中的所有主节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -p 7000 cluster nodes | grep master</div><div class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385482984082 0 connected 5960-10921</div><div class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 master - 0 1385482983582 0 connected 11423-16383</div><div class="line">97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422</div></pre></td></tr></table></figure></p>
<p>通过命令输出得知端口号为 7000 、 7001 和 7002 的节点都是主节点， 然后我们可以通过向端口号为7002 的主节点发送 <strong>DEBUG SEGFAULT</strong> 命令， 让这个主节点崩溃：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -p 7002 debug segfault</div><div class="line">Error: Server closed the connection</div></pre></td></tr></table></figure></p>
<p>现在，切换到运行着 consistency-test 的标签页， 可以看到， consistency-test 在 7002 下线之后的一段时间里将产生大量的错误警告信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">18849 R (0 err) | 18849 W (0 err) |</div><div class="line">23151 R (0 err) | 23151 W (0 err) |</div><div class="line">27302 R (0 err) | 27302 W (0 err) |</div><div class="line"></div><div class="line">... many error warnings here ...</div><div class="line"></div><div class="line">29659 R (578 err) | 29660 W (577 err) |</div><div class="line">33749 R (578 err) | 33750 W (577 err) |</div><div class="line">37918 R (578 err) | 37919 W (577 err) |</div><div class="line">42077 R (578 err) | 42078 W (577 err) |</div></pre></td></tr></table></figure></p>
<p>从 consistency-test 的这段输出可以看到， 集群在执行故障转移期间， 总共丢失了 578 个读命令和 577 个写命令， 但是并没有产生任何数据不一致。这听上去可能有点奇怪， 因为在教程的开头我们提到过， Redis 使用的是异步复制， 在执行故障转移期间， 集群可能会丢失写命令。但是在实际上， 丢失命令的情况并不常见， 因为 Redis 几乎是同时执行将命令回复发送给客户端， 以及将命令复制给从节点这两个操作， 所以实际上造成命令丢失的时间窗口是非常小的。不过， 尽管出现的几率不高， 但丢失命令的情况还是有可能会出现的， 所以我们对 Redis 集群不能提供强一致性的这一描述仍然是正确的。现在， 让我们使用 cluster nodes 命令,查看集群在执行故障转移操作之后， 主从节点的布局情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -p 7000 cluster nodes</div><div class="line">3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385503418521 0 connected</div><div class="line">a211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385503419023 0 connected</div><div class="line">97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422</div><div class="line">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385503419023 3 connected 11423-16383</div><div class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385503417005 0 connected 5960-10921</div><div class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385503418016 3 connected</div></pre></td></tr></table></figure></p>
<p>现在masters运行在 7000, 7001 和 7005端口上. 原来的master 7002现在变成了一个7005的一个从节点.<br>CLUSTER NODES 命令的输出看起来有点复杂,其实他非常的简单，含义如下:</p>
<ul>
<li>节点ID</li>
<li>IP:端口</li>
<li>标志: master, slave, myself, fail, …</li>
<li>如果是个从节点, 这里是它的主节点的NODE ID</li>
<li>集群最近一次向节点发送 PING 命令之后， 过去了多长时间还没接到回复。.</li>
<li>节点最近一次返回 PONG 回复的时间。</li>
<li>节点的配置纪元（configuration epoch）：详细信息请参考 Redis 集群规范 。</li>
<li>本节点的网络连接情况：例如 connected 。</li>
<li>节点目前包含的槽：例如 127.0.0.1:7001 目前包含号码为 5960 至 10921 的哈希槽。</li>
</ul>
<h3 id="手动故障转移"><a href="#手动故障转移" class="headerlink" title="手动故障转移"></a>手动故障转移</h3><p>有的时候在主节点没有任何问题的情况下强制手动故障转移也是很有必要的，比如想要升级主节点的Redis进程，我们可以通过故障转移将其转为slave再进行升级操作来避免对集群的可用性造成很大的影响。</p>
<p>Redis集群使用 <code>CLUSTER FAILOVER</code>命令来进行故障转移，不过要被转移的主节点的从节点上执行该命令 手动故障转移比主节点失败自动故障转移更加安全，因为手动故障转移时客户端的切换是在确保新的主节点完全复制了失败的旧的主节点数据的前提下下发生的，所以避免了数据的丢失。<br>执行手动故障转移时从节点日志如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># Manual failover user request accepted.</div><div class="line"># Received replication offset for paused master manual failover: 347540</div><div class="line"># All master replication stream processed, manual failover can start.</div><div class="line"># Start of election delayed for 0 milliseconds (rank #0, offset 347540).</div><div class="line"># Starting a failover election for epoch 7545.</div><div class="line"># Failover election won: I&apos;m the new master.</div></pre></td></tr></table></figure></p>
<p>其基本过程如下：客户端不再链接我们淘汰的主节点，同时主节点向从节点发送复制偏移量,从节点得到复制偏移量后故障转移开始,接着通知主节点进行配置切换,当客户端在旧的master上解锁后重新连接到新的主节点上。</p>
<h3 id="添加一个新节点"><a href="#添加一个新节点" class="headerlink" title="添加一个新节点"></a>添加一个新节点</h3><p>添加新的节点的基本过程就是添加一个空的节点然后移动一些数据给它，有两种情况，添加一个主节点和添加一个从节点（添加从节点时需要将这个新的节点设置为集群中某个节点的复制）<br>针对这两种情况，本节都会介绍，先从添加主节点开始.</p>
<p>两种情况第一步都是要添加 一个空的节点.<br>启动新的7006节点,使用的配置文件和以前的一样,只要把端口号改一下即可，过程如下:   </p>
<ul>
<li>在终端打开一个新的标签页.</li>
<li>进入cluster-test 目录.</li>
<li>创建并进入 7006文件夹.</li>
<li>和其他节点一样，创建redis.conf文件,需要将端口号改成7006.</li>
<li>最后启动节点 ../redis-server ./redis.conf</li>
<li>如果正常的话，节点会正确的启动.</li>
</ul>
<p>接下来使用redis-trib 来添加这个节点到现有的集群中去.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb add-node 127.0.0.1:7006 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<p>可以看到.使用<strong>addnode</strong>命令来添加节点，第一个参数是新节点的地址，第二个参数是任意一个已经存在的节点的IP和端口. 我们可以看到新的节点已经添加到集群中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:7006&gt; cluster nodes</div><div class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385543178575 0 connected 5960-10921</div><div class="line">3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385543179583 0 connected</div><div class="line">f093c80dde814da99c5cf72a7dd01590792b783b :0 myself,master - 0 0 0 connected</div><div class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543178072 3 connected</div><div class="line">a211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385543178575 0 connected</div><div class="line">97a3a64667477371c4479320d683e4c8db5858b1 127.0.0.1:7000 master - 0 1385543179080 0 connected 0-5959 10922-11422</div><div class="line">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385543177568 3 connected 11423-16383</div></pre></td></tr></table></figure></p>
<p>新节点现在已经连接上了集群， 成为集群的一份子， 并且可以对客户端的命令请求进行转向了， 但是和其他主节点相比， 新节点还有两点区别： </p>
<ul>
<li>新节点没有包含任何数据， 因为它没有包含任何哈希槽.</li>
<li>尽管新节点没有包含任何哈希槽， 但它仍然是一个主节点， 所以在集群需要将某个从节点升级为新的主节点时， 这个新节点不会被选中。</li>
</ul>
<p>接下来， 只要使用 redis-trib 程序， 将集群中的某些哈希桶移动到新节点里面， 新节点就会成为真正的主节点了。</p>
<h3 id="添加一个从节点"><a href="#添加一个从节点" class="headerlink" title="添加一个从节点"></a>添加一个从节点</h3><p>有两种方法添加从节点，可以像添加主节点一样使用redis-trib 命令，也可以像下面的例子一样使用 –slave选项:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb add-node --slave 127.0.0.1:7006 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<p>此处的命令和添加一个主节点命令类似，此处并没有指定添加的这个从节点的主节点，这种情况下系统会在其他的复制集中的主节点中随机选取一个作为这个从节点的主节点。<br>你可以通过下面的命令指定主节点:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb add-node --slave --master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7006 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<p>也可以使用CLUSTER REPLICATE 命令添加.这个命令也可以改变一个从节点的主节点。<br>例如，要给主节点 127.0.0.1:7005添加一个从节点，该节点哈希槽的范围1423-16383, 节点 ID 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e,我们需要链接新的节点（已经是空的主节点）并执行命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:7006&gt; cluster replicate 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</div></pre></td></tr></table></figure></p>
<p>我们新的从节点有了一些哈希槽，其他的节点也知道（过几秒后会更新他们自己的配置），可以使用如下命令确认:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ redis-cli -p 7000 cluster nodes | grep slave | grep 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</div><div class="line">f093c80dde814da99c5cf72a7dd01590792b783b 127.0.0.1:7006 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617702 3 connected</div><div class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617198 3 connected</div></pre></td></tr></table></figure></p>
<p>节点 3c3a0c… 有两个从节点， 7002 (已经存在的) 和 7006 (新添加的).</p>
<h3 id="移除一个节点"><a href="#移除一个节点" class="headerlink" title="移除一个节点"></a>移除一个节点</h3><p>只要使用 del-node 命令即可:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb del-node 127.0.0.1:7000 `&lt;node-id&gt;`</div></pre></td></tr></table></figure></p>
<p>第一个参数是任意一个节点的地址,第二个节点是你想要移除的节点地址。<br>使用同样的方法移除主节点,不过在移除主节点前，<strong>需要确保这个主节点是空的</strong>. 如果不是空的,需要将这个节点的数据重新分片到其他主节点上.</p>
<p>替代移除主节点的方法是手动执行故障恢复，被移除的主节点会作为一个从节点存在，不过这种情况下不会减少集群节点的数量，也需要重新分片数据.</p>
<h3 id="从节点的迁移"><a href="#从节点的迁移" class="headerlink" title="从节点的迁移"></a>从节点的迁移</h3><p>在Redis集群中会存在改变一个从节点的主节点的情况，需要执行如下命令 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CLUSTER REPLICATE &lt;master-node-id&gt;</div></pre></td></tr></table></figure></p>
<p>在特定的场景下，不需要系统管理员的协助下，自动将一个从节点从当前的主节点切换到另一个主节 的自动重新配置的过程叫做复制迁移（从节点迁移），从节点的迁移能够提高整个Redis集群的可用性.</p>
<p>你可以阅读（Redis集群规范）<a href="http://www.redis.cn/topics/cluster-spec.html" target="_blank" rel="external">/topics/cluster-spec</a>了解细节.</p>
<p>简短的概况一下从节点迁移</p>
<ul>
<li>集群会在有从节点数量最多的主节点上进行从节点的迁移.</li>
<li>要在一个主节点上添加多个从节点.</li>
<li>参数来控制从节点迁移 replica-migration-barrier:你可以仔细阅读redis.conf 。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/服务器相关/redis/Redis集群/" data-id="cjfvvphoj00ebm9fyhg9plryg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器相关/redis/redis快速的几个原因" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/服务器相关/redis/redis快速的几个原因/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a>►<a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/服务器相关/redis/redis快速的几个原因/">redis快速的几个原因</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>总体来说快速的原因如下：        </p>
<ol>
<li>绝大部分请求是纯粹的内存操作（非常快速）   </li>
<li>采用单线程,避免了不必要的上下文切换和竞争条件   </li>
<li>非阻塞IO  </li>
</ol>
<p>内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间</p>
<p>这3个条件不是相互独立的，特别是第一条，如果请求都是耗时的，采用单线程吞吐量及性能可想而知了。应该说redis为特殊的场景选择了合适的技术方案。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/服务器相关/redis/redis快速的几个原因/" data-id="cjfvvphog00e4m9fykohmz45a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux/jenkins安装和启动" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Linux/jenkins安装和启动/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Linux/jenkins安装和启动/">jenkins安装和启动</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>多种安装方式，参考<a href="https://www.ilanni.com/?p=12545" target="_blank" rel="external">https://www.ilanni.com/?p=12545</a> 或者 参考官网</p>
<p><a href="http://blog.csdn.net/wh211212/article/details/53644980" target="_blank" rel="external">http://blog.csdn.net/wh211212/article/details/53644980</a></p>
<h3 id="运行和停止Jenkins"><a href="#运行和停止Jenkins" class="headerlink" title="运行和停止Jenkins"></a>运行和停止Jenkins</h3><p>普通启动，关闭进程后jenkins关闭<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 启动Jenkins</div><div class="line">java -jar /usr/share/jenkins/jenkins.war     </div><div class="line"></div><div class="line"># 停止Jenkins</div><div class="line">按Ctrl+C 组合键</div></pre></td></tr></table></figure></p>
<p>后台启动，指定端口，指定log文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">参数：</div><div class="line">--httpPort：指定端口</div><div class="line">--daemon：后台启动</div><div class="line">--logfile：指定jenkins启动日志路径</div><div class="line"></div><div class="line">例一：</div><div class="line">java -jar /usr/share/jenkins/jenkins.war --httpPort=8081 --daemon</div><div class="line"></div><div class="line"></div><div class="line">例二：</div><div class="line">mkdir /var/log/jenkins</div><div class="line">java -jar /usr/local/src/jenkins.war --logfile=/var/log/jenkins/jenkins.log</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Linux/jenkins安装和启动/" data-id="cjfvvphh9000xm9fyycdoesoh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux/Linux账号管理与ACL权限设置" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/Linux/Linux账号管理与ACL权限设置/" class="article-date">
  <time datetime="2018-02-25T02:09:45.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/Linux/Linux账号管理与ACL权限设置/">Linux账号管理与ACL权限设置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="用户账号"><a href="#用户账号" class="headerlink" title="用户账号"></a>用户账号</h3><p>跟用户有关有两个非常重要的文件，一个是管理用户UID/GID重要参数的<code>/etc/passwd</code>，一个则是专门管理密码相关数据的<code>/etc/shadow</code></p>
<h4 id="etc-passwd文件结构"><a href="#etc-passwd文件结构" class="headerlink" title="/etc/passwd文件结构"></a>/etc/passwd文件结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">cat /etc/passwd</div><div class="line">root:x:0:0:root:/root:/bin/bash</div><div class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</div><div class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</div><div class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</div><div class="line">sync:x:4:65534:sync:/bin:/bin/sync</div><div class="line">games:x:5:60:games:/usr/games:/usr/sbin/nologin</div><div class="line">man:x:6:12:man:/var/cache/man:/usr/sbin/nologin</div><div class="line">lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin</div><div class="line">mail:x:8:8:mail:/var/mail:/usr/sbin/nologin</div><div class="line">news:x:9:9:news:/var/spool/news:/usr/sbin/nologin</div><div class="line">uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin</div><div class="line">proxy:x:13:13:proxy:/bin:/usr/sbin/nologin</div><div class="line">www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin</div><div class="line">backup:x:34:34:backup:/var/backups:/usr/sbin/nologin</div><div class="line">......</div></pre></td></tr></table></figure>
<p>每一行都代表一个账号，有几行就代表有几个账号在你的系统中！不过需要特别留意的是，里面很多账号本来就是系统正常运行所必须要的，我们可以简称它为系统账号，例如bin，daemon，adm，nobody等，这些账号请不要随意删除</p>
<p>每一行使用“:”分隔开，共有七个字段，分别是：</p>
<ol>
<li>账号名称<br>就是账号，对应UID</li>
<li>密码<br>这个字段的密码数据放到<code>/etc/shadow</code>中，所以这里会显示一个x</li>
<li>UID<br>用户标识符</li>
</ol>
<table>
<thead>
<tr>
<th>ID范围</th>
<th>该ID用户特性</th>
</tr>
</thead>
<tbody>
<tr>
<td>0（系统管理员）</td>
<td>当UID是0时，代表这个账号是“系统管理员”，所以当你要让其他的账号名称也具有root的权限时，该账号的UID改为0即可。这也就是说，一个系统上面的系统管理员不见得只有root，不过，很不建议有多个账号的UID是0</td>
</tr>
<tr>
<td>1～499（系统账号）</td>
<td>保留给系统使用的ID，其实除了0之外，其他的UID权限与特性并没有不一样。默认500以下的数字让给系统作为保留账号只是一个习惯。<br>由于系统上面启动的服务希望使用较小的权限去运行，因此不希望用root的身份去执行这些服务，所以我们就得要提供这些运行中程序的所有者账号才行。这些系统账号通常是不可登录的。<br>根据系统账号的由来，通常系统账号又被分为两种：<br>1～99:由distributions自行创建的系统账号<br>100～499:若用户有系统账号的需求时，可以使用的账号UID</td>
</tr>
<tr>
<td>500～65535（可登录账号）</td>
<td>给一般用户用的。事实上，目前的Linux内核（2.6.x版）已经可以支持到2^32-1这么大的UID号码</td>
</tr>
</tbody>
</table>
<ol>
<li>GID<br>组ID</li>
<li>用户信息说明列<br>这个字段基本上并没有什么重要用途，只是用来解释这个账号的意义而已</li>
<li>主文件夹<br>这是用户的主文件夹。以上面为例，root的主文件夹是在<code>/root</code>中，所以当root登录之后，就会立刻跑到<code>/root</code>目录里面。<strong>默认的用户主文件夹在<code>/home/yourIDname</code>中</strong></li>
<li>shell<br>当用户登录系统后就会取得一个shell来与系统的内核通信以进行用户的操作任务。那为何默认shell会使用bash呢？就是在这个字段指定的。这里比较需要注意的是，有一个shell可以用来替代成让账号无法取得shell环境的登录操作，那就是<code>/sbin/nologin</code></li>
</ol>
<h4 id="etc-shadow文件结构"><a href="#etc-shadow文件结构" class="headerlink" title="/etc/shadow文件结构"></a>/etc/shadow文件结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">root@iZwz9hwmk5t4idn4oxa4okZ:/usr/share# cat /etc/shadow</div><div class="line">root:$6$rrwxtIVE$BIRVo2hygttfTZvNINNT3TL5Qbp.QaUC7px/jkC/nEp4gtluaVIUs56DzYxkZiE4lQefSw8OmX9Nn5lCQa2Sc.:17204:0:99999:7:::</div><div class="line">daemon:*:17001:0:99999:7:::</div><div class="line">bin:*:17001:0:99999:7:::</div><div class="line">sys:*:17001:0:99999:7:::</div><div class="line">sync:*:17001:0:99999:7:::</div><div class="line">games:*:17001:0:99999:7:::</div><div class="line">man:*:17001:0:99999:7:::</div><div class="line">lp:*:17001:0:99999:7:::</div><div class="line">mail:*:17001:0:99999:7:::</div><div class="line">news:*:17001:0:99999:7:::</div><div class="line">uucp:*:17001:0:99999:7:::</div><div class="line">proxy:*:17001:0:99999:7:::</div><div class="line">www-data:*:17001:0:99999:7:::</div><div class="line">backup:*:17001:0:99999:7:::</div></pre></td></tr></table></figure>
<p>shadow同样是以“:”分隔，有9个字段，分别是：</p>
<ol>
<li>账号名称<br>由于密码也需要与账号对应</li>
<li>密码     </li>
<li>最近更改密码的日期</li>
<li>密码不可被更改的天数（与第3个字段相比）</li>
<li>密码需要重新更改的天数（与第3个字段相比）</li>
<li>密码需要更改期限前的警告天数（与第5个字段相比）</li>
<li>密码过期后的账号宽限时间(密码失效日)（与第5个字段相比）</li>
<li>账号失效日期</li>
<li>保留</li>
</ol>
<h3 id="有效与初始用户组：groups，newgrp"><a href="#有效与初始用户组：groups，newgrp" class="headerlink" title="有效与初始用户组：groups，newgrp"></a>有效与初始用户组：groups，newgrp</h3><h6 id="etc-group文件结构"><a href="#etc-group文件结构" class="headerlink" title="/etc/group文件结构"></a>/etc/group文件结构</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># cat /etc/group</div><div class="line">root:x:0:</div><div class="line">daemon:x:1:</div><div class="line">bin:x:2:</div><div class="line">sys:x:3:</div><div class="line">adm:x:4:syslog</div><div class="line">tty:x:5:</div><div class="line">ssh:x:113:</div><div class="line">ntp:x:114:</div><div class="line">lpadmin:x:115:</div><div class="line">stapdev:x:116:</div><div class="line">stapusr:x:117:</div><div class="line">stapsys:x:118:</div><div class="line">mysql:x:119:</div><div class="line">redis:x:120:</div><div class="line">activemq:x:121:</div><div class="line">tomcat7:x:122:tomcat7</div><div class="line">tomcat:x:1000:</div><div class="line">jenkins:x:123:</div><div class="line">git:x:1001:</div></pre></td></tr></table></figure>
<ol>
<li>用户组名称</li>
<li>用户组密码</li>
<li>GID</li>
<li>此用户组支持的账号名称</li>
</ol>
<h5 id="groups：有效与支持用户组的查看"><a href="#groups：有效与支持用户组的查看" class="headerlink" title="groups：有效与支持用户组的查看"></a>groups：有效与支持用户组的查看</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># groups</div><div class="line">root</div></pre></td></tr></table></figure>
<p>第一个输出的用户组即为有效用户组，通常有效用户组的作用是新建文件</p>
<h5 id="newgrp：有效用户组的切换"><a href="#newgrp：有效用户组的切换" class="headerlink" title="newgrp：有效用户组的切换"></a>newgrp：有效用户组的切换</h5><p>使用newgrp是有限制的，那就是你想要切换的用户组必须是你已经有支持的用户组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">newgrp 用户组名称</div></pre></td></tr></table></figure></p>
<p>这个命令可以改变目前用户的有效用户组，而且是以另外一个新的shell来提供这个功能的，输入exit可以回到原本的shell<br>​<br>虽然用户的环境设置（如环境变量等其他数据）不会有影响，但是用户的“用户组权限”将会重新被计算</p>
<h3 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h3><h4 id="新增用户"><a href="#新增用户" class="headerlink" title="新增用户"></a>新增用户</h4><p>使用useradd来新建用户，密码的给予则使用passwd这个命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">useradd [-u UID] [-g 初始用户组] [-G 次要用户组] [-mM] </div><div class="line">[-c 说明栏] [-d 主文件夹绝对路径] [-s shell] 用户账户名</div><div class="line">-u：后面接的是UID，是一组数字，直接指定一个特定的UID给这个账号</div><div class="line">-g：后面接的那个用户组名就是初始用户组，该永辉组的GID会被放置到/etc/passwd的第四个字段内</div><div class="line">-G：后面接的组名则是这个账号还可以加入的用户组，这个参数会修改/etc/group内的相关数据</div><div class="line">-M：强制！不要创建用户主文件夹（系统账号默认值）</div><div class="line">-m：强制！要创建用户主文件夹（一般账号默认值）</div><div class="line">-c：这个就是/etc/passwd的第五列的说明内容，</div><div class="line">-d：指定某个目录成为主文件夹，而不要使用默认值，务必使用绝对路径</div><div class="line">-r：创建一个系统的账号，这个账号的UID会有限制</div><div class="line">-s：后面接一个shell，若没有指定则默认是/bin/bash</div><div class="line">-e：后面接一个日期，格式为“YYYY-MM-DD”，此选项可以写入shadow的第八字段，即账号失效日的设置选项</div><div class="line">-f：后面接shadow的第七字段选项，指定密码是否会失效，0为立刻失效，-1为永远不失效（密码只会过期而强制于登录时重新设置而已）</div><div class="line"></div><div class="line"></div><div class="line">例如：完全参考默认值新建一个用户，名称为test</div><div class="line"># useradd test</div><div class="line"># ll -d /home/test</div><div class="line">drwx------ 4 test test 4096 Feb 25 09:38 /home/test</div><div class="line"># 默认会创建用户主文件夹，且权限为700！这是重点！</div><div class="line"># 默认会创建一个与账号一模一样的用户组名</div></pre></td></tr></table></figure></p>
<p>CentOS这些默认值主要会帮我们处理几个项目：</p>
<ol>
<li>在/etc/passwd里面创建一行与账号相关的数据，包括创建UID/GID/主文件夹等</li>
<li>在/etc/shadow里面将此账号的密码相关参数填入，但是尚未有密码</li>
<li>在/etc/group里面加入一个与账号名称一模一样的组名</li>
<li>在/home下面创建一个与账号同名的目录作为用户主文件夹，且权限为700</li>
</ol>
<h5 id="useradd-参考文件"><a href="#useradd-参考文件" class="headerlink" title="useradd 参考文件"></a>useradd 参考文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># useradd -D</div><div class="line">GROUP=100 &lt;==默认的用户组</div><div class="line">HOME=/home &lt;==默认的主文件夹所在的目录</div><div class="line">INACTIVE=-1 &lt;==密码失效日，在shadow内的第7列</div><div class="line">EXPIRE= &lt;==账号失效日，在shadow内的第8列</div><div class="line">SHELL=/bin/sh &lt;==默认的shell</div><div class="line">SKEL=/etc/skel &lt;==用户主文件夹的内容数据参考目录</div><div class="line">CREATE_MAIL_SPOOL=no &lt;==是否主动帮用户创建邮件信箱</div></pre></td></tr></table></figure>
<p>这个数据其实是由/etc/default/useradd调用出来的</p>
<p>系统上面的GID为100即是users这个用户组，此设置项目指的就是让新设用户账号的初始用户组为users这个意思。但是我们知道CentOS上面并不是这样的，在CentOS上面默认的用户组为与账户名相同的用户组。这是因为针对用户组的角度两种不同的机制所致，这两种机制分别是：</p>
<ul>
<li><code>私有用户组机制</code>：系统会创建一个与账号一样的用户组给用户作为初始用户组。这种用户组的设置机制会比较有保密性，这是因为用户都有自己的用户组，而且主文件夹的权限将会设置为700（仅有自己可进入自己的主文件夹）。使用这种机制将不会参考GROUP=100这个设置值</li>
<li><code>公共用户组机制</code>：就是以GROUP=100这个设置值作为新建账号的初始用户组，因此每个账号都属于users这个用户组，且默认主文件夹通常的权限会是“drwxr-xr-x”,由于每个账号都属于users用户组，因此大家都可以互相分享主文件夹内的数据</li>
</ul>
<h5 id="设置用户密码：passwd"><a href="#设置用户密码：passwd" class="headerlink" title="设置用户密码：passwd"></a>设置用户密码：passwd</h5><p>使用useradd创建了账号之后，在默认的情况下，该账号是暂时被封锁的，也就是说，该账号是无法登录的，设置密码以后就可以正常的登录了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># passwd [--stdin] &lt;==所有人均可使用来改自己的密码</div><div class="line"># passwd [-l] [-u] [--stdin] [-S] [-n 日数] [-x 日数] [-w 日数] [-i 日数] [-i 日期] 账号 &lt;==root功能</div><div class="line">参数：</div><div class="line">--stdin：可以通过来自前一个管道的数据，作为密码输入，对shell script有帮助！</div><div class="line">-l：是Lock的意思，会将/etc/shadow第二列最前面加上！使密码失效</div><div class="line">-u：与-l相对，是unlock的意思</div><div class="line">-S：列出密码相关参数，即shadow文件内的大部分信息</div><div class="line">-n：shadow的第4个字段，多久不可修改密码天数</div><div class="line">-x：shadow的第5个字段，多久内必须要改动密码</div><div class="line">-w：shadow的第6个字段，密码过期前的警告天数</div><div class="line">-i：shadow的第7个字段，密码失效日期</div></pre></td></tr></table></figure></p>
<p>要帮一般账号新建密码需要使用“passwd 账号”的格式，使用“passwd”表示修改自己的密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 使用standard input新建用户的密码</div><div class="line"># echo &quot;密码&quot; | passwd --stdin 账号</div></pre></td></tr></table></figure></p>
<h5 id="密码参数显示和修改功能：chage"><a href="#密码参数显示和修改功能：chage" class="headerlink" title="密码参数显示和修改功能：chage"></a>密码参数显示和修改功能：chage</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># chage [-ldEImMW] 账号名</div><div class="line">参数：</div><div class="line">-l：列出该账号的详细密码参数</div><div class="line">-d：后面接日期，修改shadow的第三字段（最近一次更改密码的日期），格式为YYYY-MM-DD</div><div class="line">-E：后面接日期，修改shadow的第八字段（账号失效日）</div><div class="line">-I：后面接日期，修改shadow的第七字段（密码失效日期）</div><div class="line">-m：后面接日期，修改shadow的第四字段（密码最短保留天数）</div><div class="line">-M：后面接日期，修改shadow的第五字段（密码多久需要进行更改）</div><div class="line">-W：后面接日期，修改shadow的第六字段（密码过期前警告日期）</div></pre></td></tr></table></figure>
<p>让用户在第一次登录时强制他们一定要更改密码后才能够使用系统资源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># useradd agetest</div><div class="line"># echo &quot;agetest&quot; | passwd --stdin agetest</div><div class="line"># chage -d 0 agetest</div></pre></td></tr></table></figure></p>
<h5 id="用户调整：usermod"><a href="#用户调整：usermod" class="headerlink" title="用户调整：usermod"></a>用户调整：usermod</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># usermod [-cdegGlsuLU] username</div><div class="line">参数：</div><div class="line">-c：后面接账号的说明，即/etc/passwd 第五列的说明</div><div class="line">-d：修改账户的主文件夹</div><div class="line">-e：修改账号失效日期，格式为YYYY-MM-DD</div><div class="line">-f：修改密码失效日期</div><div class="line">-g：修改用户初始化用户组</div><div class="line">-G：修改用户次要用户组</div><div class="line">-a：与-G合用可增加次要用户组的支持而非设置</div><div class="line">-l：修改账号名称</div><div class="line">-s：修改shell</div><div class="line">-u：修改UID数字</div><div class="line">-L：暂时将用户的密码冻结，让他无法登录，其实仅改/etc/shadow的密码</div><div class="line">-U：将/etc/shadow 密码列的!去掉</div></pre></td></tr></table></figure>
<h5 id="删除用户：userdel"><a href="#删除用户：userdel" class="headerlink" title="删除用户：userdel"></a>删除用户：userdel</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># userdel [-r] username</div><div class="line">参数：</div><div class="line">-r：连同用户的主文件夹也一起删除</div></pre></td></tr></table></figure>
<h3 id="用户功能"><a href="#用户功能" class="headerlink" title="用户功能"></a>用户功能</h3><h4 id="查阅用户相关信息：finger"><a href="#查阅用户相关信息：finger" class="headerlink" title="查阅用户相关信息：finger"></a>查阅用户相关信息：finger</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># finger [-s] username</div><div class="line">参数：</div><div class="line">-s：仅列出用户的账号，全名，终端机代号与登录时间等</div><div class="line">-m：列出与后面接的账号相同者，而不是利用部分对比（包括全名部分）</div><div class="line"></div><div class="line">例子：查看目前系统上面登录的用户与登录时间</div><div class="line"># finger</div><div class="line">Login     Name       Tty      Idle  Login Time   Office     Office Phone</div><div class="line">root      root      *pts/0          Jan  3 09:56 (210.21.9.252)</div></pre></td></tr></table></figure>
<h4 id="修改个人属性：chfn"><a href="#修改个人属性：chfn" class="headerlink" title="修改个人属性：chfn"></a>修改个人属性：chfn</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># chfn [-foph] [账号名]</div><div class="line">参数：</div><div class="line">-f：后面接完整的大名</div><div class="line">-o：办公室房间号码</div><div class="line">-p：办公室电话号码</div><div class="line">-h：家里的电话号码</div></pre></td></tr></table></figure>
<h4 id="修改shell：chsh"><a href="#修改shell：chsh" class="headerlink" title="修改shell：chsh"></a>修改shell：chsh</h4><p>change shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># chsh [-ls]</div><div class="line">参数：</div><div class="line">-l：列出目前系统上面可用的shell，其实就是/etc/shells的内容</div><div class="line">-s：设置修改自己的shell</div></pre></td></tr></table></figure></p>
<h4 id="查询某人或自己的相关UID-GID等信息"><a href="#查询某人或自己的相关UID-GID等信息" class="headerlink" title="查询某人或自己的相关UID/GID等信息"></a>查询某人或自己的相关UID/GID等信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># id [username]</div><div class="line"></div><div class="line"># id</div><div class="line">uid=0(root) gid=0(root) groups=0(root)</div></pre></td></tr></table></figure>
<h3 id="新增和删除用户组"><a href="#新增和删除用户组" class="headerlink" title="新增和删除用户组"></a>新增和删除用户组</h3><h4 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># groupadd [-g gid] [-r] 用户组名</div><div class="line">参数：</div><div class="line">-g：后面接某个特定的GID，用来直接给予某个GID</div><div class="line">-r：新建系统用户组。与/etc/login.defs 内的GID_MIN 有关</div><div class="line"></div><div class="line">例如：</div><div class="line"># groupadd group1</div><div class="line"># grep group1 /etc/group /etc/gshadow</div><div class="line">/etc/group:group1:x702:</div><div class="line">/etc/gshadow:group1:!::</div></pre></td></tr></table></figure>
<h4 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># groupmod [-g gid] [-n group_name] 用户组名</div><div class="line">参数：</div><div class="line">-g：修改既有的GID数字</div><div class="line">-n：修改既有的组名</div></pre></td></tr></table></figure>
<h4 id="groupdel"><a href="#groupdel" class="headerlink" title="groupdel"></a>groupdel</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># groupdel [groupname]</div></pre></td></tr></table></figure>
<h4 id="用户组管理员功能：gpasswd"><a href="#用户组管理员功能：gpasswd" class="headerlink" title="用户组管理员功能：gpasswd"></a>用户组管理员功能：gpasswd</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># 关于系统管理员（root）做的动作</div><div class="line"># gpasswd groupname</div><div class="line"># gpasswd [-A user1,...] [-M user3,...] groupname</div><div class="line"># gpasswd [-rR] groupname</div><div class="line">参数：</div><div class="line">若没有任何参数时，表示给予groupname一个密码（/etc/gshadow）</div><div class="line">-A：将groupname的主控权交由后面的用户管理（该用户组的管理员）</div><div class="line">-M：将某些账号加入这个用户组当中</div><div class="line">-r：将groupname的密码删除</div><div class="line">-R：让groupname的密码栏失效</div><div class="line"></div><div class="line"># 关于用户组管理员（group administrator）做到操作：</div><div class="line"># gpasswd [-ad] user groupname</div><div class="line">参数：</div><div class="line">-a：将某位用户加入到groupname这个用户组当中</div><div class="line">-d：将某位用户删除出groupname这个用户组当中</div><div class="line"></div><div class="line">例如：新建一个新用户组，并交有test管理</div><div class="line"># groupadd testgroup</div><div class="line"># gpasswd -A test testgroup</div></pre></td></tr></table></figure>
<h3 id="主机的具体权限规划：ACL的使用"><a href="#主机的具体权限规划：ACL的使用" class="headerlink" title="主机的具体权限规划：ACL的使用"></a>主机的具体权限规划：ACL的使用</h3><p>ACL是Access Control List的缩写，主要的目的是提供传统的owner，grooup，others的read，write，execute权限之外的具体权限设置。ACL可以针对单一用户，单一文件或目录来进行r，w，x的权限设置，对于需要特殊权限的使用状况非常有帮助</p>
<p>ACL主要针对以下几个方面来控制权限：</p>
<ul>
<li>用户（user）：可以针对用户来设置权限</li>
<li>用户组（group）：针对用户组来设置其权限</li>
<li>默认属性（mask）：还可以在该目录下在新建文件/目录时设置新数据的默认权限</li>
</ul>
<h4 id="ACL的设置技巧：getfacl，setfacl"><a href="#ACL的设置技巧：getfacl，setfacl" class="headerlink" title="ACL的设置技巧：getfacl，setfacl"></a>ACL的设置技巧：getfacl，setfacl</h4><h5 id="设置某个目录-文件的ACL规定-setfacl"><a href="#设置某个目录-文件的ACL规定-setfacl" class="headerlink" title="设置某个目录/文件的ACL规定:setfacl"></a>设置某个目录/文件的ACL规定:setfacl</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"># setfacl [-bkRd] [&#123;-m|-x&#125; acl参数] 目标文件名</div><div class="line">参数：</div><div class="line">-m：设置后续的acl参数给文件使用，不可与-x使用</div><div class="line">-x：删除后续的acl参数，不可与-m合用</div><div class="line">-b：删除所有的ACL设置参数</div><div class="line">-k：删除默认的ACL参数</div><div class="line">-R：递归设置acl，亦即包括子目录都会被设置起来</div><div class="line">-d：设置默认acl参数!只对目录有效，在该目录新建的数据会引用此默认值</div><div class="line"></div><div class="line"></div><div class="line"># 1.针对单一用户的设置方式：</div><div class="line"># 设置规定：“u:[用户账号列表]:[rwx]”</div><div class="line"># touch acl_test1</div><div class="line"># ll acl_test1</div><div class="line">-rw-r--r-- 1 root root 0 Jan  3 11:08 acl_test1</div><div class="line"># setfacl -m u:test:rx acl_test1</div><div class="line"># ll acl_test1</div><div class="line">-rw-r-xr--+ 1 root root 0 Jan  3 11:08 acl_test1*</div><div class="line"># 权限部分多了个+，且与原本的权限（644）看起来区别很大</div><div class="line"></div><div class="line"># 2.针对特定用户组的方式</div><div class="line"># 设置规范“g:[用户组列表]:[rwx]”</div><div class="line"></div><div class="line"># 3.针对有效权限mask的设置方式</div><div class="line"># 设置规范“m:[rwx]”</div><div class="line"># setfacl -m m:r acl_test1</div><div class="line"># getfacl acl_test1</div><div class="line"># file: acl_test1</div><div class="line"># owner: root</div><div class="line"># group: root</div><div class="line">user::rw-</div><div class="line">user:test:r-x			#effective:r--</div><div class="line">group::r--</div><div class="line">mask::r--</div><div class="line">other::r--</div><div class="line"># test仅具有r的权限而已，并不存在x权限，这就是mask功能，我们可以通过mask来规定最大允许的权限</div></pre></td></tr></table></figure>
<h5 id="取得某个目录-文件的ACL设置项目-getfacl"><a href="#取得某个目录-文件的ACL设置项目-getfacl" class="headerlink" title="取得某个目录/文件的ACL设置项目:getfacl"></a>取得某个目录/文件的ACL设置项目:getfacl</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># getfacl filename</div><div class="line"></div><div class="line"># getfacl acl_test1</div><div class="line"># file: acl_test1   &lt;== 文件名</div><div class="line"># owner: root   &lt;== 文件所有者，即ll看到的第三用户字段</div><div class="line"># group: root   &lt;== 此文件所属用户组，即ll看到的第四用户字段</div><div class="line">user::rw-   &lt;== 用户列表栏空的，代表文件所有者的权限</div><div class="line">user:test:r-x   &lt;== 针对test的权限设置为rx，与所有者不同</div><div class="line">group::r--  &lt;== 文件用户组的权限设置仅为r</div><div class="line">mask::r-x   &lt;== 此文件默认的有效权限（mask）</div><div class="line">other::r--  &lt;== 其他人拥有的权限</div></pre></td></tr></table></figure>
<p>显示的数据前面加上#的，代表这个文件的默认属性，包括文件名，文件所有者与文件所属用户组。下面出现的user，group，mask，other则是属于不用用户，用户组与有效权限的设置值</p>
<h3 id="用户身份切换"><a href="#用户身份切换" class="headerlink" title="用户身份切换"></a>用户身份切换</h3><p>一般用户转变身份成为root：</p>
<ul>
<li>以“su -”直接将身份变成root即可，但是这个命令却需要root的密码，也就是说，如果你要以su变成root 的话，你的一般用户就必须要有root的密码才行</li>
<li>以“sudo命令”执行root的命令串，由于sudo需要事先设置妥当，且sudo需要输入用户自己的密码，因此多人共管同一台主机时，sudo要比su来的好，至少root密码不会流出去</li>
</ul>
<h4 id="su"><a href="#su" class="headerlink" title="su"></a>su</h4><p>su是最简单的身份切换命令了，它可以进行任何身份的切换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># su [-lm] [-c 命令] [username]</div><div class="line">参数：</div><div class="line">- ：单纯使用 - 如“su -”，代表使用login-shell的变量文件读取方式来登录系统</div><div class="line">-l：与 - 类似，但后面需要加欲切换的用户账号。也是login-shell的方式</div><div class="line">-m：-m与-p是一样的，表示使用目前的环境设置，而不读取新用户的配置文件</div><div class="line">-c：仅进行一次命令，所以-c后面可以加上命令</div><div class="line"></div><div class="line">exit退出su环境</div></pre></td></tr></table></figure></p>
<p>单纯使用“su”切换成为root身份，读取的变量设置方式为non-login shell方式，这种方式下很多原本的变量不会被改变，还是原来用户的环境变量，如PATH</p>
<h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><p>sudo的执行仅需要自己的密码即可，甚至可以设置不需要密码也可执行！并非所有人都能够执行sudo，而是仅有/etc/sudoers内的用户才能够执行sudo这个命令，系统一开始默认仅有root可执行sudo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># sudo [-b] [-u 新用户账号]</div><div class="line">参数：</div><div class="line">-b：将后续的命令让系统自动执行，而不与目前的shell产生影响</div><div class="line">-u：后面可以接欲切换的用户，若无此项则代表切换身份为root</div></pre></td></tr></table></figure></p>
<p>sudo的执行流程：</p>
<ol>
<li>当用户执行sudo时，系统于/etc/sudoers文件中查找该用户是否有执行sudo的权限</li>
<li>若用户具有可执行sudo的权限后，便让用户输入用户自己的密码来确认</li>
<li>若密码输入成功，便开始进行sudo后续接的命令（但root执行sudo时不需要输入密码）</li>
<li>若欲切换的身份与执行者的身份相同，那也不需要输入密码</li>
</ol>
<h5 id="visudo"><a href="#visudo" class="headerlink" title="visudo"></a>visudo</h5><p>除了root之外的其他账号，若想要使用sudo执行属于root的权限命令，则root需要先用visudo去修改/etc/sudoers，让账号能够使用全部或部分的root命令功能</p>
<h6 id="单一用户可进行root所有命令与sudoers文件语法"><a href="#单一用户可进行root所有命令与sudoers文件语法" class="headerlink" title="单一用户可进行root所有命令与sudoers文件语法"></a>单一用户可进行root所有命令与sudoers文件语法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 假设要让test这个账号可以使用root的任何命令</div><div class="line"># visudo</div><div class="line">...(前面省略)...</div><div class="line">root ALL=(ALL)   ALL &lt;==找到这一行，大约在76行左右</div><div class="line">test ALL=(ALL)   ALL &lt;==这一行是你要新增的</div><div class="line">...(后面省略)...</div></pre></td></tr></table></figure>
<p>其实visudo只是利用vi将/etc/sudoers文件调用出来进行修改而已，数据格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">用户账号  登录者的来源主机名=（可切换的身份） 可执行的命令</div><div class="line">root         ALL=(ALL)                       ALL &lt;==这是默认值</div></pre></td></tr></table></figure></p>
<p>4个参数的意义：</p>
<ul>
<li><code>用户账号</code>：系统的哪个账号可以使用sudo这个命令，默认为root这个账号</li>
<li><code>登录者的来源主机名</code>：这个账号由哪台主机连接到本Linux主机，意思是这个账号可能是由哪一台网络主机连接过来的，这个设置值可以指定客户端计算机（信任用户的意思）。默认值root可来自任何一台网络主机</li>
<li><code>可切换的身份</code>：这个账号可以切换成什么身份来执行后续的命令，默认root可以切换成任何人</li>
<li><code>可执行命令</code>：这个命令请务必使用绝对路径编写。默认root可以切换任何身份且进行任何命令    </li>
</ul>
<p><strong>注意：那个ALL是特殊关键字，代表任何身份，主机或命令的意思</strong></p>
<h6 id="利用用户组以及免密码的功能处理visudo"><a href="#利用用户组以及免密码的功能处理visudo" class="headerlink" title="利用用户组以及免密码的功能处理visudo"></a>利用用户组以及免密码的功能处理visudo</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># visudo</div><div class="line">...(前面省略)...</div><div class="line">%wheel   ALL=(ALL) ALL &lt;== 大约在84行左右，请将这行的#去掉</div><div class="line"># 在最左边加上%，代表后面接的是一个“用户组”之意</div><div class="line">...(后面省略)...</div><div class="line"></div><div class="line"># usermod -a -G wheel test &lt;== 将test加入wheel的支持，现在test用户就可以使用sudo命令啦</div></pre></td></tr></table></figure>
<h6 id="设置免密码即可使用sudo"><a href="#设置免密码即可使用sudo" class="headerlink" title="设置免密码即可使用sudo"></a>设置免密码即可使用sudo</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">...(前面省略)...</div><div class="line">%wheel   ALL=(ALL) NOPASSWD:ALL </div><div class="line"># 在最左边加上%，代表后面接的是一个“用户组”之意</div><div class="line">...(后面省略)...</div></pre></td></tr></table></figure>
<h6 id="有限制的命令操作"><a href="#有限制的命令操作" class="headerlink" title="有限制的命令操作"></a>有限制的命令操作</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># visudo </div><div class="line">myuser1 ALL=(root) /usr/bin/passwd &lt;== 最后命令务必用绝对路径</div></pre></td></tr></table></figure>
<h6 id="限制用户的命令参数"><a href="#限制用户的命令参数" class="headerlink" title="限制用户的命令参数"></a>限制用户的命令参数</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># visudo</div><div class="line">myuser1 ALL=(root) !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root</div><div class="line"># 加上!代表“不可执行的意思”，因此上面这一行变成可以执行“passwd 任意字符”，但是“passwd”与“passwd root”这两个命令例外</div></pre></td></tr></table></figure>
<h6 id="通过别名设置visudo"><a href="#通过别名设置visudo" class="headerlink" title="通过别名设置visudo"></a>通过别名设置visudo</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># visudo</div><div class="line">User_Alias ADMPW = test1, test2, test3</div><div class="line">Cmnd_Alias ADMPWCOM = !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root </div><div class="line">ADMPW ALL=(root) ADMPWCOM</div></pre></td></tr></table></figure>
<p>通过<code>User_Alias</code>新建一个新账号，新账号的名称一定要用大写字符来处理，包括<code>Cmnd_Alias（命令别名）</code>，<code>Host_Alias（来源主机名）</code>都需要使用大写字符</p>
<h6 id="sudo时间间隔"><a href="#sudo时间间隔" class="headerlink" title="sudo时间间隔"></a>sudo时间间隔</h6><p>如果两次sudo操作的间隔超过5分钟，那就得要重新输入一次你的密码了</p>
<h6 id="sudo搭配su的使用方式"><a href="#sudo搭配su的使用方式" class="headerlink" title="sudo搭配su的使用方式"></a>sudo搭配su的使用方式</h6><p>很多时候我们需要大量执行很多root的工作，所以一直使用sudo觉的很烦，那有没有办法使用sudo搭配su，一口气将身份转成root，而且还使用用户自己的密码来变成root呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># visudo </div><div class="line">User_Alias ADMINS = test1, test2, test3</div><div class="line">ADMINS ALL=(root) /bin/su -</div></pre></td></tr></table></figure></p>
<p>接下来，上述的test1，test2，test3三个用户，只要输入“sudo su -”并且输入自己的密码后，立刻变成root身份，不但root密码不会外泄，用户的管理也变的非常方便</p>
<h3 id="用户的特殊shell与PAM模块"><a href="#用户的特殊shell与PAM模块" class="headerlink" title="用户的特殊shell与PAM模块"></a>用户的特殊shell与PAM模块</h3><h4 id="特殊的shell，-sbin-nologin"><a href="#特殊的shell，-sbin-nologin" class="headerlink" title="特殊的shell，/sbin/nologin"></a>特殊的shell，/sbin/nologin</h4><p>一般地，系统账号是不能登录的，系统账号的shell就是使用/sbin/nologin，如果账户使用了/sbin/nologin，即使有了密码，也是不能登录系统的，但是可以使用系统资源</p>
<h4 id="PAM模块简介"><a href="#PAM模块简介" class="headerlink" title="PAM模块简介"></a>PAM模块简介</h4><p>PAM可以说是一套应用程序编程接口（Application Programming Interface API），它提供了一连串的验证机制，只要用户将验证阶段的需求告知PAM后，PAM就能够回报用户验证的结果（成功或失败）</p>
<p>PAM通过一个与程序相同文件名的配置文件来进行一连串的认证分析需求。我们同样以passwd这个命令调用PAM。当你执行passwd后，这个程序调用PAM的流程是：</p>
<ol>
<li>用户开始执行/usr/bin/passwd这支程序，并输入密码</li>
<li>passwd调用PAM模块进行验证</li>
<li>PAM模块会到/etc/pam.d/中找寻与程序（passwd）同名的配置文件</li>
<li>依据/etc/pam.d/passwd内的设置，引用相关的PAM模块逐步进行验证分析</li>
<li>将验证结果（成功，失败以及其他信息）回传给passwd这个程序</li>
<li>passwd这支程序会根据PAM回传的结果决定下一个操作（重新输入密码或者通过验证）</li>
</ol>
<h6 id="etc-pam-d-passwd"><a href="#etc-pam-d-passwd" class="headerlink" title="/etc/pam.d/passwd"></a>/etc/pam.d/passwd</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># cat /etc/pam.d/passwd</div><div class="line">#%PAM-1.0 </div><div class="line">auth include system-auth &lt;==每一行都是一个验证过程</div><div class="line">account include system-auth</div><div class="line">password include system-auth</div><div class="line">验证类型 控制标准 PAM模块与该模块参数</div></pre></td></tr></table></figure>
<h3 id="查询用户：w，who，last，lastlog"><a href="#查询用户：w，who，last，lastlog" class="headerlink" title="查询用户：w，who，last，lastlog"></a>查询用户：w，who，last，lastlog</h3><h4 id="查询目前已登录在系统上面的用户-w-或者-who"><a href="#查询目前已登录在系统上面的用户-w-或者-who" class="headerlink" title="查询目前已登录在系统上面的用户:w 或者 who"></a>查询目前已登录在系统上面的用户:w 或者 who</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># w</div><div class="line"> 17:36:26 up 26 days,  5:13,  1 user,  load average: 0.00, 0.00, 0.00</div><div class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</div><div class="line">root     pts/0    210.21.9.252     14:20    2.00s  0.03s  0.00s w</div><div class="line"># 第一行显示目前的时间，开机（up）多久，几个用户在系统上的平均负载等</div><div class="line"></div><div class="line"># who</div><div class="line">root     pts/0        2018-01-03 14:20 (210.21.9.252)</div></pre></td></tr></table></figure>
<h4 id="查看每个账号的最近登录时间，则可以使用lastlog这个命令。lastlog会去读取-var-log-lastlog文件，结果将数据输出"><a href="#查看每个账号的最近登录时间，则可以使用lastlog这个命令。lastlog会去读取-var-log-lastlog文件，结果将数据输出" class="headerlink" title="查看每个账号的最近登录时间，则可以使用lastlog这个命令。lastlog会去读取/var/log/lastlog文件，结果将数据输出"></a>查看每个账号的最近登录时间，则可以使用lastlog这个命令。lastlog会去读取/var/log/lastlog文件，结果将数据输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># lastlog</div><div class="line">Username         Port     From             Latest</div><div class="line">root             pts/0    210.21.9.252     Wed Jan  3 14:20:31 +0800 2018</div><div class="line">daemon                                     **Never logged in**</div><div class="line">bin                                        **Never logged in**</div><div class="line">sys                                        **Never logged in**</div><div class="line">sync                                       **Never logged in**</div><div class="line">games                                      **Never logged in**</div><div class="line">man                                        **Never logged in**</div></pre></td></tr></table></figure>
<h3 id="用户对谈：write，mesg，wall"><a href="#用户对谈：write，mesg，wall" class="headerlink" title="用户对谈：write，mesg，wall"></a>用户对谈：write，mesg，wall</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"># write 用户账号 [用户所在终端接口]</div><div class="line"></div><div class="line"># who</div><div class="line">root     pts/0        2018-01-03 14:20 (210.21.9.252)</div><div class="line">test     pts/1        2018-01-03 17:47 (210.21.9.252) &lt;== test用户在线</div><div class="line"></div><div class="line"># root向test发送消息</div><div class="line"># write test pts/1</div><div class="line">write: write: you have write permission turned off.</div><div class="line"></div><div class="line">fuck</div><div class="line"></div><div class="line"># test接收到的消息</div><div class="line">Message from root@iZwz9hwmk5t4idn4oxa4okZ on pts/0 at 17:49 ...</div><div class="line">fuck</div><div class="line">EOF</div><div class="line"></div><div class="line"># test不想接收任何信息，但是对于root传来的信息没有任何抵抗力</div><div class="line">mesg n</div><div class="line">$ mesg</div><div class="line">is n</div><div class="line"></div><div class="line"># 广播</div><div class="line"># wall &quot;this is a message&quot;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2018/02/25/Linux/Linux账号管理与ACL权限设置/" data-id="cjfvvphhb0011m9fycrd0yjpe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/4/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Eclipse/">Eclipse</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Github/">Github</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Cookie/">Cookie</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JAXB/">JAXB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JavaMail/">JavaMail</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/基础/">基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/数据类型/">数据类型</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/日记/">日记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/时间日期/">时间日期</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/线程/">线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/网络NIO/">网络NIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/队列/">队列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/集合/">集合</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Application-Event/">Application Event</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/JPA/">JPA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Security/">Security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Spring-Boot/">Spring Boot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Spring-Session/">Spring Session</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Task/">Task</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-MVC/">spring MVC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/spring-data-redis/">spring data redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/基础/">基础</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/">前端技术相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/forever/">forever</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术相关/javascript/">javascript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库相关/">数据库相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据库相关/mysql/">mysql</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/">服务器相关</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hessian/">Hessian</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Hudson-Jenkins/">Hudson & Jenkins</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Memcached/">Memcached</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Nginx/">Nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/Tomcat/">Tomcat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/red5/">red5</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器相关/resin/">resin</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/正则表达式/">正则表达式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/12/服务器相关/Tomcat/TOMCAT原理详解及请求过程/">TOMCAT原理详解及请求过程</a>
          </li>
        
          <li>
            <a href="/2018/04/12/网络/HTTPS工作原理/">HTTPS工作原理</a>
          </li>
        
          <li>
            <a href="/2018/04/12/网络/三次握手和四次挥手/">三次握手和四次挥手</a>
          </li>
        
          <li>
            <a href="/2018/04/12/服务器相关/Tomcat/内存分配/">内存分配</a>
          </li>
        
          <li>
            <a href="/2018/04/12/服务器相关/Tomcat/Tomcat整体架构浅析/">Tomcat整体架构浅析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 LeoChan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>