<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LeoChan&#39;s 个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="描述啊">
<meta property="og:type" content="website">
<meta property="og:title" content="LeoChan&#39;s 个人博客">
<meta property="og:url" content="https://clq2owesome.github.io/page/18/index.html">
<meta property="og:site_name" content="LeoChan&#39;s 个人博客">
<meta property="og:description" content="描述啊">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeoChan&#39;s 个人博客">
<meta name="twitter:description" content="描述啊">
  
    <link rel="alternate" href="/atom.xml" title="LeoChan&#39;s 个人博客" type="application/atom+xml">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  

</head>

<body>
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">LeoChan&#39;s 个人博客</h1>
  
    <p class="lead blog-description">技术都是通用的，重要的是是否具有自主解决问题的能力！</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-服务器相关/redis/事物管理" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/19/服务器相关/redis/事物管理/">事物管理</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/07/19/服务器相关/redis/事物管理/" class="article-date"><time datetime="2017-07-19T02:09:45.000Z" itemprop="datePublished">2017-07-19</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a> / <a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p><code>MULTI</code> 、 <code>EXEC</code> 、 <code>DISCARD</code> 和 <code>WATCH</code> 是 Redis 事务相关的命令。事务可以一次执行多个命令， 并且带有以下两个重要的保证：    </p>
<ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li>
</ul>
<p><code>EXEC</code> 命令负责触发并执行事务中的所有命令：    </p>
<ul>
<li>如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。</li>
<li>另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。  </li>
</ul>
<p>当使用 AOF 方式做持久化的时候， Redis 会使用单个 write(2) 命令将事务写入到磁盘中。<br>然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。    </p>
<p>如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。    </p>
<p>使用redis-check-aof程序可以修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。<br>从 2.2 版本开始，Redis 还可以通过乐观锁（optimistic lock）实现 CAS （check-and-set）操作，具体信息请参考文档的后半部分。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>MULTI 命令用于开启一个事务，它总是返回 OK 。 MULTI 执行之后， 客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行， 而是被放到一个队列中， 当 EXEC命令被调用时， 所有队列中的命令才会被执行。    </p>
<p>另一方面， 通过调用 DISCARD ， 客户端可以清空事务队列， 并放弃执行事务。</p>
<p>以下是一个事务例子， 它原子地增加了 foo 和 bar 两个键的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; MULTI</div><div class="line">OK</div><div class="line">&gt; INCR foo</div><div class="line">QUEUED</div><div class="line">&gt; INCR bar</div><div class="line">QUEUED</div><div class="line">&gt; EXEC</div><div class="line">1) (integer) 1</div><div class="line">2) (integer) 1</div></pre></td></tr></table></figure></p>
<p>EXEC 命令的回复是一个数组， 数组中的每个元素都是执行事务中的命令所产生的回复。 其中， 回复元素的先后顺序和命令发送的先后顺序一致。  </p>
<p>当客户端处于事务状态时， 所有传入的命令都会返回一个内容为 <code>QUEUED</code> 的状态回复（status reply）， 这些被入队的命令将在 EXEC 命令被调用时执行。</p>
<h2 id="事务中的错误"><a href="#事务中的错误" class="headerlink" title="事务中的错误"></a>事务中的错误</h2><p>使用事务时可能会遇上以下两种错误：</p>
<ul>
<li>事务在执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 maxmemory 设置了最大内存限制的话）。</li>
<li>命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。  </li>
</ul>
<p>对于发生在 EXEC 执行之前的错误，客户端以前的做法是检查命令入队所得的返回值：如果命令入队时返回 QUEUED ，那么入队成功；否则，就是入队失败。如果有命令在入队时失败，那么大部分客户端都会停止并取消这个事务。    </p>
<p>不过，从 Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。<br>​<br>在 Redis 2.6.5 以前， Redis 只执行事务中那些入队成功的命令，而忽略那些入队失败的命令。 而新的处理方式则使得在流水线（pipeline）中包含事务变得简单，因为发送事务和读取事务的回复都只需要和服务器进行一次通讯。    </p>
<p>至于那些在 EXEC 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。    </p>
<p>从协议的角度来看这个问题，会更容易理解一些。 以下例子中， LPOP 命令的执行将出错， 尽管调用它的语法是正确的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Trying 127.0.0.1...</div><div class="line">Connected to localhost.</div><div class="line">Escape character is &apos;^]&apos;.</div><div class="line">MULTI</div><div class="line">+OK</div><div class="line">SET a 3</div><div class="line">abc</div><div class="line">+QUEUED</div><div class="line">LPOP a</div><div class="line">+QUEUED</div><div class="line">EXEC</div><div class="line">*2</div><div class="line">+OK</div><div class="line">-ERR Operation against a key holding the wrong kind of value</div></pre></td></tr></table></figure></p>
<p>EXEC 返回两条bulk-string-reply： 第一条是 OK ，而第二条是 -ERR 。 至于怎样用合适的方法来表示事务中的错误， 则是由客户端自己决定的。     </p>
<p>==最重要的是记住这样一条， 即使事务中有某条/某些命令执行失败了， 事务队列中的其他命令仍然会继续执行 —— Redis不会停止执行事务中的命令。==  </p>
<p>以下例子展示的是另一种情况， 当命令在入队时产生错误， 错误会立即被返回给客户端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MULTI</div><div class="line">+OK</div><div class="line">INCR a b c</div><div class="line">-ERR wrong number of arguments for &apos;incr&apos; command</div></pre></td></tr></table></figure></p>
<p>因为调用 INCR 命令的参数格式不正确， 所以这个 INCR 命令入队失败。</p>
<h2 id="为什么-Redis-不支持回滚（roll-back）"><a href="#为什么-Redis-不支持回滚（roll-back）" class="headerlink" title="为什么 Redis 不支持回滚（roll back）"></a>为什么 Redis 不支持回滚（roll back）</h2><p>如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。    </p>
<p>以下是这种做法的优点：</p>
<ul>
<li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li>
<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li>
</ul>
<p>有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 INCR 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 INCR ， 回滚是没有办法处理这些情况的。</p>
<h2 id="放弃事务"><a href="#放弃事务" class="headerlink" title="放弃事务"></a>放弃事务</h2><p>当执行 DISCARD 命令时， 事务会被放弃， 事务队列会被清空， 并且客户端会从事务状态中退出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; SET foo 1</div><div class="line">OK</div><div class="line">&gt; MULTI</div><div class="line">OK</div><div class="line">&gt; INCR foo</div><div class="line">QUEUED</div><div class="line">&gt; DISCARD</div><div class="line">OK</div><div class="line">&gt; GET foo</div><div class="line">&quot;1&quot;</div></pre></td></tr></table></figure></p>
<h2 id="使用-check-and-set-操作实现乐观锁"><a href="#使用-check-and-set-操作实现乐观锁" class="headerlink" title="使用 check-and-set 操作实现乐观锁"></a>使用 check-and-set 操作实现乐观锁</h2><p>WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。</p>
<p>被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回nil-reply来表示事务已经失败。  </p>
<p>举个例子， 假设我们需要原子性地为某个值进行增 1 操作（假设 INCR 不存在）。<br>首先我们可能会这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val = GET mykey</div><div class="line">val = val + 1</div><div class="line">SET mykey $val</div></pre></td></tr></table></figure></p>
<p>上面的这个实现在只有一个客户端的时候可以执行得很好。 但是， 当多个客户端同时对同一个键进行这样的操作时， 就会产生竞争条件。举个例子， 如果客户端 A 和 B 都读取了键原来的值， 比如 10 ， 那么两个客户端都会将键的值设为 11 ， 但正确的结果应该是 12 才对。  </p>
<p>有了 WATCH ， 我们就可以轻松地解决这类问题了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">WATCH mykey</div><div class="line">val = GET mykey</div><div class="line">val = val + 1</div><div class="line">MULTI</div><div class="line">SET mykey $val</div><div class="line">EXEC</div></pre></td></tr></table></figure></p>
<p>使用上面的代码， 如果在 WATCH 执行之后， EXEC 执行之前， 有其他客户端修改了 mykey 的值， 那么当前客户端的事务就会失败。 程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞为止。  </p>
<p>这种形式的锁被称作乐观锁， 它是一种非常强大的锁机制。 并且因为大多数情况下， 不同的客户端会访问不同的键， 碰撞的情况一般都很少， 所以通常并不需要进行重试。</p>
<h2 id="了解-WATCH"><a href="#了解-WATCH" class="headerlink" title="了解 WATCH"></a>了解 WATCH</h2><p>WATCH 使得 EXEC 命令需要有条件地执行： 事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。 <a href="http://code.google.com/p/redis/issues/detail?id=270" target="_blank" rel="external">了解更多-&gt;</a></p>
<p>WATCH 命令可以被调用多次。 对键的监视从 WATCH 执行之后开始生效， 直到调用 EXEC 为止。<br>用户还可以在单个 WATCH 命令中监视任意多个键， 就像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">redis&gt; WATCH key1 key2 key3</div><div class="line">OK</div></pre></td></tr></table></figure></p>
<p>当 EXEC 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消。<br>另外， 当客户端断开连接时， 该客户端对键的监视也会被取消。<br>使用无参数的 UNWATCH 命令可以手动取消对所有键的监视。 对于一些需要改动多个键的事务， 有时候程序需要同时对多个键进行加锁， 然后检查这些键的当前值是否符合程序的要求。 当值达不到要求时， 就可以使用 UNWATCH 命令来取消目前对键的监视， 中途放弃这个事务， 并等待事务的下次尝试。</p>
<h2 id="使用-WATCH-实现-ZPOP"><a href="#使用-WATCH-实现-ZPOP" class="headerlink" title="使用 WATCH 实现 ZPOP"></a>使用 WATCH 实现 ZPOP</h2><p>WATCH 可以用于创建 Redis 没有内置的原子操作。举个例子， 以下代码实现了原创的 ZPOP 命令， 它可以原子地弹出有序集合中分值（score）最小的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">WATCH zset</div><div class="line">element = ZRANGE zset 0 0</div><div class="line">MULTI</div><div class="line">ZREM zset element</div><div class="line">EXEC</div></pre></td></tr></table></figure>
<p>程序只要重复执行这段代码， 直到 EXEC 的返回值不是nil-reply回复即可。    </p>
<h2 id="Redis-脚本和事务"><a href="#Redis-脚本和事务" class="headerlink" title="Redis 脚本和事务"></a>Redis 脚本和事务</h2><p>从定义上来说， Redis 中的脚本本身就是一种事务， 所以任何在事务里可以完成的事， 在脚本里面也能完成。 并且一般来说， 使用脚本要来得更简单，并且速度更快。    </p>
<p>因为脚本功能是 Redis 2.6 才引入的， 而事务功能则更早之前就存在了， 所以 Redis 才会同时存在两种处理事务的方法。<br>不过我们并不打算在短时间内就移除事务功能， 因为事务提供了一种即使不使用脚本， 也可以避免竞争条件的方法， 而且事务本身的实现并不复杂。    </p>
<p>不过在不远的将来， 可能所有用户都会只使用脚本来实现事务也说不定。 如果真的发生这种情况的话， 那么我们将废弃并最终移除事务功能。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/07/19/服务器相关/redis/事物管理/" data-id="cj6cy7njd00bbktblawa0w34u" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-服务器相关/redis/常用原子方法" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/19/服务器相关/redis/常用原子方法/">常用原子方法</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/07/19/服务器相关/redis/常用原子方法/" class="article-date"><time datetime="2017-07-19T02:09:45.000Z" itemprop="datePublished">2017-07-19</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a> / <a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SETEX-key-seconds-value"><a href="#SETEX-key-seconds-value" class="headerlink" title="SETEX key seconds value"></a>SETEX key seconds value</h1><blockquote>
<p>起始版本：2.0.0<br>  时间复杂度：O(1)</p>
</blockquote>
<p>设置key对应字符串value，并且设置key在给定的seconds时间之后超时过期。这个命令等效于执行下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SET mykey value</div><div class="line">EXPIRE mykey seconds</div></pre></td></tr></table></figure></p>
<p>==SETEX是原子的==，也可以通过把上面两个命令放到MULTI/EXEC块中执行的方式重现。相比连续执行上面两个命令，它更快，因为当Redis当做缓存使用时，这个操作更加常用。</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">simple-string-reply</div></pre></td></tr></table></figure>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">redis&gt; SETEX mykey 10 “Hello” </div><div class="line">OK</div><div class="line">redis&gt; TTL mykey </div><div class="line">(integer) 10</div><div class="line">redis&gt; GET mykey </div><div class="line">“Hello”</div></pre></td></tr></table></figure>
<h1 id="PSETEX-key-milliseconds-value"><a href="#PSETEX-key-milliseconds-value" class="headerlink" title="PSETEX key milliseconds value"></a>PSETEX key milliseconds value</h1><blockquote>
<p>起始版本：2.6.0<br>时间复杂度：O(1)</p>
</blockquote>
<p>PSETEX和SETEX一样，唯一的区别是到期时间以毫秒为单位,而不是秒。</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">redis&gt; PSETEX mykey 1000 &quot;Hello&quot;</div><div class="line">OK</div><div class="line">redis&gt; PTTL mykey</div><div class="line">(integer) 999</div><div class="line">redis&gt; GET mykey</div><div class="line">&quot;Hello&quot;</div><div class="line">redis&gt;</div></pre></td></tr></table></figure>
<h1 id="MSET"><a href="#MSET" class="headerlink" title="MSET"></a>MSET</h1><blockquote>
<p>起始版本：1.0.1<br>时间复杂度：O(N) where N is the number of keys to set.</p>
</blockquote>
<p>对应给定的keys到他们相应的values上。MSET会用新的value替换已经存在的value，就像普通的SET命令一样。如果你不想覆盖已经存在的values，请参看命令MSETNX。<br>==MSET是原子的==，所以所有给定的keys是一次性set的。客户端不可能看到这种一部分keys被更新而另外的没有改变的情况。</p>
<h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>simple-string-reply：总是OK，因为MSET不会失败。</p>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">redis&gt; MSET key1 &quot;Hello&quot; key2 &quot;World&quot;</div><div class="line">OK</div><div class="line">redis&gt; GET key1</div><div class="line">&quot;Hello&quot;</div><div class="line">redis&gt; GET key2</div><div class="line">&quot;World&quot;</div></pre></td></tr></table></figure>
<h1 id="MGET-key-key-…"><a href="#MGET-key-key-…" class="headerlink" title="MGET key [key …]"></a>MGET key [key …]</h1><blockquote>
<p>起始版本：1.0.0<br>时间复杂度：O(N) where N is the number of keys to retrieve.</p>
</blockquote>
<p>返回所有指定的key的value。对于每个不对应string或者不存在的key，都返回特殊值nil。正因为此，这个操作从来不会失败。</p>
<h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><p>array-reply: 指定的key对应的values的list</p>
<h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子:"></a>例子:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">redis&gt; SET key1 &quot;Hello&quot;</div><div class="line">OK</div><div class="line">redis&gt; SET key2 &quot;World&quot;</div><div class="line">OK</div><div class="line">redis&gt; MGET key1 key2 nonexisting</div><div class="line">1) &quot;Hello&quot;</div><div class="line">2) &quot;World&quot;</div><div class="line">3) (nil)</div></pre></td></tr></table></figure>
<h1 id="MSETNX-key-value-key-value-…"><a href="#MSETNX-key-value-key-value-…" class="headerlink" title="MSETNX key value [key value …]"></a>MSETNX key value [key value …]</h1><blockquote>
<p>起始版本：1.0.1<br>时间复杂度：O(N) where N is the number of keys to set.</p>
</blockquote>
<p>对应给定的keys到他们相应的values上。只要有一个key已经存在，MSETNX一个操作都不会执行。由于这种特性，MSETNX可以实现要么所有的操作都成功，要么一个都不执行，这样可以用来设置不同的key，来表示一个唯一的对象的不同字段。<br>==MSETNX是原子的==，所以所有给定的keys是一次性set的。客户端不可能看到这种一部分keys被更新而另外的没有改变的情况。</p>
<h3 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h3><p>integer-reply，只有以下两种值：</p>
<ul>
<li><code>1</code> 如果所有的key被set</li>
<li><code>0</code> 如果没有key被set(至少其中有一个key是存在的)</li>
</ul>
<h3 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">redis&gt; MSETNX key1 &quot;Hello&quot; key2 &quot;there&quot;</div><div class="line">(integer) 1</div><div class="line">redis&gt; MSETNX key2 &quot;there&quot; key3 &quot;world&quot;</div><div class="line">(integer) 0</div><div class="line">redis&gt; MGET key1 key2 key3</div><div class="line">1) &quot;Hello&quot;</div><div class="line">2) &quot;there&quot;</div><div class="line">3) (nil)</div></pre></td></tr></table></figure>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/07/19/服务器相关/redis/常用原子方法/" data-id="cj6cy7nje00bdktblsoqo3x93" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-服务器相关/redis/安装(Mac版)" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/19/服务器相关/redis/安装(Mac版)/">安装(Mac版)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/07/19/服务器相关/redis/安装(Mac版)/" class="article-date"><time datetime="2017-07-19T02:09:45.000Z" itemprop="datePublished">2017-07-19</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a> / <a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brew search redis</div><div class="line">brew install redis</div></pre></td></tr></table></figure>
<p>安装后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">To have launchd start redis at login:</div><div class="line">  ln -sfv /usr/local/opt/redis/*.plist ~/Library/LaunchAgents</div><div class="line">Then to load redis now:</div><div class="line">  launchctl load ~/Library/LaunchAgents/homebrew.mxcl.redis.plist</div><div class="line">Or, if you don&apos;t want/need launchctl, you can just run:</div><div class="line">  redis-server /usr/local/etc/redis.conf</div><div class="line">==&gt; Summary</div><div class="line">🍺  /usr/local/Cellar/redis/3.0.7: 9 files, 876.3K</div></pre></td></tr></table></figure></p>
<p>Redis相关可执行文件的主要作用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">（1）redis-server  -------Redis服务器</div><div class="line">（2）redis-cli         -------Redis命令行客户端</div><div class="line">（3）redis-benchmark ---------Redis性能测试工具</div><div class="line">（4）redis-check-aof ----------AOF文件修复工具</div><div class="line">（5）redis-check-dump --------RDB文件检查工具</div></pre></td></tr></table></figure></p>
<p>开机自动启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.redis.plist</div></pre></td></tr></table></figure></p>
<p>取消开机自动启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.redis.plist</div></pre></td></tr></table></figure></p>
<p>启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">进入/usr/local/Cellar/redis/3.0.7/bin</div><div class="line">指定conf启动：</div><div class="line">./redis-server /usr/local/etc/redis.conf</div></pre></td></tr></table></figure></p>
<p>访问服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">进入/usr/local/Cellar/redis/3.0.7/bin</div><div class="line">./redis-cli -h 127.0.0.1 -p 6379</div><div class="line"></div><div class="line">输入：</div><div class="line">ping 返回PONG即为连接服务器成功</div><div class="line"></div><div class="line">设置值:</div><div class="line">set aa aa</div><div class="line">获取值：</div><div class="line">get aa</div><div class="line">退出：</div><div class="line">exit</div></pre></td></tr></table></figure></p>
<p>停止服务：<br>考虑到redis正在将内存中的数据拷贝到硬盘，所以强行终止进程可能导致数据丢失，所以争取的方式之一是通过客户端发送 shutdown命令，服务器在收到shutdown命令后，先断开所有客户端的连接，再根据配置持久化数据，再关闭Redis服务<br>redis可以妥善处理sigterm信号，多以Kill Redis的进程也可以关闭redis，效果金额发送 shutdown命令有同样的效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">进入/usr/local/Cellar/redis/3.0.7/bin</div><div class="line">./redis-cli -p 6379 shutdown</div></pre></td></tr></table></figure></p>
<p>配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">#修改为守护模式</div><div class="line">daemonize yes</div><div class="line">#设置进程锁文件</div><div class="line">pidfile /usr/local/redis/redis.pid</div><div class="line">#端口</div><div class="line">port 6379</div><div class="line">#客户端超时时间</div><div class="line">timeout 300</div><div class="line">#日志级别</div><div class="line">loglevel debug</div><div class="line">#日志文件位置</div><div class="line">logfile /usr/local/redis/log-redis.log</div><div class="line">#设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id</div><div class="line">databases 8</div><div class="line">##指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</div><div class="line">#save &lt;seconds&gt; &lt;changes&gt;</div><div class="line">#Redis默认配置文件中提供了三个条件：</div><div class="line">save 900 1</div><div class="line">save 300 10</div><div class="line">save 60 10000</div><div class="line">#指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，</div><div class="line">#可以关闭该#选项，但会导致数据库文件变的巨大</div><div class="line">rdbcompression yes</div><div class="line">#指定本地数据库文件名</div><div class="line">dbfilename dump.rdb</div><div class="line">#指定本地数据库路径</div><div class="line">dir /usr/local/redis/db/</div><div class="line">#指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能</div><div class="line">#会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有</div><div class="line">#的数据会在一段时间内只存在于内存中</div><div class="line">appendonly no</div><div class="line">#指定更新日志条件，共有3个可选值：</div><div class="line">#no：表示等操作系统进行数据缓存同步到磁盘（快）</div><div class="line">#always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）</div><div class="line">#everysec：表示每秒同步一次（折衷，默认值）</div><div class="line">appendfsync everysec</div><div class="line">&lt;/changes&gt;&lt;/seconds&gt;&lt;/dbid&gt;</div></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/07/19/服务器相关/redis/安装(Mac版)/" data-id="cj6cy7njf00bektbli5zx4ewl" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-服务器相关/redis/常用非原子方法" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/19/服务器相关/redis/常用非原子方法/">常用非原子方法</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/07/19/服务器相关/redis/常用非原子方法/" class="article-date"><time datetime="2017-07-19T02:09:45.000Z" itemprop="datePublished">2017-07-19</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a> / <a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SETNX-key-value"><a href="#SETNX-key-value" class="headerlink" title="SETNX key value"></a>SETNX key value</h1><blockquote>
<p>起始版本：1.0.0<br>  时间复杂度：O(1)</p>
</blockquote>
<p>将key设置值为value，如果key不存在，这种情况下等同SET命令。 当key存在时，什么也不做。SETNX是”SET if Not eXists”的简写</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Integer reply, 特定值:</div><div class="line">1 如果key被设置了</div><div class="line">0 如果key没有被设置</div></pre></td></tr></table></figure>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">redis&gt; SETNX mykey &quot;Hello&quot;</div><div class="line">(integer) 1</div><div class="line">redis&gt; SETNX mykey &quot;World&quot;</div><div class="line">(integer) 0</div><div class="line">redis&gt; GET mykey</div><div class="line">&quot;Hello&quot;</div><div class="line">redis&gt;</div></pre></td></tr></table></figure>
<h1 id="STRLEN-key"><a href="#STRLEN-key" class="headerlink" title="STRLEN key"></a>STRLEN key</h1><blockquote>
<p>起始版本：2.2.0<br>  时间复杂度：O(1)</p>
</blockquote>
<p>返回key的string类型value的长度。如果key对应的非string类型，就返回错误。</p>
<h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>integer-reply：key对应的字符串value的长度，或者0（key不存在）</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">redis&gt; SET mykey &quot;Hello world&quot;</div><div class="line">OK</div><div class="line">redis&gt; STRLEN mykey</div><div class="line">(integer) 11</div><div class="line">redis&gt; STRLEN nonexisting</div><div class="line">(integer) 0</div><div class="line">redis&gt;</div></pre></td></tr></table></figure>
<h1 id="SETRANGE-key-offset-value"><a href="#SETRANGE-key-offset-value" class="headerlink" title="SETRANGE key offset value"></a>SETRANGE key offset value</h1><blockquote>
<p>起始版本：2.2.0<br>时间复杂度：O(1), not counting the time taken to copy the new string in place. Usually, this string is very small so the amortized complexity is O(1). Otherwise, complexity is O(M) with M being the length of the value argument.</p>
</blockquote>
<p>这个命令的作用是覆盖key对应的string的一部分，从指定的offset处开始，覆盖value的长度。如果offset比当前key对应string还要长，那这个string后面就补0以达到offset。不存在的keys被认为是空字符串，所以这个命令可以确保key有一个足够大的字符串，能在offset处设置value。<br>注意，offset最大可以是229-1(536870911),因为redis字符串限制在512M大小。如果你需要超过这个大小，你可以用多个keys。</p>
<h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><p>integer-reply：该命令修改后的字符串长度</p>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>基本使用方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">redis&gt; SET key1 &quot;Hello World&quot;</div><div class="line">OK</div><div class="line">redis&gt; SETRANGE key1 6 &quot;Redis&quot;</div><div class="line">(integer) 11</div><div class="line">redis&gt; GET key1</div><div class="line">&quot;Hello Redis&quot;</div><div class="line">redis&gt;</div></pre></td></tr></table></figure></p>
<p>补0的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">redis&gt; SETRANGE key2 6 &quot;Redis&quot;</div><div class="line">(integer) 11</div><div class="line">redis&gt; GET key2</div><div class="line">&quot;\x00\x00\x00\x00\x00\x00Redis&quot;</div><div class="line">redis&gt;</div></pre></td></tr></table></figure></p>
<h1 id="GETRANGE-key-start-end"><a href="#GETRANGE-key-start-end" class="headerlink" title="GETRANGE key start end"></a>GETRANGE key start end</h1><blockquote>
<p>起始版本：2.4.0<br>时间复杂度：O(N) N是字符串长度，复杂度由最终返回长度决定，但由于通过一个字符串创建子字符串是很容易的，它可以被认为是O(1)。</p>
</blockquote>
<p>==警告==：这个命令是被改成GETRANGE的，在小于2.0的Redis版本中叫SUBSTR。 返回key对应的字符串value的子串，这个子串是由start和end位移决定的（两者都在string内）。可以用负的位移来表示从string尾部开始数的下标。所以-1就是最后一个字符，-2就是倒数第二个，以此类推。  </p>
<p>这个函数处理超出范围的请求时，都把结果限制在string内。</p>
<h3 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h3><p>bulk-reply</p>
<h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">redis&gt; SET mykey &quot;This is a string&quot;</div><div class="line">OK</div><div class="line">redis&gt; GETRANGE mykey 0 3</div><div class="line">&quot;This&quot;</div><div class="line">redis&gt; GETRANGE mykey -3 -1</div><div class="line">&quot;ing&quot;</div><div class="line">redis&gt; GETRANGE mykey 0 -1</div><div class="line">&quot;This is a string&quot;</div><div class="line">redis&gt; GETRANGE mykey 10 100</div><div class="line">&quot;string&quot;</div><div class="line">redis&gt;</div></pre></td></tr></table></figure>
      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/07/19/服务器相关/redis/常用非原子方法/" data-id="cj6cy7njg00bgktbl9v4xb0zt" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-服务器相关/redis/文档（持续更新中）" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/19/服务器相关/redis/文档（持续更新中）/">文档（持续更新中）</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/07/19/服务器相关/redis/文档（持续更新中）/" class="article-date"><time datetime="2017-07-19T02:09:45.000Z" itemprop="datePublished">2017-07-19</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a> / <a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="中文官方文档"><a href="#中文官方文档" class="headerlink" title="中文官方文档"></a>中文官方文档</h2><p><a href="http://www.redis.cn/" target="_blank" rel="external">http://www.redis.cn/</a></p>
<h2 id="命令大全"><a href="#命令大全" class="headerlink" title="命令大全"></a>命令大全</h2><p><a href="http://www.redis.cn/commands.html" target="_blank" rel="external">http://www.redis.cn/commands.html</a></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/07/19/服务器相关/redis/文档（持续更新中）/" data-id="cj6cy7njh00bhktblh5ktn4ob" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-服务器相关/redis/系统命令" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/19/服务器相关/redis/系统命令/">系统命令</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/07/19/服务器相关/redis/系统命令/" class="article-date"><time datetime="2017-07-19T02:09:45.000Z" itemprop="datePublished">2017-07-19</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a> / <a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MONITOR"><a href="#MONITOR" class="headerlink" title="MONITOR"></a>MONITOR</h1><p>MONITOR 是一个调试命令，返回服务器处理的每一个命令，它能帮助我们了解在数据库上发生了什么操作，可以通过redis-cli和telnet命令使用.</p>
<p>停止：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ctrl+c</div></pre></td></tr></table></figure></p>
<p>==注意：MONITOR会引起性能消耗==</p>
<h1 id="QUIT"><a href="#QUIT" class="headerlink" title="QUIT"></a>QUIT</h1><p>客户端请求与服务器关闭连接。连接将会尽可能快的将未完成的客户端请求完成处理。    </p>
<h1 id="SELECT-index"><a href="#SELECT-index" class="headerlink" title="SELECT index"></a>SELECT index</h1><p>选择一个数据库，下标值从0开始，一个新连接默认连接的数据库是DB0。</p>
<h1 id="ECHO-message"><a href="#ECHO-message" class="headerlink" title="ECHO message"></a>ECHO message</h1><p>输出信息</p>
<h1 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h1><p>如果后面没有参数时返回PONG，否则会返回后面带的参数。<br>这个命令经常用来测试一个连接是否还是可用的，或者用来测试一个连接的延时。<br>如果客户端处于频道订阅模式下，它将是一个multi-bulk返回，第一次时返回”pong”，之后返回空（empty bulk），除非命令后面更随了参数。</p>
<h1 id="DBSIZE"><a href="#DBSIZE" class="headerlink" title="DBSIZE"></a>DBSIZE</h1><p>返回当前数据里面keys的数量。</p>
<h1 id="FLUSHALL"><a href="#FLUSHALL" class="headerlink" title="FLUSHALL"></a>FLUSHALL</h1><p>删除所有数据库里面的所有数据，注意不是当前数据库，而是所有数据库。<br>这个命令永远不会出现失败。<br>这个操作的时间复杂度是O(N),N是数据库的数量。</p>
<h1 id="FLUSHDB"><a href="#FLUSHDB" class="headerlink" title="FLUSHDB"></a>FLUSHDB</h1><p>删除当前数据库里面的所有数据。<br>这个命令永远不会出现失败。<br>这个操作的时间复杂度是O(N),N是当前数据库的keys数量。</p>
<h1 id="SAVE"><a href="#SAVE" class="headerlink" title="SAVE"></a>SAVE</h1><p>SAVE 命令执行一个同步操作，以RDB文件的方式保存所有数据的快照 很少在生产环境直接使用SAVE 命令，因为它会阻塞所有的客户端的请求，可以使用BGSAVE 命令代替. 如果在BGSAVE命令的保存数据的子进程发生错误的时,用 SAVE命令保存最新的数据是最后的手段,详细的说明请参考持久化文档</p>
<h3 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h3><p>simple-string-reply: 命令成功返回OK.</p>
<h1 id="BGSAVE"><a href="#BGSAVE" class="headerlink" title="BGSAVE"></a>BGSAVE</h1><p>后台保存DB。会立即返回 OK 状态码。 Redis forks, 父进程继续提供服务以供客户端调用，子进程将DB数据保存到磁盘然后退出。如果操作成功，可以通过客户端命令LASTSAVE来检查操作结果。</p>
<h1 id="INFO-section"><a href="#INFO-section" class="headerlink" title="INFO [section]"></a>INFO [section]</h1><p>INFO命令以一种易于理解和阅读的格式，返回关于Redis服务器的各种信息和统计数值。<br>通过给定可选的参数 section ，可以让命令只返回某一部分的信息:</p>
<ul>
<li>server: Redis服务器的一般信息</li>
<li>clients: 客户端的连接部分</li>
<li>memory: 内存消耗相关信息</li>
<li>persistence: RDB和AOF相关信息</li>
<li>stats: 一般统计</li>
<li>replication: 主/从复制信息</li>
<li>cpu: 统计CPU的消耗</li>
<li>commandstats: Redis命令统计</li>
<li>cluster: Redis集群信息</li>
<li>keyspace: 数据库的相关统计<br>它也可以采取以下值:</li>
<li>all: 返回所有信息</li>
<li>default: 值返回默认设置的信息<br>如果没有使用任何参数时，默认为default。</li>
</ul>
<h1 id="CLIENT-LIST"><a href="#CLIENT-LIST" class="headerlink" title="CLIENT LIST"></a>CLIENT LIST</h1><p>Redis CLIENT LIST命令用于返回所有连接到服务器的客户端信息和统计数据。</p>
<h4 id="返回-1"><a href="#返回-1" class="headerlink" title="返回"></a>返回</h4><p>bulk-string-reply: 一个独特的字符串，格式如下：</p>
<ul>
<li>每个已连接客户端对应一行（以 LF 分割）</li>
<li>每行字符串由一系列 属性=值（property=value） 形式的域组成，每个域之间以空格分开。  </li>
</ul>
<p>下面是各字段的含义：</p>
<ul>
<li>id: 唯一的64位的客户端ID(Redis 2.8.12加入)。</li>
<li>addr: 客户端的地址和端口</li>
<li>fd: 套接字所使用的文件描述符</li>
<li>age: 以秒计算的已连接时长</li>
<li>idle: 以秒计算的空闲时长</li>
<li>flags: 客户端 flag</li>
<li>db: 该客户端正在使用的数据库 ID</li>
<li>sub: 已订阅频道的数量</li>
<li>psub: 已订阅模式的数量</li>
<li>multi: 在事务中被执行的命令数量</li>
<li>qbuf: 查询缓冲区的长度（字节为单位， 0 表示没有分配查询缓冲区）</li>
<li>qbuf-free: 查询缓冲区剩余空间的长度（字节为单位， 0 表示没有剩余空间）</li>
<li>obl: 输出缓冲区的长度（字节为单位， 0 表示没有分配输出缓冲区）</li>
<li>oll: 输出列表包含的对象数量（当输出缓冲区没有剩余空间时，命令回复会以字符串对象的形式被入队到这个队列里）</li>
<li>omem: 输出缓冲区和输出列表占用的内存总量</li>
<li>events: 文件描述符事件</li>
<li>cmd: 最近一次执行的命令</li>
</ul>
<p>客户端 flag 可以由以下部分组成：</p>
<ul>
<li>O: 客户端是 MONITOR 模式下的附属节点（slave）</li>
<li>S: 客户端是一般模式下（normal）的附属节点</li>
<li>M: 客户端是主节点（master）</li>
<li>x: 客户端正在执行事务</li>
<li>b: 客户端正在等待阻塞事件</li>
<li>i: 客户端正在等待 VM I/O 操作（已废弃）</li>
<li>d: 一个受监视（watched）的键已被修改， EXEC 命令将失败</li>
<li>c: 在将回复完整地写出之后，关闭链接</li>
<li>u: 客户端未被阻塞（unblocked）</li>
<li>U: 通过Unix套接字连接的客户端</li>
<li>r: 客户端是只读模式的集群节点</li>
<li>A: 尽可能快地关闭连接</li>
<li>N: 未设置任何 flag</li>
</ul>
<p>文件描述符事件可以是：</p>
<ul>
<li>r: 客户端套接字（在事件 loop 中）是可读的（readable）</li>
<li>w: 客户端套接字（在事件 loop 中）是可写的（writeable）</li>
</ul>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/07/19/服务器相关/redis/系统命令/" data-id="cj6cy7nji00bjktblf0w4u32o" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-服务器相关/redis/自增自减命令" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/19/服务器相关/redis/自增自减命令/">自增自减命令</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/07/19/服务器相关/redis/自增自减命令/" class="article-date"><time datetime="2017-07-19T02:09:45.000Z" itemprop="datePublished">2017-07-19</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/服务器相关/">服务器相关</a> / <a class="article-category-link" href="/categories/服务器相关/redis/">redis</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="INCR-key"><a href="#INCR-key" class="headerlink" title="INCR key"></a>INCR key</h1><blockquote>
<p>起始版本：1.0.0<br>时间复杂度：O(1)</p>
</blockquote>
<p>对存储在指定key的数值执行==原子==的加1操作。<br>如果指定的key不存在，那么在执行incr操作之前，会先将它的值设定为0。<br>如果指定的key中存储的值不是字符串类型（fix：）或者存储的字符串类型不能表示为一个整数，<br>那么执行这个命令时服务器会返回一个错误(eq:(error) ERR value is not an integer or out of range)。<br>这个操作仅限于64位的有符号整型数据。<br>==注意==: 由于redis并没有一个明确的类型来表示整型数据，所以这个操作是一个字符串操作。<br>执行这个操作的时候，key对应存储的字符串被解析为10进制的<code>64位有符号整型数据</code>。<br>事实上，Redis 内部采用整数形式（Integer representation）来存储对应的整数值，所以对该类字符串值实际上是用整数保存，也就不存在存储整数的字符串表示（String representation）所带来的额外消耗。</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>integer-reply:执行递增操作后key对应的值。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">redis&gt; SET mykey &quot;10&quot;</div><div class="line">OK</div><div class="line">redis&gt; INCR mykey</div><div class="line">(integer) 11</div><div class="line">redis&gt; GET mykey</div><div class="line">&quot;11&quot;</div></pre></td></tr></table></figure>
<h1 id="INCRBY-key-increment"><a href="#INCRBY-key-increment" class="headerlink" title="INCRBY key increment"></a>INCRBY key increment</h1><blockquote>
<p>起始版本：1.0.0<br>时间复杂度：O(1)</p>
</blockquote>
<p>将key对应的数字==原子==加increment。如果key不存在，操作之前，key就会被置为0。如果key的value类型错误或者是个不能表示成数字的字符串，就返回错误。这个操作最多支持64位有符号的正型数字。</p>
<h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>integer-reply： 增加之后的value值。</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">redis&gt; SET mykey &quot;10&quot;</div><div class="line">OK</div><div class="line">redis&gt; INCRBY mykey 5</div><div class="line">(integer) 15</div></pre></td></tr></table></figure>
<h1 id="DECR-key"><a href="#DECR-key" class="headerlink" title="DECR key"></a>DECR key</h1><blockquote>
<p>起始版本：1.0.0<br>时间复杂度：O(1)</p>
</blockquote>
<p>对key对应的数字做==原子==减1操作。如果key不存在，那么在操作之前，这个key对应的值会被置为0。如果key有一个错误类型的value或者是一个不能表示成数字的字符串，就返回错误。这个操作最大支持在64位有符号的整型数字。</p>
<h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><p>数字：减小之后的value</p>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">redis&gt; SET mykey &quot;10&quot;</div><div class="line">OK</div><div class="line">redis&gt; DECR mykey</div><div class="line">(integer) 9</div><div class="line">redis&gt; SET mykey &quot;234293482390480948029348230948&quot;</div><div class="line">OK</div><div class="line">redis&gt; DECR mykey</div><div class="line">ERR value is not an integer or out of range</div></pre></td></tr></table></figure>
<h1 id="DECRBY-key-decrement"><a href="#DECRBY-key-decrement" class="headerlink" title="DECRBY key decrement"></a>DECRBY key decrement</h1><blockquote>
<p>起始版本：1.0.0<br>时间复杂度：O(1)</p>
</blockquote>
<p>将key对应的数字==原子==减decrement。如果key不存在，操作之前，key就会被置为0。如果key的value类型错误或者是个不能表示成数字的字符串，就返回错误。这个操作最多支持64位有符号的正型数字。</p>
<h3 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h3><p>返回一个数字：减少之后的value值。</p>
<h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">redis&gt; SET mykey &quot;10&quot;</div><div class="line">OK</div><div class="line">redis&gt; DECRBY mykey 5</div><div class="line">(integer) 5</div></pre></td></tr></table></figure>
      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://clq2owesome.github.io/2017/07/19/服务器相关/redis/自增自减命令/" data-id="cj6cy7nji00bkktbluickndc9" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/page/17/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/16/">16</a></li><li><a class="page-number" href="/page/17/">17</a></li><li class="active"><span class="page-number">18</span></li><li class="disabled"><span class="page-next">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-module-inset">
  <h4>关于</h4>
  <p>该博客内的文章是博主在日常工作或者学习中总结出来，部分内容来自网络.</p>

</div>


  
  <div class="sidebar-module">
    <h4>分类</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Eclipse/">Eclipse</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Github/">Github</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/">Java</a><span class="sidebar-module-list-count">60</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/Cookie/">Cookie</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/JAXB/">JAXB</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/JavaMail/">JavaMail</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/加密解密／编码解码/">加密解密／编码解码</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/基础/">基础</a><span class="sidebar-module-list-count">8</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/数据类型/">数据类型</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/日记/">日记</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/线程/">线程</a><span class="sidebar-module-list-count">16</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/网络NIO/">网络NIO</a><span class="sidebar-module-list-count">12</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/队列/">队列</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/集合/">集合</a><span class="sidebar-module-list-count">3</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Linux/">Linux</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Maven/">Maven</a><span class="sidebar-module-list-count">9</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/">Spring</a><span class="sidebar-module-list-count">56</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Application-Event/">Application Event</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/JPA/">JPA</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Security/">Security</a><span class="sidebar-module-list-count">22</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/Task/">Task</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/spring-MVC/">spring MVC</a><span class="sidebar-module-list-count">17</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/spring-data-redis/">spring data redis</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Spring/基础/">基础</a><span class="sidebar-module-list-count">5</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/前端技术相关/">前端技术相关</a><span class="sidebar-module-list-count">3</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/前端技术相关/forever/">forever</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/前端技术相关/javascript/">javascript</a><span class="sidebar-module-list-count">1</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/数据库相关/">数据库相关</a><span class="sidebar-module-list-count">11</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/数据库相关/mysql/">mysql</a><span class="sidebar-module-list-count">11</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/">服务器相关</a><span class="sidebar-module-list-count">22</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Hessian/">Hessian</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Hudson-Jenkins/">Hudson & Jenkins</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Memcached/">Memcached</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/Tomcat/">Tomcat</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/red5/">red5</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/redis/">redis</a><span class="sidebar-module-list-count">9</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/服务器相关/resin/">resin</a><span class="sidebar-module-list-count">3</span></li></ul></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/网络/">网络</a><span class="sidebar-module-list-count">7</span></li></ul>
  </div>



  


  

  
  <div class="sidebar-module">
    <h4>归档</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">53</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">124</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>最近文章</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/2017/08/15/Spring/Security/配置十三：session管理/">配置十三：session管理</a>
        </li>
      
        <li>
          <a href="/2017/08/15/Spring/Security/配置七：缓存UserDetails/">配置七：缓存UserDetails</a>
        </li>
      
        <li>
          <a href="/2017/08/15/Spring/Security/配置四：认证过程/">配置四：认证过程</a>
        </li>
      
        <li>
          <a href="/2017/08/15/Spring/Security/配置十：退出登录/">配置十：退出登录</a>
        </li>
      
        <li>
          <a href="/2017/08/15/Spring/Security/配置十六：基于表达式的权限控制/">配置十六：基于表达式的权限控制</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2017 LeoChan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>



<script src="/js/script.js"></script>

</body>
</html>
